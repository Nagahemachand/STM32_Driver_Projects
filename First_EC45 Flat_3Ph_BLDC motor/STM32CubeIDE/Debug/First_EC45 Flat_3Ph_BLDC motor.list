
First_EC45 Flat_3Ph_BLDC motor.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001d8  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00009f90  080001e0  080001e0  000011e0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000003b8  0800a170  0800a170  0000b170  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0800a528  0800a528  0000c568  2**0
                  CONTENTS
  4 .ARM          00000008  0800a528  0800a528  0000b528  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  0800a530  0800a530  0000c568  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0800a530  0800a530  0000b530  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  0800a534  0800a534  0000b534  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000568  20000000  0800a538  0000c000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00002230  20000568  0800aaa0  0000c568  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  20002798  0800aaa0  0000c798  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  0000c568  2**0
                  CONTENTS, READONLY
 12 .debug_line   0004f4d7  00000000  00000000  0000c598  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_line_str 00000087  00000000  00000000  0005ba6f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_info   00050117  00000000  00000000  0005baf6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_abbrev 0000a3ff  00000000  00000000  000abc0d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_aranges 00002430  00000000  00000000  000b6010  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_str    0010a104  00000000  00000000  000b8440  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_rnglists 00003b4a  00000000  00000000  001c2544  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_loclists 0001f1be  00000000  00000000  001c608e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_macro  0000c98f  00000000  00000000  001e524c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .comment      00000043  00000000  00000000  001f1bdb  2**0
                  CONTENTS, READONLY
 22 .debug_frame  00005fdc  00000000  00000000  001f1c20  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080001e0 <__do_global_dtors_aux>:
 80001e0:	b510      	push	{r4, lr}
 80001e2:	4c05      	ldr	r4, [pc, #20]	@ (80001f8 <__do_global_dtors_aux+0x18>)
 80001e4:	7823      	ldrb	r3, [r4, #0]
 80001e6:	b933      	cbnz	r3, 80001f6 <__do_global_dtors_aux+0x16>
 80001e8:	4b04      	ldr	r3, [pc, #16]	@ (80001fc <__do_global_dtors_aux+0x1c>)
 80001ea:	b113      	cbz	r3, 80001f2 <__do_global_dtors_aux+0x12>
 80001ec:	4804      	ldr	r0, [pc, #16]	@ (8000200 <__do_global_dtors_aux+0x20>)
 80001ee:	f3af 8000 	nop.w
 80001f2:	2301      	movs	r3, #1
 80001f4:	7023      	strb	r3, [r4, #0]
 80001f6:	bd10      	pop	{r4, pc}
 80001f8:	20000568 	.word	0x20000568
 80001fc:	00000000 	.word	0x00000000
 8000200:	0800a158 	.word	0x0800a158

08000204 <frame_dummy>:
 8000204:	b508      	push	{r3, lr}
 8000206:	4b03      	ldr	r3, [pc, #12]	@ (8000214 <frame_dummy+0x10>)
 8000208:	b11b      	cbz	r3, 8000212 <frame_dummy+0xe>
 800020a:	4903      	ldr	r1, [pc, #12]	@ (8000218 <frame_dummy+0x14>)
 800020c:	4803      	ldr	r0, [pc, #12]	@ (800021c <frame_dummy+0x18>)
 800020e:	f3af 8000 	nop.w
 8000212:	bd08      	pop	{r3, pc}
 8000214:	00000000 	.word	0x00000000
 8000218:	2000056c 	.word	0x2000056c
 800021c:	0800a158 	.word	0x0800a158

08000220 <__aeabi_uldivmod>:
 8000220:	b953      	cbnz	r3, 8000238 <__aeabi_uldivmod+0x18>
 8000222:	b94a      	cbnz	r2, 8000238 <__aeabi_uldivmod+0x18>
 8000224:	2900      	cmp	r1, #0
 8000226:	bf08      	it	eq
 8000228:	2800      	cmpeq	r0, #0
 800022a:	bf1c      	itt	ne
 800022c:	f04f 31ff 	movne.w	r1, #4294967295
 8000230:	f04f 30ff 	movne.w	r0, #4294967295
 8000234:	f000 b96a 	b.w	800050c <__aeabi_idiv0>
 8000238:	f1ad 0c08 	sub.w	ip, sp, #8
 800023c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000240:	f000 f806 	bl	8000250 <__udivmoddi4>
 8000244:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000248:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800024c:	b004      	add	sp, #16
 800024e:	4770      	bx	lr

08000250 <__udivmoddi4>:
 8000250:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000254:	9d08      	ldr	r5, [sp, #32]
 8000256:	460c      	mov	r4, r1
 8000258:	2b00      	cmp	r3, #0
 800025a:	d14e      	bne.n	80002fa <__udivmoddi4+0xaa>
 800025c:	4694      	mov	ip, r2
 800025e:	458c      	cmp	ip, r1
 8000260:	4686      	mov	lr, r0
 8000262:	fab2 f282 	clz	r2, r2
 8000266:	d962      	bls.n	800032e <__udivmoddi4+0xde>
 8000268:	b14a      	cbz	r2, 800027e <__udivmoddi4+0x2e>
 800026a:	f1c2 0320 	rsb	r3, r2, #32
 800026e:	4091      	lsls	r1, r2
 8000270:	fa20 f303 	lsr.w	r3, r0, r3
 8000274:	fa0c fc02 	lsl.w	ip, ip, r2
 8000278:	4319      	orrs	r1, r3
 800027a:	fa00 fe02 	lsl.w	lr, r0, r2
 800027e:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8000282:	fa1f f68c 	uxth.w	r6, ip
 8000286:	fbb1 f4f7 	udiv	r4, r1, r7
 800028a:	ea4f 431e 	mov.w	r3, lr, lsr #16
 800028e:	fb07 1114 	mls	r1, r7, r4, r1
 8000292:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000296:	fb04 f106 	mul.w	r1, r4, r6
 800029a:	4299      	cmp	r1, r3
 800029c:	d90a      	bls.n	80002b4 <__udivmoddi4+0x64>
 800029e:	eb1c 0303 	adds.w	r3, ip, r3
 80002a2:	f104 30ff 	add.w	r0, r4, #4294967295
 80002a6:	f080 8112 	bcs.w	80004ce <__udivmoddi4+0x27e>
 80002aa:	4299      	cmp	r1, r3
 80002ac:	f240 810f 	bls.w	80004ce <__udivmoddi4+0x27e>
 80002b0:	3c02      	subs	r4, #2
 80002b2:	4463      	add	r3, ip
 80002b4:	1a59      	subs	r1, r3, r1
 80002b6:	fa1f f38e 	uxth.w	r3, lr
 80002ba:	fbb1 f0f7 	udiv	r0, r1, r7
 80002be:	fb07 1110 	mls	r1, r7, r0, r1
 80002c2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 80002c6:	fb00 f606 	mul.w	r6, r0, r6
 80002ca:	429e      	cmp	r6, r3
 80002cc:	d90a      	bls.n	80002e4 <__udivmoddi4+0x94>
 80002ce:	eb1c 0303 	adds.w	r3, ip, r3
 80002d2:	f100 31ff 	add.w	r1, r0, #4294967295
 80002d6:	f080 80fc 	bcs.w	80004d2 <__udivmoddi4+0x282>
 80002da:	429e      	cmp	r6, r3
 80002dc:	f240 80f9 	bls.w	80004d2 <__udivmoddi4+0x282>
 80002e0:	4463      	add	r3, ip
 80002e2:	3802      	subs	r0, #2
 80002e4:	1b9b      	subs	r3, r3, r6
 80002e6:	ea40 4004 	orr.w	r0, r0, r4, lsl #16
 80002ea:	2100      	movs	r1, #0
 80002ec:	b11d      	cbz	r5, 80002f6 <__udivmoddi4+0xa6>
 80002ee:	40d3      	lsrs	r3, r2
 80002f0:	2200      	movs	r2, #0
 80002f2:	e9c5 3200 	strd	r3, r2, [r5]
 80002f6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80002fa:	428b      	cmp	r3, r1
 80002fc:	d905      	bls.n	800030a <__udivmoddi4+0xba>
 80002fe:	b10d      	cbz	r5, 8000304 <__udivmoddi4+0xb4>
 8000300:	e9c5 0100 	strd	r0, r1, [r5]
 8000304:	2100      	movs	r1, #0
 8000306:	4608      	mov	r0, r1
 8000308:	e7f5      	b.n	80002f6 <__udivmoddi4+0xa6>
 800030a:	fab3 f183 	clz	r1, r3
 800030e:	2900      	cmp	r1, #0
 8000310:	d146      	bne.n	80003a0 <__udivmoddi4+0x150>
 8000312:	42a3      	cmp	r3, r4
 8000314:	d302      	bcc.n	800031c <__udivmoddi4+0xcc>
 8000316:	4290      	cmp	r0, r2
 8000318:	f0c0 80f0 	bcc.w	80004fc <__udivmoddi4+0x2ac>
 800031c:	1a86      	subs	r6, r0, r2
 800031e:	eb64 0303 	sbc.w	r3, r4, r3
 8000322:	2001      	movs	r0, #1
 8000324:	2d00      	cmp	r5, #0
 8000326:	d0e6      	beq.n	80002f6 <__udivmoddi4+0xa6>
 8000328:	e9c5 6300 	strd	r6, r3, [r5]
 800032c:	e7e3      	b.n	80002f6 <__udivmoddi4+0xa6>
 800032e:	2a00      	cmp	r2, #0
 8000330:	f040 8090 	bne.w	8000454 <__udivmoddi4+0x204>
 8000334:	eba1 040c 	sub.w	r4, r1, ip
 8000338:	ea4f 481c 	mov.w	r8, ip, lsr #16
 800033c:	fa1f f78c 	uxth.w	r7, ip
 8000340:	2101      	movs	r1, #1
 8000342:	fbb4 f6f8 	udiv	r6, r4, r8
 8000346:	ea4f 431e 	mov.w	r3, lr, lsr #16
 800034a:	fb08 4416 	mls	r4, r8, r6, r4
 800034e:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 8000352:	fb07 f006 	mul.w	r0, r7, r6
 8000356:	4298      	cmp	r0, r3
 8000358:	d908      	bls.n	800036c <__udivmoddi4+0x11c>
 800035a:	eb1c 0303 	adds.w	r3, ip, r3
 800035e:	f106 34ff 	add.w	r4, r6, #4294967295
 8000362:	d202      	bcs.n	800036a <__udivmoddi4+0x11a>
 8000364:	4298      	cmp	r0, r3
 8000366:	f200 80cd 	bhi.w	8000504 <__udivmoddi4+0x2b4>
 800036a:	4626      	mov	r6, r4
 800036c:	1a1c      	subs	r4, r3, r0
 800036e:	fa1f f38e 	uxth.w	r3, lr
 8000372:	fbb4 f0f8 	udiv	r0, r4, r8
 8000376:	fb08 4410 	mls	r4, r8, r0, r4
 800037a:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 800037e:	fb00 f707 	mul.w	r7, r0, r7
 8000382:	429f      	cmp	r7, r3
 8000384:	d908      	bls.n	8000398 <__udivmoddi4+0x148>
 8000386:	eb1c 0303 	adds.w	r3, ip, r3
 800038a:	f100 34ff 	add.w	r4, r0, #4294967295
 800038e:	d202      	bcs.n	8000396 <__udivmoddi4+0x146>
 8000390:	429f      	cmp	r7, r3
 8000392:	f200 80b0 	bhi.w	80004f6 <__udivmoddi4+0x2a6>
 8000396:	4620      	mov	r0, r4
 8000398:	1bdb      	subs	r3, r3, r7
 800039a:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 800039e:	e7a5      	b.n	80002ec <__udivmoddi4+0x9c>
 80003a0:	f1c1 0620 	rsb	r6, r1, #32
 80003a4:	408b      	lsls	r3, r1
 80003a6:	fa22 f706 	lsr.w	r7, r2, r6
 80003aa:	431f      	orrs	r7, r3
 80003ac:	fa20 fc06 	lsr.w	ip, r0, r6
 80003b0:	fa04 f301 	lsl.w	r3, r4, r1
 80003b4:	ea43 030c 	orr.w	r3, r3, ip
 80003b8:	40f4      	lsrs	r4, r6
 80003ba:	fa00 f801 	lsl.w	r8, r0, r1
 80003be:	0c38      	lsrs	r0, r7, #16
 80003c0:	ea4f 4913 	mov.w	r9, r3, lsr #16
 80003c4:	fbb4 fef0 	udiv	lr, r4, r0
 80003c8:	fa1f fc87 	uxth.w	ip, r7
 80003cc:	fb00 441e 	mls	r4, r0, lr, r4
 80003d0:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
 80003d4:	fb0e f90c 	mul.w	r9, lr, ip
 80003d8:	45a1      	cmp	r9, r4
 80003da:	fa02 f201 	lsl.w	r2, r2, r1
 80003de:	d90a      	bls.n	80003f6 <__udivmoddi4+0x1a6>
 80003e0:	193c      	adds	r4, r7, r4
 80003e2:	f10e 3aff 	add.w	sl, lr, #4294967295
 80003e6:	f080 8084 	bcs.w	80004f2 <__udivmoddi4+0x2a2>
 80003ea:	45a1      	cmp	r9, r4
 80003ec:	f240 8081 	bls.w	80004f2 <__udivmoddi4+0x2a2>
 80003f0:	f1ae 0e02 	sub.w	lr, lr, #2
 80003f4:	443c      	add	r4, r7
 80003f6:	eba4 0409 	sub.w	r4, r4, r9
 80003fa:	fa1f f983 	uxth.w	r9, r3
 80003fe:	fbb4 f3f0 	udiv	r3, r4, r0
 8000402:	fb00 4413 	mls	r4, r0, r3, r4
 8000406:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
 800040a:	fb03 fc0c 	mul.w	ip, r3, ip
 800040e:	45a4      	cmp	ip, r4
 8000410:	d907      	bls.n	8000422 <__udivmoddi4+0x1d2>
 8000412:	193c      	adds	r4, r7, r4
 8000414:	f103 30ff 	add.w	r0, r3, #4294967295
 8000418:	d267      	bcs.n	80004ea <__udivmoddi4+0x29a>
 800041a:	45a4      	cmp	ip, r4
 800041c:	d965      	bls.n	80004ea <__udivmoddi4+0x29a>
 800041e:	3b02      	subs	r3, #2
 8000420:	443c      	add	r4, r7
 8000422:	ea43 400e 	orr.w	r0, r3, lr, lsl #16
 8000426:	fba0 9302 	umull	r9, r3, r0, r2
 800042a:	eba4 040c 	sub.w	r4, r4, ip
 800042e:	429c      	cmp	r4, r3
 8000430:	46ce      	mov	lr, r9
 8000432:	469c      	mov	ip, r3
 8000434:	d351      	bcc.n	80004da <__udivmoddi4+0x28a>
 8000436:	d04e      	beq.n	80004d6 <__udivmoddi4+0x286>
 8000438:	b155      	cbz	r5, 8000450 <__udivmoddi4+0x200>
 800043a:	ebb8 030e 	subs.w	r3, r8, lr
 800043e:	eb64 040c 	sbc.w	r4, r4, ip
 8000442:	fa04 f606 	lsl.w	r6, r4, r6
 8000446:	40cb      	lsrs	r3, r1
 8000448:	431e      	orrs	r6, r3
 800044a:	40cc      	lsrs	r4, r1
 800044c:	e9c5 6400 	strd	r6, r4, [r5]
 8000450:	2100      	movs	r1, #0
 8000452:	e750      	b.n	80002f6 <__udivmoddi4+0xa6>
 8000454:	f1c2 0320 	rsb	r3, r2, #32
 8000458:	fa20 f103 	lsr.w	r1, r0, r3
 800045c:	fa0c fc02 	lsl.w	ip, ip, r2
 8000460:	fa24 f303 	lsr.w	r3, r4, r3
 8000464:	4094      	lsls	r4, r2
 8000466:	430c      	orrs	r4, r1
 8000468:	ea4f 481c 	mov.w	r8, ip, lsr #16
 800046c:	fa00 fe02 	lsl.w	lr, r0, r2
 8000470:	fa1f f78c 	uxth.w	r7, ip
 8000474:	fbb3 f0f8 	udiv	r0, r3, r8
 8000478:	fb08 3110 	mls	r1, r8, r0, r3
 800047c:	0c23      	lsrs	r3, r4, #16
 800047e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000482:	fb00 f107 	mul.w	r1, r0, r7
 8000486:	4299      	cmp	r1, r3
 8000488:	d908      	bls.n	800049c <__udivmoddi4+0x24c>
 800048a:	eb1c 0303 	adds.w	r3, ip, r3
 800048e:	f100 36ff 	add.w	r6, r0, #4294967295
 8000492:	d22c      	bcs.n	80004ee <__udivmoddi4+0x29e>
 8000494:	4299      	cmp	r1, r3
 8000496:	d92a      	bls.n	80004ee <__udivmoddi4+0x29e>
 8000498:	3802      	subs	r0, #2
 800049a:	4463      	add	r3, ip
 800049c:	1a5b      	subs	r3, r3, r1
 800049e:	b2a4      	uxth	r4, r4
 80004a0:	fbb3 f1f8 	udiv	r1, r3, r8
 80004a4:	fb08 3311 	mls	r3, r8, r1, r3
 80004a8:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 80004ac:	fb01 f307 	mul.w	r3, r1, r7
 80004b0:	42a3      	cmp	r3, r4
 80004b2:	d908      	bls.n	80004c6 <__udivmoddi4+0x276>
 80004b4:	eb1c 0404 	adds.w	r4, ip, r4
 80004b8:	f101 36ff 	add.w	r6, r1, #4294967295
 80004bc:	d213      	bcs.n	80004e6 <__udivmoddi4+0x296>
 80004be:	42a3      	cmp	r3, r4
 80004c0:	d911      	bls.n	80004e6 <__udivmoddi4+0x296>
 80004c2:	3902      	subs	r1, #2
 80004c4:	4464      	add	r4, ip
 80004c6:	1ae4      	subs	r4, r4, r3
 80004c8:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 80004cc:	e739      	b.n	8000342 <__udivmoddi4+0xf2>
 80004ce:	4604      	mov	r4, r0
 80004d0:	e6f0      	b.n	80002b4 <__udivmoddi4+0x64>
 80004d2:	4608      	mov	r0, r1
 80004d4:	e706      	b.n	80002e4 <__udivmoddi4+0x94>
 80004d6:	45c8      	cmp	r8, r9
 80004d8:	d2ae      	bcs.n	8000438 <__udivmoddi4+0x1e8>
 80004da:	ebb9 0e02 	subs.w	lr, r9, r2
 80004de:	eb63 0c07 	sbc.w	ip, r3, r7
 80004e2:	3801      	subs	r0, #1
 80004e4:	e7a8      	b.n	8000438 <__udivmoddi4+0x1e8>
 80004e6:	4631      	mov	r1, r6
 80004e8:	e7ed      	b.n	80004c6 <__udivmoddi4+0x276>
 80004ea:	4603      	mov	r3, r0
 80004ec:	e799      	b.n	8000422 <__udivmoddi4+0x1d2>
 80004ee:	4630      	mov	r0, r6
 80004f0:	e7d4      	b.n	800049c <__udivmoddi4+0x24c>
 80004f2:	46d6      	mov	lr, sl
 80004f4:	e77f      	b.n	80003f6 <__udivmoddi4+0x1a6>
 80004f6:	4463      	add	r3, ip
 80004f8:	3802      	subs	r0, #2
 80004fa:	e74d      	b.n	8000398 <__udivmoddi4+0x148>
 80004fc:	4606      	mov	r6, r0
 80004fe:	4623      	mov	r3, r4
 8000500:	4608      	mov	r0, r1
 8000502:	e70f      	b.n	8000324 <__udivmoddi4+0xd4>
 8000504:	3e02      	subs	r6, #2
 8000506:	4463      	add	r3, ip
 8000508:	e730      	b.n	800036c <__udivmoddi4+0x11c>
 800050a:	bf00      	nop

0800050c <__aeabi_idiv0>:
 800050c:	4770      	bx	lr
 800050e:	bf00      	nop

08000510 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8000510:	480d      	ldr	r0, [pc, #52]	@ (8000548 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8000512:	4685      	mov	sp, r0
  
/* Call the clock system initialization function.*/
    bl  SystemInit
 8000514:	f003 fe9e 	bl	8004254 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8000518:	480c      	ldr	r0, [pc, #48]	@ (800054c <LoopForever+0x6>)
  ldr r1, =_edata
 800051a:	490d      	ldr	r1, [pc, #52]	@ (8000550 <LoopForever+0xa>)
  ldr r2, =_sidata
 800051c:	4a0d      	ldr	r2, [pc, #52]	@ (8000554 <LoopForever+0xe>)
  movs r3, #0
 800051e:	2300      	movs	r3, #0
  b	LoopCopyDataInit
 8000520:	e002      	b.n	8000528 <LoopCopyDataInit>

08000522 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8000522:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8000524:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8000526:	3304      	adds	r3, #4

08000528 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8000528:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 800052a:	428c      	cmp	r4, r1
  bcc CopyDataInit
 800052c:	d3f9      	bcc.n	8000522 <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 800052e:	4a0a      	ldr	r2, [pc, #40]	@ (8000558 <LoopForever+0x12>)
  ldr r4, =_ebss
 8000530:	4c0a      	ldr	r4, [pc, #40]	@ (800055c <LoopForever+0x16>)
  movs r3, #0
 8000532:	2300      	movs	r3, #0
  b LoopFillZerobss
 8000534:	e001      	b.n	800053a <LoopFillZerobss>

08000536 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8000536:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8000538:	3204      	adds	r2, #4

0800053a <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 800053a:	42a2      	cmp	r2, r4
  bcc FillZerobss
 800053c:	d3fb      	bcc.n	8000536 <FillZerobss>
/* Call static constructors */
    bl __libc_init_array
 800053e:	f009 fdd9 	bl	800a0f4 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 8000542:	f000 fb5b 	bl	8000bfc <main>

08000546 <LoopForever>:

LoopForever:
    b LoopForever
 8000546:	e7fe      	b.n	8000546 <LoopForever>
  ldr   r0, =_estack
 8000548:	20008000 	.word	0x20008000
  ldr r0, =_sdata
 800054c:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8000550:	20000568 	.word	0x20000568
  ldr r2, =_sidata
 8000554:	0800a538 	.word	0x0800a538
  ldr r2, =_sbss
 8000558:	20000568 	.word	0x20000568
  ldr r4, =_ebss
 800055c:	20002798 	.word	0x20002798

08000560 <BusFault_Handler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 8000560:	e7fe      	b.n	8000560 <BusFault_Handler>
	...

08000564 <ASPEP_start>:
  * @brief  Starts ASPEP communication by configuring UART.
  *
  * @param  *pHandle Handler of the current instance of the ASPEP component
  */
void ASPEP_start(ASPEP_Handle_t *pHandle)
{
 8000564:	b570      	push	{r4, r5, r6, lr}
 8000566:	4604      	mov	r4, r0
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->fASPEP_HWInit(pHandle->ASPEPIp);
 8000568:	6940      	ldr	r0, [r0, #20]
 800056a:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
 800056c:	4798      	blx	r3
    pHandle->ASPEP_State = ASPEP_IDLE;
 800056e:	2300      	movs	r3, #0
    pHandle->ASPEP_TL_State = WAITING_PACKET;
    pHandle->syncPacketCount = 0; /* Sync packet counter is reset only at startup*/
    /* Configure UART to receive first packet*/
    pHandle->fASPEP_cfg_recept(pHandle->ASPEPIp, pHandle->rxHeader, ASPEP_HEADER_SIZE);
 8000570:	6d65      	ldr	r5, [r4, #84]	@ 0x54
    pHandle->ASPEP_State = ASPEP_IDLE;
 8000572:	f8a4 3064 	strh.w	r3, [r4, #100]	@ 0x64
    pHandle->syncPacketCount = 0; /* Sync packet counter is reset only at startup*/
 8000576:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
    pHandle->fASPEP_cfg_recept(pHandle->ASPEPIp, pHandle->rxHeader, ASPEP_HEADER_SIZE);
 800057a:	6960      	ldr	r0, [r4, #20]
 800057c:	f104 011c 	add.w	r1, r4, #28
 8000580:	462b      	mov	r3, r5
 8000582:	2204      	movs	r2, #4
#ifdef NULL_PTR_CHECK_ASP
  }
#endif
}
 8000584:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    pHandle->fASPEP_cfg_recept(pHandle->ASPEPIp, pHandle->rxHeader, ASPEP_HEADER_SIZE);
 8000588:	4718      	bx	r3
 800058a:	bf00      	nop

0800058c <ASPEP_sendBeacon>:
  *
  * @param  *pHandle Handler of the current instance of the ASPEP component
  * @param  *capabilities Matched capabilities between controller and performer
  */
void ASPEP_sendBeacon(ASPEP_Handle_t *pHandle, ASPEP_Capabilities_def *capabilities)
{
 800058c:	b410      	push	{r4}
  {
#endif
    uint32_t *packet = (uint32_t *)pHandle->ctrlBuffer.buffer; //cstat !MISRAC2012-Rule-11.3
    *packet = (BEACON
             | (((uint32_t)capabilities->version) << 4U)
             | (((uint32_t)capabilities->DATA_CRC) << 7U)
 800058e:	780b      	ldrb	r3, [r1, #0]
             | (((uint32_t)capabilities->version) << 4U)
 8000590:	790a      	ldrb	r2, [r1, #4]
             | (((uint32_t)capabilities->RX_maxSize) << 8U)
             | (((uint32_t)capabilities->TXS_maxSize) << 14U)
 8000592:	f891 c002 	ldrb.w	ip, [r1, #2]
  crc = CRC4_Lookup8[crc ^ (uint8_t)(header         & 0xffU)];
 8000596:	4c1e      	ldr	r4, [pc, #120]	@ (8000610 <ASPEP_sendBeacon+0x84>)
             | (((uint32_t)capabilities->DATA_CRC) << 7U)
 8000598:	01db      	lsls	r3, r3, #7
 800059a:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
             | (((uint32_t)capabilities->RX_maxSize) << 8U)
 800059e:	784a      	ldrb	r2, [r1, #1]
 80005a0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
             | (((uint32_t)capabilities->TXA_maxSize) << 21U));
 80005a4:	78ca      	ldrb	r2, [r1, #3]
             | (((uint32_t)capabilities->TXS_maxSize) << 14U)
 80005a6:	ea43 338c 	orr.w	r3, r3, ip, lsl #14
             | (((uint32_t)capabilities->TXA_maxSize) << 21U));
 80005aa:	ea43 5342 	orr.w	r3, r3, r2, lsl #21
  crc = CRC4_Lookup8[crc ^ (uint8_t)(header         & 0xffU)];
 80005ae:	b2da      	uxtb	r2, r3
 80005b0:	f042 0205 	orr.w	r2, r2, #5
  header &= 0x0fffffffU;
 80005b4:	f023 4170 	bic.w	r1, r3, #4026531840	@ 0xf0000000
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 80005b8:	5ca2      	ldrb	r2, [r4, r2]
 80005ba:	ea82 2211 	eor.w	r2, r2, r1, lsr #8
 80005be:	b2d2      	uxtb	r2, r2
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 80005c0:	5ca2      	ldrb	r2, [r4, r2]
 80005c2:	ea82 4211 	eor.w	r2, r2, r1, lsr #16
 80005c6:	b2d2      	uxtb	r2, r2
  crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 80005c8:	5ca2      	ldrb	r2, [r4, r2]
 80005ca:	4c12      	ldr	r4, [pc, #72]	@ (8000614 <ASPEP_sendBeacon+0x88>)
 80005cc:	ea82 6211 	eor.w	r2, r2, r1, lsr #24
  *headerPtr |= (uint32_t)crc << 28;
 80005d0:	5ca2      	ldrb	r2, [r4, r2]
 80005d2:	ea43 7302 	orr.w	r3, r3, r2, lsl #28
 80005d6:	f043 0305 	orr.w	r3, r3, #5
 80005da:	6203      	str	r3, [r0, #32]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80005dc:	b672      	cpsid	i
  {
#endif
    /* Insert CRC header in the packet to send */
    ASPEP_ComputeHeaderCRC((uint32_t *)txBuffer); //cstat !MISRAC2012-Rule-11.5
    __disable_irq(); /*TODO: Disable High frequency task is enough */
    if (NULL == pHandle->lockBuffer) /* Communication Ip free to send data*/
 80005de:	6c83      	ldr	r3, [r0, #72]	@ 0x48
 80005e0:	b14b      	cbz	r3, 80005f6 <ASPEP_sendBeacon+0x6a>
  __ASM volatile ("cpsie i" : : : "memory");
 80005e2:	b662      	cpsie	i
          pHandle->syncBuffer.length = bufferLength;
        }
      }
      else if(ASPEP_CTRL == dataType)
      {
        if (pHandle->ctrlBuffer.state != available)
 80005e4:	f890 3024 	ldrb.w	r3, [r0, #36]	@ 0x24
 80005e8:	b913      	cbnz	r3, 80005f0 <ASPEP_sendBeacon+0x64>
        {
          result = ASPEP_BUFFER_ERROR;
        }
        else
        {
          pHandle->ctrlBuffer.state = pending;
 80005ea:	2302      	movs	r3, #2
 80005ec:	f880 3024 	strb.w	r3, [r0, #36]	@ 0x24
}
 80005f0:	f85d 4b04 	ldr.w	r4, [sp], #4
 80005f4:	4770      	bx	lr
    (void)ASPEP_TXframeProcess(pHandle, ASPEP_CTRL, &pHandle->ctrlBuffer, ASPEP_CTRL_SIZE);
 80005f6:	f100 0120 	add.w	r1, r0, #32
        pHandle->ctrlBuffer.state = readLock;
 80005fa:	2303      	movs	r3, #3
 80005fc:	f880 3024 	strb.w	r3, [r0, #36]	@ 0x24
        pHandle->lockBuffer = (void *)&pHandle->ctrlBuffer;
 8000600:	6481      	str	r1, [r0, #72]	@ 0x48
 8000602:	b662      	cpsie	i
      pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, txBuffer, bufferLength);
 8000604:	2204      	movs	r2, #4
 8000606:	6d83      	ldr	r3, [r0, #88]	@ 0x58
}
 8000608:	f85d 4b04 	ldr.w	r4, [sp], #4
      pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, txBuffer, bufferLength);
 800060c:	6940      	ldr	r0, [r0, #20]
 800060e:	4718      	bx	r3
 8000610:	0800a1a8 	.word	0x0800a1a8
 8000614:	0800a198 	.word	0x0800a198

08000618 <ASPEP_sendPing>:
{
 8000618:	b430      	push	{r4, r5}
                   | (uint32_t)((uint32_t)cBit << 5U)
 800061a:	014b      	lsls	r3, r1, #5
    uint8_t Nbit = pHandle->syncPacketCount & 0x1U; /* Keep only LSB */
 800061c:	f890 c060 	ldrb.w	ip, [r0, #96]	@ 0x60
    uint8_t ipID = pHandle->liid & 0xFU;
 8000620:	f890 4063 	ldrb.w	r4, [r0, #99]	@ 0x63
  crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 8000624:	4d1d      	ldr	r5, [pc, #116]	@ (800069c <ASPEP_sendPing+0x84>)
                   | (uint32_t)((uint32_t)cBit << 5U)
 8000626:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
                   | (uint32_t)(((uint32_t) packetNumber) << 12U);
 800062a:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
                   | (uint32_t)((uint32_t)Nbit << 6U)
 800062e:	f00c 0101 	and.w	r1, ip, #1
                   | (uint32_t)(((uint32_t) packetNumber) << 12U);
 8000632:	ea43 1381 	orr.w	r3, r3, r1, lsl #6
 8000636:	ea43 13c1 	orr.w	r3, r3, r1, lsl #7
                   | (uint32_t)((uint32_t)ipID << 8U)
 800063a:	f004 040f 	and.w	r4, r4, #15
                   | (uint32_t)(((uint32_t) packetNumber) << 12U);
 800063e:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
  crc = CRC4_Lookup8[crc ^ (uint8_t)(header         & 0xffU)];
 8000642:	b2da      	uxtb	r2, r3
 8000644:	4c16      	ldr	r4, [pc, #88]	@ (80006a0 <ASPEP_sendPing+0x88>)
 8000646:	f042 0206 	orr.w	r2, r2, #6
                   | (uint32_t)(((uint32_t) packetNumber) << 12U);
 800064a:	f043 0106 	orr.w	r1, r3, #6
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 800064e:	5ca2      	ldrb	r2, [r4, r2]
 8000650:	ea82 2213 	eor.w	r2, r2, r3, lsr #8
 8000654:	b2d2      	uxtb	r2, r2
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 8000656:	5ca2      	ldrb	r2, [r4, r2]
 8000658:	ea82 4213 	eor.w	r2, r2, r3, lsr #16
 800065c:	b2d2      	uxtb	r2, r2
  crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 800065e:	5ca2      	ldrb	r2, [r4, r2]
 8000660:	ea82 6313 	eor.w	r3, r2, r3, lsr #24
  *headerPtr |= (uint32_t)crc << 28;
 8000664:	5ceb      	ldrb	r3, [r5, r3]
 8000666:	ea41 7303 	orr.w	r3, r1, r3, lsl #28
 800066a:	6203      	str	r3, [r0, #32]
  __ASM volatile ("cpsid i" : : : "memory");
 800066c:	b672      	cpsid	i
    if (NULL == pHandle->lockBuffer) /* Communication Ip free to send data*/
 800066e:	6c83      	ldr	r3, [r0, #72]	@ 0x48
 8000670:	b143      	cbz	r3, 8000684 <ASPEP_sendPing+0x6c>
  __ASM volatile ("cpsie i" : : : "memory");
 8000672:	b662      	cpsie	i
        if (pHandle->ctrlBuffer.state != available)
 8000674:	f890 3024 	ldrb.w	r3, [r0, #36]	@ 0x24
 8000678:	b913      	cbnz	r3, 8000680 <ASPEP_sendPing+0x68>
          pHandle->ctrlBuffer.state = pending;
 800067a:	2302      	movs	r3, #2
 800067c:	f880 3024 	strb.w	r3, [r0, #36]	@ 0x24
}
 8000680:	bc30      	pop	{r4, r5}
 8000682:	4770      	bx	lr
    (void)ASPEP_TXframeProcess(pHandle, ASPEP_CTRL, &pHandle->ctrlBuffer, ASPEP_CTRL_SIZE);
 8000684:	f100 0120 	add.w	r1, r0, #32
        pHandle->ctrlBuffer.state = readLock;
 8000688:	2303      	movs	r3, #3
 800068a:	f880 3024 	strb.w	r3, [r0, #36]	@ 0x24
        pHandle->lockBuffer = (void *)&pHandle->ctrlBuffer;
 800068e:	6481      	str	r1, [r0, #72]	@ 0x48
 8000690:	b662      	cpsie	i
      pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, txBuffer, bufferLength);
 8000692:	2204      	movs	r2, #4
 8000694:	6d83      	ldr	r3, [r0, #88]	@ 0x58
 8000696:	6940      	ldr	r0, [r0, #20]
}
 8000698:	bc30      	pop	{r4, r5}
      pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, txBuffer, bufferLength);
 800069a:	4718      	bx	r3
 800069c:	0800a198 	.word	0x0800a198
 80006a0:	0800a1a8 	.word	0x0800a1a8

080006a4 <ASPEP_getBuffer>:
    if (MCTL_SYNC == syncAsync)
 80006a4:	2a0a      	cmp	r2, #10
 80006a6:	d009      	beq.n	80006bc <ASPEP_getBuffer+0x18>
      if ((pHandle->asyncBufferA.state > writeLock) && (pHandle->asyncBufferB.state > writeLock))
 80006a8:	f890 3036 	ldrb.w	r3, [r0, #54]	@ 0x36
 80006ac:	2b01      	cmp	r3, #1
 80006ae:	d91d      	bls.n	80006ec <ASPEP_getBuffer+0x48>
 80006b0:	f890 303e 	ldrb.w	r3, [r0, #62]	@ 0x3e
 80006b4:	2b01      	cmp	r3, #1
 80006b6:	d90d      	bls.n	80006d4 <ASPEP_getBuffer+0x30>
        result = false;
 80006b8:	2000      	movs	r0, #0
}
 80006ba:	4770      	bx	lr
      if (pHandle->syncBuffer.state <= writeLock) /* Possible values are free or writeLock*/
 80006bc:	f890 302e 	ldrb.w	r3, [r0, #46]	@ 0x2e
 80006c0:	2b01      	cmp	r3, #1
 80006c2:	d8f9      	bhi.n	80006b8 <ASPEP_getBuffer+0x14>
        *buffer = &pHandle->syncBuffer.buffer[ASPEP_HEADER_SIZE];
 80006c4:	6a83      	ldr	r3, [r0, #40]	@ 0x28
        pHandle->syncBuffer.state = writeLock;
 80006c6:	2201      	movs	r2, #1
        *buffer = &pHandle->syncBuffer.buffer[ASPEP_HEADER_SIZE];
 80006c8:	3304      	adds	r3, #4
 80006ca:	600b      	str	r3, [r1, #0]
        pHandle->syncBuffer.state = writeLock;
 80006cc:	f880 202e 	strb.w	r2, [r0, #46]	@ 0x2e
  bool result = true;
 80006d0:	2001      	movs	r0, #1
 80006d2:	4770      	bx	lr
          *buffer = &pHandle->asyncBufferB.buffer[ASPEP_HEADER_SIZE];
 80006d4:	6b83      	ldr	r3, [r0, #56]	@ 0x38
          pHandle->asyncBufferB.state = writeLock;
 80006d6:	f04f 0c01 	mov.w	ip, #1
          pHandle->lastRequestedAsyncBuff = &pHandle->asyncBufferB;
 80006da:	f100 0238 	add.w	r2, r0, #56	@ 0x38
          *buffer = &pHandle->asyncBufferB.buffer[ASPEP_HEADER_SIZE];
 80006de:	3304      	adds	r3, #4
          pHandle->asyncBufferB.state = writeLock;
 80006e0:	f880 c03e 	strb.w	ip, [r0, #62]	@ 0x3e
          pHandle->lastRequestedAsyncBuff = &pHandle->asyncBufferB;
 80006e4:	6402      	str	r2, [r0, #64]	@ 0x40
          *buffer = &pHandle->asyncBufferB.buffer[ASPEP_HEADER_SIZE];
 80006e6:	600b      	str	r3, [r1, #0]
  bool result = true;
 80006e8:	2001      	movs	r0, #1
 80006ea:	4770      	bx	lr
          *buffer = &pHandle->asyncBufferA.buffer[ASPEP_HEADER_SIZE];
 80006ec:	6b03      	ldr	r3, [r0, #48]	@ 0x30
          pHandle->asyncBufferA.state = writeLock;
 80006ee:	f04f 0c01 	mov.w	ip, #1
          pHandle->lastRequestedAsyncBuff = &pHandle->asyncBufferA;
 80006f2:	f100 0230 	add.w	r2, r0, #48	@ 0x30
          *buffer = &pHandle->asyncBufferA.buffer[ASPEP_HEADER_SIZE];
 80006f6:	3304      	adds	r3, #4
          pHandle->asyncBufferA.state = writeLock;
 80006f8:	f880 c036 	strb.w	ip, [r0, #54]	@ 0x36
          pHandle->lastRequestedAsyncBuff = &pHandle->asyncBufferA;
 80006fc:	6402      	str	r2, [r0, #64]	@ 0x40
          *buffer = &pHandle->asyncBufferA.buffer[ASPEP_HEADER_SIZE];
 80006fe:	600b      	str	r3, [r1, #0]
 8000700:	e7f2      	b.n	80006e8 <ASPEP_getBuffer+0x44>
 8000702:	bf00      	nop

08000704 <ASPEP_sendPacket>:
{
 8000704:	4684      	mov	ip, r0
    if (ASPEP_CONNECTED == pHandle-> ASPEP_State)
 8000706:	f890 0064 	ldrb.w	r0, [r0, #100]	@ 0x64
 800070a:	2802      	cmp	r0, #2
 800070c:	d001      	beq.n	8000712 <ASPEP_sendPacket+0xe>
      result = ASPEP_NOT_CONNECTED;
 800070e:	2002      	movs	r0, #2
 8000710:	4770      	bx	lr
      tmpHeader = ((uint32_t)((uint32_t)txDataLengthTemp << (uint32_t)4) | (uint32_t)syncAsync);
 8000712:	ea43 1002 	orr.w	r0, r3, r2, lsl #4
      *header = tmpHeader;
 8000716:	f841 0c04 	str.w	r0, [r1, #-4]
      if (1U == pHandle->Capabilities.DATA_CRC)
 800071a:	f89c 006c 	ldrb.w	r0, [ip, #108]	@ 0x6c
 800071e:	2801      	cmp	r0, #1
 8000720:	d104      	bne.n	800072c <ASPEP_sendPacket+0x28>
        packet[txDataLengthTemp] = (uint8_t)0xCA; /* Dummy CRC */
 8000722:	f64f 60ca 	movw	r0, #65226	@ 0xfeca
 8000726:	5288      	strh	r0, [r1, r2]
        txDataLengthTemp += (uint16_t)ASPEP_DATACRC_SIZE;
 8000728:	3202      	adds	r2, #2
 800072a:	b292      	uxth	r2, r2
      if (MCTL_SYNC == syncAsync)
 800072c:	2b0a      	cmp	r3, #10
 800072e:	d105      	bne.n	800073c <ASPEP_sendPacket+0x38>
        if (pSupHandle->MCP_PacketAvailable)
 8000730:	f89c 0010 	ldrb.w	r0, [ip, #16]
 8000734:	b348      	cbz	r0, 800078a <ASPEP_sendPacket+0x86>
          pSupHandle->MCP_PacketAvailable = false; /* CMD from controller is processed*/
 8000736:	2000      	movs	r0, #0
 8000738:	f88c 0010 	strb.w	r0, [ip, #16]
  uint32_t header = *headerPtr;
 800073c:	f851 0c04 	ldr.w	r0, [r1, #-4]
{
 8000740:	b570      	push	{r4, r5, r6, lr}
  crc = CRC4_Lookup8[crc ^ (uint8_t)(header         & 0xffU)];
 8000742:	4d34      	ldr	r5, [pc, #208]	@ (8000814 <ASPEP_sendPacket+0x110>)
 8000744:	b2c4      	uxtb	r4, r0
        result = ASPEP_TXframeProcess(pHandle, syncAsync, header, txDataLengthTemp + (uint16_t)ASPEP_HEADER_SIZE);
 8000746:	3204      	adds	r2, #4
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 8000748:	5d2e      	ldrb	r6, [r5, r4]
 800074a:	f3c0 2407 	ubfx	r4, r0, #8, #8
 800074e:	4074      	eors	r4, r6
      header--; /* Header ues 4*8 bits on top of txBuffer*/
 8000750:	f1a1 0e04 	sub.w	lr, r1, #4
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 8000754:	5d2e      	ldrb	r6, [r5, r4]
 8000756:	f3c0 4407 	ubfx	r4, r0, #16, #8
 800075a:	4074      	eors	r4, r6
        result = ASPEP_TXframeProcess(pHandle, syncAsync, header, txDataLengthTemp + (uint16_t)ASPEP_HEADER_SIZE);
 800075c:	b292      	uxth	r2, r2
  crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 800075e:	5d2c      	ldrb	r4, [r5, r4]
 8000760:	f3c0 6503 	ubfx	r5, r0, #24, #4
 8000764:	406c      	eors	r4, r5
 8000766:	4d2c      	ldr	r5, [pc, #176]	@ (8000818 <ASPEP_sendPacket+0x114>)
  *headerPtr |= (uint32_t)crc << 28;
 8000768:	5d2c      	ldrb	r4, [r5, r4]
 800076a:	ea40 7004 	orr.w	r0, r0, r4, lsl #28
 800076e:	f841 0c04 	str.w	r0, [r1, #-4]
  __ASM volatile ("cpsid i" : : : "memory");
 8000772:	b672      	cpsid	i
    if (NULL == pHandle->lockBuffer) /* Communication Ip free to send data*/
 8000774:	f8dc 1048 	ldr.w	r1, [ip, #72]	@ 0x48
 8000778:	b1b9      	cbz	r1, 80007aa <ASPEP_sendPacket+0xa6>
  __ASM volatile ("cpsie i" : : : "memory");
 800077a:	b662      	cpsie	i
      if (MCTL_ASYNC == dataType)
 800077c:	2b09      	cmp	r3, #9
 800077e:	d006      	beq.n	800078e <ASPEP_sendPacket+0x8a>
      else if (MCTL_SYNC == dataType)
 8000780:	2b0a      	cmp	r3, #10
 8000782:	d02a      	beq.n	80007da <ASPEP_sendPacket+0xd6>
      else if(ASPEP_CTRL == dataType)
 8000784:	b37b      	cbz	r3, 80007e6 <ASPEP_sendPacket+0xe2>
  uint8_t result = ASPEP_OK;
 8000786:	2000      	movs	r0, #0
}
 8000788:	bd70      	pop	{r4, r5, r6, pc}
          result = MCTL_SYNC_NOT_EXPECTED;
 800078a:	2001      	movs	r0, #1
}
 800078c:	4770      	bx	lr
        if (txBuffer != (uint8_t *)pHandle->lastRequestedAsyncBuff->buffer)
 800078e:	f8dc 3040 	ldr.w	r3, [ip, #64]	@ 0x40
 8000792:	6819      	ldr	r1, [r3, #0]
  uint8_t result = ASPEP_OK;
 8000794:	458e      	cmp	lr, r1
 8000796:	bf14      	ite	ne
 8000798:	2003      	movne	r0, #3
 800079a:	2000      	moveq	r0, #0
        if (NULL == pHandle->asyncNextBuffer)
 800079c:	f8dc 1044 	ldr.w	r1, [ip, #68]	@ 0x44
 80007a0:	b3a1      	cbz	r1, 800080c <ASPEP_sendPacket+0x108>
        pHandle->lastRequestedAsyncBuff->state = pending;
 80007a2:	2102      	movs	r1, #2
 80007a4:	7199      	strb	r1, [r3, #6]
        pHandle->lastRequestedAsyncBuff->length = bufferLength;
 80007a6:	809a      	strh	r2, [r3, #4]
}
 80007a8:	bd70      	pop	{r4, r5, r6, pc}
      if (MCTL_ASYNC == dataType)
 80007aa:	2b09      	cmp	r3, #9
 80007ac:	d029      	beq.n	8000802 <ASPEP_sendPacket+0xfe>
      else if (MCTL_SYNC == dataType)
 80007ae:	2b0a      	cmp	r3, #10
        pHandle->syncBuffer.state = readLock;
 80007b0:	f04f 0303 	mov.w	r3, #3
 80007b4:	bf0b      	itete	eq
 80007b6:	f88c 302e 	strbeq.w	r3, [ip, #46]	@ 0x2e
        pHandle->ctrlBuffer.state = readLock;
 80007ba:	f88c 3024 	strbne.w	r3, [ip, #36]	@ 0x24
        pHandle->lockBuffer = (void *)&pHandle->syncBuffer;
 80007be:	f10c 0328 	addeq.w	r3, ip, #40	@ 0x28
        pHandle->lockBuffer = (void *)&pHandle->ctrlBuffer;
 80007c2:	f10c 0320 	addne.w	r3, ip, #32
        pHandle->lockBuffer = (void *)pHandle->lastRequestedAsyncBuff;
 80007c6:	f8cc 3048 	str.w	r3, [ip, #72]	@ 0x48
 80007ca:	b662      	cpsie	i
      pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, txBuffer, bufferLength);
 80007cc:	f8dc 3058 	ldr.w	r3, [ip, #88]	@ 0x58
 80007d0:	f8dc 0014 	ldr.w	r0, [ip, #20]
 80007d4:	4671      	mov	r1, lr
 80007d6:	4798      	blx	r3
 80007d8:	e7d5      	b.n	8000786 <ASPEP_sendPacket+0x82>
        if (pHandle -> syncBuffer.state != writeLock)
 80007da:	f89c 302e 	ldrb.w	r3, [ip, #46]	@ 0x2e
 80007de:	2b01      	cmp	r3, #1
 80007e0:	d009      	beq.n	80007f6 <ASPEP_sendPacket+0xf2>
          result = ASPEP_BUFFER_ERROR;
 80007e2:	2003      	movs	r0, #3
}
 80007e4:	bd70      	pop	{r4, r5, r6, pc}
        if (pHandle->ctrlBuffer.state != available)
 80007e6:	f89c 3024 	ldrb.w	r3, [ip, #36]	@ 0x24
 80007ea:	2b00      	cmp	r3, #0
 80007ec:	d1f9      	bne.n	80007e2 <ASPEP_sendPacket+0xde>
          pHandle->ctrlBuffer.state = pending;
 80007ee:	2302      	movs	r3, #2
 80007f0:	f88c 3024 	strb.w	r3, [ip, #36]	@ 0x24
 80007f4:	e7c7      	b.n	8000786 <ASPEP_sendPacket+0x82>
          pHandle->syncBuffer.state = pending;
 80007f6:	2302      	movs	r3, #2
 80007f8:	f88c 302e 	strb.w	r3, [ip, #46]	@ 0x2e
          pHandle->syncBuffer.length = bufferLength;
 80007fc:	f8ac 202c 	strh.w	r2, [ip, #44]	@ 0x2c
 8000800:	e7c1      	b.n	8000786 <ASPEP_sendPacket+0x82>
        pHandle->lastRequestedAsyncBuff->state = readLock;
 8000802:	f8dc 3040 	ldr.w	r3, [ip, #64]	@ 0x40
 8000806:	2103      	movs	r1, #3
 8000808:	7199      	strb	r1, [r3, #6]
        pHandle->lockBuffer = (void *)pHandle->lastRequestedAsyncBuff;
 800080a:	e7dc      	b.n	80007c6 <ASPEP_sendPacket+0xc2>
          pHandle->asyncNextBuffer = pHandle->lastRequestedAsyncBuff;
 800080c:	f8cc 3044 	str.w	r3, [ip, #68]	@ 0x44
 8000810:	e7c7      	b.n	80007a2 <ASPEP_sendPacket+0x9e>
 8000812:	bf00      	nop
 8000814:	0800a1a8 	.word	0x0800a1a8
 8000818:	0800a198 	.word	0x0800a198

0800081c <ASPEP_HWDataTransmittedIT>:
  * Therefore, there is no need to protect this ISR against another higher priority ISR (HF Task).
  *
  * @param  *pHandle Handler of the current instance of the ASPEP component
  */
void ASPEP_HWDataTransmittedIT(ASPEP_Handle_t *pHandle)
{
 800081c:	b510      	push	{r4, lr}
  }
  else
  {
#endif
    /* First free previous readLock buffer */
    if (pHandle->ctrlBuffer.state == readLock)
 800081e:	f890 3024 	ldrb.w	r3, [r0, #36]	@ 0x24
 8000822:	2b03      	cmp	r3, #3
{
 8000824:	4604      	mov	r4, r0
    if (pHandle->ctrlBuffer.state == readLock)
 8000826:	d013      	beq.n	8000850 <ASPEP_HWDataTransmittedIT+0x34>
      pHandle->ctrlBuffer.state = available;
    }
    else /* if previous buffer was not ASPEP_CTRL, then the buffer locked is a MCTL_Buff_t */
    {
      MCTL_Buff_t *tempBuff = (MCTL_Buff_t *)pHandle->lockBuffer; //cstat !MISRAC2012-Rule-11.5
      tempBuff->state = available;
 8000828:	6c82      	ldr	r2, [r0, #72]	@ 0x48
 800082a:	2100      	movs	r1, #0
 800082c:	7191      	strb	r1, [r2, #6]
    }
    if (pHandle->syncBuffer.state == pending)
 800082e:	f890 202e 	ldrb.w	r2, [r0, #46]	@ 0x2e
 8000832:	2a02      	cmp	r2, #2
 8000834:	d013      	beq.n	800085e <ASPEP_HWDataTransmittedIT+0x42>
      pHandle->lockBuffer = (void *)&pHandle->syncBuffer;
      pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, pHandle->syncBuffer.buffer, pHandle->syncBuffer.length);
      pHandle->syncBuffer.state = readLock;
    }
    /* Second prepare transfer of pending buffer */
    else if (pHandle->ctrlBuffer.state == pending)
 8000836:	2b02      	cmp	r3, #2
 8000838:	d11d      	bne.n	8000876 <ASPEP_HWDataTransmittedIT+0x5a>
    {
      pHandle->lockBuffer = (void *)(&pHandle ->ctrlBuffer);
 800083a:	f100 0120 	add.w	r1, r0, #32
      pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, pHandle->ctrlBuffer.buffer, ASPEP_CTRL_SIZE);
 800083e:	6d83      	ldr	r3, [r0, #88]	@ 0x58
      pHandle->lockBuffer = (void *)(&pHandle ->ctrlBuffer);
 8000840:	6481      	str	r1, [r0, #72]	@ 0x48
      pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, pHandle->ctrlBuffer.buffer, ASPEP_CTRL_SIZE);
 8000842:	2204      	movs	r2, #4
 8000844:	6940      	ldr	r0, [r0, #20]
 8000846:	4798      	blx	r3
      pHandle->ctrlBuffer.state = readLock;
 8000848:	2303      	movs	r3, #3
 800084a:	f884 3024 	strb.w	r3, [r4, #36]	@ 0x24
      __enable_irq();
    }
#ifdef NULL_PTR_CHECK_ASP
  }
#endif
}
 800084e:	bd10      	pop	{r4, pc}
    if (pHandle->syncBuffer.state == pending)
 8000850:	f890 302e 	ldrb.w	r3, [r0, #46]	@ 0x2e
      pHandle->ctrlBuffer.state = available;
 8000854:	2200      	movs	r2, #0
    if (pHandle->syncBuffer.state == pending)
 8000856:	2b02      	cmp	r3, #2
      pHandle->ctrlBuffer.state = available;
 8000858:	f880 2024 	strb.w	r2, [r0, #36]	@ 0x24
    if (pHandle->syncBuffer.state == pending)
 800085c:	d10b      	bne.n	8000876 <ASPEP_HWDataTransmittedIT+0x5a>
      pHandle->lockBuffer = (void *)&pHandle->syncBuffer;
 800085e:	f104 0028 	add.w	r0, r4, #40	@ 0x28
      pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, pHandle->syncBuffer.buffer, pHandle->syncBuffer.length);
 8000862:	6da3      	ldr	r3, [r4, #88]	@ 0x58
      pHandle->lockBuffer = (void *)&pHandle->syncBuffer;
 8000864:	64a0      	str	r0, [r4, #72]	@ 0x48
      pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, pHandle->syncBuffer.buffer, pHandle->syncBuffer.length);
 8000866:	8da2      	ldrh	r2, [r4, #44]	@ 0x2c
 8000868:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 800086a:	6960      	ldr	r0, [r4, #20]
 800086c:	4798      	blx	r3
      pHandle->syncBuffer.state = readLock;
 800086e:	2303      	movs	r3, #3
 8000870:	f884 302e 	strb.w	r3, [r4, #46]	@ 0x2e
}
 8000874:	bd10      	pop	{r4, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 8000876:	b672      	cpsid	i
      if (pHandle->asyncNextBuffer != NULL)
 8000878:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 800087a:	b1cb      	cbz	r3, 80008b0 <ASPEP_HWDataTransmittedIT+0x94>
        pHandle->asyncNextBuffer->state = readLock;
 800087c:	2203      	movs	r2, #3
        pHandle->lockBuffer = (void *)pHandle->asyncNextBuffer;
 800087e:	64a3      	str	r3, [r4, #72]	@ 0x48
        pHandle->asyncNextBuffer->state = readLock;
 8000880:	719a      	strb	r2, [r3, #6]
        pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, pHandle->asyncNextBuffer->buffer, pHandle->asyncNextBuffer->length);
 8000882:	6819      	ldr	r1, [r3, #0]
 8000884:	889a      	ldrh	r2, [r3, #4]
 8000886:	6960      	ldr	r0, [r4, #20]
 8000888:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 800088a:	4798      	blx	r3
        if ((pHandle->asyncBufferA.state == pending) || (pHandle->asyncBufferB.state == pending))
 800088c:	f894 3036 	ldrb.w	r3, [r4, #54]	@ 0x36
 8000890:	2b02      	cmp	r3, #2
 8000892:	d007      	beq.n	80008a4 <ASPEP_HWDataTransmittedIT+0x88>
 8000894:	f894 303e 	ldrb.w	r3, [r4, #62]	@ 0x3e
 8000898:	2b02      	cmp	r3, #2
 800089a:	d003      	beq.n	80008a4 <ASPEP_HWDataTransmittedIT+0x88>
          pHandle->asyncNextBuffer = NULL;
 800089c:	2300      	movs	r3, #0
 800089e:	6463      	str	r3, [r4, #68]	@ 0x44
  __ASM volatile ("cpsie i" : : : "memory");
 80008a0:	b662      	cpsie	i
}
 80008a2:	bd10      	pop	{r4, pc}
          uint32_t temp = (uint32_t)&pHandle->asyncBufferA + (uint32_t)&pHandle->asyncBufferB
 80008a4:	6c62      	ldr	r2, [r4, #68]	@ 0x44
 80008a6:	0063      	lsls	r3, r4, #1
 80008a8:	3368      	adds	r3, #104	@ 0x68
 80008aa:	1a9b      	subs	r3, r3, r2
          pHandle->asyncNextBuffer = (MCTL_Buff_t *) temp; //cstat !MISRAC2012-Rule-11.4
 80008ac:	6463      	str	r3, [r4, #68]	@ 0x44
        {
 80008ae:	e7f7      	b.n	80008a0 <ASPEP_HWDataTransmittedIT+0x84>
        pHandle->lockBuffer = NULL;
 80008b0:	64a3      	str	r3, [r4, #72]	@ 0x48
 80008b2:	e7f5      	b.n	80008a0 <ASPEP_HWDataTransmittedIT+0x84>

080008b4 <ASPEP_RXframeProcess>:
    uint16_t packetNumber;
#if VALID_CRC_DATA
    bool validCRCData = true;
#endif
    *packetLength = 0;
    if (pHandle->NewPacketAvailable)
 80008b4:	f890 3061 	ldrb.w	r3, [r0, #97]	@ 0x61
    uint32_t packetHeader = *((uint32_t *)pHandle->rxHeader); //cstat !MISRAC2012-Rule-11.3
 80008b8:	69c2      	ldr	r2, [r0, #28]
    *packetLength = 0;
 80008ba:	f04f 0c00 	mov.w	ip, #0
{
 80008be:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80008c2:	4604      	mov	r4, r0
    *packetLength = 0;
 80008c4:	f8a1 c000 	strh.w	ip, [r1]
    if (pHandle->NewPacketAvailable)
 80008c8:	b1cb      	cbz	r3, 80008fe <ASPEP_RXframeProcess+0x4a>
    {
      pHandle->NewPacketAvailable = false; /* Consumes new packet*/
      switch (pHandle->ASPEP_State)
 80008ca:	f890 3064 	ldrb.w	r3, [r0, #100]	@ 0x64
      pHandle->NewPacketAvailable = false; /* Consumes new packet*/
 80008ce:	f880 c061 	strb.w	ip, [r0, #97]	@ 0x61
      switch (pHandle->ASPEP_State)
 80008d2:	2b01      	cmp	r3, #1
 80008d4:	d055      	beq.n	8000982 <ASPEP_RXframeProcess+0xce>
 80008d6:	2b02      	cmp	r3, #2
 80008d8:	d018      	beq.n	800090c <ASPEP_RXframeProcess+0x58>
 80008da:	b933      	cbnz	r3, 80008ea <ASPEP_RXframeProcess+0x36>
      {
        case ASPEP_IDLE:
        {
          if (BEACON == pHandle->rxPacketType)
 80008dc:	6e81      	ldr	r1, [r0, #104]	@ 0x68
 80008de:	2905      	cmp	r1, #5
 80008e0:	f000 80e3 	beq.w	8000aaa <ASPEP_RXframeProcess+0x1f6>
              /* Nothing to do, controller has to send back new beacon with matching capabilities */
            }
            /* Beacon Packet must be answered*/
            ASPEP_sendBeacon(pHandle, &pHandle->Capabilities);
          }
          else if (PING == pHandle->rxPacketType)
 80008e4:	2906      	cmp	r1, #6
 80008e6:	f000 8129 	beq.w	8000b3c <ASPEP_RXframeProcess+0x288>
  uint8_t *result = NULL; //cstat !MISRAC2012-Rule-8.13
 80008ea:	2500      	movs	r5, #0

        default:
          break;
      }
      /* The valid received packet is now safely consumes, we are ready to receive a new packet */
      pHandle->fASPEP_cfg_recept(pHandle->ASPEPIp, pHandle->rxHeader, ASPEP_HEADER_SIZE);
 80008ec:	6960      	ldr	r0, [r4, #20]
 80008ee:	6d63      	ldr	r3, [r4, #84]	@ 0x54
 80008f0:	2204      	movs	r2, #4
 80008f2:	f104 011c 	add.w	r1, r4, #28
 80008f6:	4798      	blx	r3
    }
#ifdef NULL_PTR_CHECK_ASP
  }
#endif
  return (result);
}
 80008f8:	4628      	mov	r0, r5
 80008fa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    else if (pHandle->badPacketFlag > ASPEP_OK)
 80008fe:	f890 3062 	ldrb.w	r3, [r0, #98]	@ 0x62
 8000902:	b9bb      	cbnz	r3, 8000934 <ASPEP_RXframeProcess+0x80>
  uint8_t *result = NULL; //cstat !MISRAC2012-Rule-8.13
 8000904:	2500      	movs	r5, #0
}
 8000906:	4628      	mov	r0, r5
 8000908:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
          if (BEACON == pHandle->rxPacketType)
 800090c:	6e83      	ldr	r3, [r0, #104]	@ 0x68
 800090e:	2b05      	cmp	r3, #5
 8000910:	d045      	beq.n	800099e <ASPEP_RXframeProcess+0xea>
          else if (PING == pHandle->rxPacketType)
 8000912:	2b06      	cmp	r3, #6
 8000914:	f000 8118 	beq.w	8000b48 <ASPEP_RXframeProcess+0x294>
          else if (DATA_PACKET == pHandle->rxPacketType)
 8000918:	2b09      	cmp	r3, #9
 800091a:	d1e6      	bne.n	80008ea <ASPEP_RXframeProcess+0x36>
              pHandle->syncPacketCount++; /* this counter is incremented at each valid data packet received from controller */
 800091c:	f890 3060 	ldrb.w	r3, [r0, #96]	@ 0x60
              *packetLength = pHandle->rxLengthASPEP;
 8000920:	f8b0 205c 	ldrh.w	r2, [r0, #92]	@ 0x5c
              result = pHandle->rxBuffer;
 8000924:	69a5      	ldr	r5, [r4, #24]
              pHandle->syncPacketCount++; /* this counter is incremented at each valid data packet received from controller */
 8000926:	3301      	adds	r3, #1
              pSupHandle->MCP_PacketAvailable = true; /* Will be consumed in ASPEP_sendPacket */
 8000928:	2001      	movs	r0, #1
              pHandle->syncPacketCount++; /* this counter is incremented at each valid data packet received from controller */
 800092a:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
              pSupHandle->MCP_PacketAvailable = true; /* Will be consumed in ASPEP_sendPacket */
 800092e:	7420      	strb	r0, [r4, #16]
              *packetLength = pHandle->rxLengthASPEP;
 8000930:	800a      	strh	r2, [r1, #0]
              result = pHandle->rxBuffer;
 8000932:	e7db      	b.n	80008ec <ASPEP_RXframeProcess+0x38>
  *packet = NACK | (uint32_t)(((uint32_t) errorInfo) << 8U) | (uint32_t)(((uint32_t) errorInfo) << 16U);
 8000934:	eb03 2303 	add.w	r3, r3, r3, lsl #8
 8000938:	021b      	lsls	r3, r3, #8
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 800093a:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800093e:	488b      	ldr	r0, [pc, #556]	@ (8000b6c <ASPEP_RXframeProcess+0x2b8>)
  crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 8000940:	4d8b      	ldr	r5, [pc, #556]	@ (8000b70 <ASPEP_RXframeProcess+0x2bc>)
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 8000942:	f082 0209 	eor.w	r2, r2, #9
  *packet = NACK | (uint32_t)(((uint32_t) errorInfo) << 8U) | (uint32_t)(((uint32_t) errorInfo) << 16U);
 8000946:	f043 010f 	orr.w	r1, r3, #15
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 800094a:	5c82      	ldrb	r2, [r0, r2]
 800094c:	ea82 4313 	eor.w	r3, r2, r3, lsr #16
 8000950:	b2db      	uxtb	r3, r3
  crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 8000952:	5cc3      	ldrb	r3, [r0, r3]
  *headerPtr |= (uint32_t)crc << 28;
 8000954:	5ceb      	ldrb	r3, [r5, r3]
 8000956:	ea41 7303 	orr.w	r3, r1, r3, lsl #28
 800095a:	6223      	str	r3, [r4, #32]
  __ASM volatile ("cpsid i" : : : "memory");
 800095c:	b672      	cpsid	i
    if (NULL == pHandle->lockBuffer) /* Communication Ip free to send data*/
 800095e:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 8000960:	2b00      	cmp	r3, #0
 8000962:	f000 80f7 	beq.w	8000b54 <ASPEP_RXframeProcess+0x2a0>
  __ASM volatile ("cpsie i" : : : "memory");
 8000966:	b662      	cpsie	i
        if (pHandle->ctrlBuffer.state != available)
 8000968:	f894 3024 	ldrb.w	r3, [r4, #36]	@ 0x24
 800096c:	b913      	cbnz	r3, 8000974 <ASPEP_RXframeProcess+0xc0>
          pHandle->ctrlBuffer.state = pending;
 800096e:	2302      	movs	r3, #2
 8000970:	f884 3024 	strb.w	r3, [r4, #36]	@ 0x24
      pHandle->badPacketFlag = ASPEP_OK;
 8000974:	2200      	movs	r2, #0
      pHandle->fASPEP_HWSync(pHandle->ASPEPIp);
 8000976:	6d23      	ldr	r3, [r4, #80]	@ 0x50
 8000978:	6960      	ldr	r0, [r4, #20]
      pHandle->badPacketFlag = ASPEP_OK;
 800097a:	f884 2062 	strb.w	r2, [r4, #98]	@ 0x62
      pHandle->fASPEP_HWSync(pHandle->ASPEPIp);
 800097e:	4798      	blx	r3
 8000980:	e7c0      	b.n	8000904 <ASPEP_RXframeProcess+0x50>
          if (BEACON == pHandle->rxPacketType)
 8000982:	6e81      	ldr	r1, [r0, #104]	@ 0x68
 8000984:	2905      	cmp	r1, #5
 8000986:	d04f      	beq.n	8000a28 <ASPEP_RXframeProcess+0x174>
          else if (PING == pHandle->rxPacketType)
 8000988:	2906      	cmp	r1, #6
 800098a:	d1ae      	bne.n	80008ea <ASPEP_RXframeProcess+0x36>
            ASPEP_sendPing(pHandle, ASPEP_PING_CFG, packetNumber);
 800098c:	4619      	mov	r1, r3
 800098e:	f3c2 320f 	ubfx	r2, r2, #12, #16
 8000992:	f7ff fe41 	bl	8000618 <ASPEP_sendPing>
            pHandle->ASPEP_State = ASPEP_CONNECTED;
 8000996:	2302      	movs	r3, #2
 8000998:	f884 3064 	strb.w	r3, [r4, #100]	@ 0x64
 800099c:	e7a5      	b.n	80008ea <ASPEP_RXframeProcess+0x36>
  MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 800099e:	f894 e01d 	ldrb.w	lr, [r4, #29]
  pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_maxSize);
 80009a2:	f894 506d 	ldrb.w	r5, [r4, #109]	@ 0x6d
  MasterCapabilities.DATA_CRC = pHandle->rxHeader[0] >> 7U ;                     /*Bit 7 */
 80009a6:	7f00      	ldrb	r0, [r0, #28]
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80009a8:	f894 606c 	ldrb.w	r6, [r4, #108]	@ 0x6c
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 80009ac:	f894 706e 	ldrb.w	r7, [r4, #110]	@ 0x6e
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 80009b0:	f894 906f 	ldrb.w	r9, [r4, #111]	@ 0x6f
  MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 80009b4:	f00e 0e3f 	and.w	lr, lr, #63	@ 0x3f
  MasterCapabilities.DATA_CRC = pHandle->rxHeader[0] >> 7U ;                     /*Bit 7 */
 80009b8:	09c0      	lsrs	r0, r0, #7
  pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_maxSize);
 80009ba:	4575      	cmp	r5, lr
 80009bc:	bf28      	it	cs
 80009be:	4675      	movcs	r5, lr
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80009c0:	42b0      	cmp	r0, r6
 80009c2:	4601      	mov	r1, r0
  MasterCapabilities.TXS_maxSize = (uint8_t)((packetHeader&0x01FC000U)  >> 14); /*Bits 14 to 20 */
 80009c4:	f3c2 3886 	ubfx	r8, r2, #14, #7
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80009c8:	bf28      	it	cs
 80009ca:	4631      	movcs	r1, r6
 80009cc:	4663      	mov	r3, ip
 80009ce:	f361 0307 	bfi	r3, r1, #0, #8
  MasterCapabilities.TXA_maxSize = (uint8_t)((packetHeader&0xFE00000U) >> 21);  /*Bits 21 to 27  */
 80009d2:	f3c2 5a46 	ubfx	sl, r2, #21, #7
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 80009d6:	45b8      	cmp	r8, r7
 80009d8:	4641      	mov	r1, r8
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80009da:	f365 230f 	bfi	r3, r5, #8, #8
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 80009de:	bf28      	it	cs
 80009e0:	4639      	movcs	r1, r7
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 80009e2:	45ca      	cmp	sl, r9
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80009e4:	f361 4317 	bfi	r3, r1, #16, #8
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 80009e8:	4651      	mov	r1, sl
 80009ea:	bf28      	it	cs
 80009ec:	4649      	movcs	r1, r9
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80009ee:	f361 631f 	bfi	r3, r1, #24, #8
  if ((MasterCapabilities.DATA_CRC != pHandle->Capabilities.DATA_CRC)
 80009f2:	42b0      	cmp	r0, r6
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80009f4:	66e3      	str	r3, [r4, #108]	@ 0x6c
  if ((MasterCapabilities.DATA_CRC != pHandle->Capabilities.DATA_CRC)
 80009f6:	f104 016c 	add.w	r1, r4, #108	@ 0x6c
 80009fa:	d80f      	bhi.n	8000a1c <ASPEP_RXframeProcess+0x168>
   || (MasterCapabilities.RX_maxSize > pHandle->Capabilities.RX_maxSize)
 80009fc:	45ae      	cmp	lr, r5
 80009fe:	d80d      	bhi.n	8000a1c <ASPEP_RXframeProcess+0x168>
   || (pHandle->Capabilities.TXS_maxSize != MasterCapabilities.TXS_maxSize )
 8000a00:	45b8      	cmp	r8, r7
 8000a02:	d80b      	bhi.n	8000a1c <ASPEP_RXframeProcess+0x168>
   || (pHandle->Capabilities.TXA_maxSize != MasterCapabilities.TXA_maxSize )
 8000a04:	45ca      	cmp	sl, r9
 8000a06:	d809      	bhi.n	8000a1c <ASPEP_RXframeProcess+0x168>
   || (MasterCapabilities.version != pHandle->Capabilities.version) )
 8000a08:	f894 c070 	ldrb.w	ip, [r4, #112]	@ 0x70
 8000a0c:	f3c2 1202 	ubfx	r2, r2, #4, #3
 8000a10:	ebac 0c02 	sub.w	ip, ip, r2
 8000a14:	fabc fc8c 	clz	ip, ip
 8000a18:	ea4f 1c5c 	mov.w	ip, ip, lsr #5
 8000a1c:	f884 c064 	strb.w	ip, [r4, #100]	@ 0x64
            ASPEP_sendBeacon(pHandle, &pHandle->Capabilities);
 8000a20:	4620      	mov	r0, r4
 8000a22:	f7ff fdb3 	bl	800058c <ASPEP_sendBeacon>
 8000a26:	e760      	b.n	80008ea <ASPEP_RXframeProcess+0x36>
  MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 8000a28:	7f45      	ldrb	r5, [r0, #29]
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8000a2a:	f890 606c 	ldrb.w	r6, [r0, #108]	@ 0x6c
  MasterCapabilities.DATA_CRC = pHandle->rxHeader[0] >> 7U ;                     /*Bit 7 */
 8000a2e:	7f01      	ldrb	r1, [r0, #28]
  pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_maxSize);
 8000a30:	f890 006d 	ldrb.w	r0, [r0, #109]	@ 0x6d
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 8000a34:	f894 706e 	ldrb.w	r7, [r4, #110]	@ 0x6e
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 8000a38:	f894 e06f 	ldrb.w	lr, [r4, #111]	@ 0x6f
  MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 8000a3c:	f005 053f 	and.w	r5, r5, #63	@ 0x3f
  MasterCapabilities.DATA_CRC = pHandle->rxHeader[0] >> 7U ;                     /*Bit 7 */
 8000a40:	09c9      	lsrs	r1, r1, #7
  pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_maxSize);
 8000a42:	42a8      	cmp	r0, r5
 8000a44:	bf28      	it	cs
 8000a46:	4628      	movcs	r0, r5
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8000a48:	42b1      	cmp	r1, r6
 8000a4a:	4663      	mov	r3, ip
 8000a4c:	468c      	mov	ip, r1
 8000a4e:	bf28      	it	cs
 8000a50:	46b4      	movcs	ip, r6
 8000a52:	f36c 0307 	bfi	r3, ip, #0, #8
  MasterCapabilities.TXS_maxSize = (uint8_t)((packetHeader&0x01FC000U)  >> 14); /*Bits 14 to 20 */
 8000a56:	f3c2 3c86 	ubfx	ip, r2, #14, #7
  MasterCapabilities.TXA_maxSize = (uint8_t)((packetHeader&0xFE00000U) >> 21);  /*Bits 21 to 27  */
 8000a5a:	f3c2 5846 	ubfx	r8, r2, #21, #7
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 8000a5e:	45bc      	cmp	ip, r7
 8000a60:	46e1      	mov	r9, ip
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8000a62:	f360 230f 	bfi	r3, r0, #8, #8
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 8000a66:	bf28      	it	cs
 8000a68:	46b9      	movcs	r9, r7
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 8000a6a:	45f0      	cmp	r8, lr
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8000a6c:	f369 4317 	bfi	r3, r9, #16, #8
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 8000a70:	46c1      	mov	r9, r8
 8000a72:	bf28      	it	cs
 8000a74:	46f1      	movcs	r9, lr
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8000a76:	f369 631f 	bfi	r3, r9, #24, #8
  if ((MasterCapabilities.DATA_CRC != pHandle->Capabilities.DATA_CRC)
 8000a7a:	42b1      	cmp	r1, r6
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8000a7c:	66e3      	str	r3, [r4, #108]	@ 0x6c
  if ((MasterCapabilities.DATA_CRC != pHandle->Capabilities.DATA_CRC)
 8000a7e:	d80b      	bhi.n	8000a98 <ASPEP_RXframeProcess+0x1e4>
   || (MasterCapabilities.RX_maxSize > pHandle->Capabilities.RX_maxSize)
 8000a80:	4285      	cmp	r5, r0
 8000a82:	d809      	bhi.n	8000a98 <ASPEP_RXframeProcess+0x1e4>
   || (pHandle->Capabilities.TXS_maxSize != MasterCapabilities.TXS_maxSize )
 8000a84:	45bc      	cmp	ip, r7
 8000a86:	d807      	bhi.n	8000a98 <ASPEP_RXframeProcess+0x1e4>
   || (pHandle->Capabilities.TXA_maxSize != MasterCapabilities.TXA_maxSize )
 8000a88:	45f0      	cmp	r8, lr
 8000a8a:	d805      	bhi.n	8000a98 <ASPEP_RXframeProcess+0x1e4>
   || (MasterCapabilities.version != pHandle->Capabilities.version) )
 8000a8c:	f894 3070 	ldrb.w	r3, [r4, #112]	@ 0x70
 8000a90:	f3c2 1202 	ubfx	r2, r2, #4, #3
 8000a94:	4293      	cmp	r3, r2
 8000a96:	d002      	beq.n	8000a9e <ASPEP_RXframeProcess+0x1ea>
              pHandle->ASPEP_State = ASPEP_IDLE;
 8000a98:	2300      	movs	r3, #0
 8000a9a:	f884 3064 	strb.w	r3, [r4, #100]	@ 0x64
            ASPEP_sendBeacon(pHandle, &pHandle->Capabilities);
 8000a9e:	f104 016c 	add.w	r1, r4, #108	@ 0x6c
 8000aa2:	4620      	mov	r0, r4
 8000aa4:	f7ff fd72 	bl	800058c <ASPEP_sendBeacon>
 8000aa8:	e71f      	b.n	80008ea <ASPEP_RXframeProcess+0x36>
  MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 8000aaa:	f890 c01d 	ldrb.w	ip, [r0, #29]
  pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_maxSize);
 8000aae:	f890 106d 	ldrb.w	r1, [r0, #109]	@ 0x6d
  MasterCapabilities.DATA_CRC = pHandle->rxHeader[0] >> 7U ;                     /*Bit 7 */
 8000ab2:	7f05      	ldrb	r5, [r0, #28]
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8000ab4:	f890 606c 	ldrb.w	r6, [r0, #108]	@ 0x6c
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 8000ab8:	f890 706e 	ldrb.w	r7, [r0, #110]	@ 0x6e
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 8000abc:	f894 906f 	ldrb.w	r9, [r4, #111]	@ 0x6f
  MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 8000ac0:	f00c 0c3f 	and.w	ip, ip, #63	@ 0x3f
  MasterCapabilities.DATA_CRC = pHandle->rxHeader[0] >> 7U ;                     /*Bit 7 */
 8000ac4:	09ed      	lsrs	r5, r5, #7
  pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_maxSize);
 8000ac6:	4561      	cmp	r1, ip
 8000ac8:	bf28      	it	cs
 8000aca:	4661      	movcs	r1, ip
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8000acc:	42b5      	cmp	r5, r6
 8000ace:	4628      	mov	r0, r5
  MasterCapabilities.TXS_maxSize = (uint8_t)((packetHeader&0x01FC000U)  >> 14); /*Bits 14 to 20 */
 8000ad0:	f3c2 3886 	ubfx	r8, r2, #14, #7
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8000ad4:	bf28      	it	cs
 8000ad6:	4630      	movcs	r0, r6
 8000ad8:	f360 0307 	bfi	r3, r0, #0, #8
  MasterCapabilities.TXA_maxSize = (uint8_t)((packetHeader&0xFE00000U) >> 21);  /*Bits 21 to 27  */
 8000adc:	f3c2 5a46 	ubfx	sl, r2, #21, #7
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 8000ae0:	45b8      	cmp	r8, r7
 8000ae2:	4640      	mov	r0, r8
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8000ae4:	f361 230f 	bfi	r3, r1, #8, #8
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 8000ae8:	bf28      	it	cs
 8000aea:	4638      	movcs	r0, r7
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 8000aec:	45ca      	cmp	sl, r9
 8000aee:	46d6      	mov	lr, sl
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8000af0:	f360 4317 	bfi	r3, r0, #16, #8
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 8000af4:	bf28      	it	cs
 8000af6:	46ce      	movcs	lr, r9
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8000af8:	f36e 631f 	bfi	r3, lr, #24, #8
  if ((MasterCapabilities.DATA_CRC != pHandle->Capabilities.DATA_CRC)
 8000afc:	42b5      	cmp	r5, r6
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8000afe:	66e3      	str	r3, [r4, #108]	@ 0x6c
  if ((MasterCapabilities.DATA_CRC != pHandle->Capabilities.DATA_CRC)
 8000b00:	d8cd      	bhi.n	8000a9e <ASPEP_RXframeProcess+0x1ea>
   || (MasterCapabilities.RX_maxSize > pHandle->Capabilities.RX_maxSize)
 8000b02:	458c      	cmp	ip, r1
 8000b04:	d8cb      	bhi.n	8000a9e <ASPEP_RXframeProcess+0x1ea>
   || (pHandle->Capabilities.TXS_maxSize != MasterCapabilities.TXS_maxSize )
 8000b06:	45b8      	cmp	r8, r7
 8000b08:	d8c9      	bhi.n	8000a9e <ASPEP_RXframeProcess+0x1ea>
   || (pHandle->Capabilities.TXA_maxSize != MasterCapabilities.TXA_maxSize )
 8000b0a:	45ca      	cmp	sl, r9
 8000b0c:	d8c7      	bhi.n	8000a9e <ASPEP_RXframeProcess+0x1ea>
   || (MasterCapabilities.version != pHandle->Capabilities.version) )
 8000b0e:	f894 3070 	ldrb.w	r3, [r4, #112]	@ 0x70
 8000b12:	f3c2 1202 	ubfx	r2, r2, #4, #3
 8000b16:	4293      	cmp	r3, r2
 8000b18:	d1c1      	bne.n	8000a9e <ASPEP_RXframeProcess+0x1ea>
              pHandle->maxRXPayload = (pHandle->Capabilities.RX_maxSize + (uint16_t)1U) * (uint16_t)32U;
 8000b1a:	1c4b      	adds	r3, r1, #1
              pSupHandle->txSyncMaxPayload = (pHandle->Capabilities.TXS_maxSize + (uint16_t)1U) * (uint16_t)32U;
 8000b1c:	1c42      	adds	r2, r0, #1
 8000b1e:	b2d2      	uxtb	r2, r2
              pHandle->maxRXPayload = (pHandle->Capabilities.RX_maxSize + (uint16_t)1U) * (uint16_t)32U;
 8000b20:	b2db      	uxtb	r3, r3
              pSupHandle->txSyncMaxPayload = (pHandle->Capabilities.TXS_maxSize + (uint16_t)1U) * (uint16_t)32U;
 8000b22:	0152      	lsls	r2, r2, #5
              pSupHandle->txAsyncMaxPayload = (pHandle->Capabilities.TXA_maxSize) * (uint16_t)64U;
 8000b24:	ea4f 1e8e 	mov.w	lr, lr, lsl #6
              pHandle->maxRXPayload = (pHandle->Capabilities.RX_maxSize + (uint16_t)1U) * (uint16_t)32U;
 8000b28:	015b      	lsls	r3, r3, #5
              pHandle->ASPEP_State = ASPEP_CONFIGURED;
 8000b2a:	2101      	movs	r1, #1
              pSupHandle->txSyncMaxPayload = (pHandle->Capabilities.TXS_maxSize + (uint16_t)1U) * (uint16_t)32U;
 8000b2c:	81a2      	strh	r2, [r4, #12]
              pSupHandle->txAsyncMaxPayload = (pHandle->Capabilities.TXA_maxSize) * (uint16_t)64U;
 8000b2e:	f8a4 e00e 	strh.w	lr, [r4, #14]
              pHandle->maxRXPayload = (pHandle->Capabilities.RX_maxSize + (uint16_t)1U) * (uint16_t)32U;
 8000b32:	f8a4 305e 	strh.w	r3, [r4, #94]	@ 0x5e
              pHandle->ASPEP_State = ASPEP_CONFIGURED;
 8000b36:	f884 1064 	strb.w	r1, [r4, #100]	@ 0x64
 8000b3a:	e7b0      	b.n	8000a9e <ASPEP_RXframeProcess+0x1ea>
            ASPEP_sendPing(pHandle, ASPEP_PING_RESET, packetNumber);
 8000b3c:	f3c2 320f 	ubfx	r2, r2, #12, #16
 8000b40:	4619      	mov	r1, r3
 8000b42:	f7ff fd69 	bl	8000618 <ASPEP_sendPing>
 8000b46:	e6d0      	b.n	80008ea <ASPEP_RXframeProcess+0x36>
            ASPEP_sendPing(pHandle, ASPEP_PING_CFG, packetNumber);
 8000b48:	f3c2 320f 	ubfx	r2, r2, #12, #16
 8000b4c:	2101      	movs	r1, #1
 8000b4e:	f7ff fd63 	bl	8000618 <ASPEP_sendPing>
 8000b52:	e6ca      	b.n	80008ea <ASPEP_RXframeProcess+0x36>
  (void)ASPEP_TXframeProcess(pHandle, ASPEP_CTRL, &pHandle->ctrlBuffer, ASPEP_CTRL_SIZE);
 8000b54:	f104 0120 	add.w	r1, r4, #32
        pHandle->ctrlBuffer.state = readLock;
 8000b58:	2303      	movs	r3, #3
 8000b5a:	f884 3024 	strb.w	r3, [r4, #36]	@ 0x24
        pHandle->lockBuffer = (void *)&pHandle->ctrlBuffer;
 8000b5e:	64a1      	str	r1, [r4, #72]	@ 0x48
 8000b60:	b662      	cpsie	i
      pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, txBuffer, bufferLength);
 8000b62:	2204      	movs	r2, #4
 8000b64:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 8000b66:	6960      	ldr	r0, [r4, #20]
 8000b68:	4798      	blx	r3
 8000b6a:	e703      	b.n	8000974 <ASPEP_RXframeProcess+0xc0>
 8000b6c:	0800a1a8 	.word	0x0800a1a8
 8000b70:	0800a198 	.word	0x0800a198

08000b74 <ASPEP_HWReset>:
  * @brief  Resets DMA after debugger has stopped the MCU.
  *
  * @param  *pHandle Handler of the current instance of the ASPEP component
  */
void ASPEP_HWReset(ASPEP_Handle_t *pHandle)
{
 8000b74:	4601      	mov	r1, r0
  {
#endif
    /* We must reset the RX state machine to be sure to not be in Waiting packet state */
    /* Otherwise the arrival of a new packet will trigger a NewPacketAvailable despite */
    /* the fact that bytes have been lost because of overrun (debugger paused for instance) */
    pHandle->ASPEP_TL_State = WAITING_PACKET;
 8000b76:	2200      	movs	r2, #0
 8000b78:	f880 2065 	strb.w	r2, [r0, #101]	@ 0x65
    pHandle->fASPEP_cfg_recept(pHandle->ASPEPIp, pHandle->rxHeader, ASPEP_HEADER_SIZE);
 8000b7c:	6d43      	ldr	r3, [r0, #84]	@ 0x54
 8000b7e:	6940      	ldr	r0, [r0, #20]
 8000b80:	2204      	movs	r2, #4
 8000b82:	311c      	adds	r1, #28
 8000b84:	4718      	bx	r3
 8000b86:	bf00      	nop

08000b88 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8000b88:	b510      	push	{r4, lr}
 8000b8a:	b094      	sub	sp, #80	@ 0x50
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8000b8c:	2238      	movs	r2, #56	@ 0x38
 8000b8e:	2100      	movs	r1, #0
 8000b90:	a806      	add	r0, sp, #24
 8000b92:	f009 faa7 	bl	800a0e4 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8000b96:	2000      	movs	r0, #0
 8000b98:	e9cd 0001 	strd	r0, r0, [sp, #4]
 8000b9c:	e9cd 0003 	strd	r0, r0, [sp, #12]
 8000ba0:	9005      	str	r0, [sp, #20]

  /** Configure the main internal regulator output voltage
  */
  HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1_BOOST);
 8000ba2:	f004 fc47 	bl	8005434 <HAL_PWREx_ControlVoltageScaling>

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8000ba6:	2001      	movs	r0, #1
 8000ba8:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = RCC_PLLM_DIV6;
 8000bac:	2206      	movs	r2, #6
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8000bae:	e9cd 0106 	strd	r0, r1, [sp, #24]
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8000bb2:	2302      	movs	r3, #2
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8000bb4:	2403      	movs	r4, #3
  RCC_OscInitStruct.PLL.PLLM = RCC_PLLM_DIV6;
 8000bb6:	920f      	str	r2, [sp, #60]	@ 0x3c
  RCC_OscInitStruct.PLL.PLLN = 85;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV8;
 8000bb8:	2155      	movs	r1, #85	@ 0x55
 8000bba:	2208      	movs	r2, #8
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000bbc:	a806      	add	r0, sp, #24
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8000bbe:	e9cd 340d 	strd	r3, r4, [sp, #52]	@ 0x34
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV8;
 8000bc2:	e9cd 1210 	strd	r1, r2, [sp, #64]	@ 0x40
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
 8000bc6:	e9cd 3312 	strd	r3, r3, [sp, #72]	@ 0x48
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000bca:	f004 fcad 	bl	8005528 <HAL_RCC_OscConfig>
 8000bce:	b108      	cbz	r0, 8000bd4 <SystemClock_Config+0x4c>
  __ASM volatile ("cpsid i" : : : "memory");
 8000bd0:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 8000bd2:	e7fe      	b.n	8000bd2 <SystemClock_Config+0x4a>
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 8000bd4:	2104      	movs	r1, #4
 8000bd6:	4603      	mov	r3, r0
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8000bd8:	220f      	movs	r2, #15
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 8000bda:	eb0d 0001 	add.w	r0, sp, r1
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8000bde:	e9cd 2401 	strd	r2, r4, [sp, #4]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8000be2:	e9cd 3303 	strd	r3, r3, [sp, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8000be6:	9305      	str	r3, [sp, #20]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 8000be8:	f004 ff1c 	bl	8005a24 <HAL_RCC_ClockConfig>
 8000bec:	b108      	cbz	r0, 8000bf2 <SystemClock_Config+0x6a>
 8000bee:	b672      	cpsid	i
  while (1)
 8000bf0:	e7fe      	b.n	8000bf0 <SystemClock_Config+0x68>
  HAL_RCC_EnableCSS();
 8000bf2:	f005 f867 	bl	8005cc4 <HAL_RCC_EnableCSS>
}
 8000bf6:	b014      	add	sp, #80	@ 0x50
 8000bf8:	bd10      	pop	{r4, pc}
 8000bfa:	bf00      	nop

08000bfc <main>:
{
 8000bfc:	b580      	push	{r7, lr}
 8000bfe:	b0a4      	sub	sp, #144	@ 0x90
  HAL_Init();
 8000c00:	f003 fb32 	bl	8004268 <HAL_Init>
  SystemClock_Config();
 8000c04:	f7ff ffc0 	bl	8000b88 <SystemClock_Config>
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8000c08:	4b9c      	ldr	r3, [pc, #624]	@ (8000e7c <main+0x280>)
  hadc1.Instance = ADC1;
 8000c0a:	4c9d      	ldr	r4, [pc, #628]	@ (8000e80 <main+0x284>)
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8000c0c:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8000c0e:	f042 0220 	orr.w	r2, r2, #32
 8000c12:	64da      	str	r2, [r3, #76]	@ 0x4c
 8000c14:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8000c16:	f002 0220 	and.w	r2, r2, #32
 8000c1a:	9203      	str	r2, [sp, #12]
 8000c1c:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8000c1e:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8000c20:	f042 0204 	orr.w	r2, r2, #4
 8000c24:	64da      	str	r2, [r3, #76]	@ 0x4c
 8000c26:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8000c28:	f002 0204 	and.w	r2, r2, #4
 8000c2c:	9204      	str	r2, [sp, #16]
 8000c2e:	9a04      	ldr	r2, [sp, #16]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8000c30:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8000c32:	f042 0201 	orr.w	r2, r2, #1
 8000c36:	64da      	str	r2, [r3, #76]	@ 0x4c
 8000c38:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8000c3a:	f002 0201 	and.w	r2, r2, #1
 8000c3e:	9205      	str	r2, [sp, #20]
 8000c40:	9a05      	ldr	r2, [sp, #20]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8000c42:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8000c44:	f042 0202 	orr.w	r2, r2, #2
 8000c48:	64da      	str	r2, [r3, #76]	@ 0x4c
 8000c4a:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8000c4c:	f002 0202 	and.w	r2, r2, #2
 8000c50:	9206      	str	r2, [sp, #24]
 8000c52:	9a06      	ldr	r2, [sp, #24]
  __HAL_RCC_DMAMUX1_CLK_ENABLE();
 8000c54:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
 8000c56:	f042 0204 	orr.w	r2, r2, #4
 8000c5a:	649a      	str	r2, [r3, #72]	@ 0x48
 8000c5c:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
 8000c5e:	f002 0204 	and.w	r2, r2, #4
 8000c62:	9201      	str	r2, [sp, #4]
 8000c64:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_DMA1_CLK_ENABLE();
 8000c66:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
 8000c68:	f042 0201 	orr.w	r2, r2, #1
 8000c6c:	649a      	str	r2, [r3, #72]	@ 0x48
 8000c6e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
  ADC_MultiModeTypeDef multimode = {0};
 8000c70:	2500      	movs	r5, #0
  __HAL_RCC_DMA1_CLK_ENABLE();
 8000c72:	f003 0301 	and.w	r3, r3, #1
  ADC_InjectionConfTypeDef sConfigInjected = {0};
 8000c76:	4629      	mov	r1, r5
  __HAL_RCC_DMA1_CLK_ENABLE();
 8000c78:	9302      	str	r3, [sp, #8]
  ADC_InjectionConfTypeDef sConfigInjected = {0};
 8000c7a:	223c      	movs	r2, #60	@ 0x3c
 8000c7c:	a815      	add	r0, sp, #84	@ 0x54
  ADC_ChannelConfTypeDef sConfig = {0};
 8000c7e:	2720      	movs	r7, #32
  __HAL_RCC_DMA1_CLK_ENABLE();
 8000c80:	9b02      	ldr	r3, [sp, #8]
  ADC_MultiModeTypeDef multimode = {0};
 8000c82:	950a      	str	r5, [sp, #40]	@ 0x28
 8000c84:	e9cd 550b 	strd	r5, r5, [sp, #44]	@ 0x2c
  ADC_InjectionConfTypeDef sConfigInjected = {0};
 8000c88:	f009 fa2c 	bl	800a0e4 <memset>
  ADC_ChannelConfTypeDef sConfig = {0};
 8000c8c:	4629      	mov	r1, r5
 8000c8e:	463a      	mov	r2, r7
 8000c90:	a80d      	add	r0, sp, #52	@ 0x34
 8000c92:	f009 fa27 	bl	800a0e4 <memset>
  hadc1.Instance = ADC1;
 8000c96:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
 8000c9a:	6023      	str	r3, [r4, #0]
  hadc1.Init.DataAlign = ADC_DATAALIGN_LEFT;
 8000c9c:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
 8000ca0:	e9c4 5501 	strd	r5, r5, [r4, #4]
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 8000ca4:	e9c4 550b 	strd	r5, r5, [r4, #44]	@ 0x2c
  hadc1.Init.GainCompensation = 0;
 8000ca8:	6125      	str	r5, [r4, #16]
  hadc1.Init.LowPowerAutoWait = DISABLE;
 8000caa:	83a5      	strh	r5, [r4, #28]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
 8000cac:	f884 5024 	strb.w	r5, [r4, #36]	@ 0x24
  hadc1.Init.DMAContinuousRequests = DISABLE;
 8000cb0:	f884 5038 	strb.w	r5, [r4, #56]	@ 0x38
  hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 8000cb4:	63e5      	str	r5, [r4, #60]	@ 0x3c
  hadc1.Init.OversamplingMode = DISABLE;
 8000cb6:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
  hadc1.Init.DataAlign = ADC_DATAALIGN_LEFT;
 8000cba:	60e3      	str	r3, [r4, #12]
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8000cbc:	2601      	movs	r6, #1
 8000cbe:	2504      	movs	r5, #4
  hadc1.Init.NbrOfConversion = 2;
 8000cc0:	2302      	movs	r3, #2
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 8000cc2:	4620      	mov	r0, r4
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8000cc4:	e9c4 6505 	strd	r6, r5, [r4, #20]
  hadc1.Init.NbrOfConversion = 2;
 8000cc8:	6223      	str	r3, [r4, #32]
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 8000cca:	f003 faf7 	bl	80042bc <HAL_ADC_Init>
 8000cce:	b108      	cbz	r0, 8000cd4 <main+0xd8>
 8000cd0:	b672      	cpsid	i
  while (1)
 8000cd2:	e7fe      	b.n	8000cd2 <main+0xd6>
  multimode.Mode = ADC_MODE_INDEPENDENT;
 8000cd4:	900a      	str	r0, [sp, #40]	@ 0x28
  if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
 8000cd6:	a90a      	add	r1, sp, #40	@ 0x28
 8000cd8:	4620      	mov	r0, r4
 8000cda:	f004 f91b 	bl	8004f14 <HAL_ADCEx_MultiModeConfigChannel>
 8000cde:	b108      	cbz	r0, 8000ce4 <main+0xe8>
 8000ce0:	b672      	cpsid	i
  while (1)
 8000ce2:	e7fe      	b.n	8000ce2 <main+0xe6>
  sConfigInjected.ExternalTrigInjecConv = ADC_EXTERNALTRIGINJEC_T1_TRGO;
 8000ce4:	2380      	movs	r3, #128	@ 0x80
  sConfigInjected.InjectedOffset = 0;
 8000ce6:	e9cd 5019 	strd	r5, r0, [sp, #100]	@ 0x64
  sConfigInjected.InjectedDiscontinuousConvMode = DISABLE;
 8000cea:	f8ad 0078 	strh.w	r0, [sp, #120]	@ 0x78
  sConfigInjected.QueueInjectedContext = DISABLE;
 8000cee:	f88d 007a 	strb.w	r0, [sp, #122]	@ 0x7a
  sConfigInjected.InjecOversamplingMode = DISABLE;
 8000cf2:	f88d 0084 	strb.w	r0, [sp, #132]	@ 0x84
  sConfigInjected.InjectedRank = ADC_INJECTED_RANK_1;
 8000cf6:	4863      	ldr	r0, [pc, #396]	@ (8000e84 <main+0x288>)
  sConfigInjected.InjectedSamplingTime = ADC_SAMPLETIME_6CYCLES_5;
 8000cf8:	9617      	str	r6, [sp, #92]	@ 0x5c
  sConfigInjected.ExternalTrigInjecConvEdge = ADC_EXTERNALTRIGINJECCONV_EDGE_RISING;
 8000cfa:	e9cd 331f 	strd	r3, r3, [sp, #124]	@ 0x7c
  sConfigInjected.InjectedRank = ADC_INJECTED_RANK_1;
 8000cfe:	2309      	movs	r3, #9
 8000d00:	e9cd 0315 	strd	r0, r3, [sp, #84]	@ 0x54
  sConfigInjected.InjectedSingleDiff = ADC_SINGLE_ENDED;
 8000d04:	f04f 087f 	mov.w	r8, #127	@ 0x7f
  sConfigInjected.InjectedNbrOfConversion = 3;
 8000d08:	2303      	movs	r3, #3
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
 8000d0a:	a915      	add	r1, sp, #84	@ 0x54
 8000d0c:	4620      	mov	r0, r4
  sConfigInjected.InjectedSingleDiff = ADC_SINGLE_ENDED;
 8000d0e:	f8cd 8060 	str.w	r8, [sp, #96]	@ 0x60
  sConfigInjected.InjectedNbrOfConversion = 3;
 8000d12:	931d      	str	r3, [sp, #116]	@ 0x74
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
 8000d14:	f003 fe1e 	bl	8004954 <HAL_ADCEx_InjectedConfigChannel>
 8000d18:	b108      	cbz	r0, 8000d1e <main+0x122>
 8000d1a:	b672      	cpsid	i
  while (1)
 8000d1c:	e7fe      	b.n	8000d1c <main+0x120>
  sConfigInjected.InjectedRank = ADC_INJECTED_RANK_2;
 8000d1e:	495a      	ldr	r1, [pc, #360]	@ (8000e88 <main+0x28c>)
 8000d20:	f240 130f 	movw	r3, #271	@ 0x10f
 8000d24:	e9cd 1315 	strd	r1, r3, [sp, #84]	@ 0x54
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
 8000d28:	4620      	mov	r0, r4
 8000d2a:	a915      	add	r1, sp, #84	@ 0x54
 8000d2c:	f003 fe12 	bl	8004954 <HAL_ADCEx_InjectedConfigChannel>
 8000d30:	b108      	cbz	r0, 8000d36 <main+0x13a>
 8000d32:	b672      	cpsid	i
  while (1)
 8000d34:	e7fe      	b.n	8000d34 <main+0x138>
  sConfigInjected.InjectedRank = ADC_INJECTED_RANK_3;
 8000d36:	4a55      	ldr	r2, [pc, #340]	@ (8000e8c <main+0x290>)
 8000d38:	f240 2315 	movw	r3, #533	@ 0x215
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
 8000d3c:	a915      	add	r1, sp, #84	@ 0x54
 8000d3e:	4620      	mov	r0, r4
  sConfigInjected.InjectedRank = ADC_INJECTED_RANK_3;
 8000d40:	e9cd 2315 	strd	r2, r3, [sp, #84]	@ 0x54
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
 8000d44:	f003 fe06 	bl	8004954 <HAL_ADCEx_InjectedConfigChannel>
 8000d48:	b108      	cbz	r0, 8000d4e <main+0x152>
 8000d4a:	b672      	cpsid	i
  while (1)
 8000d4c:	e7fe      	b.n	8000d4c <main+0x150>
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8000d4e:	f8df e150 	ldr.w	lr, [pc, #336]	@ 8000ea0 <main+0x2a4>
  sConfig.Offset = 0;
 8000d52:	9012      	str	r0, [sp, #72]	@ 0x48
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8000d54:	2306      	movs	r3, #6
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8000d56:	a90d      	add	r1, sp, #52	@ 0x34
 8000d58:	4620      	mov	r0, r4
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8000d5a:	e9cd e30d 	strd	lr, r3, [sp, #52]	@ 0x34
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
 8000d5e:	f8cd 8040 	str.w	r8, [sp, #64]	@ 0x40
  sConfig.SamplingTime = ADC_SAMPLETIME_47CYCLES_5;
 8000d62:	950f      	str	r5, [sp, #60]	@ 0x3c
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
 8000d64:	9511      	str	r5, [sp, #68]	@ 0x44
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8000d66:	f003 fba3 	bl	80044b0 <HAL_ADC_ConfigChannel>
 8000d6a:	b108      	cbz	r0, 8000d70 <main+0x174>
 8000d6c:	b672      	cpsid	i
  while (1)
 8000d6e:	e7fe      	b.n	8000d6e <main+0x172>
  sConfig.Rank = ADC_REGULAR_RANK_2;
 8000d70:	f8df c130 	ldr.w	ip, [pc, #304]	@ 8000ea4 <main+0x2a8>
 8000d74:	230c      	movs	r3, #12
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8000d76:	4620      	mov	r0, r4
 8000d78:	a90d      	add	r1, sp, #52	@ 0x34
  sConfig.Rank = ADC_REGULAR_RANK_2;
 8000d7a:	e9cd c30d 	strd	ip, r3, [sp, #52]	@ 0x34
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8000d7e:	f003 fb97 	bl	80044b0 <HAL_ADC_ConfigChannel>
 8000d82:	b108      	cbz	r0, 8000d88 <main+0x18c>
 8000d84:	b672      	cpsid	i
  while (1)
 8000d86:	e7fe      	b.n	8000d86 <main+0x18a>
  hcordic.Instance = CORDIC;
 8000d88:	4841      	ldr	r0, [pc, #260]	@ (8000e90 <main+0x294>)
 8000d8a:	4b42      	ldr	r3, [pc, #264]	@ (8000e94 <main+0x298>)
 8000d8c:	6003      	str	r3, [r0, #0]
  if (HAL_CORDIC_Init(&hcordic) != HAL_OK)
 8000d8e:	f004 f927 	bl	8004fe0 <HAL_CORDIC_Init>
 8000d92:	4604      	mov	r4, r0
 8000d94:	b108      	cbz	r0, 8000d9a <main+0x19e>
 8000d96:	b672      	cpsid	i
  while (1)
 8000d98:	e7fe      	b.n	8000d98 <main+0x19c>
  htim1.Instance = TIM1;
 8000d9a:	4d3f      	ldr	r5, [pc, #252]	@ (8000e98 <main+0x29c>)
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8000d9c:	9007      	str	r0, [sp, #28]
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};
 8000d9e:	4601      	mov	r1, r0
  TIMEx_BreakInputConfigTypeDef sBreakInputConfig = {0};
 8000da0:	e9cd 000a 	strd	r0, r0, [sp, #40]	@ 0x28
  TIM_OC_InitTypeDef sConfigOC = {0};
 8000da4:	e9cd 000c 	strd	r0, r0, [sp, #48]	@ 0x30
 8000da8:	e9cd 000e 	strd	r0, r0, [sp, #56]	@ 0x38
 8000dac:	e9cd 0010 	strd	r0, r0, [sp, #64]	@ 0x40
 8000db0:	e9cd 0012 	strd	r0, r0, [sp, #72]	@ 0x48
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8000db4:	e9cd 0008 	strd	r0, r0, [sp, #32]
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};
 8000db8:	2234      	movs	r2, #52	@ 0x34
 8000dba:	a815      	add	r0, sp, #84	@ 0x54
 8000dbc:	f009 f992 	bl	800a0e4 <memset>
  htim1.Instance = TIM1;
 8000dc0:	4b36      	ldr	r3, [pc, #216]	@ (8000e9c <main+0x2a0>)
  htim1.Init.CounterMode = TIM_COUNTERMODE_CENTERALIGNED1;
 8000dc2:	60af      	str	r7, [r5, #8]
  htim1.Instance = TIM1;
 8000dc4:	602b      	str	r3, [r5, #0]
  if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
 8000dc6:	4628      	mov	r0, r5
  htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV2;
 8000dc8:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8000dcc:	f44f 57a6 	mov.w	r7, #5312	@ 0x14c0
 8000dd0:	e9c5 7303 	strd	r7, r3, [r5, #12]
  htim1.Init.RepetitionCounter = (REP_COUNTER);
 8000dd4:	616e      	str	r6, [r5, #20]
  htim1.Init.Prescaler = ((TIM_CLOCK_DIVIDER) - 1);
 8000dd6:	606c      	str	r4, [r5, #4]
  htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8000dd8:	61ac      	str	r4, [r5, #24]
  if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
 8000dda:	f005 fa41 	bl	8006260 <HAL_TIM_PWM_Init>
 8000dde:	4603      	mov	r3, r0
 8000de0:	b108      	cbz	r0, 8000de6 <main+0x1ea>
 8000de2:	b672      	cpsid	i
  while (1)
 8000de4:	e7fe      	b.n	8000de4 <main+0x1e8>
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8000de6:	e9cd 3308 	strd	r3, r3, [sp, #32]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 8000dea:	a907      	add	r1, sp, #28
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_OC4REF;
 8000dec:	2370      	movs	r3, #112	@ 0x70
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 8000dee:	4628      	mov	r0, r5
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_OC4REF;
 8000df0:	9307      	str	r3, [sp, #28]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 8000df2:	f005 fcc7 	bl	8006784 <HAL_TIMEx_MasterConfigSynchronization>
 8000df6:	b108      	cbz	r0, 8000dfc <main+0x200>
 8000df8:	b672      	cpsid	i
  while (1)
 8000dfa:	e7fe      	b.n	8000dfa <main+0x1fe>
  sBreakInputConfig.Source = TIM_BREAKINPUTSOURCE_BKIN;
 8000dfc:	2101      	movs	r1, #1
  if (HAL_TIMEx_ConfigBreakInput(&htim1, TIM_BREAKINPUT_BRK, &sBreakInputConfig) != HAL_OK)
 8000dfe:	aa0a      	add	r2, sp, #40	@ 0x28
 8000e00:	4825      	ldr	r0, [pc, #148]	@ (8000e98 <main+0x29c>)
  sBreakInputConfig.Polarity = TIM_BREAKINPUTSOURCE_POLARITY_LOW;
 8000e02:	910c      	str	r1, [sp, #48]	@ 0x30
  sBreakInputConfig.Enable = TIM_BREAKINPUTSOURCE_ENABLE;
 8000e04:	e9cd 110a 	strd	r1, r1, [sp, #40]	@ 0x28
  if (HAL_TIMEx_ConfigBreakInput(&htim1, TIM_BREAKINPUT_BRK, &sBreakInputConfig) != HAL_OK)
 8000e08:	f005 fd5c 	bl	80068c4 <HAL_TIMEx_ConfigBreakInput>
 8000e0c:	4602      	mov	r2, r0
 8000e0e:	b108      	cbz	r0, 8000e14 <main+0x218>
 8000e10:	b672      	cpsid	i
  while (1)
 8000e12:	e7fe      	b.n	8000e12 <main+0x216>
  sConfigOC.Pulse = ((PWM_PERIOD_CYCLES) / 4);
 8000e14:	2160      	movs	r1, #96	@ 0x60
 8000e16:	f44f 6326 	mov.w	r3, #2656	@ 0xa60
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_LOW;
 8000e1a:	2408      	movs	r4, #8
  sConfigOC.Pulse = ((PWM_PERIOD_CYCLES) / 4);
 8000e1c:	e9cd 130d 	strd	r1, r3, [sp, #52]	@ 0x34
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_LOW;
 8000e20:	e9cd 040f 	strd	r0, r4, [sp, #60]	@ 0x3c
  sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
 8000e24:	e9cd 0011 	strd	r0, r0, [sp, #68]	@ 0x44
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_SET;
 8000e28:	f44f 7300 	mov.w	r3, #512	@ 0x200
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8000e2c:	481a      	ldr	r0, [pc, #104]	@ (8000e98 <main+0x29c>)
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_SET;
 8000e2e:	9313      	str	r3, [sp, #76]	@ 0x4c
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8000e30:	a90d      	add	r1, sp, #52	@ 0x34
 8000e32:	f005 fbc1 	bl	80065b8 <HAL_TIM_PWM_ConfigChannel>
 8000e36:	b108      	cbz	r0, 8000e3c <main+0x240>
 8000e38:	b672      	cpsid	i
  while (1)
 8000e3a:	e7fe      	b.n	8000e3a <main+0x23e>
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 8000e3c:	4816      	ldr	r0, [pc, #88]	@ (8000e98 <main+0x29c>)
 8000e3e:	2204      	movs	r2, #4
 8000e40:	a90d      	add	r1, sp, #52	@ 0x34
 8000e42:	f005 fbb9 	bl	80065b8 <HAL_TIM_PWM_ConfigChannel>
 8000e46:	b108      	cbz	r0, 8000e4c <main+0x250>
 8000e48:	b672      	cpsid	i
  while (1)
 8000e4a:	e7fe      	b.n	8000e4a <main+0x24e>
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
 8000e4c:	4812      	ldr	r0, [pc, #72]	@ (8000e98 <main+0x29c>)
 8000e4e:	4622      	mov	r2, r4
 8000e50:	a90d      	add	r1, sp, #52	@ 0x34
 8000e52:	f005 fbb1 	bl	80065b8 <HAL_TIM_PWM_ConfigChannel>
 8000e56:	b108      	cbz	r0, 8000e5c <main+0x260>
 8000e58:	b672      	cpsid	i
  while (1)
 8000e5a:	e7fe      	b.n	8000e5a <main+0x25e>
  sConfigOC.Pulse = (((PWM_PERIOD_CYCLES) / 2) - (HTMIN));
 8000e5c:	2170      	movs	r1, #112	@ 0x70
 8000e5e:	f241 42bf 	movw	r2, #5311	@ 0x14bf
 8000e62:	e9cd 120d 	strd	r1, r2, [sp, #52]	@ 0x34
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
 8000e66:	9010      	str	r0, [sp, #64]	@ 0x40
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
 8000e68:	9013      	str	r0, [sp, #76]	@ 0x4c
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
 8000e6a:	220c      	movs	r2, #12
 8000e6c:	480a      	ldr	r0, [pc, #40]	@ (8000e98 <main+0x29c>)
 8000e6e:	a90d      	add	r1, sp, #52	@ 0x34
 8000e70:	f005 fba2 	bl	80065b8 <HAL_TIM_PWM_ConfigChannel>
 8000e74:	4603      	mov	r3, r0
 8000e76:	b1b8      	cbz	r0, 8000ea8 <main+0x2ac>
 8000e78:	b672      	cpsid	i
  while (1)
 8000e7a:	e7fe      	b.n	8000e7a <main+0x27e>
 8000e7c:	40021000 	.word	0x40021000
 8000e80:	20000754 	.word	0x20000754
 8000e84:	04300002 	.word	0x04300002
 8000e88:	1d500080 	.word	0x1d500080
 8000e8c:	19200040 	.word	0x19200040
 8000e90:	2000072c 	.word	0x2000072c
 8000e94:	40020c00 	.word	0x40020c00
 8000e98:	200006e0 	.word	0x200006e0
 8000e9c:	40012c00 	.word	0x40012c00
 8000ea0:	08600004 	.word	0x08600004
 8000ea4:	21800100 	.word	0x21800100
  sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_ENABLE;
 8000ea8:	f44f 6000 	mov.w	r0, #2048	@ 0x800
 8000eac:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 8000eb0:	e9cd 0115 	strd	r0, r1, [sp, #84]	@ 0x54
  sBreakDeadTimeConfig.DeadTime = ((DEAD_TIME_COUNTS) / 2);
 8000eb4:	2148      	movs	r1, #72	@ 0x48
 8000eb6:	e9cd 3117 	strd	r3, r1, [sp, #92]	@ 0x5c
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 8000eba:	f44f 5480 	mov.w	r4, #4096	@ 0x1000
 8000ebe:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
 8000ec2:	e9cd 4119 	strd	r4, r1, [sp, #100]	@ 0x64
  sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;
 8000ec6:	f04f 7100 	mov.w	r1, #33554432	@ 0x2000000
  sBreakDeadTimeConfig.BreakFilter = 3;
 8000eca:	2203      	movs	r2, #3
  sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;
 8000ecc:	e9cd 311d 	strd	r3, r1, [sp, #116]	@ 0x74
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 8000ed0:	4840      	ldr	r0, [pc, #256]	@ (8000fd4 <main+0x3d8>)
  sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
 8000ed2:	9321      	str	r3, [sp, #132]	@ 0x84
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 8000ed4:	a915      	add	r1, sp, #84	@ 0x54
  sBreakDeadTimeConfig.BreakAFMode = TIM_BREAK_AFMODE_INPUT;
 8000ed6:	e9cd 231b 	strd	r2, r3, [sp, #108]	@ 0x6c
  sBreakDeadTimeConfig.Break2AFMode = TIM_BREAK_AFMODE_INPUT;
 8000eda:	e9cd 231f 	strd	r2, r3, [sp, #124]	@ 0x7c
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 8000ede:	f005 fca3 	bl	8006828 <HAL_TIMEx_ConfigBreakDeadTime>
 8000ee2:	4605      	mov	r5, r0
 8000ee4:	b108      	cbz	r0, 8000eea <main+0x2ee>
 8000ee6:	b672      	cpsid	i
  while (1)
 8000ee8:	e7fe      	b.n	8000ee8 <main+0x2ec>
  HAL_TIM_MspPostInit(&htim1);
 8000eea:	483a      	ldr	r0, [pc, #232]	@ (8000fd4 <main+0x3d8>)
  huart2.Instance = USART2;
 8000eec:	4c3a      	ldr	r4, [pc, #232]	@ (8000fd8 <main+0x3dc>)
  HAL_TIM_MspPostInit(&htim1);
 8000eee:	f002 ffd9 	bl	8003ea4 <HAL_TIM_MspPostInit>
  huart2.Init.BaudRate = 1843200;
 8000ef2:	4a3a      	ldr	r2, [pc, #232]	@ (8000fdc <main+0x3e0>)
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8000ef4:	62a5      	str	r5, [r4, #40]	@ 0x28
  huart2.Init.BaudRate = 1843200;
 8000ef6:	f44f 13e1 	mov.w	r3, #1843200	@ 0x1c2000
 8000efa:	e9c4 2300 	strd	r2, r3, [r4]
  if (HAL_UART_Init(&huart2) != HAL_OK)
 8000efe:	4620      	mov	r0, r4
  huart2.Init.Mode = UART_MODE_TX_RX;
 8000f00:	230c      	movs	r3, #12
  huart2.Init.StopBits = UART_STOPBITS_1;
 8000f02:	e9c4 5502 	strd	r5, r5, [r4, #8]
  huart2.Init.Mode = UART_MODE_TX_RX;
 8000f06:	e9c4 5304 	strd	r5, r3, [r4, #16]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 8000f0a:	e9c4 5506 	strd	r5, r5, [r4, #24]
  huart2.Init.ClockPrescaler = UART_PRESCALER_DIV1;
 8000f0e:	e9c4 5508 	strd	r5, r5, [r4, #32]
  if (HAL_UART_Init(&huart2) != HAL_OK)
 8000f12:	f006 f80b 	bl	8006f2c <HAL_UART_Init>
 8000f16:	4601      	mov	r1, r0
 8000f18:	b108      	cbz	r0, 8000f1e <main+0x322>
 8000f1a:	b672      	cpsid	i
  while (1)
 8000f1c:	e7fe      	b.n	8000f1c <main+0x320>
  if (HAL_UARTEx_SetTxFifoThreshold(&huart2, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 8000f1e:	4620      	mov	r0, r4
 8000f20:	f006 f856 	bl	8006fd0 <HAL_UARTEx_SetTxFifoThreshold>
 8000f24:	4601      	mov	r1, r0
 8000f26:	b108      	cbz	r0, 8000f2c <main+0x330>
 8000f28:	b672      	cpsid	i
  while (1)
 8000f2a:	e7fe      	b.n	8000f2a <main+0x32e>
  if (HAL_UARTEx_SetRxFifoThreshold(&huart2, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 8000f2c:	4620      	mov	r0, r4
 8000f2e:	f006 f891 	bl	8007054 <HAL_UARTEx_SetRxFifoThreshold>
 8000f32:	b108      	cbz	r0, 8000f38 <main+0x33c>
 8000f34:	b672      	cpsid	i
  while (1)
 8000f36:	e7fe      	b.n	8000f36 <main+0x33a>
  if (HAL_UARTEx_DisableFifoMode(&huart2) != HAL_OK)
 8000f38:	4620      	mov	r0, r4
 8000f3a:	f006 f82b 	bl	8006f94 <HAL_UARTEx_DisableFifoMode>
 8000f3e:	b108      	cbz	r0, 8000f44 <main+0x348>
 8000f40:	b672      	cpsid	i
  while (1)
 8000f42:	e7fe      	b.n	8000f42 <main+0x346>
  MX_MotorControl_Init();
 8000f44:	f001 f94a 	bl	80021dc <MX_MotorControl_Init>
  HAL_NVIC_SetPriority(USART2_IRQn, 8, 0);
 8000f48:	2200      	movs	r2, #0
 8000f4a:	2108      	movs	r1, #8
 8000f4c:	2026      	movs	r0, #38	@ 0x26
 8000f4e:	f004 f873 	bl	8005038 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(USART2_IRQn);
 8000f52:	2026      	movs	r0, #38	@ 0x26
 8000f54:	f004 f8ac 	bl	80050b0 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 8, 0);
 8000f58:	2200      	movs	r2, #0
 8000f5a:	2108      	movs	r1, #8
 8000f5c:	200b      	movs	r0, #11
 8000f5e:	f004 f86b 	bl	8005038 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
 8000f62:	200b      	movs	r0, #11
 8000f64:	f004 f8a4 	bl	80050b0 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(TIM1_BRK_TIM15_IRQn, 9, 0);
 8000f68:	2200      	movs	r2, #0
 8000f6a:	2109      	movs	r1, #9
 8000f6c:	2018      	movs	r0, #24
 8000f6e:	f004 f863 	bl	8005038 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(TIM1_BRK_TIM15_IRQn);
 8000f72:	2018      	movs	r0, #24
 8000f74:	f004 f89c 	bl	80050b0 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(TIM1_UP_TIM16_IRQn, 5, 0);
 8000f78:	2200      	movs	r2, #0
 8000f7a:	2105      	movs	r1, #5
 8000f7c:	2019      	movs	r0, #25
 8000f7e:	f004 f85b 	bl	8005038 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(TIM1_UP_TIM16_IRQn);
 8000f82:	2019      	movs	r0, #25
 8000f84:	f004 f894 	bl	80050b0 <HAL_NVIC_EnableIRQ>
  osThreadDef(mediumFrequency, startMediumFrequencyTask, osPriorityNormal, 0, 128);
 8000f88:	4c15      	ldr	r4, [pc, #84]	@ (8000fe0 <main+0x3e4>)
  HAL_NVIC_SetPriority(ADC1_2_IRQn, 7, 0);
 8000f8a:	2200      	movs	r2, #0
 8000f8c:	2107      	movs	r1, #7
 8000f8e:	2012      	movs	r0, #18
 8000f90:	f004 f852 	bl	8005038 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(ADC1_2_IRQn);
 8000f94:	2012      	movs	r0, #18
 8000f96:	f004 f88b 	bl	80050b0 <HAL_NVIC_EnableIRQ>
  osThreadDef(mediumFrequency, startMediumFrequencyTask, osPriorityNormal, 0, 128);
 8000f9a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8000f9c:	ad0d      	add	r5, sp, #52	@ 0x34
 8000f9e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8000fa0:	f854 3b04 	ldr.w	r3, [r4], #4
 8000fa4:	602b      	str	r3, [r5, #0]
  mediumFrequencyHandle = osThreadCreate(osThread(mediumFrequency), NULL);
 8000fa6:	2100      	movs	r1, #0
 8000fa8:	a80d      	add	r0, sp, #52	@ 0x34
 8000faa:	f006 f89b 	bl	80070e4 <osThreadCreate>
 8000fae:	4b0d      	ldr	r3, [pc, #52]	@ (8000fe4 <main+0x3e8>)
 8000fb0:	6018      	str	r0, [r3, #0]
  osThreadDef(safety, StartSafetyTask, osPriorityAboveNormal, 0, 128);
 8000fb2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8000fb4:	ad15      	add	r5, sp, #84	@ 0x54
 8000fb6:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8000fb8:	6823      	ldr	r3, [r4, #0]
 8000fba:	602b      	str	r3, [r5, #0]
  safetyHandle = osThreadCreate(osThread(safety), NULL);
 8000fbc:	2100      	movs	r1, #0
 8000fbe:	a815      	add	r0, sp, #84	@ 0x54
 8000fc0:	f006 f890 	bl	80070e4 <osThreadCreate>
 8000fc4:	4b08      	ldr	r3, [pc, #32]	@ (8000fe8 <main+0x3ec>)
 8000fc6:	6018      	str	r0, [r3, #0]
  MC_StartMotor1();
 8000fc8:	f000 f81c 	bl	8001004 <MC_StartMotor1>
  osKernelStart();
 8000fcc:	f006 f884 	bl	80070d8 <osKernelStart>
  while (1)
 8000fd0:	e7fe      	b.n	8000fd0 <main+0x3d4>
 8000fd2:	bf00      	nop
 8000fd4:	200006e0 	.word	0x200006e0
 8000fd8:	2000064c 	.word	0x2000064c
 8000fdc:	40004400 	.word	0x40004400
 8000fe0:	0800a170 	.word	0x0800a170
 8000fe4:	20000588 	.word	0x20000588
 8000fe8:	20000584 	.word	0x20000584

08000fec <HAL_TIM_PeriodElapsedCallback>:
  if (htim->Instance == TIM6) {
 8000fec:	4b03      	ldr	r3, [pc, #12]	@ (8000ffc <HAL_TIM_PeriodElapsedCallback+0x10>)
 8000fee:	6802      	ldr	r2, [r0, #0]
 8000ff0:	429a      	cmp	r2, r3
 8000ff2:	d000      	beq.n	8000ff6 <HAL_TIM_PeriodElapsedCallback+0xa>
}
 8000ff4:	4770      	bx	lr
    HAL_IncTick();
 8000ff6:	f003 b94f 	b.w	8004298 <HAL_IncTick>
 8000ffa:	bf00      	nop
 8000ffc:	40001000 	.word	0x40001000

08001000 <Error_Handler>:
 8001000:	b672      	cpsid	i
  while (1)
 8001002:	e7fe      	b.n	8001002 <Error_Handler+0x2>

08001004 <MC_StartMotor1>:
  *
  * @retval returns true if the command is successfully executed, false otherwise.
  */
__weak bool MC_StartMotor1(void)
{
  return (MCI_StartMotor(pMCI[M1]));
 8001004:	4b01      	ldr	r3, [pc, #4]	@ (800100c <MC_StartMotor1+0x8>)
 8001006:	6818      	ldr	r0, [r3, #0]
 8001008:	f000 b8a8 	b.w	800115c <MCI_StartMotor>
 800100c:	20001994 	.word	0x20001994

08001010 <MC_ProfilerCommand>:
 * @brief Not implemented MC_Profiler function.
 *  */ //cstat !MISRAC2012-Rule-2.7 !RED-unused-param  !MISRAC2012-Rule-2.7  !MISRAC2012-Rule-8.13
__weak uint8_t MC_ProfilerCommand(uint16_t rxLength, uint8_t *rxBuffer, int16_t txSyncFreeSpace, uint16_t *txLength, uint8_t *txBuffer)
{
  return (MCP_CMD_UNKNOWN);
}
 8001010:	2002      	movs	r0, #2
 8001012:	4770      	bx	lr

08001014 <MC_APP_BootHook>:
   */

/* USER CODE BEGIN BootHook */

/* USER CODE END BootHook */
}
 8001014:	4770      	bx	lr
 8001016:	bf00      	nop

08001018 <MC_APP_PostMediumFrequencyHook_M1>:
 * @brief Hook function called right after the Medium Frequency Task for Motor 1.
 *
 *
 *
 */
__weak void MC_APP_PostMediumFrequencyHook_M1(void)
 8001018:	4770      	bx	lr
 800101a:	bf00      	nop

0800101c <MCI_ExecSpeedRamp>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->lastCommand = MCI_CMD_EXECSPEEDRAMP;
 800101c:	2301      	movs	r3, #1
 800101e:	7403      	strb	r3, [r0, #16]
    pHandle->hFinalSpeed = hFinalSpeed;
 8001020:	8241      	strh	r1, [r0, #18]
    pHandle->hDurationms = hDurationms;
 8001022:	8402      	strh	r2, [r0, #32]
    pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 8001024:	f880 3028 	strb.w	r3, [r0, #40]	@ 0x28

#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
}
 8001028:	4770      	bx	lr
 800102a:	bf00      	nop

0800102c <MCI_ExecTorqueRamp>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->lastCommand = MCI_CMD_EXECTORQUERAMP;
 800102c:	f04f 0c02 	mov.w	ip, #2
    pHandle->hFinalTorque = hFinalTorque;
    pHandle->hDurationms = hDurationms;
    pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 8001030:	f240 4301 	movw	r3, #1025	@ 0x401
    pHandle->lastCommand = MCI_CMD_EXECTORQUERAMP;
 8001034:	f880 c010 	strb.w	ip, [r0, #16]
    pHandle->hFinalTorque = hFinalTorque;
 8001038:	8281      	strh	r1, [r0, #20]
    pHandle->hDurationms = hDurationms;
 800103a:	8402      	strh	r2, [r0, #32]
    pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 800103c:	8503      	strh	r3, [r0, #40]	@ 0x28
    pHandle->LastModalitySetByUser = MCM_TORQUE_MODE;
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
}
 800103e:	4770      	bx	lr

08001040 <MCI_SetSpeedMode>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->pFOCVars->bDriveInput = INTERNAL;
 8001040:	6843      	ldr	r3, [r0, #4]
{
 8001042:	b510      	push	{r4, lr}
    pHandle->pFOCVars->bDriveInput = INTERNAL;
 8001044:	2200      	movs	r2, #0
 8001046:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
{
 800104a:	4604      	mov	r4, r0
    STC_SetControlMode(pHandle->pSTC, MCM_SPEED_MODE);
 800104c:	2103      	movs	r1, #3
 800104e:	6800      	ldr	r0, [r0, #0]
 8001050:	f008 fb9c 	bl	800978c <STC_SetControlMode>
    pHandle->LastModalitySetByUser = MCM_SPEED_MODE;
 8001054:	2303      	movs	r3, #3
 8001056:	f884 3029 	strb.w	r3, [r4, #41]	@ 0x29
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
}
 800105a:	bd10      	pop	{r4, pc}

0800105c <MCI_SetOpenLoopCurrentMode>:
  * @note This function is only available when the Open loop Debug feature is
  * enabled at firmware generation time.
  */
__weak void MCI_SetOpenLoopCurrentMode(MCI_Handle_t *pHandle)
{
  pHandle->pFOCVars->bDriveInput = EXTERNAL;
 800105c:	6843      	ldr	r3, [r0, #4]
{
 800105e:	b510      	push	{r4, lr}
  pHandle->pFOCVars->bDriveInput = EXTERNAL;
 8001060:	2201      	movs	r2, #1
 8001062:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
{
 8001066:	4604      	mov	r4, r0
  STC_SetControlMode(pHandle->pSTC, MCM_OPEN_LOOP_CURRENT_MODE);
 8001068:	2102      	movs	r1, #2
 800106a:	6800      	ldr	r0, [r0, #0]
 800106c:	f008 fb8e 	bl	800978c <STC_SetControlMode>
  pHandle->LastModalitySetByUser = MCM_OPEN_LOOP_CURRENT_MODE;
 8001070:	2302      	movs	r3, #2
 8001072:	f884 3029 	strb.w	r3, [r4, #41]	@ 0x29
}
 8001076:	bd10      	pop	{r4, pc}

08001078 <MCI_SetOpenLoopVoltageMode>:
  *
  * @note This function is only available when the Open loop Debug feature is
  * enabled at firmware generation time.
  */
__weak void MCI_SetOpenLoopVoltageMode(MCI_Handle_t *pHandle)
{
 8001078:	b538      	push	{r3, r4, r5, lr}
  pHandle->pFOCVars->bDriveInput = EXTERNAL;
 800107a:	6843      	ldr	r3, [r0, #4]
 800107c:	2501      	movs	r5, #1
{
 800107e:	4604      	mov	r4, r0
  pHandle->pFOCVars->bDriveInput = EXTERNAL;
 8001080:	f883 5024 	strb.w	r5, [r3, #36]	@ 0x24
  STC_SetControlMode(pHandle->pSTC, MCM_OPEN_LOOP_VOLTAGE_MODE);
 8001084:	6800      	ldr	r0, [r0, #0]
 8001086:	4629      	mov	r1, r5
 8001088:	f008 fb80 	bl	800978c <STC_SetControlMode>
  pHandle->LastModalitySetByUser = MCM_OPEN_LOOP_VOLTAGE_MODE;
 800108c:	f884 5029 	strb.w	r5, [r4, #41]	@ 0x29
}
 8001090:	bd38      	pop	{r3, r4, r5, pc}
 8001092:	bf00      	nop

08001094 <MCI_FaultProcessing>:
  }
  else
  {
#endif
    /* Set current errors */
    pHandle->CurrentFaults = (pHandle->CurrentFaults | hSetErrors ) & (~hResetErrors);
 8001094:	8c83      	ldrh	r3, [r0, #36]	@ 0x24
    pHandle->PastFaults |= hSetErrors;
 8001096:	f8b0 c026 	ldrh.w	ip, [r0, #38]	@ 0x26
    pHandle->CurrentFaults = (pHandle->CurrentFaults | hSetErrors ) & (~hResetErrors);
 800109a:	430b      	orrs	r3, r1
 800109c:	ea23 0302 	bic.w	r3, r3, r2
    pHandle->PastFaults |= hSetErrors;
 80010a0:	ea41 010c 	orr.w	r1, r1, ip
    pHandle->CurrentFaults = (pHandle->CurrentFaults | hSetErrors ) & (~hResetErrors);
 80010a4:	8483      	strh	r3, [r0, #36]	@ 0x24
    pHandle->PastFaults |= hSetErrors;
 80010a6:	84c1      	strh	r1, [r0, #38]	@ 0x26
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
}
 80010a8:	4770      	bx	lr
 80010aa:	bf00      	nop

080010ac <MCI_ExecBufferedCommands>:
    /* Nothing to do */
  }
  else
  {
#endif
    if ( pHandle->CommandState == MCI_COMMAND_NOT_ALREADY_EXECUTED )
 80010ac:	f890 3028 	ldrb.w	r3, [r0, #40]	@ 0x28
 80010b0:	2b01      	cmp	r3, #1
 80010b2:	d000      	beq.n	80010b6 <MCI_ExecBufferedCommands+0xa>
 80010b4:	4770      	bx	lr
{
 80010b6:	b510      	push	{r4, lr}
    {
      bool commandHasBeenExecuted = false;
      switch (pHandle->lastCommand)
 80010b8:	7c03      	ldrb	r3, [r0, #16]
 80010ba:	3b01      	subs	r3, #1
 80010bc:	4604      	mov	r4, r0
 80010be:	2b04      	cmp	r3, #4
 80010c0:	d82a      	bhi.n	8001118 <MCI_ExecBufferedCommands+0x6c>
 80010c2:	e8df f003 	tbb	[pc, r3]
 80010c6:	192d      	.short	0x192d
 80010c8:	0311      	.short	0x0311
 80010ca:	03          	.byte	0x03
 80010cb:	00          	.byte	0x00
          break;
        }

        case MCI_CMD_SETOPENLOOPVOLTAGE:
        {
          pHandle->pFOCVars->bDriveInput = EXTERNAL;
 80010cc:	6843      	ldr	r3, [r0, #4]
 80010ce:	2201      	movs	r2, #1
 80010d0:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
          VSS_SetMecAcceleration( pHandle->pVSS, pHandle->hFinalSpeed, pHandle->hDurationms);
 80010d4:	8c02      	ldrh	r2, [r0, #32]
 80010d6:	f9b0 1012 	ldrsh.w	r1, [r0, #18]
 80010da:	68c0      	ldr	r0, [r0, #12]
 80010dc:	f008 ffb4 	bl	800a048 <VSS_SetMecAcceleration>
          break;
      }

      if (commandHasBeenExecuted)
      {
        pHandle->CommandState = MCI_COMMAND_EXECUTED_SUCCESSFULLY;
 80010e0:	2302      	movs	r3, #2
 80010e2:	f884 3028 	strb.w	r3, [r4, #40]	@ 0x28
      }
    }
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
}
 80010e6:	bd10      	pop	{r4, pc}
          pHandle->pFOCVars->bDriveInput = EXTERNAL;
 80010e8:	6843      	ldr	r3, [r0, #4]
 80010ea:	2201      	movs	r2, #1
 80010ec:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
          pHandle->pFOCVars->Iqdref = pHandle->Iqdref;
 80010f0:	f8d0 2016 	ldr.w	r2, [r0, #22]
 80010f4:	611a      	str	r2, [r3, #16]
      if (commandHasBeenExecuted)
 80010f6:	e7f3      	b.n	80010e0 <MCI_ExecBufferedCommands+0x34>
          pHandle->pFOCVars->bDriveInput = INTERNAL;
 80010f8:	6843      	ldr	r3, [r0, #4]
 80010fa:	2200      	movs	r2, #0
 80010fc:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
          STC_SetControlMode(pHandle->pSTC, MCM_TORQUE_MODE);
 8001100:	6800      	ldr	r0, [r0, #0]
 8001102:	2104      	movs	r1, #4
 8001104:	f008 fb42 	bl	800978c <STC_SetControlMode>
          commandHasBeenExecuted = STC_ExecRamp(pHandle->pSTC, pHandle->hFinalTorque, pHandle->hDurationms);
 8001108:	8c22      	ldrh	r2, [r4, #32]
 800110a:	f9b4 1014 	ldrsh.w	r1, [r4, #20]
 800110e:	6820      	ldr	r0, [r4, #0]
 8001110:	f008 fb40 	bl	8009794 <STC_ExecRamp>
      if (commandHasBeenExecuted)
 8001114:	2800      	cmp	r0, #0
 8001116:	d1e3      	bne.n	80010e0 <MCI_ExecBufferedCommands+0x34>
        pHandle->CommandState = MCI_COMMAND_EXECUTED_UNSUCCESSFULLY;
 8001118:	2303      	movs	r3, #3
 800111a:	f884 3028 	strb.w	r3, [r4, #40]	@ 0x28
}
 800111e:	bd10      	pop	{r4, pc}
          pHandle->pFOCVars->bDriveInput = INTERNAL;
 8001120:	6843      	ldr	r3, [r0, #4]
 8001122:	2200      	movs	r2, #0
 8001124:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
          STC_SetControlMode(pHandle->pSTC, MCM_SPEED_MODE);
 8001128:	6800      	ldr	r0, [r0, #0]
 800112a:	2103      	movs	r1, #3
 800112c:	f008 fb2e 	bl	800978c <STC_SetControlMode>
          VSS_SetMecAcceleration( pHandle->pVSS, pHandle->hFinalSpeed, pHandle->hDurationms);
 8001130:	8c22      	ldrh	r2, [r4, #32]
 8001132:	f9b4 1012 	ldrsh.w	r1, [r4, #18]
 8001136:	68e0      	ldr	r0, [r4, #12]
 8001138:	f008 ff86 	bl	800a048 <VSS_SetMecAcceleration>
          commandHasBeenExecuted = STC_ExecRamp(pHandle->pSTC, pHandle->hFinalSpeed, pHandle->hDurationms);
 800113c:	8c22      	ldrh	r2, [r4, #32]
 800113e:	f9b4 1012 	ldrsh.w	r1, [r4, #18]
 8001142:	6820      	ldr	r0, [r4, #0]
 8001144:	f008 fb26 	bl	8009794 <STC_ExecRamp>
          break;
 8001148:	e7e4      	b.n	8001114 <MCI_ExecBufferedCommands+0x68>
 800114a:	bf00      	nop

0800114c <MCI_GetSTMState>:
#ifdef NULL_PTR_CHECK_MC_INT
  return ((MC_NULL == pHandle) ? FAULT_NOW : pHandle->State);
#else
  return (pHandle->State);
#endif
}
 800114c:	f890 0023 	ldrb.w	r0, [r0, #35]	@ 0x23
 8001150:	4770      	bx	lr
 8001152:	bf00      	nop

08001154 <MCI_GetOccurredFaults>:
#ifdef NULL_PTR_CHECK_MC_INT
  return ((MC_NULL == pHandle) ? MC_SW_ERROR : (uint16_t)pHandle->PastFaults);
#else
  return ((uint16_t)pHandle->PastFaults);
#endif
}
 8001154:	8cc0      	ldrh	r0, [r0, #38]	@ 0x26
 8001156:	4770      	bx	lr

08001158 <MCI_GetCurrentFaults>:
#ifdef NULL_PTR_CHECK_MC_INT
  return ((MC_NULL == pHandle) ? MC_SW_ERROR : (uint16_t)pHandle->CurrentFaults);
#else
  return ((uint16_t)pHandle->CurrentFaults);
#endif
}
 8001158:	8c80      	ldrh	r0, [r0, #36]	@ 0x24
 800115a:	4770      	bx	lr

0800115c <MCI_StartMotor>:
{
 800115c:	b510      	push	{r4, lr}
 800115e:	4604      	mov	r4, r0
    if ((IDLE == MCI_GetSTMState(pHandle)) &&
 8001160:	f7ff fff4 	bl	800114c <MCI_GetSTMState>
 8001164:	b108      	cbz	r0, 800116a <MCI_StartMotor+0xe>
  bool retVal = false;
 8001166:	2000      	movs	r0, #0
}
 8001168:	bd10      	pop	{r4, pc}
        (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 800116a:	4620      	mov	r0, r4
 800116c:	f7ff fff2 	bl	8001154 <MCI_GetOccurredFaults>
    if ((IDLE == MCI_GetSTMState(pHandle)) &&
 8001170:	2800      	cmp	r0, #0
 8001172:	d1f8      	bne.n	8001166 <MCI_StartMotor+0xa>
        (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)))
 8001174:	4620      	mov	r0, r4
 8001176:	f7ff ffef 	bl	8001158 <MCI_GetCurrentFaults>
        (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 800117a:	2800      	cmp	r0, #0
 800117c:	d1f3      	bne.n	8001166 <MCI_StartMotor+0xa>
      pHandle->DirectCommand = MCI_START;
 800117e:	2001      	movs	r0, #1
 8001180:	f884 0022 	strb.w	r0, [r4, #34]	@ 0x22
      pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 8001184:	f884 0028 	strb.w	r0, [r4, #40]	@ 0x28
}
 8001188:	bd10      	pop	{r4, pc}
 800118a:	bf00      	nop

0800118c <MCI_StopMotor>:
{
 800118c:	b538      	push	{r3, r4, r5, lr}
 800118e:	4605      	mov	r5, r0
    State = MCI_GetSTMState(pHandle);
 8001190:	f7ff ffdc 	bl	800114c <MCI_GetSTMState>
    if ((IDLE == State) || (ICLWAIT == State))
 8001194:	4604      	mov	r4, r0
 8001196:	b118      	cbz	r0, 80011a0 <MCI_StopMotor+0x14>
 8001198:	f1b0 040c 	subs.w	r4, r0, #12
 800119c:	bf18      	it	ne
 800119e:	2401      	movne	r4, #1
    if ((MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 80011a0:	4628      	mov	r0, r5
 80011a2:	f7ff ffd7 	bl	8001154 <MCI_GetOccurredFaults>
 80011a6:	b110      	cbz	r0, 80011ae <MCI_StopMotor+0x22>
  bool retVal = false;
 80011a8:	2400      	movs	r4, #0
}
 80011aa:	4620      	mov	r0, r4
 80011ac:	bd38      	pop	{r3, r4, r5, pc}
        (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)) &&
 80011ae:	4628      	mov	r0, r5
 80011b0:	f7ff ffd2 	bl	8001158 <MCI_GetCurrentFaults>
    if ((MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 80011b4:	2800      	cmp	r0, #0
 80011b6:	d1f7      	bne.n	80011a8 <MCI_StopMotor+0x1c>
        (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)) &&
 80011b8:	2c00      	cmp	r4, #0
 80011ba:	d0f5      	beq.n	80011a8 <MCI_StopMotor+0x1c>
      pHandle->DirectCommand = MCI_STOP;
 80011bc:	2305      	movs	r3, #5
 80011be:	f885 3022 	strb.w	r3, [r5, #34]	@ 0x22
      retVal = true;
 80011c2:	e7f2      	b.n	80011aa <MCI_StopMotor+0x1e>

080011c4 <MCI_FaultAcknowledged>:
{
 80011c4:	b510      	push	{r4, lr}
 80011c6:	4604      	mov	r4, r0
    if ((FAULT_OVER == MCI_GetSTMState(pHandle)) && (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)))
 80011c8:	f7ff ffc0 	bl	800114c <MCI_GetSTMState>
 80011cc:	280b      	cmp	r0, #11
 80011ce:	d001      	beq.n	80011d4 <MCI_FaultAcknowledged+0x10>
  bool reVal = false;
 80011d0:	2000      	movs	r0, #0
}
 80011d2:	bd10      	pop	{r4, pc}
    if ((FAULT_OVER == MCI_GetSTMState(pHandle)) && (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)))
 80011d4:	4620      	mov	r0, r4
 80011d6:	f7ff ffbf 	bl	8001158 <MCI_GetCurrentFaults>
 80011da:	2800      	cmp	r0, #0
 80011dc:	d1f8      	bne.n	80011d0 <MCI_FaultAcknowledged+0xc>
      pHandle->DirectCommand = MCI_ACK_FAULTS;
 80011de:	2302      	movs	r3, #2
 80011e0:	f884 3022 	strb.w	r3, [r4, #34]	@ 0x22
      pHandle->PastFaults = MC_NO_FAULTS;
 80011e4:	84e0      	strh	r0, [r4, #38]	@ 0x26
      reVal = true;
 80011e6:	2001      	movs	r0, #1
}
 80011e8:	bd10      	pop	{r4, pc}
 80011ea:	bf00      	nop

080011ec <MCI_GetFaultState>:
    LocalFaultState = MC_SW_ERROR | (MC_SW_ERROR << 16);
  }
  else
  {
#endif
    LocalFaultState = (uint32_t)(pHandle->PastFaults);
 80011ec:	8cc3      	ldrh	r3, [r0, #38]	@ 0x26
    LocalFaultState |= (uint32_t)(pHandle->CurrentFaults) << 16;
 80011ee:	8c80      	ldrh	r0, [r0, #36]	@ 0x24
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
  return (LocalFaultState);
}
 80011f0:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 80011f4:	4770      	bx	lr
 80011f6:	bf00      	nop

080011f8 <MCI_GetControlMode>:
#ifdef NULL_PTR_CHECK_MC_INT
  return ((MC_NULL == pHandle) ? MCM_TORQUE_MODE : pHandle->LastModalitySetByUser);
#else
  return (pHandle->LastModalitySetByUser);
#endif
}
 80011f8:	f890 0029 	ldrb.w	r0, [r0, #41]	@ 0x29
 80011fc:	4770      	bx	lr
 80011fe:	bf00      	nop

08001200 <MCI_SetCurrentReferences>:
{
 8001200:	b530      	push	{r4, r5, lr}
 8001202:	b083      	sub	sp, #12
 8001204:	4604      	mov	r4, r0
 8001206:	460d      	mov	r5, r1
    mode = MCI_GetControlMode( pHandle );
 8001208:	f7ff fff6 	bl	80011f8 <MCI_GetControlMode>
    if (mode == MCM_OPEN_LOOP_CURRENT_MODE)
 800120c:	2802      	cmp	r0, #2
 800120e:	d00b      	beq.n	8001228 <MCI_SetCurrentReferences+0x28>
      pHandle->lastCommand = MCI_CMD_SETCURRENTREFERENCES;
 8001210:	2203      	movs	r2, #3
      pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 8001212:	2301      	movs	r3, #1
 8001214:	2004      	movs	r0, #4
      pHandle->lastCommand = MCI_CMD_SETCURRENTREFERENCES;
 8001216:	7422      	strb	r2, [r4, #16]
      pHandle->Iqdref.q = Iqdref.q;
 8001218:	f8c4 5016 	str.w	r5, [r4, #22]
      pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 800121c:	f884 3028 	strb.w	r3, [r4, #40]	@ 0x28
      pHandle->LastModalitySetByUser = mode;
 8001220:	f884 0029 	strb.w	r0, [r4, #41]	@ 0x29
}
 8001224:	b003      	add	sp, #12
 8001226:	bd30      	pop	{r4, r5, pc}
      pHandle->pFOCVars->Iqdref.q = Iqdref.q;
 8001228:	6863      	ldr	r3, [r4, #4]
      pHandle->Iqdref.q = Iqdref.q;
 800122a:	f8c4 5016 	str.w	r5, [r4, #22]
      pHandle->pFOCVars->Iqdref.q = Iqdref.q;
 800122e:	611d      	str	r5, [r3, #16]
      pHandle->LastModalitySetByUser = mode;
 8001230:	f884 0029 	strb.w	r0, [r4, #41]	@ 0x29
}
 8001234:	b003      	add	sp, #12
 8001236:	bd30      	pop	{r4, r5, pc}

08001238 <MCI_GetImposedMotorDirection>:
    /* Nothing to do */
  }
  else
  {
#endif
    switch (pHandle->lastCommand)
 8001238:	7c03      	ldrb	r3, [r0, #16]
 800123a:	2b02      	cmp	r3, #2
 800123c:	d005      	beq.n	800124a <MCI_GetImposedMotorDirection+0x12>
 800123e:	2b03      	cmp	r3, #3
 8001240:	d013      	beq.n	800126a <MCI_GetImposedMotorDirection+0x32>
 8001242:	2b01      	cmp	r3, #1
 8001244:	d009      	beq.n	800125a <MCI_GetImposedMotorDirection+0x22>
  int16_t retVal = 1;
 8001246:	2001      	movs	r0, #1
    }
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
  return (retVal);
}
 8001248:	4770      	bx	lr
        if (pHandle->hFinalTorque < 0)
 800124a:	f9b0 3014 	ldrsh.w	r3, [r0, #20]
          retVal = -1;
 800124e:	2b00      	cmp	r3, #0
 8001250:	bfac      	ite	ge
 8001252:	2001      	movge	r0, #1
 8001254:	f04f 30ff 	movlt.w	r0, #4294967295
 8001258:	4770      	bx	lr
        if (pHandle->hFinalSpeed < 0)
 800125a:	f9b0 3012 	ldrsh.w	r3, [r0, #18]
          retVal = -1;
 800125e:	2b00      	cmp	r3, #0
 8001260:	bfac      	ite	ge
 8001262:	2001      	movge	r0, #1
 8001264:	f04f 30ff 	movlt.w	r0, #4294967295
 8001268:	4770      	bx	lr
        if (pHandle->Iqdref.q < 0)
 800126a:	f9b0 3016 	ldrsh.w	r3, [r0, #22]
          retVal = -1;
 800126e:	2b00      	cmp	r3, #0
 8001270:	bfac      	ite	ge
 8001272:	2001      	movge	r0, #1
 8001274:	f04f 30ff 	movlt.w	r0, #4294967295
 8001278:	4770      	bx	lr
 800127a:	bf00      	nop

0800127c <MCI_GetLastRampFinalSpeed>:
  }
  return (retVal);
#else
  return (pHandle->hFinalSpeed);
#endif
}
 800127c:	f9b0 0012 	ldrsh.w	r0, [r0, #18]
 8001280:	4770      	bx	lr
 8001282:	bf00      	nop

08001284 <MCI_GetLastRampFinalTorque>:
  }
  return (retVal);
#else
  return (pHandle->hFinalTorque);
#endif
}
 8001284:	f9b0 0014 	ldrsh.w	r0, [r0, #20]
 8001288:	4770      	bx	lr
 800128a:	bf00      	nop

0800128c <MCI_GetLastRampFinalDuration>:
  }
  return (retVal);
#else
  return (pHandle->hDurationms);
#endif
}
 800128c:	8c00      	ldrh	r0, [r0, #32]
 800128e:	4770      	bx	lr

08001290 <MCI_StopRamp>:
    /* Nothing to do */
  }
  else
  {
#endif
    STC_StopRamp(pHandle->pSTC);
 8001290:	6803      	ldr	r3, [r0, #0]
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->RampRemainingStep = 0U;
 8001292:	2200      	movs	r2, #0
 8001294:	60da      	str	r2, [r3, #12]
    pHandle->IncDecAmount = 0;
 8001296:	619a      	str	r2, [r3, #24]
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
}
 8001298:	4770      	bx	lr
 800129a:	bf00      	nop

0800129c <MCI_GetAvrgMecSpeedUnit>:
static inline SpeednPosFdbk_Handle_t *STC_GetSpeedSensor(SpeednTorqCtrl_Handle_t *pHandle)
{
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  return ((MC_NULL ==  pHandle) ? MC_NULL : pHandle->SPD);
#else
  return (pHandle->SPD);
 800129c:	6803      	ldr	r3, [r0, #0]
  }
  else
  {
#endif
    SpeednPosFdbk_Handle_t * SpeedSensor = STC_GetSpeedSensor(pHandle->pSTC);
    temp_speed = SPD_GetAvrgMecSpeedUnit(SpeedSensor);
 800129e:	6958      	ldr	r0, [r3, #20]
 80012a0:	f008 ba0c 	b.w	80096bc <SPD_GetAvrgMecSpeedUnit>

080012a4 <MCI_GetMecSpeedRefUnit>:
__weak int16_t MCI_GetMecSpeedRefUnit(MCI_Handle_t *pHandle)
{
#ifdef NULL_PTR_CHECK_MC_INT
  return ((MC_NULL == pHandle) ? 0 : STC_GetMecSpeedRefUnit(pHandle->pSTC));
#else
  return (STC_GetMecSpeedRefUnit(pHandle->pSTC));
 80012a4:	6800      	ldr	r0, [r0, #0]
 80012a6:	f008 ba6d 	b.w	8009784 <STC_GetMecSpeedRefUnit>
 80012aa:	bf00      	nop

080012ac <MCI_GetIab>:
  {
    tempVal = pHandle->pFOCVars->Iab;
  }
  return (tempVal);
#else
  return (pHandle->pFOCVars->Iab);
 80012ac:	6842      	ldr	r2, [r0, #4]
 80012ae:	6810      	ldr	r0, [r2, #0]
 80012b0:	2300      	movs	r3, #0
 80012b2:	b282      	uxth	r2, r0
 80012b4:	f362 030f 	bfi	r3, r2, #0, #16
 80012b8:	0c00      	lsrs	r0, r0, #16
 80012ba:	f360 431f 	bfi	r3, r0, #16, #16
{
 80012be:	b082      	sub	sp, #8
#endif
}
 80012c0:	4618      	mov	r0, r3
 80012c2:	b002      	add	sp, #8
 80012c4:	4770      	bx	lr
 80012c6:	bf00      	nop

080012c8 <MCI_GetIalphabeta>:
  {
    tempVal = pHandle->pFOCVars->Ialphabeta;
  }
  return (tempVal);
#else
  return (pHandle->pFOCVars->Ialphabeta);
 80012c8:	6842      	ldr	r2, [r0, #4]
 80012ca:	6850      	ldr	r0, [r2, #4]
 80012cc:	2300      	movs	r3, #0
 80012ce:	b282      	uxth	r2, r0
 80012d0:	f362 030f 	bfi	r3, r2, #0, #16
 80012d4:	0c00      	lsrs	r0, r0, #16
 80012d6:	f360 431f 	bfi	r3, r0, #16, #16
{
 80012da:	b082      	sub	sp, #8
#endif
}
 80012dc:	4618      	mov	r0, r3
 80012de:	b002      	add	sp, #8
 80012e0:	4770      	bx	lr
 80012e2:	bf00      	nop

080012e4 <MCI_GetIqd>:
  {
    tempVal = pHandle->pFOCVars->Iqd;
  }
  return (tempVal);
#else
  return (pHandle->pFOCVars->Iqd);
 80012e4:	6842      	ldr	r2, [r0, #4]
 80012e6:	68d0      	ldr	r0, [r2, #12]
 80012e8:	2300      	movs	r3, #0
 80012ea:	b282      	uxth	r2, r0
 80012ec:	f362 030f 	bfi	r3, r2, #0, #16
 80012f0:	0c00      	lsrs	r0, r0, #16
 80012f2:	f360 431f 	bfi	r3, r0, #16, #16
{
 80012f6:	b082      	sub	sp, #8
#endif
}
 80012f8:	4618      	mov	r0, r3
 80012fa:	b002      	add	sp, #8
 80012fc:	4770      	bx	lr
 80012fe:	bf00      	nop

08001300 <MCI_GetIqdref>:
  {
    tempVal = pHandle->pFOCVars->Iqdref;
  }
  return (tempVal);
#else
  return (pHandle->pFOCVars->Iqdref);
 8001300:	6842      	ldr	r2, [r0, #4]
 8001302:	6910      	ldr	r0, [r2, #16]
 8001304:	2300      	movs	r3, #0
 8001306:	b282      	uxth	r2, r0
 8001308:	f362 030f 	bfi	r3, r2, #0, #16
 800130c:	0c00      	lsrs	r0, r0, #16
 800130e:	f360 431f 	bfi	r3, r0, #16, #16
{
 8001312:	b082      	sub	sp, #8
#endif
}
 8001314:	4618      	mov	r0, r3
 8001316:	b002      	add	sp, #8
 8001318:	4770      	bx	lr
 800131a:	bf00      	nop

0800131c <MCI_GetVqd>:
  {
    tempVal = pHandle->pFOCVars->Vqd;
  }
  return (tempVal);
#else
  return (pHandle->pFOCVars->Vqd);
 800131c:	6842      	ldr	r2, [r0, #4]
 800131e:	f8d2 0016 	ldr.w	r0, [r2, #22]
 8001322:	2300      	movs	r3, #0
 8001324:	b282      	uxth	r2, r0
 8001326:	f362 030f 	bfi	r3, r2, #0, #16
 800132a:	0c00      	lsrs	r0, r0, #16
 800132c:	f360 431f 	bfi	r3, r0, #16, #16
{
 8001330:	b082      	sub	sp, #8
#endif
}
 8001332:	4618      	mov	r0, r3
 8001334:	b002      	add	sp, #8
 8001336:	4770      	bx	lr

08001338 <MCI_GetValphabeta>:
  {
    tempVal = pHandle->pFOCVars->Valphabeta;
  }
  return (tempVal);
#else
  return (pHandle->pFOCVars->Valphabeta);
 8001338:	6842      	ldr	r2, [r0, #4]
 800133a:	f8d2 001a 	ldr.w	r0, [r2, #26]
 800133e:	2300      	movs	r3, #0
 8001340:	b282      	uxth	r2, r0
 8001342:	f362 030f 	bfi	r3, r2, #0, #16
 8001346:	0c00      	lsrs	r0, r0, #16
 8001348:	f360 431f 	bfi	r3, r0, #16, #16
{
 800134c:	b082      	sub	sp, #8
#endif
}
 800134e:	4618      	mov	r0, r3
 8001350:	b002      	add	sp, #8
 8001352:	4770      	bx	lr

08001354 <MCI_GetTeref>:
__weak int16_t MCI_GetTeref(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
{
#ifdef NULL_PTR_CHECK_MC_INT
  return ((MC_NULL == pHandle) ? 0 : pHandle->pFOCVars->hTeref);
#else
  return (pHandle->pFOCVars->hTeref);
 8001354:	6843      	ldr	r3, [r0, #4]
#endif
}
 8001356:	f9b3 001e 	ldrsh.w	r0, [r3, #30]
 800135a:	4770      	bx	lr

0800135c <MCI_Clear_Iqdref>:
/**
  * @brief  It re-initializes Iqdref variables with their default values.
  * @param  pHandle Pointer on the component instance to work on.
  */
__weak void MCI_Clear_Iqdref(MCI_Handle_t *pHandle)
{
 800135c:	b510      	push	{r4, lr}
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->pFOCVars->Iqdref = STC_GetDefaultIqdref(pHandle->pSTC);
 800135e:	e9d0 0400 	ldrd	r0, r4, [r0]
 8001362:	f008 fa99 	bl	8009898 <STC_GetDefaultIqdref>
 8001366:	f3c0 430f 	ubfx	r3, r0, #16, #16
 800136a:	8220      	strh	r0, [r4, #16]
 800136c:	8263      	strh	r3, [r4, #18]
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
}
 800136e:	bd10      	pop	{r4, pc}

08001370 <MCM_Clarke>:
  *                       beta = -(2*b+a)/sqrt(3)
  * @param  Input: stator values a and b in ab_t format.
  * @retval Stator values alpha and beta in alphabeta_t format.
  */
__weak alphabeta_t MCM_Clarke(ab_t Input)
{
 8001370:	f3c0 430f 	ubfx	r3, r0, #16, #16
  /* qIalpha = qIas*/
  Output.alpha = Input.a;

  a_divSQRT3_tmp = divSQRT_3 * ((int32_t)Input.a);

  b_divSQRT3_tmp = divSQRT_3 * ((int32_t)Input.b);
 8001374:	f644 11e6 	movw	r1, #18918	@ 0x49e6
#ifndef FULL_MISRA_C_COMPLIANCY_MC_MATH
  /* WARNING: the below instruction is not MISRA compliant, user should verify
    that Cortex-M3 assembly instruction ASR (arithmetic shift right) is used by
    the compiler to perform the shift (instead of LSR logical shift right) */
  //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
  wbeta_tmp = (-(a_divSQRT3_tmp) - (b_divSQRT3_tmp) - (b_divSQRT3_tmp)) >> 15;
 8001378:	f24b 621a 	movw	r2, #46618	@ 0xb61a
  b_divSQRT3_tmp = divSQRT_3 * ((int32_t)Input.b);
 800137c:	fb13 f301 	smulbb	r3, r3, r1
  wbeta_tmp = (-(a_divSQRT3_tmp) - (b_divSQRT3_tmp) - (b_divSQRT3_tmp)) >> 15;
 8001380:	fb10 f202 	smulbb	r2, r0, r2
 8001384:	eba2 0243 	sub.w	r2, r2, r3, lsl #1
#else
  wbeta_tmp = (-(a_divSQRT3_tmp) - (b_divSQRT3_tmp) - (b_divSQRT3_tmp)) / 32768;
#endif

  /* Check saturation of Ibeta */
  if (wbeta_tmp > INT16_MAX)
 8001388:	f1b2 4f80 	cmp.w	r2, #1073741824	@ 0x40000000
{
 800138c:	b084      	sub	sp, #16
 800138e:	b203      	sxth	r3, r0
  if (wbeta_tmp > INT16_MAX)
 8001390:	da05      	bge.n	800139e <MCM_Clarke+0x2e>
 8001392:	13d1      	asrs	r1, r2, #15
  {
    hbeta_tmp = INT16_MAX;
  }
  else if (wbeta_tmp < (-32768))
 8001394:	f511 4f00 	cmn.w	r1, #32768	@ 0x8000
 8001398:	da0c      	bge.n	80013b4 <MCM_Clarke+0x44>
 800139a:	4a09      	ldr	r2, [pc, #36]	@ (80013c0 <MCM_Clarke+0x50>)
 800139c:	e001      	b.n	80013a2 <MCM_Clarke+0x32>
 800139e:	f647 72ff 	movw	r2, #32767	@ 0x7fff
  else
  {
    /* Nothing to do */
  }

  return (Output);
 80013a2:	b29b      	uxth	r3, r3
 80013a4:	2000      	movs	r0, #0
 80013a6:	f363 000f 	bfi	r0, r3, #0, #16
 80013aa:	b293      	uxth	r3, r2
 80013ac:	f363 401f 	bfi	r0, r3, #16, #16
}
 80013b0:	b004      	add	sp, #16
 80013b2:	4770      	bx	lr
    hbeta_tmp = ((int16_t)wbeta_tmp);
 80013b4:	4802      	ldr	r0, [pc, #8]	@ (80013c0 <MCM_Clarke+0x50>)
 80013b6:	b20a      	sxth	r2, r1
 80013b8:	4282      	cmp	r2, r0
 80013ba:	bfb8      	it	lt
 80013bc:	4602      	movlt	r2, r0
 80013be:	e7f0      	b.n	80013a2 <MCM_Clarke+0x32>
 80013c0:	ffff8001 	.word	0xffff8001

080013c4 <MCM_Trig_Functions>:
  } CosSin;
  //cstat +MISRAC2012-Rule-19.2
  /* Configure CORDIC */
  /* Misra  violation Rule 11.4 A�Conversion�should�not�be�performed�between�a�
   * pointer�to�object and an integer type */
  WRITE_REG(CORDIC->CSR, CORDIC_CONFIG_COSINE);
 80013c4:	4b09      	ldr	r3, [pc, #36]	@ (80013ec <MCM_Trig_Functions+0x28>)
  /* Misra  violation Rule�11.4 A�Conversion�should�not�be�performed�between�a
   * pointer�to�object and an integer type */
  LL_CORDIC_WriteData(CORDIC, ((uint32_t)0x7FFF0000) + ((uint32_t)hAngle));
 80013c6:	f100 40ff 	add.w	r0, r0, #2139095040	@ 0x7f800000
  WRITE_REG(CORDIC->CSR, CORDIC_CONFIG_COSINE);
 80013ca:	f04f 1260 	mov.w	r2, #6291552	@ 0x600060
  LL_CORDIC_WriteData(CORDIC, ((uint32_t)0x7FFF0000) + ((uint32_t)hAngle));
 80013ce:	f500 00fe 	add.w	r0, r0, #8323072	@ 0x7f0000
  WRITE_REG(CORDIC->CSR, CORDIC_CONFIG_COSINE);
 80013d2:	601a      	str	r2, [r3, #0]
  * @param  InData 0 .. 0xFFFFFFFF : 32-bit value to be provided as input data for CORDIC processing.
  * @retval None
  */
__STATIC_INLINE void LL_CORDIC_WriteData(CORDIC_TypeDef *CORDICx, uint32_t InData)
{
  WRITE_REG(CORDICx->WDATA, InData);
 80013d4:	6058      	str	r0, [r3, #4]
  * @param  CORDICx CORDIC Instance
  * @retval 32-bit output data of CORDIC processing.
  */
__STATIC_INLINE uint32_t LL_CORDIC_ReadData(const CORDIC_TypeDef *CORDICx)
{
  return (uint32_t)(READ_REG(CORDICx->RDATA));
 80013d6:	689b      	ldr	r3, [r3, #8]
  /* Read angle */
  /* Misra  violation Rule�11.4 A�Conversion�should�not�be�performed between�a
   * pointer�to object and an integer type */
  CosSin.CordicRdata = LL_CORDIC_ReadData(CORDIC);
  return (CosSin.Components); //cstat !UNION-type-punning
 80013d8:	2000      	movs	r0, #0
 80013da:	b29a      	uxth	r2, r3
 80013dc:	f362 000f 	bfi	r0, r2, #0, #16
 80013e0:	0c1b      	lsrs	r3, r3, #16
{
 80013e2:	b082      	sub	sp, #8
  return (CosSin.Components); //cstat !UNION-type-punning
 80013e4:	f363 401f 	bfi	r0, r3, #16, #16
}
 80013e8:	b002      	add	sp, #8
 80013ea:	4770      	bx	lr
 80013ec:	40020c00 	.word	0x40020c00

080013f0 <MCM_Park>:
{
 80013f0:	b530      	push	{r4, r5, lr}
 80013f2:	4605      	mov	r5, r0
 80013f4:	4604      	mov	r4, r0
 80013f6:	b085      	sub	sp, #20
  Local_Vector_Components = MCM_Trig_Functions(Theta);
 80013f8:	4608      	mov	r0, r1
 80013fa:	f7ff ffe3 	bl	80013c4 <MCM_Trig_Functions>
 80013fe:	b22d      	sxth	r5, r5
 8001400:	b201      	sxth	r1, r0
 8001402:	1424      	asrs	r4, r4, #16
 8001404:	1400      	asrs	r0, r0, #16
  q_tmp_1 = Input.alpha * ((int32_t )Local_Vector_Components.hCos);
 8001406:	fb05 f301 	mul.w	r3, r5, r1
  wqd_tmp = (q_tmp_1 - q_tmp_2) >> 15; //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 800140a:	fb04 3310 	mls	r3, r4, r0, r3
  if (wqd_tmp > INT16_MAX)
 800140e:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8001412:	da05      	bge.n	8001420 <MCM_Park+0x30>
 8001414:	13da      	asrs	r2, r3, #15
  else if (wqd_tmp < (-32768))
 8001416:	f512 4f00 	cmn.w	r2, #32768	@ 0x8000
 800141a:	da22      	bge.n	8001462 <MCM_Park+0x72>
 800141c:	4a14      	ldr	r2, [pc, #80]	@ (8001470 <MCM_Park+0x80>)
 800141e:	e001      	b.n	8001424 <MCM_Park+0x34>
 8001420:	f647 72ff 	movw	r2, #32767	@ 0x7fff
  d_tmp_2 = Input.beta * ((int32_t )Local_Vector_Components.hCos);
 8001424:	fb01 f404 	mul.w	r4, r1, r4
  wqd_tmp = (d_tmp_1 + d_tmp_2) >> 15; //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 8001428:	fb05 4400 	mla	r4, r5, r0, r4
  if (wqd_tmp > INT16_MAX)
 800142c:	f1b4 4f80 	cmp.w	r4, #1073741824	@ 0x40000000
  wqd_tmp = (d_tmp_1 + d_tmp_2) >> 15; //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 8001430:	ea4f 33e4 	mov.w	r3, r4, asr #15
  if (wqd_tmp > INT16_MAX)
 8001434:	da04      	bge.n	8001440 <MCM_Park+0x50>
  else if (wqd_tmp < (-32768))
 8001436:	f513 4f00 	cmn.w	r3, #32768	@ 0x8000
 800143a:	da0c      	bge.n	8001456 <MCM_Park+0x66>
 800143c:	4b0c      	ldr	r3, [pc, #48]	@ (8001470 <MCM_Park+0x80>)
 800143e:	e001      	b.n	8001444 <MCM_Park+0x54>
 8001440:	f647 73ff 	movw	r3, #32767	@ 0x7fff
  return (Output);
 8001444:	b292      	uxth	r2, r2
 8001446:	2000      	movs	r0, #0
 8001448:	f362 000f 	bfi	r0, r2, #0, #16
 800144c:	b29b      	uxth	r3, r3
 800144e:	f363 401f 	bfi	r0, r3, #16, #16
}
 8001452:	b005      	add	sp, #20
 8001454:	bd30      	pop	{r4, r5, pc}
    hqd_tmp = ((int16_t)wqd_tmp);
 8001456:	4906      	ldr	r1, [pc, #24]	@ (8001470 <MCM_Park+0x80>)
 8001458:	b21b      	sxth	r3, r3
 800145a:	428b      	cmp	r3, r1
 800145c:	bfb8      	it	lt
 800145e:	460b      	movlt	r3, r1
 8001460:	e7f0      	b.n	8001444 <MCM_Park+0x54>
    hqd_tmp = ((int16_t)wqd_tmp);
 8001462:	4b03      	ldr	r3, [pc, #12]	@ (8001470 <MCM_Park+0x80>)
 8001464:	b212      	sxth	r2, r2
 8001466:	429a      	cmp	r2, r3
 8001468:	bfb8      	it	lt
 800146a:	461a      	movlt	r2, r3
 800146c:	e7da      	b.n	8001424 <MCM_Park+0x34>
 800146e:	bf00      	nop
 8001470:	ffff8001 	.word	0xffff8001

08001474 <MCM_Rev_Park>:
{
 8001474:	b530      	push	{r4, r5, lr}
 8001476:	4605      	mov	r5, r0
 8001478:	b085      	sub	sp, #20
 800147a:	4604      	mov	r4, r0
  Local_Vector_Components = MCM_Trig_Functions(Theta);
 800147c:	4608      	mov	r0, r1
 800147e:	f7ff ffa1 	bl	80013c4 <MCM_Trig_Functions>
 8001482:	1424      	asrs	r4, r4, #16
 8001484:	1402      	asrs	r2, r0, #16
 8001486:	b22d      	sxth	r5, r5
 8001488:	b200      	sxth	r0, r0
  alpha_tmp2 = Input.d * ((int32_t)Local_Vector_Components.hSin);
 800148a:	fb04 f302 	mul.w	r3, r4, r2
  Output.alpha = (int16_t)(((alpha_tmp1) + (alpha_tmp2)) >> 15);
 800148e:	fb05 3300 	mla	r3, r5, r0, r3
  beta_tmp2 = Input.d * ((int32_t)Local_Vector_Components.hCos);
 8001492:	fb00 f404 	mul.w	r4, r0, r4
  Output.beta = (int16_t)((beta_tmp2 - beta_tmp1) >> 15);
 8001496:	fb05 4412 	mls	r4, r5, r2, r4
  return (Output);
 800149a:	f3c3 33cf 	ubfx	r3, r3, #15, #16
 800149e:	2000      	movs	r0, #0
 80014a0:	f363 000f 	bfi	r0, r3, #0, #16
 80014a4:	f3c4 34cf 	ubfx	r4, r4, #15, #16
 80014a8:	f364 401f 	bfi	r0, r4, #16, #16
}
 80014ac:	b005      	add	sp, #20
 80014ae:	bd30      	pop	{r4, r5, pc}

080014b0 <MCM_Sqrt>:
  */
__weak int32_t MCM_Sqrt(int32_t wInput)
{
  int32_t wtemprootnew;

  if (wInput > 0)
 80014b0:	2800      	cmp	r0, #0
 80014b2:	dd09      	ble.n	80014c8 <MCM_Sqrt+0x18>
 80014b4:	b672      	cpsid	i
  {
    uint32_t retVal;
    /* Disable Irq as sqrt is used in MF and HF task */
    __disable_irq();
    /* Configure CORDIC */
    WRITE_REG(CORDIC->CSR, CORDIC_CONFIG_SQRT);
 80014b6:	4b05      	ldr	r3, [pc, #20]	@ (80014cc <MCM_Sqrt+0x1c>)
 80014b8:	f240 1269 	movw	r2, #361	@ 0x169
 80014bc:	601a      	str	r2, [r3, #0]
  WRITE_REG(CORDICx->WDATA, InData);
 80014be:	6058      	str	r0, [r3, #4]
  return (uint32_t)(READ_REG(CORDICx->RDATA));
 80014c0:	6898      	ldr	r0, [r3, #8]
    LL_CORDIC_WriteData(CORDIC, ((uint32_t)wInput));
    /* Read sqrt and return */
#ifndef FULL_MISRA_C_COMPLIANCY_MC_MATH
    retVal = (LL_CORDIC_ReadData(CORDIC)) >> 15; //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 80014c2:	0bc0      	lsrs	r0, r0, #15
  __ASM volatile ("cpsie i" : : : "memory");
 80014c4:	b662      	cpsie	i
}
 80014c6:	4770      	bx	lr
    __enable_irq();

  }
  else
  {
    wtemprootnew = (int32_t)0;
 80014c8:	2000      	movs	r0, #0
  }

  return (wtemprootnew);
}
 80014ca:	4770      	bx	lr
 80014cc:	40020c00 	.word	0x40020c00

080014d0 <MCboot>:
{
  /* USER CODE BEGIN MCboot 0 */

  /* USER CODE END MCboot 0 */

  if (MC_NULL == pMCIList)
 80014d0:	b310      	cbz	r0, 8001518 <MCboot+0x48>
{
 80014d2:	b538      	push	{r3, r4, r5, lr}
    /* Nothing to do */
  }
  else
  {

    bMCBootCompleted = (uint8_t )0;
 80014d4:	4d11      	ldr	r5, [pc, #68]	@ (800151c <MCboot+0x4c>)
 80014d6:	2300      	movs	r3, #0
 80014d8:	702b      	strb	r3, [r5, #0]
 80014da:	4604      	mov	r4, r0

    /*************************************************/
    /*    FOC initialization         */
    /*************************************************/
    FOC_Init();
 80014dc:	f000 f9f4 	bl	80018c8 <FOC_Init>

    ASPEP_start(&aspepOverUartA);
 80014e0:	480f      	ldr	r0, [pc, #60]	@ (8001520 <MCboot+0x50>)
 80014e2:	f7ff f83f 	bl	8000564 <ASPEP_start>
    /* USER CODE END MCboot 1 */

    /******************************************************/
    /*   PID component initialization: speed regulation   */
    /******************************************************/
    PID_HandleInit(&PIDSpeedHandle_M1);
 80014e6:	480f      	ldr	r0, [pc, #60]	@ (8001524 <MCboot+0x54>)
 80014e8:	f006 ff56 	bl	8008398 <PID_HandleInit>

    /****************************************************/
    /*   Virtual speed sensor component initialization  */
    /****************************************************/
    VSS_Init(&VirtualSpeedSensorM1);
 80014ec:	480e      	ldr	r0, [pc, #56]	@ (8001528 <MCboot+0x58>)
 80014ee:	f008 fd03 	bl	8009ef8 <VSS_Init>

    /********************************************************/
    /*   Bus voltage sensor component initialization        */
    /********************************************************/
    (void)RCM_RegisterRegConv(&VbusRegConv_M1);
 80014f2:	480e      	ldr	r0, [pc, #56]	@ (800152c <MCboot+0x5c>)
 80014f4:	f002 f90e 	bl	8003714 <RCM_RegisterRegConv>
    RVBS_Init(&BusVoltageSensor_M1);
 80014f8:	480d      	ldr	r0, [pc, #52]	@ (8001530 <MCboot+0x60>)
 80014fa:	f007 ff29 	bl	8009350 <RVBS_Init>

    /*******************************************************/
    /*   Temperature measurement component initialization  */
    /*******************************************************/
    (void)RCM_RegisterRegConv(&TempRegConv_M1);
 80014fe:	480d      	ldr	r0, [pc, #52]	@ (8001534 <MCboot+0x64>)
 8001500:	f002 f908 	bl	8003714 <RCM_RegisterRegConv>
    NTC_Init(&TempSensor_M1);
 8001504:	480c      	ldr	r0, [pc, #48]	@ (8001538 <MCboot+0x68>)
 8001506:	f006 fef1 	bl	80082ec <NTC_Init>

    pMCIList[M1] = &Mci[M1];
 800150a:	4b0c      	ldr	r3, [pc, #48]	@ (800153c <MCboot+0x6c>)
 800150c:	6023      	str	r3, [r4, #0]

    /* Applicative hook in MCBoot() */
    MC_APP_BootHook();
 800150e:	f7ff fd81 	bl	8001014 <MC_APP_BootHook>

    /* USER CODE BEGIN MCboot 2 */

    /* USER CODE END MCboot 2 */

    bMCBootCompleted = 1U;
 8001512:	2301      	movs	r3, #1
 8001514:	702b      	strb	r3, [r5, #0]
  }
}
 8001516:	bd38      	pop	{r3, r4, r5, pc}
 8001518:	4770      	bx	lr
 800151a:	bf00      	nop
 800151c:	200007fc 	.word	0x200007fc
 8001520:	200004d0 	.word	0x200004d0
 8001524:	200003a8 	.word	0x200003a8
 8001528:	2000043c 	.word	0x2000043c
 800152c:	20000400 	.word	0x20000400
 8001530:	200003e4 	.word	0x200003e4
 8001534:	2000042c 	.word	0x2000042c
 8001538:	20000410 	.word	0x20000410
 800153c:	20000000 	.word	0x20000000

08001540 <MC_RunMotorControlTasks>:
 * - Power Factor Correction Task (if enabled).
 * - User Interface task.
 */
__weak void MC_RunMotorControlTasks(void)
{
  if (0U == bMCBootCompleted)
 8001540:	4b1d      	ldr	r3, [pc, #116]	@ (80015b8 <MC_RunMotorControlTasks+0x78>)
 8001542:	781b      	ldrb	r3, [r3, #0]
 8001544:	b1bb      	cbz	r3, 8001576 <MC_RunMotorControlTasks+0x36>
{
 8001546:	b570      	push	{r4, r5, r6, lr}
    /* ** Medium Frequency Tasks ** */
/* USER CODE BEGIN MC_Scheduler 0 */

/* USER CODE END MC_Scheduler 0 */

    if(hMFTaskCounterM1 > 0u)
 8001548:	4c1c      	ldr	r4, [pc, #112]	@ (80015bc <MC_RunMotorControlTasks+0x7c>)
 800154a:	8823      	ldrh	r3, [r4, #0]
 800154c:	b1a3      	cbz	r3, 8001578 <MC_RunMotorControlTasks+0x38>
    {
      hMFTaskCounterM1--;
 800154e:	3b01      	subs	r3, #1
 8001550:	b29b      	uxth	r3, r3

      /* USER CODE END MC_Scheduler 1 */

      hMFTaskCounterM1 = (uint16_t)MF_TASK_OCCURENCE_TICKS;
    }
    if(hBootCapDelayCounterM1 > 0U)
 8001552:	4a1b      	ldr	r2, [pc, #108]	@ (80015c0 <MC_RunMotorControlTasks+0x80>)
      hMFTaskCounterM1--;
 8001554:	8023      	strh	r3, [r4, #0]
    if(hBootCapDelayCounterM1 > 0U)
 8001556:	8813      	ldrh	r3, [r2, #0]
 8001558:	b29b      	uxth	r3, r3
 800155a:	b11b      	cbz	r3, 8001564 <MC_RunMotorControlTasks+0x24>
    {
      hBootCapDelayCounterM1--;
 800155c:	8813      	ldrh	r3, [r2, #0]
 800155e:	3b01      	subs	r3, #1
 8001560:	b29b      	uxth	r3, r3
 8001562:	8013      	strh	r3, [r2, #0]
    }
    else
    {
      /* Nothing to do */
    }
    if(hStopPermanencyCounterM1 > 0U)
 8001564:	4a17      	ldr	r2, [pc, #92]	@ (80015c4 <MC_RunMotorControlTasks+0x84>)
 8001566:	8813      	ldrh	r3, [r2, #0]
 8001568:	b29b      	uxth	r3, r3
 800156a:	b11b      	cbz	r3, 8001574 <MC_RunMotorControlTasks+0x34>
    {
      hStopPermanencyCounterM1--;
 800156c:	8813      	ldrh	r3, [r2, #0]
 800156e:	3b01      	subs	r3, #1
 8001570:	b29b      	uxth	r3, r3
 8001572:	8013      	strh	r3, [r2, #0]

  /* USER CODE BEGIN MC_Scheduler 2 */

  /* USER CODE END MC_Scheduler 2 */
  }
}
 8001574:	bd70      	pop	{r4, r5, r6, pc}
 8001576:	4770      	bx	lr
      MCP_Over_UartA.rxBuffer = MCP_Over_UartA.pTransportLayer->fRXPacketProcess(MCP_Over_UartA.pTransportLayer,
 8001578:	4d13      	ldr	r5, [pc, #76]	@ (80015c8 <MC_RunMotorControlTasks+0x88>)
      TSK_MediumFrequencyTaskM1();
 800157a:	f000 fa5b 	bl	8001a34 <TSK_MediumFrequencyTaskM1>
      MC_APP_PostMediumFrequencyHook_M1();
 800157e:	f7ff fd4b 	bl	8001018 <MC_APP_PostMediumFrequencyHook_M1>
      MCP_Over_UartA.rxBuffer = MCP_Over_UartA.pTransportLayer->fRXPacketProcess(MCP_Over_UartA.pTransportLayer,
 8001582:	4629      	mov	r1, r5
 8001584:	f851 0b0c 	ldr.w	r0, [r1], #12
 8001588:	6883      	ldr	r3, [r0, #8]
 800158a:	4798      	blx	r3
 800158c:	6068      	str	r0, [r5, #4]
      if ( 0U == MCP_Over_UartA.rxBuffer)
 800158e:	b130      	cbz	r0, 800159e <MC_RunMotorControlTasks+0x5e>
        if (0U == MCP_Over_UartA.pTransportLayer->fGetBuffer(MCP_Over_UartA.pTransportLayer,
 8001590:	4629      	mov	r1, r5
 8001592:	220a      	movs	r2, #10
 8001594:	f851 0b08 	ldr.w	r0, [r1], #8
 8001598:	6803      	ldr	r3, [r0, #0]
 800159a:	4798      	blx	r3
 800159c:	b908      	cbnz	r0, 80015a2 <MC_RunMotorControlTasks+0x62>
{
 800159e:	2301      	movs	r3, #1
 80015a0:	e7d7      	b.n	8001552 <MC_RunMotorControlTasks+0x12>
          MCP_ReceivedPacket(&MCP_Over_UartA);
 80015a2:	4628      	mov	r0, r5
 80015a4:	f000 fd5e 	bl	8002064 <MCP_ReceivedPacket>
          MCP_Over_UartA.pTransportLayer->fSendPacket(MCP_Over_UartA.pTransportLayer, MCP_Over_UartA.txBuffer,
 80015a8:	6828      	ldr	r0, [r5, #0]
 80015aa:	89ea      	ldrh	r2, [r5, #14]
 80015ac:	6846      	ldr	r6, [r0, #4]
 80015ae:	68a9      	ldr	r1, [r5, #8]
 80015b0:	230a      	movs	r3, #10
 80015b2:	47b0      	blx	r6
 80015b4:	e7f3      	b.n	800159e <MC_RunMotorControlTasks+0x5e>
 80015b6:	bf00      	nop
 80015b8:	200007fc 	.word	0x200007fc
 80015bc:	20000802 	.word	0x20000802
 80015c0:	20000800 	.word	0x20000800
 80015c4:	200007fe 	.word	0x200007fe
 80015c8:	200004c0 	.word	0x200004c0

080015cc <TSK_SetChargeBootCapDelayM1>:
  * @param  hTickCount number of ticks to be counted.
  * @retval void
  */
__weak void TSK_SetChargeBootCapDelayM1(uint16_t hTickCount)
{
   hBootCapDelayCounterM1 = hTickCount;
 80015cc:	4b01      	ldr	r3, [pc, #4]	@ (80015d4 <TSK_SetChargeBootCapDelayM1+0x8>)
 80015ce:	8018      	strh	r0, [r3, #0]
}
 80015d0:	4770      	bx	lr
 80015d2:	bf00      	nop
 80015d4:	20000800 	.word	0x20000800

080015d8 <TSK_ChargeBootCapDelayHasElapsedM1>:
  * @retval bool true if time has elapsed, false otherwise.
  */
__weak bool TSK_ChargeBootCapDelayHasElapsedM1(void)
{
  bool retVal = false;
  if (((uint16_t)0) == hBootCapDelayCounterM1)
 80015d8:	4b03      	ldr	r3, [pc, #12]	@ (80015e8 <TSK_ChargeBootCapDelayHasElapsedM1+0x10>)
 80015da:	8818      	ldrh	r0, [r3, #0]
 80015dc:	b280      	uxth	r0, r0
  {
    retVal = true;
  }
  return (retVal);
}
 80015de:	fab0 f080 	clz	r0, r0
 80015e2:	0940      	lsrs	r0, r0, #5
 80015e4:	4770      	bx	lr
 80015e6:	bf00      	nop
 80015e8:	20000800 	.word	0x20000800

080015ec <TSK_SetStopPermanencyTimeM1>:
  * @param  hTickCount number of ticks to be counted.
  * @retval void
  */
__weak void TSK_SetStopPermanencyTimeM1(uint16_t hTickCount)
{
  hStopPermanencyCounterM1 = hTickCount;
 80015ec:	4b01      	ldr	r3, [pc, #4]	@ (80015f4 <TSK_SetStopPermanencyTimeM1+0x8>)
 80015ee:	8018      	strh	r0, [r3, #0]
}
 80015f0:	4770      	bx	lr
 80015f2:	bf00      	nop
 80015f4:	200007fe 	.word	0x200007fe

080015f8 <TSK_StopPermanencyTimeHasElapsedM1>:
  * @retval bool true if time is elapsed, false otherwise.
  */
__weak bool TSK_StopPermanencyTimeHasElapsedM1(void)
{
  bool retVal = false;
  if (((uint16_t)0) == hStopPermanencyCounterM1)
 80015f8:	4b03      	ldr	r3, [pc, #12]	@ (8001608 <TSK_StopPermanencyTimeHasElapsedM1+0x10>)
 80015fa:	8818      	ldrh	r0, [r3, #0]
 80015fc:	b280      	uxth	r0, r0
  {
    retVal = true;
  }
  return (retVal);
}
 80015fe:	fab0 f080 	clz	r0, r0
 8001602:	0940      	lsrs	r0, r0, #5
 8001604:	4770      	bx	lr
 8001606:	bf00      	nop
 8001608:	200007fe 	.word	0x200007fe

0800160c <TSK_HighFrequencyTask>:
  * subsystem (see the state machine(s)).
  *
  * @retval Number of the  motor instance which FOC loop was executed.
  */
__weak uint8_t TSK_HighFrequencyTask(void)
{
 800160c:	b508      	push	{r3, lr}
  uint8_t bMotorNbr;
  bMotorNbr = 0;
  /* USER CODE BEGIN HighFrequencyTask 0 */

  /* USER CODE END HighFrequencyTask 0 */
  FOC_HighFrequencyTask(bMotorNbr);
 800160e:	2000      	movs	r0, #0
 8001610:	f000 fbc0 	bl	8001d94 <FOC_HighFrequencyTask>

  /* USER CODE BEGIN HighFrequencyTask 1 */

  /* USER CODE END HighFrequencyTask 1 */

  GLOBAL_TIMESTAMP++;
 8001614:	4a06      	ldr	r2, [pc, #24]	@ (8001630 <TSK_HighFrequencyTask+0x24>)
  if (0U == MCPA_UART_A.Mark)
 8001616:	4807      	ldr	r0, [pc, #28]	@ (8001634 <TSK_HighFrequencyTask+0x28>)
  GLOBAL_TIMESTAMP++;
 8001618:	6813      	ldr	r3, [r2, #0]
  if (0U == MCPA_UART_A.Mark)
 800161a:	f890 1029 	ldrb.w	r1, [r0, #41]	@ 0x29
  GLOBAL_TIMESTAMP++;
 800161e:	3301      	adds	r3, #1
 8001620:	6013      	str	r3, [r2, #0]
  if (0U == MCPA_UART_A.Mark)
 8001622:	b909      	cbnz	r1, 8001628 <TSK_HighFrequencyTask+0x1c>
    MCPA_dataLog (&MCPA_UART_A);
  }

  return (bMotorNbr);

}
 8001624:	2000      	movs	r0, #0
 8001626:	bd08      	pop	{r3, pc}
    MCPA_dataLog (&MCPA_UART_A);
 8001628:	f006 fce2 	bl	8007ff0 <MCPA_dataLog>
}
 800162c:	2000      	movs	r0, #0
 800162e:	bd08      	pop	{r3, pc}
 8001630:	20002794 	.word	0x20002794
 8001634:	20000494 	.word	0x20000494

08001638 <TSK_SafetyTask_PWMOFF>:
  * @brief  Safety task implementation if  MC.M1_ON_OVER_VOLTAGE == TURN_OFF_PWM.
  * @param  bMotor Motor reference number defined
  *         \link Motors_reference_number here \endlink.
  */
__weak void TSK_SafetyTask_PWMOFF(uint8_t bMotor)
{
 8001638:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /* USER CODE END TSK_SafetyTask_PWMOFF 0 */
  uint16_t CodeReturn = MC_NO_ERROR;
  uint8_t lbmotor = M1;
  const uint16_t errMask[NBR_OF_MOTORS] = {VBUS_TEMP_ERR_MASK};
  /* Check for fault if FW protection is activated. It returns MC_OVER_TEMP or MC_NO_ERROR */
  if (M1 == bMotor)
 800163a:	4604      	mov	r4, r0
 800163c:	b1a8      	cbz	r0, 800166a <TSK_SafetyTask_PWMOFF+0x32>
  {
    /* Nothing to do */
  }

/* Due to warning array subscript 1 is above array bounds of PWMC_Handle_t *[1] [-Warray-bounds] */
   CodeReturn |= PWMC_IsFaultOccurred(pwmcHandle[lbmotor]);     /* check for fault. It return MC_OVER_CURR or MC_NO_FAULTS
 800163e:	4e22      	ldr	r6, [pc, #136]	@ (80016c8 <TSK_SafetyTask_PWMOFF+0x90>)
 8001640:	6830      	ldr	r0, [r6, #0]
 8001642:	f000 ffe3 	bl	800260c <PWMC_IsFaultOccurred>
 8001646:	4601      	mov	r1, r0
  }
  else
  {
    /* Nothing to do */
  }
  MCI_FaultProcessing(&Mci[bMotor], CodeReturn, ~CodeReturn); /* Process faults */
 8001648:	4d20      	ldr	r5, [pc, #128]	@ (80016cc <TSK_SafetyTask_PWMOFF+0x94>)
 800164a:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 800164e:	eb04 0343 	add.w	r3, r4, r3, lsl #1
 8001652:	eb05 0583 	add.w	r5, r5, r3, lsl #2
 8001656:	43ca      	mvns	r2, r1
 8001658:	4628      	mov	r0, r5
 800165a:	b292      	uxth	r2, r2
 800165c:	f7ff fd1a 	bl	8001094 <MCI_FaultProcessing>

  if (MCI_GetFaultState(&Mci[bMotor]) != (uint32_t)MC_NO_FAULTS)
 8001660:	4628      	mov	r0, r5
 8001662:	f7ff fdc3 	bl	80011ec <MCI_GetFaultState>
 8001666:	b9d8      	cbnz	r0, 80016a0 <TSK_SafetyTask_PWMOFF+0x68>
    /* No errors */
  }
  /* USER CODE BEGIN TSK_SafetyTask_PWMOFF 3 */

  /* USER CODE END TSK_SafetyTask_PWMOFF 3 */
}
 8001668:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    uint16_t rawValueM1 = RCM_ExecRegularConv(&TempRegConv_M1);
 800166a:	4819      	ldr	r0, [pc, #100]	@ (80016d0 <TSK_SafetyTask_PWMOFF+0x98>)
   CodeReturn |= PWMC_IsFaultOccurred(pwmcHandle[lbmotor]);     /* check for fault. It return MC_OVER_CURR or MC_NO_FAULTS
 800166c:	4e16      	ldr	r6, [pc, #88]	@ (80016c8 <TSK_SafetyTask_PWMOFF+0x90>)
    uint16_t rawValueM1 = RCM_ExecRegularConv(&TempRegConv_M1);
 800166e:	f002 f94d 	bl	800390c <RCM_ExecRegularConv>
 8001672:	4601      	mov	r1, r0
    CodeReturn |= errMask[bMotor] & NTC_CalcAvTemp(&TempSensor_M1, rawValueM1);
 8001674:	4817      	ldr	r0, [pc, #92]	@ (80016d4 <TSK_SafetyTask_PWMOFF+0x9c>)
 8001676:	f006 fe4b 	bl	8008310 <NTC_CalcAvTemp>
 800167a:	4607      	mov	r7, r0
   CodeReturn |= PWMC_IsFaultOccurred(pwmcHandle[lbmotor]);     /* check for fault. It return MC_OVER_CURR or MC_NO_FAULTS
 800167c:	6830      	ldr	r0, [r6, #0]
 800167e:	f000 ffc5 	bl	800260c <PWMC_IsFaultOccurred>
 8001682:	4605      	mov	r5, r0
    uint16_t rawValueM1 =  RCM_ExecRegularConv(&VbusRegConv_M1);
 8001684:	4814      	ldr	r0, [pc, #80]	@ (80016d8 <TSK_SafetyTask_PWMOFF+0xa0>)
 8001686:	f002 f941 	bl	800390c <RCM_ExecRegularConv>
 800168a:	4601      	mov	r1, r0
    CodeReturn |= errMask[bMotor] & RVBS_CalcAvVbus(&BusVoltageSensor_M1, rawValueM1);
 800168c:	4813      	ldr	r0, [pc, #76]	@ (80016dc <TSK_SafetyTask_PWMOFF+0xa4>)
 800168e:	f007 fe8b 	bl	80093a8 <RVBS_CalcAvVbus>
 8001692:	4307      	orrs	r7, r0
 8001694:	f007 070e 	and.w	r7, r7, #14
 8001698:	ea45 0107 	orr.w	r1, r5, r7
 800169c:	b289      	uxth	r1, r1
 800169e:	e7d3      	b.n	8001648 <TSK_SafetyTask_PWMOFF+0x10>
    PWMC_SwitchOffPWM(pwmcHandle[bMotor]);
 80016a0:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
 80016a4:	f000 ff66 	bl	8002574 <PWMC_SwitchOffPWM>
    if (MCPA_UART_A.Mark != 0U)
 80016a8:	480d      	ldr	r0, [pc, #52]	@ (80016e0 <TSK_SafetyTask_PWMOFF+0xa8>)
 80016aa:	f890 3029 	ldrb.w	r3, [r0, #41]	@ 0x29
 80016ae:	b923      	cbnz	r3, 80016ba <TSK_SafetyTask_PWMOFF+0x82>
    FOC_Clear(bMotor);
 80016b0:	4620      	mov	r0, r4
}
 80016b2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    FOC_Clear(bMotor);
 80016b6:	f000 b8b9 	b.w	800182c <FOC_Clear>
      MCPA_flushDataLog (&MCPA_UART_A);
 80016ba:	f006 fd59 	bl	8008170 <MCPA_flushDataLog>
    FOC_Clear(bMotor);
 80016be:	4620      	mov	r0, r4
}
 80016c0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    FOC_Clear(bMotor);
 80016c4:	f000 b8b2 	b.w	800182c <FOC_Clear>
 80016c8:	200007ec 	.word	0x200007ec
 80016cc:	20000000 	.word	0x20000000
 80016d0:	2000042c 	.word	0x2000042c
 80016d4:	20000410 	.word	0x20000410
 80016d8:	20000400 	.word	0x20000400
 80016dc:	200003e4 	.word	0x200003e4
 80016e0:	20000494 	.word	0x20000494

080016e4 <TSK_SafetyTask>:
{
 80016e4:	b508      	push	{r3, lr}
  if (1U == bMCBootCompleted)
 80016e6:	4b06      	ldr	r3, [pc, #24]	@ (8001700 <TSK_SafetyTask+0x1c>)
 80016e8:	781b      	ldrb	r3, [r3, #0]
 80016ea:	2b01      	cmp	r3, #1
 80016ec:	d000      	beq.n	80016f0 <TSK_SafetyTask+0xc>
}
 80016ee:	bd08      	pop	{r3, pc}
    TSK_SafetyTask_PWMOFF(M1);
 80016f0:	2000      	movs	r0, #0
 80016f2:	f7ff ffa1 	bl	8001638 <TSK_SafetyTask_PWMOFF>
}
 80016f6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCM_ExecUserConv();
 80016fa:	f002 b9cf 	b.w	8003a9c <RCM_ExecUserConv>
 80016fe:	bf00      	nop
 8001700:	200007fc 	.word	0x200007fc

08001704 <TSK_HardwareFaultTask>:
  *
  *  This function is to be executed when a general hardware failure has been detected
  * by the microcontroller and is used to put the system in safety condition.
  */
__weak void TSK_HardwareFaultTask(void)
{
 8001704:	b508      	push	{r3, lr}
  /* USER CODE BEGIN TSK_HardwareFaultTask 0 */

  /* USER CODE END TSK_HardwareFaultTask 0 */
   FOC_Clear(M1);
 8001706:	2000      	movs	r0, #0
 8001708:	f000 f890 	bl	800182c <FOC_Clear>
  MCI_FaultProcessing(&Mci[M1], MC_SW_ERROR, 0);

  /* USER CODE BEGIN TSK_HardwareFaultTask 1 */

  /* USER CODE END TSK_HardwareFaultTask 1 */
}
 800170c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  MCI_FaultProcessing(&Mci[M1], MC_SW_ERROR, 0);
 8001710:	4802      	ldr	r0, [pc, #8]	@ (800171c <TSK_HardwareFaultTask+0x18>)
 8001712:	2200      	movs	r2, #0
 8001714:	2180      	movs	r1, #128	@ 0x80
 8001716:	f7ff bcbd 	b.w	8001094 <MCI_FaultProcessing>
 800171a:	bf00      	nop
 800171c:	20000000 	.word	0x20000000

08001720 <startMediumFrequencyTask>:

/* startMediumFrequencyTask function */
void startMediumFrequencyTask(void const * argument)
{
 8001720:	b508      	push	{r3, lr}
  /* USER CODE BEGIN MF task 1 */
  /* Infinite loop */
  for(;;)
  {
    /* Delay of 500us */
    vTaskDelay(1);
 8001722:	2001      	movs	r0, #1
 8001724:	f006 fabc 	bl	8007ca0 <vTaskDelay>
    MC_RunMotorControlTasks();
 8001728:	f7ff ff0a 	bl	8001540 <MC_RunMotorControlTasks>
  for(;;)
 800172c:	e7f9      	b.n	8001722 <startMediumFrequencyTask+0x2>
 800172e:	bf00      	nop

08001730 <StartSafetyTask>:
  /* USER CODE END MF task 1 */
}

/* startSafetyTask function */
void StartSafetyTask(void const * argument)
{
 8001730:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SF task 1 */
  /* Infinite loop */
  for(;;)
  {
    /* Delay of 500us */
    vTaskDelay(1);
 8001732:	2001      	movs	r0, #1
 8001734:	f006 fab4 	bl	8007ca0 <vTaskDelay>
    TSK_SafetyTask();
 8001738:	f7ff ffd4 	bl	80016e4 <TSK_SafetyTask>
  for(;;)
 800173c:	e7f9      	b.n	8001732 <StartSafetyTask+0x2>
 800173e:	bf00      	nop

08001740 <mc_lock_pins>:

 /**
  * @brief  Locks GPIO pins used for Motor Control to prevent accidental reconfiguration.
  */
__weak void mc_lock_pins (void)
{
 8001740:	b4f0      	push	{r4, r5, r6, r7}
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
{
  __IO uint32_t temp;
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8001742:	f04f 4390 	mov.w	r3, #1207959552	@ 0x48000000
 8001746:	4a32      	ldr	r2, [pc, #200]	@ (8001810 <mc_lock_pins+0xd0>)
 8001748:	61da      	str	r2, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 800174a:	f44f 7180 	mov.w	r1, #256	@ 0x100
 800174e:	61d9      	str	r1, [r3, #28]
 8001750:	b08c      	sub	sp, #48	@ 0x30
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8001752:	61da      	str	r2, [r3, #28]
  /* Read LCKR register. This read is mandatory to complete key lock sequence */
  temp = READ_REG(GPIOx->LCKR);
 8001754:	69da      	ldr	r2, [r3, #28]
 8001756:	920b      	str	r2, [sp, #44]	@ 0x2c
  WRITE_REG(GPIOx->LCKR, PinMask);
 8001758:	f44f 7100 	mov.w	r1, #512	@ 0x200
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 800175c:	f44f 3281 	mov.w	r2, #66048	@ 0x10200
  (void) temp;
 8001760:	980b      	ldr	r0, [sp, #44]	@ 0x2c
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8001762:	61da      	str	r2, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 8001764:	61d9      	str	r1, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8001766:	61da      	str	r2, [r3, #28]
  temp = READ_REG(GPIOx->LCKR);
 8001768:	69da      	ldr	r2, [r3, #28]
 800176a:	920a      	str	r2, [sp, #40]	@ 0x28
  WRITE_REG(GPIOx->LCKR, PinMask);
 800176c:	2140      	movs	r1, #64	@ 0x40
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 800176e:	4a29      	ldr	r2, [pc, #164]	@ (8001814 <mc_lock_pins+0xd4>)
  (void) temp;
 8001770:	980a      	ldr	r0, [sp, #40]	@ 0x28
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8001772:	61da      	str	r2, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 8001774:	61d9      	str	r1, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8001776:	61da      	str	r2, [r3, #28]
  temp = READ_REG(GPIOx->LCKR);
 8001778:	69d9      	ldr	r1, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 800177a:	4a27      	ldr	r2, [pc, #156]	@ (8001818 <mc_lock_pins+0xd8>)
  temp = READ_REG(GPIOx->LCKR);
 800177c:	9109      	str	r1, [sp, #36]	@ 0x24
  WRITE_REG(GPIOx->LCKR, PinMask);
 800177e:	2401      	movs	r4, #1
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8001780:	f04f 1101 	mov.w	r1, #65537	@ 0x10001
  (void) temp;
 8001784:	9809      	ldr	r0, [sp, #36]	@ 0x24
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8001786:	61d1      	str	r1, [r2, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 8001788:	61d4      	str	r4, [r2, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 800178a:	61d1      	str	r1, [r2, #28]
  temp = READ_REG(GPIOx->LCKR);
 800178c:	69d0      	ldr	r0, [r2, #28]
 800178e:	9008      	str	r0, [sp, #32]
  (void) temp;
 8001790:	9d08      	ldr	r5, [sp, #32]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8001792:	f44f 3082 	mov.w	r0, #66560	@ 0x10400
  WRITE_REG(GPIOx->LCKR, PinMask);
 8001796:	f44f 6580 	mov.w	r5, #1024	@ 0x400
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 800179a:	61d8      	str	r0, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 800179c:	61dd      	str	r5, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 800179e:	61d8      	str	r0, [r3, #28]
  temp = READ_REG(GPIOx->LCKR);
 80017a0:	69d8      	ldr	r0, [r3, #28]
 80017a2:	9007      	str	r0, [sp, #28]
  (void) temp;
 80017a4:	9d07      	ldr	r5, [sp, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80017a6:	481d      	ldr	r0, [pc, #116]	@ (800181c <mc_lock_pins+0xdc>)
 80017a8:	61d0      	str	r0, [r2, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 80017aa:	2502      	movs	r5, #2
 80017ac:	61d5      	str	r5, [r2, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80017ae:	61d0      	str	r0, [r2, #28]
  temp = READ_REG(GPIOx->LCKR);
 80017b0:	69d2      	ldr	r2, [r2, #28]
 80017b2:	9206      	str	r2, [sp, #24]
  (void) temp;
 80017b4:	9a06      	ldr	r2, [sp, #24]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80017b6:	4a1a      	ldr	r2, [pc, #104]	@ (8001820 <mc_lock_pins+0xe0>)
 80017b8:	61da      	str	r2, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 80017ba:	2680      	movs	r6, #128	@ 0x80
 80017bc:	61de      	str	r6, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80017be:	61da      	str	r2, [r3, #28]
  temp = READ_REG(GPIOx->LCKR);
 80017c0:	69da      	ldr	r2, [r3, #28]
 80017c2:	9205      	str	r2, [sp, #20]
  (void) temp;
 80017c4:	9a05      	ldr	r2, [sp, #20]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80017c6:	4a17      	ldr	r2, [pc, #92]	@ (8001824 <mc_lock_pins+0xe4>)
 80017c8:	4e17      	ldr	r6, [pc, #92]	@ (8001828 <mc_lock_pins+0xe8>)
 80017ca:	61d6      	str	r6, [r2, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 80017cc:	2704      	movs	r7, #4
 80017ce:	61d7      	str	r7, [r2, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80017d0:	61d6      	str	r6, [r2, #28]
  temp = READ_REG(GPIOx->LCKR);
 80017d2:	69d6      	ldr	r6, [r2, #28]
 80017d4:	9604      	str	r6, [sp, #16]
  (void) temp;
 80017d6:	9e04      	ldr	r6, [sp, #16]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80017d8:	61d0      	str	r0, [r2, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 80017da:	61d5      	str	r5, [r2, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80017dc:	61d0      	str	r0, [r2, #28]
  temp = READ_REG(GPIOx->LCKR);
 80017de:	69d6      	ldr	r6, [r2, #28]
 80017e0:	9603      	str	r6, [sp, #12]
  (void) temp;
 80017e2:	9e03      	ldr	r6, [sp, #12]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80017e4:	61d1      	str	r1, [r2, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 80017e6:	61d4      	str	r4, [r2, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80017e8:	61d1      	str	r1, [r2, #28]
  temp = READ_REG(GPIOx->LCKR);
 80017ea:	69d2      	ldr	r2, [r2, #28]
 80017ec:	9202      	str	r2, [sp, #8]
  (void) temp;
 80017ee:	9a02      	ldr	r2, [sp, #8]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80017f0:	61d8      	str	r0, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 80017f2:	61dd      	str	r5, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80017f4:	61d8      	str	r0, [r3, #28]
  temp = READ_REG(GPIOx->LCKR);
 80017f6:	69da      	ldr	r2, [r3, #28]
 80017f8:	9201      	str	r2, [sp, #4]
  (void) temp;
 80017fa:	9a01      	ldr	r2, [sp, #4]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80017fc:	61d9      	str	r1, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 80017fe:	61dc      	str	r4, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8001800:	61d9      	str	r1, [r3, #28]
  temp = READ_REG(GPIOx->LCKR);
 8001802:	69db      	ldr	r3, [r3, #28]
 8001804:	9300      	str	r3, [sp, #0]
  (void) temp;
 8001806:	9b00      	ldr	r3, [sp, #0]
LL_GPIO_LockPin(M1_TEMPERATURE_GPIO_Port, M1_TEMPERATURE_Pin);
LL_GPIO_LockPin(M1_CURR_AMPL_V_GPIO_Port, M1_CURR_AMPL_V_Pin);
LL_GPIO_LockPin(M1_CURR_AMPL_W_GPIO_Port, M1_CURR_AMPL_W_Pin);
LL_GPIO_LockPin(M1_BUS_VOLTAGE_GPIO_Port, M1_BUS_VOLTAGE_Pin);
LL_GPIO_LockPin(M1_CURR_AMPL_U_GPIO_Port, M1_CURR_AMPL_U_Pin);
}
 8001808:	b00c      	add	sp, #48	@ 0x30
 800180a:	bcf0      	pop	{r4, r5, r6, r7}
 800180c:	4770      	bx	lr
 800180e:	bf00      	nop
 8001810:	00010100 	.word	0x00010100
 8001814:	00010040 	.word	0x00010040
 8001818:	48000400 	.word	0x48000400
 800181c:	00010002 	.word	0x00010002
 8001820:	00010080 	.word	0x00010080
 8001824:	48000800 	.word	0x48000800
 8001828:	00010004 	.word	0x00010004

0800182c <FOC_Clear>:
  *         controller. It must be called before each motor restart.
  *         It does not clear speed sensor.
  * @param  bMotor related motor it can be M1 or M2.
  */
__weak void FOC_Clear(uint8_t bMotor)
{
 800182c:	b538      	push	{r3, r4, r5, lr}
 800182e:	4604      	mov	r4, r0
  /* USER CODE BEGIN FOC_Clear 0 */

  /* USER CODE END FOC_Clear 0 */
  MC_ControlMode_t mode;

  mode = MCI_GetControlMode( &Mci[bMotor] );
 8001830:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 8001834:	481e      	ldr	r0, [pc, #120]	@ (80018b0 <FOC_Clear+0x84>)
 8001836:	eb04 0343 	add.w	r3, r4, r3, lsl #1
 800183a:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 800183e:	f7ff fcdb 	bl	80011f8 <MCI_GetControlMode>
  ab_t NULL_ab = {((int16_t)0), ((int16_t)0)};
  qd_t NULL_qd = {((int16_t)0), ((int16_t)0)};
  alphabeta_t NULL_alphabeta = {((int16_t)0), ((int16_t)0)};

  FOCVars[bMotor].Iab = NULL_ab;
  FOCVars[bMotor].Ialphabeta = NULL_alphabeta;
 8001842:	2226      	movs	r2, #38	@ 0x26
  FOCVars[bMotor].Iqd = NULL_qd;
  if ( mode != MCM_OPEN_LOOP_VOLTAGE_MODE && mode != MCM_OPEN_LOOP_CURRENT_MODE)
 8001844:	3801      	subs	r0, #1
 8001846:	fb04 f202 	mul.w	r2, r4, r2
 800184a:	4b1a      	ldr	r3, [pc, #104]	@ (80018b4 <FOC_Clear+0x88>)
 800184c:	b2c0      	uxtb	r0, r0
 800184e:	2801      	cmp	r0, #1
  FOCVars[bMotor].Iab = NULL_ab;
 8001850:	f04f 0100 	mov.w	r1, #0
 8001854:	5099      	str	r1, [r3, r2]
 8001856:	eb03 0c02 	add.w	ip, r3, r2
  {
    FOCVars[bMotor].Iqdref = NULL_qd;
 800185a:	bf88      	it	hi
 800185c:	3210      	addhi	r2, #16
  FOCVars[bMotor].Iab = NULL_ab;
 800185e:	f8cc 1004 	str.w	r1, [ip, #4]
  FOCVars[bMotor].Iqd = NULL_qd;
 8001862:	f8cc 100c 	str.w	r1, [ip, #12]
    FOCVars[bMotor].Iqdref = NULL_qd;
 8001866:	bf88      	it	hi
 8001868:	5099      	strhi	r1, [r3, r2]
 800186a:	2126      	movs	r1, #38	@ 0x26
 800186c:	fb01 3304 	mla	r3, r1, r4, r3
  FOCVars[bMotor].hTeref = (int16_t)0;
  FOCVars[bMotor].Vqd = NULL_qd;
  FOCVars[bMotor].Valphabeta = NULL_alphabeta;
  FOCVars[bMotor].hElAngle = (int16_t)0;

  PID_SetIntegralTerm(pPIDIq[bMotor], ((int32_t)0));
 8001870:	4a11      	ldr	r2, [pc, #68]	@ (80018b8 <FOC_Clear+0x8c>)
  FOCVars[bMotor].Vqd = NULL_qd;
 8001872:	2500      	movs	r5, #0
  PID_SetIntegralTerm(pPIDIq[bMotor], ((int32_t)0));
 8001874:	f852 0024 	ldr.w	r0, [r2, r4, lsl #2]
  FOCVars[bMotor].Vqd = NULL_qd;
 8001878:	f8c3 5016 	str.w	r5, [r3, #22]
 800187c:	f8c3 501a 	str.w	r5, [r3, #26]
 8001880:	f8c3 501e 	str.w	r5, [r3, #30]
  PID_SetIntegralTerm(pPIDIq[bMotor], ((int32_t)0));
 8001884:	4629      	mov	r1, r5
 8001886:	f006 fd9b 	bl	80083c0 <PID_SetIntegralTerm>
  PID_SetIntegralTerm(pPIDId[bMotor], ((int32_t)0));
 800188a:	4b0c      	ldr	r3, [pc, #48]	@ (80018bc <FOC_Clear+0x90>)
 800188c:	4629      	mov	r1, r5
 800188e:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 8001892:	f006 fd95 	bl	80083c0 <PID_SetIntegralTerm>

  STC_Clear(pSTC[bMotor]);
 8001896:	4b0a      	ldr	r3, [pc, #40]	@ (80018c0 <FOC_Clear+0x94>)
 8001898:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 800189c:	f007 ff6a 	bl	8009774 <STC_Clear>

  PWMC_SwitchOffPWM(pwmcHandle[bMotor]);
 80018a0:	4b08      	ldr	r3, [pc, #32]	@ (80018c4 <FOC_Clear+0x98>)
 80018a2:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]

  /* USER CODE BEGIN FOC_Clear 1 */

  /* USER CODE END FOC_Clear 1 */
}
 80018a6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  PWMC_SwitchOffPWM(pwmcHandle[bMotor]);
 80018aa:	f000 be63 	b.w	8002574 <PWMC_SwitchOffPWM>
 80018ae:	bf00      	nop
 80018b0:	20000000 	.word	0x20000000
 80018b4:	200007c4 	.word	0x200007c4
 80018b8:	20000034 	.word	0x20000034
 80018bc:	20000030 	.word	0x20000030
 80018c0:	20000038 	.word	0x20000038
 80018c4:	200007ec 	.word	0x200007ec

080018c8 <FOC_Init>:
{
 80018c8:	b5f0      	push	{r4, r5, r6, r7, lr}
    pwmcHandle[M1] = &PWM_Handle_M1._Super;
 80018ca:	4d2c      	ldr	r5, [pc, #176]	@ (800197c <FOC_Init+0xb4>)
    PID_HandleInit(&PIDSpeedHandle_M1);
 80018cc:	4e2c      	ldr	r6, [pc, #176]	@ (8001980 <FOC_Init+0xb8>)
    pwmcHandle[M1] = &PWM_Handle_M1._Super;
 80018ce:	482d      	ldr	r0, [pc, #180]	@ (8001984 <FOC_Init+0xbc>)
    STO_CR_Init (&STO_CR_M1);
 80018d0:	4f2d      	ldr	r7, [pc, #180]	@ (8001988 <FOC_Init+0xc0>)
    STC_Init(pSTC[M1],&PIDSpeedHandle_M1, &STO_CR_M1._Super);
 80018d2:	4c2e      	ldr	r4, [pc, #184]	@ (800198c <FOC_Init+0xc4>)
    pwmcHandle[M1] = &PWM_Handle_M1._Super;
 80018d4:	6028      	str	r0, [r5, #0]
{
 80018d6:	b085      	sub	sp, #20
    R3_1_Init(&PWM_Handle_M1);
 80018d8:	f007 f8de 	bl	8008a98 <R3_1_Init>
    startTimers();
 80018dc:	f000 fc96 	bl	800220c <startTimers>
    PID_HandleInit(&PIDSpeedHandle_M1);
 80018e0:	4630      	mov	r0, r6
 80018e2:	f006 fd59 	bl	8008398 <PID_HandleInit>
    STO_CR_Init (&STO_CR_M1);
 80018e6:	4638      	mov	r0, r7
 80018e8:	f008 f9f4 	bl	8009cd4 <STO_CR_Init>
    STC_Init(pSTC[M1],&PIDSpeedHandle_M1, &STO_CR_M1._Super);
 80018ec:	6820      	ldr	r0, [r4, #0]
 80018ee:	463a      	mov	r2, r7
 80018f0:	4631      	mov	r1, r6
 80018f2:	f007 ff27 	bl	8009744 <STC_Init>
    RUC_Init(&RevUpControlM1, pSTC[M1], &VirtualSpeedSensorM1, &STO_M1, pwmcHandle[M1]);
 80018f6:	4f26      	ldr	r7, [pc, #152]	@ (8001990 <FOC_Init+0xc8>)
 80018f8:	6829      	ldr	r1, [r5, #0]
 80018fa:	9100      	str	r1, [sp, #0]
 80018fc:	6821      	ldr	r1, [r4, #0]
 80018fe:	4b25      	ldr	r3, [pc, #148]	@ (8001994 <FOC_Init+0xcc>)
 8001900:	4825      	ldr	r0, [pc, #148]	@ (8001998 <FOC_Init+0xd0>)
    OL_Init(&OpenLoop_ParamsM1, &VirtualSpeedSensorM1);     /* Only if M1 has open loop */
 8001902:	4e26      	ldr	r6, [pc, #152]	@ (800199c <FOC_Init+0xd4>)
    pMPM[M1]->pFOCVars = &FOCVars[M1];
 8001904:	4d26      	ldr	r5, [pc, #152]	@ (80019a0 <FOC_Init+0xd8>)
    RUC_Init(&RevUpControlM1, pSTC[M1], &VirtualSpeedSensorM1, &STO_M1, pwmcHandle[M1]);
 8001906:	463a      	mov	r2, r7
 8001908:	f007 fe0e 	bl	8009528 <RUC_Init>
    PID_HandleInit(&PIDIqHandle_M1);
 800190c:	4825      	ldr	r0, [pc, #148]	@ (80019a4 <FOC_Init+0xdc>)
 800190e:	f006 fd43 	bl	8008398 <PID_HandleInit>
    PID_HandleInit(&PIDIdHandle_M1);
 8001912:	4825      	ldr	r0, [pc, #148]	@ (80019a8 <FOC_Init+0xe0>)
 8001914:	f006 fd40 	bl	8008398 <PID_HandleInit>
    pMPM[M1]->pVBS = &(BusVoltageSensor_M1._Super);
 8001918:	4b24      	ldr	r3, [pc, #144]	@ (80019ac <FOC_Init+0xe4>)
 800191a:	4a25      	ldr	r2, [pc, #148]	@ (80019b0 <FOC_Init+0xe8>)
 800191c:	681b      	ldr	r3, [r3, #0]
    OL_Init(&OpenLoop_ParamsM1, &VirtualSpeedSensorM1);     /* Only if M1 has open loop */
 800191e:	4639      	mov	r1, r7
    pMPM[M1]->pVBS = &(BusVoltageSensor_M1._Super);
 8001920:	60da      	str	r2, [r3, #12]
    pMPM[M1]->pFOCVars = &FOCVars[M1];
 8001922:	609d      	str	r5, [r3, #8]
    OL_Init(&OpenLoop_ParamsM1, &VirtualSpeedSensorM1);     /* Only if M1 has open loop */
 8001924:	4630      	mov	r0, r6
 8001926:	f006 fd1d 	bl	8008364 <OL_Init>
    pOpenLoop[M1] = &OpenLoop_ParamsM1;
 800192a:	4a22      	ldr	r2, [pc, #136]	@ (80019b4 <FOC_Init+0xec>)
    pREMNG[M1] = &RampExtMngrHFParamsM1;
 800192c:	4822      	ldr	r0, [pc, #136]	@ (80019b8 <FOC_Init+0xf0>)
    pOpenLoop[M1] = &OpenLoop_ParamsM1;
 800192e:	6016      	str	r6, [r2, #0]
    pREMNG[M1] = &RampExtMngrHFParamsM1;
 8001930:	4a22      	ldr	r2, [pc, #136]	@ (80019bc <FOC_Init+0xf4>)
    MCI_SetSpeedMode(&Mci[M1]);
 8001932:	4e23      	ldr	r6, [pc, #140]	@ (80019c0 <FOC_Init+0xf8>)
    pREMNG[M1] = &RampExtMngrHFParamsM1;
 8001934:	6010      	str	r0, [r2, #0]
    REMNG_Init(pREMNG[M1]);
 8001936:	f007 fd65 	bl	8009404 <REMNG_Init>
    FOC_Clear(M1);
 800193a:	2000      	movs	r0, #0
 800193c:	f7ff ff76 	bl	800182c <FOC_Clear>
    FOCVars[M1].bDriveInput = EXTERNAL;
 8001940:	2301      	movs	r3, #1
    FOCVars[M1].Iqdref = STC_GetDefaultIqdref(pSTC[M1]);
 8001942:	6820      	ldr	r0, [r4, #0]
    FOCVars[M1].bDriveInput = EXTERNAL;
 8001944:	f885 3024 	strb.w	r3, [r5, #36]	@ 0x24
    FOCVars[M1].Iqdref = STC_GetDefaultIqdref(pSTC[M1]);
 8001948:	f007 ffa6 	bl	8009898 <STC_GetDefaultIqdref>
 800194c:	f3c0 430f 	ubfx	r3, r0, #16, #16
 8001950:	8228      	strh	r0, [r5, #16]
    FOCVars[M1].UserIdref = STC_GetDefaultIqdref(pSTC[M1]).d;
 8001952:	6820      	ldr	r0, [r4, #0]
    FOCVars[M1].Iqdref = STC_GetDefaultIqdref(pSTC[M1]);
 8001954:	826b      	strh	r3, [r5, #18]
    FOCVars[M1].UserIdref = STC_GetDefaultIqdref(pSTC[M1]).d;
 8001956:	f007 ff9f 	bl	8009898 <STC_GetDefaultIqdref>
 800195a:	f3c0 400f 	ubfx	r0, r0, #16, #16
 800195e:	82a8      	strh	r0, [r5, #20]
    MCI_SetSpeedMode(&Mci[M1]);
 8001960:	4630      	mov	r0, r6
 8001962:	f7ff fb6d 	bl	8001040 <MCI_SetSpeedMode>
    MCI_ExecSpeedRamp(&Mci[M1],
 8001966:	6820      	ldr	r0, [r4, #0]
 8001968:	f007 ff92 	bl	8009890 <STC_GetMecSpeedRefUnitDefault>
 800196c:	2200      	movs	r2, #0
 800196e:	4601      	mov	r1, r0
 8001970:	4630      	mov	r0, r6
}
 8001972:	b005      	add	sp, #20
 8001974:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    MCI_ExecSpeedRamp(&Mci[M1],
 8001978:	f7ff bb50 	b.w	800101c <MCI_ExecSpeedRamp>
 800197c:	200007ec 	.word	0x200007ec
 8001980:	200003a8 	.word	0x200003a8
 8001984:	20000200 	.word	0x20000200
 8001988:	2000007c 	.word	0x2000007c
 800198c:	20000038 	.word	0x20000038
 8001990:	2000043c 	.word	0x2000043c
 8001994:	20000068 	.word	0x20000068
 8001998:	200002a4 	.word	0x200002a4
 800199c:	20000058 	.word	0x20000058
 80019a0:	200007c4 	.word	0x200007c4
 80019a4:	2000037c 	.word	0x2000037c
 80019a8:	20000350 	.word	0x20000350
 80019ac:	2000002c 	.word	0x2000002c
 80019b0:	200003e4 	.word	0x200003e4
 80019b4:	20000804 	.word	0x20000804
 80019b8:	20000040 	.word	0x20000040
 80019bc:	200007c0 	.word	0x200007c0
 80019c0:	20000000 	.word	0x20000000

080019c4 <FOC_InitAdditionalMethods>:
    {
  /* USER CODE BEGIN FOC_InitAdditionalMethods 0 */

  /* USER CODE END FOC_InitAdditionalMethods 0 */
    }
}
 80019c4:	4770      	bx	lr
 80019c6:	bf00      	nop

080019c8 <FOC_CalcCurrRef>:
  *         MTPA algorithm(s). It must be called with the periodicity specified
  *         in oTSC parameters.
  * @param  bMotor related motor it can be M1 or M2.
  */
__weak void FOC_CalcCurrRef(uint8_t bMotor)
{
 80019c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80019cc:	4604      	mov	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
 80019ce:	b672      	cpsid	i

  /* Enter critical section */
  /* Disable interrupts to avoid any interruption during Iqd reference latching */
  /* to avoid MF task writing them while HF task reading them */
  __disable_irq();
  IqdTmp = FOCVars[bMotor].Iqdref;
 80019d0:	4e15      	ldr	r6, [pc, #84]	@ (8001a28 <FOC_CalcCurrRef+0x60>)
 80019d2:	2526      	movs	r5, #38	@ 0x26
 80019d4:	fb05 6500 	mla	r5, r5, r0, r6
 80019d8:	f9b5 8010 	ldrsh.w	r8, [r5, #16]
 80019dc:	f9b5 7012 	ldrsh.w	r7, [r5, #18]
  __ASM volatile ("cpsie i" : : : "memory");
 80019e0:	b662      	cpsie	i
  /* USER CODE BEGIN FOC_CalcCurrRef 0 */

  /* USER CODE END FOC_CalcCurrRef 0 */
  MC_ControlMode_t mode;

  mode = MCI_GetControlMode( &Mci[bMotor] );
 80019e2:	4812      	ldr	r0, [pc, #72]	@ (8001a2c <FOC_CalcCurrRef+0x64>)
 80019e4:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 80019e8:	eb04 0343 	add.w	r3, r4, r3, lsl #1
 80019ec:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 80019f0:	f7ff fc02 	bl	80011f8 <MCI_GetControlMode>
  if (INTERNAL == FOCVars[bMotor].bDriveInput
 80019f4:	f895 3024 	ldrb.w	r3, [r5, #36]	@ 0x24
 80019f8:	b91b      	cbnz	r3, 8001a02 <FOC_CalcCurrRef+0x3a>
               && (mode != MCM_OPEN_LOOP_VOLTAGE_MODE && mode != MCM_OPEN_LOOP_CURRENT_MODE))
 80019fa:	3801      	subs	r0, #1
 80019fc:	b2c3      	uxtb	r3, r0
 80019fe:	2b01      	cmp	r3, #1
 8001a00:	d809      	bhi.n	8001a16 <FOC_CalcCurrRef+0x4e>
  __ASM volatile ("cpsid i" : : : "memory");
 8001a02:	b672      	cpsid	i
  }

  /* Enter critical section */
  /* Disable interrupts to avoid any interruption during Iqd reference restoring */
  __disable_irq();
  FOCVars[bMotor].Iqdref = IqdTmp;
 8001a04:	2326      	movs	r3, #38	@ 0x26
 8001a06:	fb03 6604 	mla	r6, r3, r4, r6
 8001a0a:	f8a6 8010 	strh.w	r8, [r6, #16]
 8001a0e:	8277      	strh	r7, [r6, #18]
  __ASM volatile ("cpsie i" : : : "memory");
 8001a10:	b662      	cpsie	i
  /* Exit critical section */
  __enable_irq();
  /* USER CODE BEGIN FOC_CalcCurrRef 1 */

  /* USER CODE END FOC_CalcCurrRef 1 */
}
 8001a12:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    FOCVars[bMotor].hTeref = STC_CalcTorqueReference(pSTC[bMotor]);
 8001a16:	4b06      	ldr	r3, [pc, #24]	@ (8001a30 <FOC_CalcCurrRef+0x68>)
 8001a18:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 8001a1c:	f007 ff02 	bl	8009824 <STC_CalcTorqueReference>
 8001a20:	4680      	mov	r8, r0
 8001a22:	83e8      	strh	r0, [r5, #30]
    IqdTmp.q = FOCVars[bMotor].hTeref;
 8001a24:	e7ed      	b.n	8001a02 <FOC_CalcCurrRef+0x3a>
 8001a26:	bf00      	nop
 8001a28:	200007c4 	.word	0x200007c4
 8001a2c:	20000000 	.word	0x20000000
 8001a30:	20000038 	.word	0x20000038

08001a34 <TSK_MediumFrequencyTaskM1>:
{
 8001a34:	b5f0      	push	{r4, r5, r6, r7, lr}
  mode = MCI_GetControlMode(&Mci[M1]);
 8001a36:	4cc0      	ldr	r4, [pc, #768]	@ (8001d38 <TSK_MediumFrequencyTaskM1+0x304>)
{
 8001a38:	b083      	sub	sp, #12
  int16_t wAux = 0;
 8001a3a:	2300      	movs	r3, #0
  mode = MCI_GetControlMode(&Mci[M1]);
 8001a3c:	4620      	mov	r0, r4
  int16_t wAux = 0;
 8001a3e:	f8ad 3000 	strh.w	r3, [sp]
  mode = MCI_GetControlMode(&Mci[M1]);
 8001a42:	f7ff fbd9 	bl	80011f8 <MCI_GetControlMode>
  bool IsSpeedReliable = STO_CR_CalcAvrgMecSpeedUnit(&STO_CR_M1, &wAux);
 8001a46:	4669      	mov	r1, sp
  mode = MCI_GetControlMode(&Mci[M1]);
 8001a48:	4605      	mov	r5, r0
  bool IsSpeedReliable = STO_CR_CalcAvrgMecSpeedUnit(&STO_CR_M1, &wAux);
 8001a4a:	48bc      	ldr	r0, [pc, #752]	@ (8001d3c <TSK_MediumFrequencyTaskM1+0x308>)
 8001a4c:	f008 f876 	bl	8009b3c <STO_CR_CalcAvrgMecSpeedUnit>
  PQD_CalcElMotorPower(pMPM[M1]);
 8001a50:	4bbb      	ldr	r3, [pc, #748]	@ (8001d40 <TSK_MediumFrequencyTaskM1+0x30c>)
  bool IsSpeedReliable = STO_CR_CalcAvrgMecSpeedUnit(&STO_CR_M1, &wAux);
 8001a52:	4606      	mov	r6, r0
  PQD_CalcElMotorPower(pMPM[M1]);
 8001a54:	6818      	ldr	r0, [r3, #0]
 8001a56:	f006 fd27 	bl	80084a8 <PQD_CalcElMotorPower>
  if (MCI_GetCurrentFaults(&Mci[M1]) == MC_NO_FAULTS)
 8001a5a:	4620      	mov	r0, r4
 8001a5c:	f7ff fb7c 	bl	8001158 <MCI_GetCurrentFaults>
 8001a60:	b120      	cbz	r0, 8001a6c <TSK_MediumFrequencyTaskM1+0x38>
    Mci[M1].State = FAULT_NOW;
 8001a62:	230a      	movs	r3, #10
 8001a64:	f884 3023 	strb.w	r3, [r4, #35]	@ 0x23
}
 8001a68:	b003      	add	sp, #12
 8001a6a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (MCI_GetOccurredFaults(&Mci[M1]) == MC_NO_FAULTS)
 8001a6c:	4620      	mov	r0, r4
 8001a6e:	f7ff fb71 	bl	8001154 <MCI_GetOccurredFaults>
 8001a72:	bb78      	cbnz	r0, 8001ad4 <TSK_MediumFrequencyTaskM1+0xa0>
      switch (Mci[M1].State)
 8001a74:	f894 3023 	ldrb.w	r3, [r4, #35]	@ 0x23
 8001a78:	2b13      	cmp	r3, #19
 8001a7a:	d8f5      	bhi.n	8001a68 <TSK_MediumFrequencyTaskM1+0x34>
 8001a7c:	a201      	add	r2, pc, #4	@ (adr r2, 8001a84 <TSK_MediumFrequencyTaskM1+0x50>)
 8001a7e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8001a82:	bf00      	nop
 8001a84:	08001c71 	.word	0x08001c71
 8001a88:	08001a69 	.word	0x08001a69
 8001a8c:	08001a69 	.word	0x08001a69
 8001a90:	08001a69 	.word	0x08001a69
 8001a94:	08001be9 	.word	0x08001be9
 8001a98:	08001a69 	.word	0x08001a69
 8001a9c:	08001bb9 	.word	0x08001bb9
 8001aa0:	08001a69 	.word	0x08001a69
 8001aa4:	08001b99 	.word	0x08001b99
 8001aa8:	08001a69 	.word	0x08001a69
 8001aac:	08001ad5 	.word	0x08001ad5
 8001ab0:	08001b89 	.word	0x08001b89
 8001ab4:	08001a69 	.word	0x08001a69
 8001ab8:	08001a69 	.word	0x08001a69
 8001abc:	08001a69 	.word	0x08001a69
 8001ac0:	08001a69 	.word	0x08001a69
 8001ac4:	08001b39 	.word	0x08001b39
 8001ac8:	08001b01 	.word	0x08001b01
 8001acc:	08001a69 	.word	0x08001a69
 8001ad0:	08001adf 	.word	0x08001adf
      Mci[M1].State = FAULT_OVER;
 8001ad4:	230b      	movs	r3, #11
 8001ad6:	f884 3023 	strb.w	r3, [r4, #35]	@ 0x23
}
 8001ada:	b003      	add	sp, #12
 8001adc:	bdf0      	pop	{r4, r5, r6, r7, pc}
          if (MCI_STOP == Mci[M1].DirectCommand)
 8001ade:	f894 3022 	ldrb.w	r3, [r4, #34]	@ 0x22
 8001ae2:	2b05      	cmp	r3, #5
 8001ae4:	f000 80e2 	beq.w	8001cac <TSK_MediumFrequencyTaskM1+0x278>
            if (! RUC_Exec(&RevUpControlM1))
 8001ae8:	4896      	ldr	r0, [pc, #600]	@ (8001d44 <TSK_MediumFrequencyTaskM1+0x310>)
 8001aea:	f007 fda7 	bl	800963c <RUC_Exec>
 8001aee:	4602      	mov	r2, r0
 8001af0:	2800      	cmp	r0, #0
 8001af2:	f040 80ea 	bne.w	8001cca <TSK_MediumFrequencyTaskM1+0x296>
              MCI_FaultProcessing(&Mci[M1], MC_START_UP, 0);
 8001af6:	4890      	ldr	r0, [pc, #576]	@ (8001d38 <TSK_MediumFrequencyTaskM1+0x304>)
 8001af8:	2110      	movs	r1, #16
 8001afa:	f7ff facb 	bl	8001094 <MCI_FaultProcessing>
 8001afe:	e7b3      	b.n	8001a68 <TSK_MediumFrequencyTaskM1+0x34>
          if (MCI_STOP == Mci[M1].DirectCommand)
 8001b00:	f894 3022 	ldrb.w	r3, [r4, #34]	@ 0x22
    R3_1_SwitchOffPWM(pwmcHandle[motor]);
 8001b04:	4d90      	ldr	r5, [pc, #576]	@ (8001d48 <TSK_MediumFrequencyTaskM1+0x314>)
          if (MCI_STOP == Mci[M1].DirectCommand)
 8001b06:	2b05      	cmp	r3, #5
    R3_1_SwitchOffPWM(pwmcHandle[motor]);
 8001b08:	6828      	ldr	r0, [r5, #0]
          if (MCI_STOP == Mci[M1].DirectCommand)
 8001b0a:	f000 80d1 	beq.w	8001cb0 <TSK_MediumFrequencyTaskM1+0x27c>
            if (PWMC_CurrentReadingCalibr(pwmcHandle[M1], CRC_EXEC))
 8001b0e:	2101      	movs	r1, #1
 8001b10:	f000 fd34 	bl	800257c <PWMC_CurrentReadingCalibr>
 8001b14:	2800      	cmp	r0, #0
 8001b16:	d0a7      	beq.n	8001a68 <TSK_MediumFrequencyTaskM1+0x34>
              if (MCI_MEASURE_OFFSETS == Mci[M1].DirectCommand)
 8001b18:	f894 3022 	ldrb.w	r3, [r4, #34]	@ 0x22
 8001b1c:	2b03      	cmp	r3, #3
 8001b1e:	f000 812e 	beq.w	8001d7e <TSK_MediumFrequencyTaskM1+0x34a>
                R3_1_TurnOnLowSides(pwmcHandle[M1],M1_CHARGE_BOOT_CAP_DUTY_CYCLES);
 8001b22:	6828      	ldr	r0, [r5, #0]
 8001b24:	2100      	movs	r1, #0
 8001b26:	f006 ff19 	bl	800895c <R3_1_TurnOnLowSides>
                TSK_SetChargeBootCapDelayM1(M1_CHARGE_BOOT_CAP_TICKS);
 8001b2a:	2014      	movs	r0, #20
 8001b2c:	f7ff fd4e 	bl	80015cc <TSK_SetChargeBootCapDelayM1>
                Mci[M1].State = CHARGE_BOOT_CAP;
 8001b30:	2310      	movs	r3, #16
 8001b32:	f884 3023 	strb.w	r3, [r4, #35]	@ 0x23
 8001b36:	e797      	b.n	8001a68 <TSK_MediumFrequencyTaskM1+0x34>
          if (MCI_STOP == Mci[M1].DirectCommand)
 8001b38:	f894 3022 	ldrb.w	r3, [r4, #34]	@ 0x22
 8001b3c:	2b05      	cmp	r3, #5
 8001b3e:	f000 80b5 	beq.w	8001cac <TSK_MediumFrequencyTaskM1+0x278>
            if (TSK_ChargeBootCapDelayHasElapsedM1())
 8001b42:	f7ff fd49 	bl	80015d8 <TSK_ChargeBootCapDelayHasElapsedM1>
 8001b46:	2800      	cmp	r0, #0
 8001b48:	d08e      	beq.n	8001a68 <TSK_MediumFrequencyTaskM1+0x34>
              R3_1_SwitchOffPWM(pwmcHandle[M1]);
 8001b4a:	4e7f      	ldr	r6, [pc, #508]	@ (8001d48 <TSK_MediumFrequencyTaskM1+0x314>)
 8001b4c:	6830      	ldr	r0, [r6, #0]
 8001b4e:	f006 fe55 	bl	80087fc <R3_1_SwitchOffPWM>
              FOCVars[M1].bDriveInput = EXTERNAL;
 8001b52:	4b7e      	ldr	r3, [pc, #504]	@ (8001d4c <TSK_MediumFrequencyTaskM1+0x318>)
              STC_SetSpeedSensor( pSTC[M1], &VirtualSpeedSensorM1._Super );
 8001b54:	497e      	ldr	r1, [pc, #504]	@ (8001d50 <TSK_MediumFrequencyTaskM1+0x31c>)
              FOCVars[M1].bDriveInput = EXTERNAL;
 8001b56:	2201      	movs	r2, #1
 8001b58:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
              STC_SetSpeedSensor( pSTC[M1], &VirtualSpeedSensorM1._Super );
 8001b5c:	4b7d      	ldr	r3, [pc, #500]	@ (8001d54 <TSK_MediumFrequencyTaskM1+0x320>)
 8001b5e:	6818      	ldr	r0, [r3, #0]
 8001b60:	f007 fe06 	bl	8009770 <STC_SetSpeedSensor>
              STO_CR_Clear(&STO_CR_M1);
 8001b64:	4875      	ldr	r0, [pc, #468]	@ (8001d3c <TSK_MediumFrequencyTaskM1+0x308>)
 8001b66:	f008 f889 	bl	8009c7c <STO_CR_Clear>
              FOC_Clear( M1 );
 8001b6a:	2000      	movs	r0, #0
 8001b6c:	f7ff fe5e 	bl	800182c <FOC_Clear>
              if (MCM_OPEN_LOOP_VOLTAGE_MODE == mode || MCM_OPEN_LOOP_CURRENT_MODE == mode)
 8001b70:	1e6b      	subs	r3, r5, #1
 8001b72:	b2db      	uxtb	r3, r3
                Mci[M1].State = RUN;
 8001b74:	2b01      	cmp	r3, #1
 8001b76:	bf8c      	ite	hi
 8001b78:	2304      	movhi	r3, #4
 8001b7a:	2306      	movls	r3, #6
              PWMC_SwitchOnPWM(pwmcHandle[M1]);
 8001b7c:	6830      	ldr	r0, [r6, #0]
 8001b7e:	f884 3023 	strb.w	r3, [r4, #35]	@ 0x23
 8001b82:	f000 fcf9 	bl	8002578 <PWMC_SwitchOnPWM>
 8001b86:	e76f      	b.n	8001a68 <TSK_MediumFrequencyTaskM1+0x34>
          if (MCI_ACK_FAULTS == Mci[M1].DirectCommand)
 8001b88:	f894 3022 	ldrb.w	r3, [r4, #34]	@ 0x22
 8001b8c:	2b02      	cmp	r3, #2
 8001b8e:	f47f af6b 	bne.w	8001a68 <TSK_MediumFrequencyTaskM1+0x34>
            Mci[M1].DirectCommand = MCI_NO_COMMAND;
 8001b92:	2300      	movs	r3, #0
 8001b94:	8463      	strh	r3, [r4, #34]	@ 0x22
 8001b96:	e767      	b.n	8001a68 <TSK_MediumFrequencyTaskM1+0x34>
          if (TSK_StopPermanencyTimeHasElapsedM1())
 8001b98:	f7ff fd2e 	bl	80015f8 <TSK_StopPermanencyTimeHasElapsedM1>
 8001b9c:	2800      	cmp	r0, #0
 8001b9e:	f43f af63 	beq.w	8001a68 <TSK_MediumFrequencyTaskM1+0x34>
            STC_SetSpeedSensor(pSTC[M1], &VirtualSpeedSensorM1._Super);    /* Sensor-less */
 8001ba2:	4b6c      	ldr	r3, [pc, #432]	@ (8001d54 <TSK_MediumFrequencyTaskM1+0x320>)
 8001ba4:	496a      	ldr	r1, [pc, #424]	@ (8001d50 <TSK_MediumFrequencyTaskM1+0x31c>)
 8001ba6:	6818      	ldr	r0, [r3, #0]
 8001ba8:	f007 fde2 	bl	8009770 <STC_SetSpeedSensor>
            VSS_Clear(&VirtualSpeedSensorM1); /* Reset measured speed in IDLE */
 8001bac:	4868      	ldr	r0, [pc, #416]	@ (8001d50 <TSK_MediumFrequencyTaskM1+0x31c>)
 8001bae:	f008 f995 	bl	8009edc <VSS_Clear>
            Mci[M1].DirectCommand = MCI_NO_COMMAND;
 8001bb2:	2300      	movs	r3, #0
 8001bb4:	8463      	strh	r3, [r4, #34]	@ 0x22
 8001bb6:	e757      	b.n	8001a68 <TSK_MediumFrequencyTaskM1+0x34>
          if (MCI_STOP == Mci[M1].DirectCommand)
 8001bb8:	f894 3022 	ldrb.w	r3, [r4, #34]	@ 0x22
 8001bbc:	2b05      	cmp	r3, #5
 8001bbe:	d075      	beq.n	8001cac <TSK_MediumFrequencyTaskM1+0x278>
            MCI_ExecBufferedCommands(&Mci[M1]);
 8001bc0:	485d      	ldr	r0, [pc, #372]	@ (8001d38 <TSK_MediumFrequencyTaskM1+0x304>)
 8001bc2:	f7ff fa73 	bl	80010ac <MCI_ExecBufferedCommands>
            if (mode != MCM_OPEN_LOOP_VOLTAGE_MODE && mode != MCM_OPEN_LOOP_CURRENT_MODE)
 8001bc6:	1e6b      	subs	r3, r5, #1
 8001bc8:	b2db      	uxtb	r3, r3
 8001bca:	2b01      	cmp	r3, #1
 8001bcc:	f240 80ce 	bls.w	8001d6c <TSK_MediumFrequencyTaskM1+0x338>
              FOC_CalcCurrRef(M1);
 8001bd0:	2000      	movs	r0, #0
 8001bd2:	f7ff fef9 	bl	80019c8 <FOC_CalcCurrRef>
              if(!IsSpeedReliable)
 8001bd6:	2e00      	cmp	r6, #0
 8001bd8:	f47f af46 	bne.w	8001a68 <TSK_MediumFrequencyTaskM1+0x34>
                MCI_FaultProcessing(&Mci[M1], MC_SPEED_FDBK, 0);
 8001bdc:	4856      	ldr	r0, [pc, #344]	@ (8001d38 <TSK_MediumFrequencyTaskM1+0x304>)
 8001bde:	4632      	mov	r2, r6
 8001be0:	2120      	movs	r1, #32
 8001be2:	f7ff fa57 	bl	8001094 <MCI_FaultProcessing>
 8001be6:	e73f      	b.n	8001a68 <TSK_MediumFrequencyTaskM1+0x34>
          if (MCI_STOP == Mci[M1].DirectCommand)
 8001be8:	f894 3022 	ldrb.w	r3, [r4, #34]	@ 0x22
 8001bec:	2b05      	cmp	r3, #5
 8001bee:	d05d      	beq.n	8001cac <TSK_MediumFrequencyTaskM1+0x278>
            if(! RUC_Exec(&RevUpControlM1))
 8001bf0:	4854      	ldr	r0, [pc, #336]	@ (8001d44 <TSK_MediumFrequencyTaskM1+0x310>)
 8001bf2:	f007 fd23 	bl	800963c <RUC_Exec>
 8001bf6:	4602      	mov	r2, r0
 8001bf8:	2800      	cmp	r0, #0
 8001bfa:	f040 8093 	bne.w	8001d24 <TSK_MediumFrequencyTaskM1+0x2f0>
              MCI_FaultProcessing(&Mci[M1], MC_START_UP, 0);
 8001bfe:	484e      	ldr	r0, [pc, #312]	@ (8001d38 <TSK_MediumFrequencyTaskM1+0x304>)
 8001c00:	2110      	movs	r1, #16
 8001c02:	f7ff fa47 	bl	8001094 <MCI_FaultProcessing>
            (void)VSS_CalcAvrgMecSpeedUnit(&VirtualSpeedSensorM1, &hForcedMecSpeedUnit);
 8001c06:	4852      	ldr	r0, [pc, #328]	@ (8001d50 <TSK_MediumFrequencyTaskM1+0x31c>)
 8001c08:	f10d 0102 	add.w	r1, sp, #2
 8001c0c:	f008 f9ca 	bl	8009fa4 <VSS_CalcAvrgMecSpeedUnit>
            if (true == RUC_FirstAccelerationStageReached(&RevUpControlM1))
 8001c10:	484c      	ldr	r0, [pc, #304]	@ (8001d44 <TSK_MediumFrequencyTaskM1+0x310>)
 8001c12:	f007 fd49 	bl	80096a8 <RUC_FirstAccelerationStageReached>
 8001c16:	2800      	cmp	r0, #0
 8001c18:	f43f af26 	beq.w	8001a68 <TSK_MediumFrequencyTaskM1+0x34>
              ObserverConverged = STO_CR_IsObserverConverged(&STO_CR_M1, hForcedMecSpeedUnit);
 8001c1c:	4e47      	ldr	r6, [pc, #284]	@ (8001d3c <TSK_MediumFrequencyTaskM1+0x308>)
 8001c1e:	f9bd 1002 	ldrsh.w	r1, [sp, #2]
 8001c22:	4630      	mov	r0, r6
 8001c24:	f008 f88c 	bl	8009d40 <STO_CR_IsObserverConverged>
 8001c28:	4605      	mov	r5, r0
              (void)VSS_SetStartTransition(&VirtualSpeedSensorM1, ObserverConverged);
 8001c2a:	4629      	mov	r1, r5
 8001c2c:	4848      	ldr	r0, [pc, #288]	@ (8001d50 <TSK_MediumFrequencyTaskM1+0x31c>)
 8001c2e:	f008 fa47 	bl	800a0c0 <VSS_SetStartTransition>
            if (ObserverConverged)
 8001c32:	2d00      	cmp	r5, #0
 8001c34:	f43f af18 	beq.w	8001a68 <TSK_MediumFrequencyTaskM1+0x34>
              qd_t StatorCurrent = MCM_Park(FOCVars[M1].Ialphabeta, SPD_GetElAngle(&STO_CR_M1._Super));
 8001c38:	4f44      	ldr	r7, [pc, #272]	@ (8001d4c <TSK_MediumFrequencyTaskM1+0x318>)
 8001c3a:	f9b6 1004 	ldrsh.w	r1, [r6, #4]
 8001c3e:	6878      	ldr	r0, [r7, #4]
              REMNG_Init(pREMNG[M1]);
 8001c40:	4d45      	ldr	r5, [pc, #276]	@ (8001d58 <TSK_MediumFrequencyTaskM1+0x324>)
              qd_t StatorCurrent = MCM_Park(FOCVars[M1].Ialphabeta, SPD_GetElAngle(&STO_CR_M1._Super));
 8001c42:	f7ff fbd5 	bl	80013f0 <MCM_Park>
 8001c46:	4603      	mov	r3, r0
              REMNG_Init(pREMNG[M1]);
 8001c48:	6828      	ldr	r0, [r5, #0]
              qd_t StatorCurrent = MCM_Park(FOCVars[M1].Ialphabeta, SPD_GetElAngle(&STO_CR_M1._Super));
 8001c4a:	9301      	str	r3, [sp, #4]
              REMNG_Init(pREMNG[M1]);
 8001c4c:	f007 fbda 	bl	8009404 <REMNG_Init>
              (void)REMNG_ExecRamp(pREMNG[M1], FOCVars[M1].Iqdref.q, 0);
 8001c50:	f9b7 1010 	ldrsh.w	r1, [r7, #16]
 8001c54:	6828      	ldr	r0, [r5, #0]
 8001c56:	2200      	movs	r2, #0
 8001c58:	f007 fc20 	bl	800949c <REMNG_ExecRamp>
              (void)REMNG_ExecRamp(pREMNG[M1], StatorCurrent.q, TRANSITION_DURATION);
 8001c5c:	f9bd 1004 	ldrsh.w	r1, [sp, #4]
 8001c60:	6828      	ldr	r0, [r5, #0]
 8001c62:	2219      	movs	r2, #25
 8001c64:	f007 fc1a 	bl	800949c <REMNG_ExecRamp>
              Mci[M1].State = SWITCH_OVER;
 8001c68:	2313      	movs	r3, #19
 8001c6a:	f884 3023 	strb.w	r3, [r4, #35]	@ 0x23
 8001c6e:	e6fb      	b.n	8001a68 <TSK_MediumFrequencyTaskM1+0x34>
          if ((MCI_START == Mci[M1].DirectCommand) || (MCI_MEASURE_OFFSETS == Mci[M1].DirectCommand))
 8001c70:	f894 3022 	ldrb.w	r3, [r4, #34]	@ 0x22
 8001c74:	f003 03fd 	and.w	r3, r3, #253	@ 0xfd
 8001c78:	2b01      	cmp	r3, #1
 8001c7a:	f47f aef5 	bne.w	8001a68 <TSK_MediumFrequencyTaskM1+0x34>
            if ( mode != MCM_OPEN_LOOP_VOLTAGE_MODE && mode != MCM_OPEN_LOOP_CURRENT_MODE)
 8001c7e:	1e6b      	subs	r3, r5, #1
 8001c80:	b2db      	uxtb	r3, r3
 8001c82:	2b01      	cmp	r3, #1
 8001c84:	d906      	bls.n	8001c94 <TSK_MediumFrequencyTaskM1+0x260>
              RUC_Clear(&RevUpControlM1, MCI_GetImposedMotorDirection(&Mci[M1]));
 8001c86:	482c      	ldr	r0, [pc, #176]	@ (8001d38 <TSK_MediumFrequencyTaskM1+0x304>)
 8001c88:	f7ff fad6 	bl	8001238 <MCI_GetImposedMotorDirection>
 8001c8c:	4601      	mov	r1, r0
 8001c8e:	482d      	ldr	r0, [pc, #180]	@ (8001d44 <TSK_MediumFrequencyTaskM1+0x310>)
 8001c90:	f007 fc88 	bl	80095a4 <RUC_Clear>
            if (pwmcHandle[M1]->offsetCalibStatus == false)
 8001c94:	4d2c      	ldr	r5, [pc, #176]	@ (8001d48 <TSK_MediumFrequencyTaskM1+0x314>)
 8001c96:	6828      	ldr	r0, [r5, #0]
 8001c98:	f890 107f 	ldrb.w	r1, [r0, #127]	@ 0x7f
 8001c9c:	2900      	cmp	r1, #0
 8001c9e:	d15f      	bne.n	8001d60 <TSK_MediumFrequencyTaskM1+0x32c>
              (void)PWMC_CurrentReadingCalibr(pwmcHandle[M1], CRC_START);
 8001ca0:	f000 fc6c 	bl	800257c <PWMC_CurrentReadingCalibr>
              Mci[M1].State = OFFSET_CALIB;
 8001ca4:	2311      	movs	r3, #17
 8001ca6:	f884 3023 	strb.w	r3, [r4, #35]	@ 0x23
 8001caa:	e6dd      	b.n	8001a68 <TSK_MediumFrequencyTaskM1+0x34>
    R3_1_SwitchOffPWM(pwmcHandle[motor]);
 8001cac:	4b26      	ldr	r3, [pc, #152]	@ (8001d48 <TSK_MediumFrequencyTaskM1+0x314>)
 8001cae:	6818      	ldr	r0, [r3, #0]
 8001cb0:	f006 fda4 	bl	80087fc <R3_1_SwitchOffPWM>
  FOC_Clear(motor);
 8001cb4:	2000      	movs	r0, #0
 8001cb6:	f7ff fdb9 	bl	800182c <FOC_Clear>
  TSK_SetStopPermanencyTimeM1(STOPPERMANENCY_TICKS);
 8001cba:	f44f 7048 	mov.w	r0, #800	@ 0x320
 8001cbe:	f7ff fc95 	bl	80015ec <TSK_SetStopPermanencyTimeM1>
  Mci[motor].State = STOP;
 8001cc2:	2308      	movs	r3, #8
 8001cc4:	f884 3023 	strb.w	r3, [r4, #35]	@ 0x23
}
 8001cc8:	e6ce      	b.n	8001a68 <TSK_MediumFrequencyTaskM1+0x34>
              LoopClosed = VSS_CalcAvrgMecSpeedUnit(&VirtualSpeedSensorM1, &hForcedMecSpeedUnit);
 8001cca:	4821      	ldr	r0, [pc, #132]	@ (8001d50 <TSK_MediumFrequencyTaskM1+0x31c>)
 8001ccc:	a901      	add	r1, sp, #4
 8001cce:	f008 f969 	bl	8009fa4 <VSS_CalcAvrgMecSpeedUnit>
 8001cd2:	4605      	mov	r5, r0
              tempBool = VSS_TransitionEnded(&VirtualSpeedSensorM1);
 8001cd4:	481e      	ldr	r0, [pc, #120]	@ (8001d50 <TSK_MediumFrequencyTaskM1+0x31c>)
 8001cd6:	f008 fa01 	bl	800a0dc <VSS_TransitionEnded>
              LoopClosed = LoopClosed || tempBool;
 8001cda:	b915      	cbnz	r5, 8001ce2 <TSK_MediumFrequencyTaskM1+0x2ae>
 8001cdc:	2800      	cmp	r0, #0
 8001cde:	f43f aec3 	beq.w	8001a68 <TSK_MediumFrequencyTaskM1+0x34>
                                    (((int32_t)FOCVars[M1].Iqdref.q * (int16_t)PID_GetKIDivisor(&PIDSpeedHandle_M1))
 8001ce2:	4b1a      	ldr	r3, [pc, #104]	@ (8001d4c <TSK_MediumFrequencyTaskM1+0x318>)
 8001ce4:	481d      	ldr	r0, [pc, #116]	@ (8001d5c <TSK_MediumFrequencyTaskM1+0x328>)
 8001ce6:	f9b3 6010 	ldrsh.w	r6, [r3, #16]
                STC_SetSpeedSensor(pSTC[M1], &STO_CR_M1._Super); /* Observer has converged */
 8001cea:	4d1a      	ldr	r5, [pc, #104]	@ (8001d54 <TSK_MediumFrequencyTaskM1+0x320>)
                                    (((int32_t)FOCVars[M1].Iqdref.q * (int16_t)PID_GetKIDivisor(&PIDSpeedHandle_M1))
 8001cec:	f006 fb72 	bl	80083d4 <PID_GetKIDivisor>
                PID_SetIntegralTerm(&PIDSpeedHandle_M1,
 8001cf0:	b201      	sxth	r1, r0
 8001cf2:	fb06 f101 	mul.w	r1, r6, r1
 8001cf6:	4819      	ldr	r0, [pc, #100]	@ (8001d5c <TSK_MediumFrequencyTaskM1+0x328>)
 8001cf8:	f006 fb62 	bl	80083c0 <PID_SetIntegralTerm>
                STC_SetSpeedSensor(pSTC[M1], &STO_CR_M1._Super); /* Observer has converged */
 8001cfc:	490f      	ldr	r1, [pc, #60]	@ (8001d3c <TSK_MediumFrequencyTaskM1+0x308>)
 8001cfe:	6828      	ldr	r0, [r5, #0]
 8001d00:	f007 fd36 	bl	8009770 <STC_SetSpeedSensor>
                FOC_InitAdditionalMethods(M1);
 8001d04:	2000      	movs	r0, #0
 8001d06:	f7ff fe5d 	bl	80019c4 <FOC_InitAdditionalMethods>
                FOC_CalcCurrRef(M1);
 8001d0a:	2000      	movs	r0, #0
 8001d0c:	f7ff fe5c 	bl	80019c8 <FOC_CalcCurrRef>
                STC_ForceSpeedReferenceToCurrentSpeed(pSTC[M1]); /* Init the reference speed to current speed */
 8001d10:	6828      	ldr	r0, [r5, #0]
 8001d12:	f007 fdcf 	bl	80098b4 <STC_ForceSpeedReferenceToCurrentSpeed>
                MCI_ExecBufferedCommands(&Mci[M1]); /* Exec the speed ramp after changing of the speed sensor */
 8001d16:	4808      	ldr	r0, [pc, #32]	@ (8001d38 <TSK_MediumFrequencyTaskM1+0x304>)
 8001d18:	f7ff f9c8 	bl	80010ac <MCI_ExecBufferedCommands>
                Mci[M1].State = RUN;
 8001d1c:	2306      	movs	r3, #6
 8001d1e:	f884 3023 	strb.w	r3, [r4, #35]	@ 0x23
 8001d22:	e6a1      	b.n	8001a68 <TSK_MediumFrequencyTaskM1+0x34>
              IqdRef.q = STC_CalcTorqueReference(pSTC[M1]);
 8001d24:	4b0b      	ldr	r3, [pc, #44]	@ (8001d54 <TSK_MediumFrequencyTaskM1+0x320>)
 8001d26:	6818      	ldr	r0, [r3, #0]
 8001d28:	f007 fd7c 	bl	8009824 <STC_CalcTorqueReference>
              IqdRef.d = FOCVars[M1].UserIdref;
 8001d2c:	4b07      	ldr	r3, [pc, #28]	@ (8001d4c <TSK_MediumFrequencyTaskM1+0x318>)
 8001d2e:	f9b3 2014 	ldrsh.w	r2, [r3, #20]
              FOCVars[M1].Iqdref = IqdRef;
 8001d32:	8218      	strh	r0, [r3, #16]
 8001d34:	825a      	strh	r2, [r3, #18]
 8001d36:	e766      	b.n	8001c06 <TSK_MediumFrequencyTaskM1+0x1d2>
 8001d38:	20000000 	.word	0x20000000
 8001d3c:	2000007c 	.word	0x2000007c
 8001d40:	2000002c 	.word	0x2000002c
 8001d44:	200002a4 	.word	0x200002a4
 8001d48:	200007ec 	.word	0x200007ec
 8001d4c:	200007c4 	.word	0x200007c4
 8001d50:	2000043c 	.word	0x2000043c
 8001d54:	20000038 	.word	0x20000038
 8001d58:	200007c0 	.word	0x200007c0
 8001d5c:	200003a8 	.word	0x200003a8
              pwmcHandle[M1]->OffCalibrWaitTimeCounter = 1u;
 8001d60:	2101      	movs	r1, #1
 8001d62:	f8a0 1060 	strh.w	r1, [r0, #96]	@ 0x60
              (void)PWMC_CurrentReadingCalibr(pwmcHandle[M1], CRC_EXEC);
 8001d66:	f000 fc09 	bl	800257c <PWMC_CurrentReadingCalibr>
              R3_1_TurnOnLowSides(pwmcHandle[M1],M1_CHARGE_BOOT_CAP_DUTY_CYCLES);
 8001d6a:	e6da      	b.n	8001b22 <TSK_MediumFrequencyTaskM1+0xee>
              VSS_CalcAvrgMecSpeedUnit( &VirtualSpeedSensorM1, &hForcedMecSpeedUnit);
 8001d6c:	a901      	add	r1, sp, #4
 8001d6e:	4807      	ldr	r0, [pc, #28]	@ (8001d8c <TSK_MediumFrequencyTaskM1+0x358>)
 8001d70:	f008 f918 	bl	8009fa4 <VSS_CalcAvrgMecSpeedUnit>
              OL_Calc(pOpenLoop[M1]);
 8001d74:	4b06      	ldr	r3, [pc, #24]	@ (8001d90 <TSK_MediumFrequencyTaskM1+0x35c>)
 8001d76:	6818      	ldr	r0, [r3, #0]
 8001d78:	f006 fafc 	bl	8008374 <OL_Calc>
 8001d7c:	e674      	b.n	8001a68 <TSK_MediumFrequencyTaskM1+0x34>
                FOC_Clear(M1);
 8001d7e:	2000      	movs	r0, #0
 8001d80:	f7ff fd54 	bl	800182c <FOC_Clear>
                Mci[M1].DirectCommand = MCI_NO_COMMAND;
 8001d84:	2300      	movs	r3, #0
 8001d86:	8463      	strh	r3, [r4, #34]	@ 0x22
 8001d88:	e66e      	b.n	8001a68 <TSK_MediumFrequencyTaskM1+0x34>
 8001d8a:	bf00      	nop
 8001d8c:	2000043c 	.word	0x2000043c
 8001d90:	20000804 	.word	0x20000804

08001d94 <FOC_HighFrequencyTask>:
  * subsystem (see the state machine(s)).
  *
  * @retval Number of the  motor instance which FOC loop was executed.
  */
__weak uint8_t FOC_HighFrequencyTask(uint8_t bMotorNbr)
{
 8001d94:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  /* USER CODE END HighFrequencyTask 0 */

  Observer_Inputs_t STO_Inputs; /* Only if sensorless main */

  STO_Inputs.Valfa_beta = FOCVars[M1].Valphabeta;  /* Only if sensorless */
  if (SWITCH_OVER == Mci[M1].State)
 8001d98:	f8df 8134 	ldr.w	r8, [pc, #308]	@ 8001ed0 <FOC_HighFrequencyTask+0x13c>
  STO_Inputs.Valfa_beta = FOCVars[M1].Valphabeta;  /* Only if sensorless */
 8001d9c:	4c4b      	ldr	r4, [pc, #300]	@ (8001ecc <FOC_HighFrequencyTask+0x138>)
  if (SWITCH_OVER == Mci[M1].State)
 8001d9e:	f898 3023 	ldrb.w	r3, [r8, #35]	@ 0x23
{
 8001da2:	b088      	sub	sp, #32
 8001da4:	4605      	mov	r5, r0
  if (SWITCH_OVER == Mci[M1].State)
 8001da6:	2b13      	cmp	r3, #19
  STO_Inputs.Valfa_beta = FOCVars[M1].Valphabeta;  /* Only if sensorless */
 8001da8:	f8d4 001a 	ldr.w	r0, [r4, #26]
 8001dac:	9005      	str	r0, [sp, #20]
  if (SWITCH_OVER == Mci[M1].State)
 8001dae:	f000 8081 	beq.w	8001eb4 <FOC_HighFrequencyTask+0x120>
  int16_t hElAngle;
  uint16_t hCodeError;
  SpeednPosFdbk_Handle_t *speedHandle;
  MC_ControlMode_t mode;

  mode = MCI_GetControlMode( &Mci[M1] );
 8001db2:	4847      	ldr	r0, [pc, #284]	@ (8001ed0 <FOC_HighFrequencyTask+0x13c>)
  speedHandle = STC_GetSpeedSensor(pSTC[M1]);
  hElAngle = SPD_GetElAngle(speedHandle);
  hElAngle += SPD_GetInstElSpeedDpp(speedHandle)*PARK_ANGLE_COMPENSATION_FACTOR;
  PWMC_GetPhaseCurrents(pwmcHandle[M1], &Iab);
 8001db4:	4f47      	ldr	r7, [pc, #284]	@ (8001ed4 <FOC_HighFrequencyTask+0x140>)
  mode = MCI_GetControlMode( &Mci[M1] );
 8001db6:	f7ff fa1f 	bl	80011f8 <MCI_GetControlMode>
  speedHandle = STC_GetSpeedSensor(pSTC[M1]);
 8001dba:	4b47      	ldr	r3, [pc, #284]	@ (8001ed8 <FOC_HighFrequencyTask+0x144>)
 8001dbc:	681b      	ldr	r3, [r3, #0]
  mode = MCI_GetControlMode( &Mci[M1] );
 8001dbe:	4681      	mov	r9, r0
static inline int16_t SPD_GetElAngle(const SpeednPosFdbk_Handle_t *pHandle)
{
#ifdef NULL_PTR_CHECK_SPD_POS_FBK
  return ((MC_NULL == pHandle) ? 0 : pHandle->hElAngle);
#else
  return (pHandle->hElAngle);
 8001dc0:	695b      	ldr	r3, [r3, #20]
  PWMC_GetPhaseCurrents(pwmcHandle[M1], &Iab);
 8001dc2:	6838      	ldr	r0, [r7, #0]
 8001dc4:	f9b3 6004 	ldrsh.w	r6, [r3, #4]
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->pFctGetPhaseCurrents(pHandle, Iab);
 8001dc8:	6803      	ldr	r3, [r0, #0]
 8001dca:	a902      	add	r1, sp, #8
 8001dcc:	4798      	blx	r3
  RCM_ReadOngoingConv();
 8001dce:	f001 fedd 	bl	8003b8c <RCM_ReadOngoingConv>
  RCM_ExecNextConv();
 8001dd2:	f001 fe97 	bl	8003b04 <RCM_ExecNextConv>
  Ialphabeta = MCM_Clarke(Iab);
 8001dd6:	9802      	ldr	r0, [sp, #8]
 8001dd8:	f7ff faca 	bl	8001370 <MCM_Clarke>
  Iqd = MCM_Park(Ialphabeta, hElAngle);
 8001ddc:	4631      	mov	r1, r6
  Ialphabeta = MCM_Clarke(Iab);
 8001dde:	9003      	str	r0, [sp, #12]
  Iqd = MCM_Park(Ialphabeta, hElAngle);
 8001de0:	f7ff fb06 	bl	80013f0 <MCM_Park>
  Vqd.q = PI_Controller(pPIDIq[M1], (int32_t)(FOCVars[M1].Iqdref.q) - Iqd.q);
 8001de4:	f9b4 3010 	ldrsh.w	r3, [r4, #16]
  Iqd = MCM_Park(Ialphabeta, hElAngle);
 8001de8:	9000      	str	r0, [sp, #0]
  Vqd.q = PI_Controller(pPIDIq[M1], (int32_t)(FOCVars[M1].Iqdref.q) - Iqd.q);
 8001dea:	b201      	sxth	r1, r0
 8001dec:	1a59      	subs	r1, r3, r1
 8001dee:	4b3b      	ldr	r3, [pc, #236]	@ (8001edc <FOC_HighFrequencyTask+0x148>)
 8001df0:	6818      	ldr	r0, [r3, #0]
 8001df2:	f006 fb19 	bl	8008428 <PI_Controller>
  Vqd.d = PI_Controller(pPIDId[M1], (int32_t)(FOCVars[M1].Iqdref.d) - Iqd.d);
 8001df6:	f9bd 3002 	ldrsh.w	r3, [sp, #2]
 8001dfa:	f9b4 1012 	ldrsh.w	r1, [r4, #18]
 8001dfe:	1ac9      	subs	r1, r1, r3
 8001e00:	4b37      	ldr	r3, [pc, #220]	@ (8001ee0 <FOC_HighFrequencyTask+0x14c>)
  Vqd.q = PI_Controller(pPIDIq[M1], (int32_t)(FOCVars[M1].Iqdref.q) - Iqd.q);
 8001e02:	4682      	mov	sl, r0
  Vqd.d = PI_Controller(pPIDId[M1], (int32_t)(FOCVars[M1].Iqdref.d) - Iqd.d);
 8001e04:	6818      	ldr	r0, [r3, #0]
 8001e06:	f006 fb0f 	bl	8008428 <PI_Controller>
 8001e0a:	fa1f f18a 	uxth.w	r1, sl
  if (mode == MCM_OPEN_LOOP_VOLTAGE_MODE)
 8001e0e:	f1b9 0f01 	cmp.w	r9, #1
 8001e12:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 8001e16:	d047      	beq.n	8001ea8 <FOC_HighFrequencyTask+0x114>
  }
  else
  {
    /* Nothing to do */
  }
  Vqd = Circle_Limitation(&CircleLimitationM1, Vqd);
 8001e18:	4832      	ldr	r0, [pc, #200]	@ (8001ee4 <FOC_HighFrequencyTask+0x150>)
 8001e1a:	f006 f8bb 	bl	8007f94 <Circle_Limitation>
  hElAngle += SPD_GetInstElSpeedDpp(speedHandle)*REV_PARK_ANGLE_COMPENSATION_FACTOR;
  Valphabeta = MCM_Rev_Park(Vqd, hElAngle);
 8001e1e:	4631      	mov	r1, r6
  Vqd = Circle_Limitation(&CircleLimitationM1, Vqd);
 8001e20:	4681      	mov	r9, r0
  Valphabeta = MCM_Rev_Park(Vqd, hElAngle);
 8001e22:	f7ff fb27 	bl	8001474 <MCM_Rev_Park>
 8001e26:	4601      	mov	r1, r0
  hCodeError = PWMC_SetPhaseVoltage(pwmcHandle[M1], Valphabeta);
 8001e28:	6838      	ldr	r0, [r7, #0]
  Valphabeta = MCM_Rev_Park(Vqd, hElAngle);
 8001e2a:	9104      	str	r1, [sp, #16]
  hCodeError = PWMC_SetPhaseVoltage(pwmcHandle[M1], Valphabeta);
 8001e2c:	f000 fa5a 	bl	80022e4 <PWMC_SetPhaseVoltage>
 8001e30:	4601      	mov	r1, r0

  FOCVars[M1].Vqd = Vqd;
  FOCVars[M1].Iab = Iab;
 8001e32:	9802      	ldr	r0, [sp, #8]
 8001e34:	6020      	str	r0, [r4, #0]
  FOCVars[M1].Ialphabeta = Ialphabeta;
 8001e36:	9803      	ldr	r0, [sp, #12]
 8001e38:	6060      	str	r0, [r4, #4]
  FOCVars[M1].Iqd = Iqd;
 8001e3a:	9800      	ldr	r0, [sp, #0]
 8001e3c:	60e0      	str	r0, [r4, #12]
  if(hFOCreturn == MC_DURATION)
 8001e3e:	2901      	cmp	r1, #1
  FOCVars[M1].Valphabeta = Valphabeta;
 8001e40:	9804      	ldr	r0, [sp, #16]
  FOCVars[M1].Vqd = Vqd;
 8001e42:	f8c4 9016 	str.w	r9, [r4, #22]
  FOCVars[M1].hElAngle = hElAngle;
 8001e46:	8426      	strh	r6, [r4, #32]
  FOCVars[M1].Valphabeta = Valphabeta;
 8001e48:	f8c4 001a 	str.w	r0, [r4, #26]
  if(hFOCreturn == MC_DURATION)
 8001e4c:	d024      	beq.n	8001e98 <FOC_HighFrequencyTask+0x104>
  {
    temp_avBusVoltage_d = pHandle->AvBusVoltage_d;
  }
  return (temp_avBusVoltage_d);
#else
  return (pHandle->AvBusVoltage_d);
 8001e4e:	4b26      	ldr	r3, [pc, #152]	@ (8001ee8 <FOC_HighFrequencyTask+0x154>)
    STO_Inputs.Ialfa_beta = FOCVars[M1].Ialphabeta; /* Only if sensorless */
 8001e50:	6860      	ldr	r0, [r4, #4]
    STO_Inputs.Vbus = VBS_GetAvBusVoltage_d(&(BusVoltageSensor_M1._Super)); /* Only for sensorless */
 8001e52:	88db      	ldrh	r3, [r3, #6]
    STO_Inputs.Ialfa_beta = FOCVars[M1].Ialphabeta; /* Only if sensorless */
 8001e54:	9006      	str	r0, [sp, #24]
    (void)STO_CR_CalcElAngle(&STO_CR_M1, &STO_Inputs);
 8001e56:	a905      	add	r1, sp, #20
 8001e58:	4824      	ldr	r0, [pc, #144]	@ (8001eec <FOC_HighFrequencyTask+0x158>)
    STO_Inputs.Vbus = VBS_GetAvBusVoltage_d(&(BusVoltageSensor_M1._Super)); /* Only for sensorless */
 8001e5a:	f8ad 301c 	strh.w	r3, [sp, #28]
    (void)STO_CR_CalcElAngle(&STO_CR_M1, &STO_Inputs);
 8001e5e:	f007 fd31 	bl	80098c4 <STO_CR_CalcElAngle>
    STO_CR_CalcAvrgElSpeedDpp(&STO_CR_M1); /* Only in case of Sensor-less */
 8001e62:	4822      	ldr	r0, [pc, #136]	@ (8001eec <FOC_HighFrequencyTask+0x158>)
 8001e64:	f007 ffec 	bl	8009e40 <STO_CR_CalcAvrgElSpeedDpp>
    if((START == Mci[M1].State) || (SWITCH_OVER == Mci[M1].State) || (RUN == Mci[M1].State))
 8001e68:	f898 3023 	ldrb.w	r3, [r8, #35]	@ 0x23
 8001e6c:	f003 02fd 	and.w	r2, r3, #253	@ 0xfd
 8001e70:	2a04      	cmp	r2, #4
 8001e72:	d005      	beq.n	8001e80 <FOC_HighFrequencyTask+0xec>
 8001e74:	2b13      	cmp	r3, #19
 8001e76:	d003      	beq.n	8001e80 <FOC_HighFrequencyTask+0xec>
}
 8001e78:	4628      	mov	r0, r5
 8001e7a:	b008      	add	sp, #32
 8001e7c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8001e80:	4b1a      	ldr	r3, [pc, #104]	@ (8001eec <FOC_HighFrequencyTask+0x158>)
      (void)VSS_CalcElAngle(&VirtualSpeedSensorM1, &hObsAngle);
 8001e82:	481b      	ldr	r0, [pc, #108]	@ (8001ef0 <FOC_HighFrequencyTask+0x15c>)
      int16_t hObsAngle = SPD_GetElAngle(&STO_CR_M1._Super);
 8001e84:	889b      	ldrh	r3, [r3, #4]
 8001e86:	f8ad 3010 	strh.w	r3, [sp, #16]
      (void)VSS_CalcElAngle(&VirtualSpeedSensorM1, &hObsAngle);
 8001e8a:	a904      	add	r1, sp, #16
 8001e8c:	f008 f838 	bl	8009f00 <VSS_CalcElAngle>
}
 8001e90:	4628      	mov	r0, r5
 8001e92:	b008      	add	sp, #32
 8001e94:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    MCI_FaultProcessing(&Mci[M1], MC_DURATION, 0);
 8001e98:	480d      	ldr	r0, [pc, #52]	@ (8001ed0 <FOC_HighFrequencyTask+0x13c>)
 8001e9a:	2200      	movs	r2, #0
 8001e9c:	f7ff f8fa 	bl	8001094 <MCI_FaultProcessing>
}
 8001ea0:	4628      	mov	r0, r5
 8001ea2:	b008      	add	sp, #32
 8001ea4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    Vqd = OL_VqdConditioning(pOpenLoop[M1]);
 8001ea8:	4b12      	ldr	r3, [pc, #72]	@ (8001ef4 <FOC_HighFrequencyTask+0x160>)
 8001eaa:	6818      	ldr	r0, [r3, #0]
 8001eac:	f006 fa5e 	bl	800836c <OL_VqdConditioning>
 8001eb0:	4601      	mov	r1, r0
 8001eb2:	e7b1      	b.n	8001e18 <FOC_HighFrequencyTask+0x84>
    if (!REMNG_RampCompleted(pREMNG[M1]))
 8001eb4:	4e10      	ldr	r6, [pc, #64]	@ (8001ef8 <FOC_HighFrequencyTask+0x164>)
 8001eb6:	6830      	ldr	r0, [r6, #0]
 8001eb8:	f007 face 	bl	8009458 <REMNG_RampCompleted>
 8001ebc:	2800      	cmp	r0, #0
 8001ebe:	f47f af78 	bne.w	8001db2 <FOC_HighFrequencyTask+0x1e>
      FOCVars[M1].Iqdref.q = (int16_t)REMNG_Calc(pREMNG[M1]);
 8001ec2:	6830      	ldr	r0, [r6, #0]
 8001ec4:	f007 faa6 	bl	8009414 <REMNG_Calc>
 8001ec8:	8220      	strh	r0, [r4, #16]
 8001eca:	e772      	b.n	8001db2 <FOC_HighFrequencyTask+0x1e>
 8001ecc:	200007c4 	.word	0x200007c4
 8001ed0:	20000000 	.word	0x20000000
 8001ed4:	200007ec 	.word	0x200007ec
 8001ed8:	20000038 	.word	0x20000038
 8001edc:	20000034 	.word	0x20000034
 8001ee0:	20000030 	.word	0x20000030
 8001ee4:	2000003c 	.word	0x2000003c
 8001ee8:	200003e4 	.word	0x200003e4
 8001eec:	2000007c 	.word	0x2000007c
 8001ef0:	2000043c 	.word	0x2000043c
 8001ef4:	20000804 	.word	0x20000804
 8001ef8:	200007c0 	.word	0x200007c0

08001efc <RI_SetRegCommandParser>:
  * @param  txSyncFreeSpace Space available for synchronous transmission
  *
  * @retval Returns #MCP_CMD_OK if the command is acknowledged and #MCP_CMD_NOK if not.
  */
uint8_t RI_SetRegCommandParser (MCP_Handle_t * pHandle, uint16_t txSyncFreeSpace)
{
 8001efc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  {
#endif
    uint16_t * dataElementID;
    uint8_t * rxData = pHandle->rxBuffer;
    uint8_t * txData = pHandle->txBuffer;
    int16_t rxLength = pHandle->rxLength;
 8001f00:	f9b0 400c 	ldrsh.w	r4, [r0, #12]
    uint8_t accessResult;

    uint16_t regID;
    uint8_t typeID;
    uint8_t motorID;
    uint8_t (*SetRegFcts[NBR_OF_MOTORS+1])(uint16_t, uint8_t, uint8_t*, uint16_t*, int16_t) = {&RI_SetRegisterGlobal, &RI_SetRegisterMotor1};
 8001f04:	4b31      	ldr	r3, [pc, #196]	@ (8001fcc <RI_SetRegCommandParser+0xd0>)
{
 8001f06:	b089      	sub	sp, #36	@ 0x24
    uint16_t size = 0U;
 8001f08:	f04f 0900 	mov.w	r9, #0
    uint8_t (*SetRegFcts[NBR_OF_MOTORS+1])(uint16_t, uint8_t, uint8_t*, uint16_t*, int16_t) = {&RI_SetRegisterGlobal, &RI_SetRegisterMotor1};
 8001f0c:	9306      	str	r3, [sp, #24]
    uint8_t number_of_item =0;
    pHandle->txLength = 0;

    while (rxLength > 0)
 8001f0e:	454c      	cmp	r4, r9
    uint8_t (*SetRegFcts[NBR_OF_MOTORS+1])(uint16_t, uint8_t, uint8_t*, uint16_t*, int16_t) = {&RI_SetRegisterGlobal, &RI_SetRegisterMotor1};
 8001f10:	4b2f      	ldr	r3, [pc, #188]	@ (8001fd0 <RI_SetRegCommandParser+0xd4>)
    uint16_t size = 0U;
 8001f12:	f8ad 9016 	strh.w	r9, [sp, #22]
    uint8_t * txData = pHandle->txBuffer;
 8001f16:	e9d0 c601 	ldrd	ip, r6, [r0, #4]
{
 8001f1a:	4607      	mov	r7, r0
    uint8_t (*SetRegFcts[NBR_OF_MOTORS+1])(uint16_t, uint8_t, uint8_t*, uint16_t*, int16_t) = {&RI_SetRegisterGlobal, &RI_SetRegisterMotor1};
 8001f1c:	9307      	str	r3, [sp, #28]
    pHandle->txLength = 0;
 8001f1e:	f8a0 900e 	strh.w	r9, [r0, #14]
    while (rxLength > 0)
 8001f22:	dd47      	ble.n	8001fb4 <RI_SetRegCommandParser+0xb8>
 8001f24:	eb06 0801 	add.w	r8, r6, r1
  uint8_t retVal = MCP_CMD_OK;
 8001f28:	f8cd 900c 	str.w	r9, [sp, #12]
        accessResult = SetRegFcts[motorID](regID, typeID, rxData, &size, rxLength);
        /* Prepare next data*/
        rxLength = (int16_t) (rxLength - size);
        rxData = rxData+size;
        /* If there is only one CMD in the buffer, we do not store the result */
        if ((1U == number_of_item) && (0 == rxLength))
 8001f2c:	f1c6 0a01 	rsb	sl, r6, #1
      rxData = rxData+MCP_ID_SIZE; // Shift buffer to the next data
 8001f30:	f10c 0502 	add.w	r5, ip, #2
      regID = *dataElementID & REG_MASK;
 8001f34:	f8bc c000 	ldrh.w	ip, [ip]
      typeID = (uint8_t)*dataElementID & TYPE_MASK;
 8001f38:	fa5f f18c 	uxtb.w	r1, ip
      rxLength = rxLength-MCP_ID_SIZE; // We consume 2 byte in the DataID
 8001f3c:	3c02      	subs	r4, #2
        accessResult = SetRegFcts[motorID](regID, typeID, rxData, &size, rxLength);
 8001f3e:	f001 0b07 	and.w	fp, r1, #7
 8001f42:	f10d 0920 	add.w	r9, sp, #32
      if (motorID > NBR_OF_MOTORS)
 8001f46:	f01c 0f06 	tst.w	ip, #6
        accessResult = SetRegFcts[motorID](regID, typeID, rxData, &size, rxLength);
 8001f4a:	fa0f fe84 	sxth.w	lr, r4
 8001f4e:	f10d 0316 	add.w	r3, sp, #22
 8001f52:	462a      	mov	r2, r5
      rxLength = rxLength-MCP_ID_SIZE; // We consume 2 byte in the DataID
 8001f54:	b2a4      	uxth	r4, r4
      regID = *dataElementID & REG_MASK;
 8001f56:	f02c 0007 	bic.w	r0, ip, #7
        accessResult = SetRegFcts[motorID](regID, typeID, rxData, &size, rxLength);
 8001f5a:	eb09 0b8b 	add.w	fp, r9, fp, lsl #2
 8001f5e:	f001 0138 	and.w	r1, r1, #56	@ 0x38
      if (motorID > NBR_OF_MOTORS)
 8001f62:	d11b      	bne.n	8001f9c <RI_SetRegCommandParser+0xa0>
        accessResult = SetRegFcts[motorID](regID, typeID, rxData, &size, rxLength);
 8001f64:	f8cd e000 	str.w	lr, [sp]
 8001f68:	f85b bc08 	ldr.w	fp, [fp, #-8]
 8001f6c:	47d8      	blx	fp
        rxLength = (int16_t) (rxLength - size);
 8001f6e:	f8bd 2016 	ldrh.w	r2, [sp, #22]
        if ((1U == number_of_item) && (0 == rxLength))
 8001f72:	eb06 030a 	add.w	r3, r6, sl
 8001f76:	b2db      	uxtb	r3, r3
        rxLength = (int16_t) (rxLength - size);
 8001f78:	1aa4      	subs	r4, r4, r2
        if ((1U == number_of_item) && (0 == rxLength))
 8001f7a:	2b01      	cmp	r3, #1
        rxLength = (int16_t) (rxLength - size);
 8001f7c:	b224      	sxth	r4, r4
        rxData = rxData+size;
 8001f7e:	eb05 0c02 	add.w	ip, r5, r2
        if ((1U == number_of_item) && (0 == rxLength))
 8001f82:	d013      	beq.n	8001fac <RI_SetRegCommandParser+0xb0>
        {
          retVal = accessResult;
        }
        else
        {/* Store the result for each access to be able to report failing access */
          if (txSyncFreeSpace !=0 )
 8001f84:	4546      	cmp	r6, r8
 8001f86:	d00d      	beq.n	8001fa4 <RI_SetRegCommandParser+0xa8>
          {
            *txData = accessResult;
 8001f88:	f806 0b01 	strb.w	r0, [r6], #1
            txData = txData+1;
            pHandle->txLength++;
 8001f8c:	89fb      	ldrh	r3, [r7, #14]
 8001f8e:	3301      	adds	r3, #1
 8001f90:	81fb      	strh	r3, [r7, #14]
            txSyncFreeSpace--; /* decrement one by one no wraparound possible */
            retVal = (accessResult != MCP_CMD_OK) ? MCP_CMD_NOK : retVal;
 8001f92:	b1a0      	cbz	r0, 8001fbe <RI_SetRegCommandParser+0xc2>
            if ((accessResult == MCP_ERROR_BAD_DATA_TYPE) || (accessResult == MCP_ERROR_BAD_RAW_FORMAT))
 8001f94:	2807      	cmp	r0, #7
 8001f96:	d001      	beq.n	8001f9c <RI_SetRegCommandParser+0xa0>
 8001f98:	280a      	cmp	r0, #10
 8001f9a:	d10e      	bne.n	8001fba <RI_SetRegCommandParser+0xbe>
        retVal = MCP_CMD_NOK;
 8001f9c:	2001      	movs	r0, #1
    }
  #ifdef NULL_PTR_CHECK_REG_INT
  }
#endif
  return (retVal);
}
 8001f9e:	b009      	add	sp, #36	@ 0x24
 8001fa0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 8001fa4:	2008      	movs	r0, #8
}
 8001fa6:	b009      	add	sp, #36	@ 0x24
 8001fa8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ((1U == number_of_item) && (0 == rxLength))
 8001fac:	2c00      	cmp	r4, #0
 8001fae:	d1e9      	bne.n	8001f84 <RI_SetRegCommandParser+0x88>
    if (MCP_CMD_OK == retVal)
 8001fb0:	2800      	cmp	r0, #0
 8001fb2:	d1f4      	bne.n	8001f9e <RI_SetRegCommandParser+0xa2>
      pHandle->txLength = 0;
 8001fb4:	2000      	movs	r0, #0
 8001fb6:	81f8      	strh	r0, [r7, #14]
 8001fb8:	e7f1      	b.n	8001f9e <RI_SetRegCommandParser+0xa2>
            retVal = (accessResult != MCP_CMD_OK) ? MCP_CMD_NOK : retVal;
 8001fba:	2301      	movs	r3, #1
 8001fbc:	9303      	str	r3, [sp, #12]
    while (rxLength > 0)
 8001fbe:	2c00      	cmp	r4, #0
 8001fc0:	dcb6      	bgt.n	8001f30 <RI_SetRegCommandParser+0x34>
 8001fc2:	9803      	ldr	r0, [sp, #12]
    if (MCP_CMD_OK == retVal)
 8001fc4:	2800      	cmp	r0, #0
 8001fc6:	d0f5      	beq.n	8001fb4 <RI_SetRegCommandParser+0xb8>
 8001fc8:	e7e9      	b.n	8001f9e <RI_SetRegCommandParser+0xa2>
 8001fca:	bf00      	nop
 8001fcc:	08002645 	.word	0x08002645
 8001fd0:	08002749 	.word	0x08002749

08001fd4 <RI_GetRegCommandParser>:
  * @param  txSyncFreeSpace Space available for synchronous transmission
  *
  * @retval Returns #MCP_CMD_OK if the command is acknowledged and #MCP_CMD_NOK if not.
  */
uint8_t RI_GetRegCommandParser (MCP_Handle_t * pHandle, uint16_t txSyncFreeSpace)
{
 8001fd4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8001fd8:	b086      	sub	sp, #24
  {
#endif
    uint16_t * dataElementID;
    uint8_t * rxData = pHandle->rxBuffer;
    uint8_t * txData = pHandle->txBuffer;
    uint16_t size = 0U;
 8001fda:	2300      	movs	r3, #0
 8001fdc:	f8ad 300e 	strh.w	r3, [sp, #14]

    uint16_t regID;
    uint8_t typeID;
    uint8_t motorID;
    uint8_t (*GetRegFcts[NBR_OF_MOTORS+1])(uint16_t, uint8_t, uint8_t*, uint16_t*, int16_t) = {&RI_GetRegisterGlobal, &RI_GetRegisterMotor1};
    pHandle->txLength = 0;
 8001fe0:	81c3      	strh	r3, [r0, #14]
    uint16_t rxLength = pHandle->rxLength;
 8001fe2:	f8b0 800c 	ldrh.w	r8, [r0, #12]
    uint8_t (*GetRegFcts[NBR_OF_MOTORS+1])(uint16_t, uint8_t, uint8_t*, uint16_t*, int16_t) = {&RI_GetRegisterGlobal, &RI_GetRegisterMotor1};
 8001fe6:	4b1d      	ldr	r3, [pc, #116]	@ (800205c <RI_GetRegCommandParser+0x88>)
 8001fe8:	9304      	str	r3, [sp, #16]
 8001fea:	4b1d      	ldr	r3, [pc, #116]	@ (8002060 <RI_GetRegCommandParser+0x8c>)
    uint8_t * rxData = pHandle->rxBuffer;
 8001fec:	f8d0 9004 	ldr.w	r9, [r0, #4]
    uint8_t * txData = pHandle->txBuffer;
 8001ff0:	6886      	ldr	r6, [r0, #8]
    uint8_t (*GetRegFcts[NBR_OF_MOTORS+1])(uint16_t, uint8_t, uint8_t*, uint16_t*, int16_t) = {&RI_GetRegisterGlobal, &RI_GetRegisterMotor1};
 8001ff2:	9305      	str	r3, [sp, #20]
    while (rxLength > 0U)
 8001ff4:	f1b8 0f00 	cmp.w	r8, #0
 8001ff8:	d016      	beq.n	8002028 <RI_GetRegCommandParser+0x54>
 8001ffa:	4607      	mov	r7, r0
 8001ffc:	b20d      	sxth	r5, r1
    uint8_t * rxData = pHandle->rxBuffer;
 8001ffe:	464c      	mov	r4, r9
    {
      dataElementID = (uint16_t *) rxData;
      rxLength = rxLength - MCP_ID_SIZE;
      rxData = rxData + MCP_ID_SIZE; // Shift buffer to the next MCP_ID

      regID = *dataElementID & REG_MASK;
 8002000:	f834 cb02 	ldrh.w	ip, [r4], #2
      typeID = (uint8_t)*dataElementID & TYPE_MASK;
 8002004:	fa5f f18c 	uxtb.w	r1, ip
        retVal = MCP_CMD_NOK;
        rxLength = 0;
      }
      else
      {
        retVal = GetRegFcts[motorID](regID, typeID, txData, &size, freeSpaceS16);
 8002008:	f001 0e07 	and.w	lr, r1, #7
 800200c:	f10d 0a18 	add.w	sl, sp, #24
      if (motorID > NBR_OF_MOTORS)
 8002010:	f01c 0f06 	tst.w	ip, #6
        retVal = GetRegFcts[motorID](regID, typeID, txData, &size, freeSpaceS16);
 8002014:	4632      	mov	r2, r6
      regID = *dataElementID & REG_MASK;
 8002016:	f02c 0007 	bic.w	r0, ip, #7
        retVal = GetRegFcts[motorID](regID, typeID, txData, &size, freeSpaceS16);
 800201a:	f10d 030e 	add.w	r3, sp, #14
 800201e:	eb0a 0e8e 	add.w	lr, sl, lr, lsl #2
 8002022:	f001 0138 	and.w	r1, r1, #56	@ 0x38
      if (motorID > NBR_OF_MOTORS)
 8002026:	d003      	beq.n	8002030 <RI_GetRegCommandParser+0x5c>
        retVal = MCP_CMD_NOK;
 8002028:	2001      	movs	r0, #1
    }
#ifdef NULL_PTR_CHECK_REG_INT
  }
#endif
  return (retVal);
}
 800202a:	b006      	add	sp, #24
 800202c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        retVal = GetRegFcts[motorID](regID, typeID, txData, &size, freeSpaceS16);
 8002030:	9500      	str	r5, [sp, #0]
 8002032:	f85e ac08 	ldr.w	sl, [lr, #-8]
 8002036:	47d0      	blx	sl
        if (retVal == MCP_CMD_OK )
 8002038:	eba8 0304 	sub.w	r3, r8, r4
    while (rxLength > 0U)
 800203c:	fa19 f383 	uxtah	r3, r9, r3
 8002040:	b29b      	uxth	r3, r3
        if (retVal == MCP_CMD_OK )
 8002042:	2800      	cmp	r0, #0
 8002044:	d1f1      	bne.n	800202a <RI_GetRegCommandParser+0x56>
          txData = txData+size;
 8002046:	f8bd 100e 	ldrh.w	r1, [sp, #14]
          pHandle->txLength += size;
 800204a:	89fa      	ldrh	r2, [r7, #14]
          freeSpaceS16 = freeSpaceS16-size;
 800204c:	1a6d      	subs	r5, r5, r1
          pHandle->txLength += size;
 800204e:	440a      	add	r2, r1
          txData = txData+size;
 8002050:	440e      	add	r6, r1
          pHandle->txLength += size;
 8002052:	81fa      	strh	r2, [r7, #14]
          freeSpaceS16 = freeSpaceS16-size;
 8002054:	b22d      	sxth	r5, r5
    while (rxLength > 0U)
 8002056:	2b00      	cmp	r3, #0
 8002058:	d1d2      	bne.n	8002000 <RI_GetRegCommandParser+0x2c>
 800205a:	e7e6      	b.n	800202a <RI_GetRegCommandParser+0x56>
 800205c:	08002d05 	.word	0x08002d05
 8002060:	08002e39 	.word	0x08002e39

08002064 <MCP_ReceivedPacket>:
  * @brief  Parses the header from the received packet and call the required function depending on the command sent by the controller device.
  *
  * @param  pHandle Handler of the current instance of the MCP component
  */
void MCP_ReceivedPacket(MCP_Handle_t *pHandle)
{
 8002064:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002066:	4604      	mov	r4, r0
  }
  else /* Length is 0, this is a request to send back the last packet */
  {
#endif
    packetHeader = (uint16_t *)pHandle->rxBuffer; //cstat !MISRAC2012-Rule-11.3
    command = (uint16_t)(*packetHeader & CMD_MASK);
 8002068:	6846      	ldr	r6, [r0, #4]
    pHandle->rxLength = pHandle->rxLength - MCP_HEADER_SIZE;
    pHandle->rxBuffer = pHandle->rxBuffer + MCP_HEADER_SIZE;

    /* Commands requiering payload response must be aware of space available for the payload */
    /* Last byte is reserved for MCP response*/
    txSyncFreeSpace = (int16_t)pHandle->pTransportLayer->txSyncMaxPayload - 1;
 800206a:	6822      	ldr	r2, [r4, #0]
    command = (uint16_t)(*packetHeader & CMD_MASK);
 800206c:	f836 3b02 	ldrh.w	r3, [r6], #2
    pHandle->rxLength = pHandle->rxLength - MCP_HEADER_SIZE;
 8002070:	8980      	ldrh	r0, [r0, #12]
    txSyncFreeSpace = (int16_t)pHandle->pTransportLayer->txSyncMaxPayload - 1;
 8002072:	8992      	ldrh	r2, [r2, #12]
    if ((command & MCP_USER_CMD_MASK) == MCP_USER_CMD)
 8002074:	f403 457f 	and.w	r5, r3, #65280	@ 0xff00
    txSyncFreeSpace = (int16_t)pHandle->pTransportLayer->txSyncMaxPayload - 1;
 8002078:	3a01      	subs	r2, #1
    pHandle->rxLength = pHandle->rxLength - MCP_HEADER_SIZE;
 800207a:	3802      	subs	r0, #2
    command = (uint16_t)(*packetHeader & CMD_MASK);
 800207c:	f023 0c07 	bic.w	ip, r3, #7
    if ((command & MCP_USER_CMD_MASK) == MCP_USER_CMD)
 8002080:	f5b5 7f80 	cmp.w	r5, #256	@ 0x100
    txSyncFreeSpace = (int16_t)pHandle->pTransportLayer->txSyncMaxPayload - 1;
 8002084:	b291      	uxth	r1, r2
{
 8002086:	b083      	sub	sp, #12
    pHandle->rxLength = pHandle->rxLength - MCP_HEADER_SIZE;
 8002088:	b280      	uxth	r0, r0
    command = (uint16_t)(*packetHeader & CMD_MASK);
 800208a:	fa1f fc8c 	uxth.w	ip, ip
    txSyncFreeSpace = (int16_t)pHandle->pTransportLayer->txSyncMaxPayload - 1;
 800208e:	b212      	sxth	r2, r2
    if ((command & MCP_USER_CMD_MASK) == MCP_USER_CMD)
 8002090:	d048      	beq.n	8002124 <MCP_ReceivedPacket+0xc0>
    motorID = (uint8_t)((*packetHeader - 1U) & MOTOR_MASK);
 8002092:	3b01      	subs	r3, #1
    MCI_Handle_t *pMCI = &Mci[motorID];
 8002094:	f003 0307 	and.w	r3, r3, #7
 8002098:	4d4e      	ldr	r5, [pc, #312]	@ (80021d4 <MCP_ReceivedPacket+0x170>)
    pHandle->rxLength = pHandle->rxLength - MCP_HEADER_SIZE;
 800209a:	81a0      	strh	r0, [r4, #12]
    MCI_Handle_t *pMCI = &Mci[motorID];
 800209c:	eb03 0783 	add.w	r7, r3, r3, lsl #2
 80020a0:	eb03 0347 	add.w	r3, r3, r7, lsl #1
 80020a4:	eb05 0783 	add.w	r7, r5, r3, lsl #2

    /* Initialization of the tx length, command which send back data has to increment the txLength
     * (case of Read register) */
    pHandle->txLength = 0U;

    switch (command)
 80020a8:	f1bc 0f38 	cmp.w	ip, #56	@ 0x38
    pHandle->txLength = 0U;
 80020ac:	f04f 0500 	mov.w	r5, #0
    pHandle->rxBuffer = pHandle->rxBuffer + MCP_HEADER_SIZE;
 80020b0:	6066      	str	r6, [r4, #4]
    pHandle->txLength = 0U;
 80020b2:	81e5      	strh	r5, [r4, #14]
    switch (command)
 80020b4:	d82a      	bhi.n	800210c <MCP_ReceivedPacket+0xa8>
 80020b6:	f1bc 0f38 	cmp.w	ip, #56	@ 0x38
 80020ba:	d81e      	bhi.n	80020fa <MCP_ReceivedPacket+0x96>
 80020bc:	e8df f00c 	tbb	[pc, ip]
 80020c0:	1d1d1d54 	.word	0x1d1d1d54
 80020c4:	1d1d1d1d 	.word	0x1d1d1d1d
 80020c8:	1d1d1d5c 	.word	0x1d1d1d5c
 80020cc:	1d1d1d1d 	.word	0x1d1d1d1d
 80020d0:	1d1d1d4f 	.word	0x1d1d1d4f
 80020d4:	1d1d1d1d 	.word	0x1d1d1d1d
 80020d8:	1d1d1d47 	.word	0x1d1d1d47
 80020dc:	1d1d1d1d 	.word	0x1d1d1d1d
 80020e0:	1d1d1d41 	.word	0x1d1d1d41
 80020e4:	1d1d1d1d 	.word	0x1d1d1d1d
 80020e8:	1d1d1d61 	.word	0x1d1d1d61
 80020ec:	1d1d1d1d 	.word	0x1d1d1d1d
 80020f0:	1d1d1d3d 	.word	0x1d1d1d3d
 80020f4:	1d1d1d1d 	.word	0x1d1d1d1d
 80020f8:	69          	.byte	0x69
 80020f9:	00          	.byte	0x00
 80020fa:	2300      	movs	r3, #0
 80020fc:	2002      	movs	r0, #2
      {
        MCPResponse = MCP_CMD_UNKNOWN;
        break;
      }
    }
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 80020fe:	68a2      	ldr	r2, [r4, #8]
 8002100:	54d0      	strb	r0, [r2, r3]
    pHandle->txLength++;
 8002102:	89e3      	ldrh	r3, [r4, #14]
 8002104:	3301      	adds	r3, #1
 8002106:	81e3      	strh	r3, [r4, #14]
#ifdef NULL_PTR_CHECK_MCP
  }
#endif
}
 8002108:	b003      	add	sp, #12
 800210a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    switch (command)
 800210c:	f1bc 0f68 	cmp.w	ip, #104	@ 0x68
 8002110:	d045      	beq.n	800219e <MCP_ReceivedPacket+0x13a>
 8002112:	f1bc 0f48 	cmp.w	ip, #72	@ 0x48
 8002116:	d1f0      	bne.n	80020fa <MCP_ReceivedPacket+0x96>
        MCI_Clear_Iqdref(pMCI);
 8002118:	4638      	mov	r0, r7
 800211a:	f7ff f91f 	bl	800135c <MCI_Clear_Iqdref>
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 800211e:	89e3      	ldrh	r3, [r4, #14]
        MCPResponse = MCP_CMD_OK;
 8002120:	4628      	mov	r0, r5
        break;
 8002122:	e7ec      	b.n	80020fe <MCP_ReceivedPacket+0x9a>
      userCommand = ((uint8_t)(command & 0xF8U) >> 3U);
 8002124:	f3cc 0cc4 	ubfx	ip, ip, #3, #5
    pHandle->txLength = 0U;
 8002128:	2300      	movs	r3, #0
        if ((userCommand < MCP_USER_CALLBACK_MAX) && (MCP_UserCallBack[userCommand] != NULL))
 800212a:	f1bc 0f01 	cmp.w	ip, #1
    pHandle->rxLength = pHandle->rxLength - MCP_HEADER_SIZE;
 800212e:	81a0      	strh	r0, [r4, #12]
    pHandle->rxBuffer = pHandle->rxBuffer + MCP_HEADER_SIZE;
 8002130:	6066      	str	r6, [r4, #4]
    pHandle->txLength = 0U;
 8002132:	81e3      	strh	r3, [r4, #14]
        if ((userCommand < MCP_USER_CALLBACK_MAX) && (MCP_UserCallBack[userCommand] != NULL))
 8002134:	d93c      	bls.n	80021b0 <MCP_ReceivedPacket+0x14c>
          MCPResponse = MCP_ERROR_CALLBACK_NOT_REGISTRED;
 8002136:	200d      	movs	r0, #13
 8002138:	e7e1      	b.n	80020fe <MCP_ReceivedPacket+0x9a>
        if (IDLE == MCI_GetSTMState(pMCI))
 800213a:	4638      	mov	r0, r7
 800213c:	f7ff f806 	bl	800114c <MCI_GetSTMState>
 8002140:	b128      	cbz	r0, 800214e <MCP_ReceivedPacket+0xea>
          (void)MCI_StopMotor(pMCI);
 8002142:	4638      	mov	r0, r7
 8002144:	f7ff f822 	bl	800118c <MCI_StopMotor>
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002148:	89e3      	ldrh	r3, [r4, #14]
        MCPResponse = MCP_CMD_OK;
 800214a:	2000      	movs	r0, #0
 800214c:	e7d7      	b.n	80020fe <MCP_ReceivedPacket+0x9a>
          MCPResponse = (MCI_StartMotor(pMCI) == true) ? MCP_CMD_OK : MCP_CMD_NOK;
 800214e:	4638      	mov	r0, r7
 8002150:	f7ff f804 	bl	800115c <MCI_StartMotor>
 8002154:	f080 0001 	eor.w	r0, r0, #1
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002158:	89e3      	ldrh	r3, [r4, #14]
          MCPResponse = (MCI_StartMotor(pMCI) == true) ? MCP_CMD_OK : MCP_CMD_NOK;
 800215a:	b2c0      	uxtb	r0, r0
 800215c:	e7cf      	b.n	80020fe <MCP_ReceivedPacket+0x9a>
        MCPResponse = RI_GetRegCommandParser(pHandle, (uint16_t)txSyncFreeSpace);
 800215e:	4620      	mov	r0, r4
 8002160:	f7ff ff38 	bl	8001fd4 <RI_GetRegCommandParser>
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002164:	89e3      	ldrh	r3, [r4, #14]
        break;
 8002166:	e7ca      	b.n	80020fe <MCP_ReceivedPacket+0x9a>
        *pHandle->txBuffer = MCP_VERSION;
 8002168:	68a3      	ldr	r3, [r4, #8]
        pHandle->txLength = 4U;
 800216a:	2104      	movs	r1, #4
        *pHandle->txBuffer = MCP_VERSION;
 800216c:	2201      	movs	r2, #1
        pHandle->txLength = 4U;
 800216e:	81e1      	strh	r1, [r4, #14]
        *pHandle->txBuffer = MCP_VERSION;
 8002170:	701a      	strb	r2, [r3, #0]
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002172:	89e3      	ldrh	r3, [r4, #14]
        MCPResponse = MCP_CMD_OK;
 8002174:	2000      	movs	r0, #0
        break;
 8002176:	e7c2      	b.n	80020fe <MCP_ReceivedPacket+0x9a>
        MCPResponse = RI_SetRegCommandParser(pHandle, (uint16_t)txSyncFreeSpace);
 8002178:	4620      	mov	r0, r4
 800217a:	f7ff febf 	bl	8001efc <RI_SetRegCommandParser>
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 800217e:	89e3      	ldrh	r3, [r4, #14]
        break;
 8002180:	e7bd      	b.n	80020fe <MCP_ReceivedPacket+0x9a>
        if (RUN == MCI_GetSTMState(pMCI))
 8002182:	4638      	mov	r0, r7
 8002184:	f7fe ffe2 	bl	800114c <MCI_GetSTMState>
 8002188:	2806      	cmp	r0, #6
 800218a:	d01d      	beq.n	80021c8 <MCP_ReceivedPacket+0x164>
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 800218c:	89e3      	ldrh	r3, [r4, #14]
        MCPResponse = MCP_CMD_OK;
 800218e:	2000      	movs	r0, #0
 8002190:	e7b5      	b.n	80020fe <MCP_ReceivedPacket+0x9a>
        (void)MCI_FaultAcknowledged(pMCI);
 8002192:	4638      	mov	r0, r7
 8002194:	f7ff f816 	bl	80011c4 <MCI_FaultAcknowledged>
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002198:	89e3      	ldrh	r3, [r4, #14]
        MCPResponse = MCP_CMD_OK;
 800219a:	2000      	movs	r0, #0
        break;
 800219c:	e7af      	b.n	80020fe <MCP_ReceivedPacket+0x9a>
        MCPResponse = MC_ProfilerCommand(pHandle->rxLength, pHandle->rxBuffer, txSyncFreeSpace, &pHandle->txLength,
 800219e:	68a3      	ldr	r3, [r4, #8]
 80021a0:	9300      	str	r3, [sp, #0]
 80021a2:	4631      	mov	r1, r6
 80021a4:	f104 030e 	add.w	r3, r4, #14
 80021a8:	f7fe ff32 	bl	8001010 <MC_ProfilerCommand>
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 80021ac:	89e3      	ldrh	r3, [r4, #14]
        break;
 80021ae:	e7a6      	b.n	80020fe <MCP_ReceivedPacket+0x9a>
        if ((userCommand < MCP_USER_CALLBACK_MAX) && (MCP_UserCallBack[userCommand] != NULL))
 80021b0:	4b09      	ldr	r3, [pc, #36]	@ (80021d8 <MCP_ReceivedPacket+0x174>)
 80021b2:	f853 502c 	ldr.w	r5, [r3, ip, lsl #2]
 80021b6:	b15d      	cbz	r5, 80021d0 <MCP_ReceivedPacket+0x16c>
          MCPResponse = MCP_UserCallBack[userCommand](pHandle->rxLength, pHandle->rxBuffer, txSyncFreeSpace,
 80021b8:	68a3      	ldr	r3, [r4, #8]
 80021ba:	9300      	str	r3, [sp, #0]
 80021bc:	4631      	mov	r1, r6
 80021be:	f104 030e 	add.w	r3, r4, #14
 80021c2:	47a8      	blx	r5
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 80021c4:	89e3      	ldrh	r3, [r4, #14]
          MCPResponse = MCP_UserCallBack[userCommand](pHandle->rxLength, pHandle->rxBuffer, txSyncFreeSpace,
 80021c6:	e79a      	b.n	80020fe <MCP_ReceivedPacket+0x9a>
          MCI_StopRamp(pMCI);
 80021c8:	4638      	mov	r0, r7
 80021ca:	f7ff f861 	bl	8001290 <MCI_StopRamp>
 80021ce:	e7dd      	b.n	800218c <MCP_ReceivedPacket+0x128>
 80021d0:	462b      	mov	r3, r5
 80021d2:	e7b0      	b.n	8002136 <MCP_ReceivedPacket+0xd2>
 80021d4:	20000000 	.word	0x20000000
 80021d8:	20000808 	.word	0x20000808

080021dc <MX_MotorControl_Init>:
 *
 * CubeMX calls this function after all peripherals initializations and
 * before the NVIC is configured
 */
__weak void MX_MotorControl_Init(void)
{
 80021dc:	b508      	push	{r3, lr}

  /* Initialize the Motor Control Subsystem */
  MCboot(pMCI);
 80021de:	4803      	ldr	r0, [pc, #12]	@ (80021ec <MX_MotorControl_Init+0x10>)
 80021e0:	f7ff f976 	bl	80014d0 <MCboot>
  mc_lock_pins();
}
 80021e4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  mc_lock_pins();
 80021e8:	f7ff baaa 	b.w	8001740 <mc_lock_pins>
 80021ec:	20001994 	.word	0x20001994

080021f0 <vPortSetupTimerInterrupt>:

void vPortSetupTimerInterrupt( void )
{
 80021f0:	b508      	push	{r3, lr}
  /* Reconfigure the SysTick interrupt to fire every 500 us. */
  (void)HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/SYS_TICK_FREQUENCY);
 80021f2:	f003 fd1b 	bl	8005c2c <HAL_RCC_GetHCLKFreq>
 80021f6:	4b04      	ldr	r3, [pc, #16]	@ (8002208 <vPortSetupTimerInterrupt+0x18>)
 80021f8:	fba3 3000 	umull	r3, r0, r3, r0
 80021fc:	09c0      	lsrs	r0, r0, #7
}
 80021fe:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  (void)HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/SYS_TICK_FREQUENCY);
 8002202:	f002 bf63 	b.w	80050cc <HAL_SYSTICK_Config>
 8002206:	bf00      	nop
 8002208:	10624dd3 	.word	0x10624dd3

0800220c <startTimers>:
  *         @arg @ref LL_TIM_TS_ETRF
  * @retval None
  */
__STATIC_INLINE void LL_TIM_SetTriggerInput(TIM_TypeDef *TIMx, uint32_t TriggerInput)
{
  MODIFY_REG(TIMx->SMCR, TIM_SMCR_TS, TriggerInput);
 800220c:	4922      	ldr	r1, [pc, #136]	@ (8002298 <startTimers+0x8c>)
  *         (*) value not defined in all devices.
  * @retval State of Periphs (1 or 0).
  */
__STATIC_INLINE uint32_t LL_APB1_GRP1_IsEnabledClock(uint32_t Periphs)
{
  return ((READ_BIT(RCC->APB1ENR1, Periphs) == Periphs) ? 1UL : 0UL);
 800220e:	4a23      	ldr	r2, [pc, #140]	@ (800229c <startTimers+0x90>)
 8002210:	688b      	ldr	r3, [r1, #8]
 8002212:	f423 1340 	bic.w	r3, r3, #3145728	@ 0x300000
 8002216:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 800221a:	f043 0310 	orr.w	r3, r3, #16
  * When this function is called, TIM1 and/or TIM8 must be in a frozen state
  * with CNT, ARR, REP RATE and trigger correctly set (these settings are
  * usually performed in the Init method accordingly with the configuration)
  */
__weak void startTimers(void)
{
 800221e:	b410      	push	{r4}
 8002220:	608b      	str	r3, [r1, #8]
  MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, SlaveMode);
 8002222:	688b      	ldr	r3, [r1, #8]
 8002224:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8002228:	f023 0307 	bic.w	r3, r3, #7
 800222c:	f043 0306 	orr.w	r3, r3, #6
 8002230:	608b      	str	r3, [r1, #8]
 8002232:	6d93      	ldr	r3, [r2, #88]	@ 0x58
 8002234:	07db      	lsls	r3, r3, #31
 8002236:	b083      	sub	sp, #12
 8002238:	d416      	bmi.n	8002268 <startTimers+0x5c>
  SET_BIT(RCC->APB1ENR1, Periphs);
 800223a:	6d93      	ldr	r3, [r2, #88]	@ 0x58
 800223c:	f043 0301 	orr.w	r3, r3, #1
 8002240:	6593      	str	r3, [r2, #88]	@ 0x58
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 8002242:	6d93      	ldr	r3, [r2, #88]	@ 0x58
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_GenerateEvent_UPDATE(TIM_TypeDef *TIMx)
{
  SET_BIT(TIMx->EGR, TIM_EGR_UG);
 8002244:	f04f 4180 	mov.w	r1, #1073741824	@ 0x40000000
 8002248:	f003 0301 	and.w	r3, r3, #1
 800224c:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 800224e:	9b01      	ldr	r3, [sp, #4]
 8002250:	694b      	ldr	r3, [r1, #20]
 8002252:	f043 0301 	orr.w	r3, r3, #1
 8002256:	614b      	str	r3, [r1, #20]
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_APB1_GRP1_DisableClock(uint32_t Periphs)
{
  CLEAR_BIT(RCC->APB1ENR1, Periphs);
 8002258:	6d93      	ldr	r3, [r2, #88]	@ 0x58
 800225a:	f023 0301 	bic.w	r3, r3, #1
 800225e:	6593      	str	r3, [r2, #88]	@ 0x58
    trigOut = LL_TIM_ReadReg(TIM2, CR2) & TIM_CR2_MMS;
    LL_TIM_SetTriggerOutput(TIM2, LL_TIM_TRGO_UPDATE);
    LL_TIM_GenerateEvent_UPDATE(TIM2);
    LL_TIM_SetTriggerOutput(TIM2, trigOut);
  }
}
 8002260:	b003      	add	sp, #12
 8002262:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002266:	4770      	bx	lr
    trigOut = LL_TIM_ReadReg(TIM2, CR2) & TIM_CR2_MMS;
 8002268:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 800226c:	480c      	ldr	r0, [pc, #48]	@ (80022a0 <startTimers+0x94>)
 800226e:	685a      	ldr	r2, [r3, #4]
 8002270:	6859      	ldr	r1, [r3, #4]
 8002272:	4c0c      	ldr	r4, [pc, #48]	@ (80022a4 <startTimers+0x98>)
 8002274:	4001      	ands	r1, r0
 8002276:	f041 0120 	orr.w	r1, r1, #32
 800227a:	6059      	str	r1, [r3, #4]
  SET_BIT(TIMx->EGR, TIM_EGR_UG);
 800227c:	6959      	ldr	r1, [r3, #20]
 800227e:	f041 0101 	orr.w	r1, r1, #1
 8002282:	6159      	str	r1, [r3, #20]
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 8002284:	6859      	ldr	r1, [r3, #4]
 8002286:	4022      	ands	r2, r4
 8002288:	4001      	ands	r1, r0
 800228a:	430a      	orrs	r2, r1
 800228c:	605a      	str	r2, [r3, #4]
}
 800228e:	b003      	add	sp, #12
 8002290:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002294:	4770      	bx	lr
 8002296:	bf00      	nop
 8002298:	40012c00 	.word	0x40012c00
 800229c:	40021000 	.word	0x40021000
 80022a0:	fdffff8f 	.word	0xfdffff8f
 80022a4:	02000070 	.word	0x02000070

080022a8 <waitForPolarizationEnd>:
  {
#endif
    uint16_t hCalibrationPeriodCounter;
    uint16_t hMaxPeriodsNumber;

    hMaxPeriodsNumber = ((uint16_t)2 * NB_CONVERSIONS) * (((uint16_t)repCnt + 1U) >> 1);
 80022a8:	3201      	adds	r2, #1
{
 80022aa:	b570      	push	{r4, r5, r6, lr}
    hMaxPeriodsNumber = ((uint16_t)2 * NB_CONVERSIONS) * (((uint16_t)repCnt + 1U) >> 1);
 80022ac:	0852      	lsrs	r2, r2, #1
  WRITE_REG(TIMx->SR, ~(TIM_SR_CC1IF));
 80022ae:	f06f 0602 	mvn.w	r6, #2
 80022b2:	0155      	lsls	r5, r2, #5
 80022b4:	6106      	str	r6, [r0, #16]

    /* Wait for NB_CONVERSIONS to be executed */
    LL_TIM_ClearFlag_CC1(TIMx);
    hCalibrationPeriodCounter = 0u;
 80022b6:	2200      	movs	r2, #0
    while (*cnt < NB_CONVERSIONS)
 80022b8:	f893 c000 	ldrb.w	ip, [r3]
 80022bc:	f1bc 0f0f 	cmp.w	ip, #15
    {
      if ((uint32_t)ERROR == LL_TIM_IsActiveFlag_CC1(TIMx))
      {
        LL_TIM_ClearFlag_CC1(TIMx);
        hCalibrationPeriodCounter++;
 80022c0:	f102 0e01 	add.w	lr, r2, #1
    while (*cnt < NB_CONVERSIONS)
 80022c4:	d80c      	bhi.n	80022e0 <waitForPolarizationEnd+0x38>
  return ((READ_BIT(TIMx->SR, TIM_SR_CC1IF) == (TIM_SR_CC1IF)) ? 1UL : 0UL);
 80022c6:	6904      	ldr	r4, [r0, #16]
 80022c8:	07a4      	lsls	r4, r4, #30
 80022ca:	d5f5      	bpl.n	80022b8 <waitForPolarizationEnd+0x10>
        hCalibrationPeriodCounter++;
 80022cc:	fa1f f28e 	uxth.w	r2, lr
        if (hCalibrationPeriodCounter >= hMaxPeriodsNumber)
 80022d0:	4295      	cmp	r5, r2
  WRITE_REG(TIMx->SR, ~(TIM_SR_CC1IF));
 80022d2:	6106      	str	r6, [r0, #16]
 80022d4:	d8f0      	bhi.n	80022b8 <waitForPolarizationEnd+0x10>
        {
          if (*cnt < NB_CONVERSIONS)
 80022d6:	781c      	ldrb	r4, [r3, #0]
 80022d8:	2c0f      	cmp	r4, #15
 80022da:	d8ed      	bhi.n	80022b8 <waitForPolarizationEnd+0x10>
          {
            *SWerror = 1u;
 80022dc:	2301      	movs	r3, #1
 80022de:	800b      	strh	r3, [r1, #0]
      }
    }
#ifdef NULL_PTR_CHECK_POW_COM
  }
#endif
  }
 80022e0:	bd70      	pop	{r4, r5, r6, pc}
 80022e2:	bf00      	nop

080022e4 <PWMC_SetPhaseVoltage>:
  * @param  Valfa_beta: Voltage Components expressed in the @f$(\alpha, \beta)@f$ reference frame.
  * @retval #MC_NO_ERROR if no error occurred or #MC_DURATION if the duty cycles were
  *         set too late for being taken into account in the next PWM cycle.
  */
__weak uint16_t PWMC_SetPhaseVoltage(PWMC_Handle_t *pHandle, alphabeta_t Valfa_beta)
{
 80022e4:	b530      	push	{r4, r5, lr}
    int32_t wTimePhA;
    int32_t wTimePhB;
    int32_t wTimePhC;

    wUAlpha = Valfa_beta.alpha * (int32_t)pHandle->hT_Sqrt3;
    wUBeta = -(Valfa_beta.beta * ((int32_t)pHandle->PWMperiod)) * 2;
 80022e6:	f8b0 4070 	ldrh.w	r4, [r0, #112]	@ 0x70
    wUAlpha = Valfa_beta.alpha * (int32_t)pHandle->hT_Sqrt3;
 80022ea:	f8b0 204e 	ldrh.w	r2, [r0, #78]	@ 0x4e
    wUBeta = -(Valfa_beta.beta * ((int32_t)pHandle->PWMperiod)) * 2;
 80022ee:	ea4f 4c21 	mov.w	ip, r1, asr #16
    wUAlpha = Valfa_beta.alpha * (int32_t)pHandle->hT_Sqrt3;
 80022f2:	b20b      	sxth	r3, r1
    wUBeta = -(Valfa_beta.beta * ((int32_t)pHandle->PWMperiod)) * 2;
 80022f4:	fb04 fc0c 	mul.w	ip, r4, ip
 80022f8:	ebcc 7ccc 	rsb	ip, ip, ip, lsl #31
    wUAlpha = Valfa_beta.alpha * (int32_t)pHandle->hT_Sqrt3;
 80022fc:	fb02 f303 	mul.w	r3, r2, r3

    wX = wUBeta;
    wY = (wUBeta + wUAlpha) / 2;
 8002300:	eb03 024c 	add.w	r2, r3, ip, lsl #1
    wZ = (wUBeta - wUAlpha) / 2;
 8002304:	ebc3 034c 	rsb	r3, r3, ip, lsl #1
    wY = (wUBeta + wUAlpha) / 2;
 8002308:	eb02 7ed2 	add.w	lr, r2, r2, lsr #31
    wZ = (wUBeta - wUAlpha) / 2;
 800230c:	eb03 71d3 	add.w	r1, r3, r3, lsr #31

    /* Sector calculation from wX, wY, wZ */
    if (wY < 0)
 8002310:	1c55      	adds	r5, r2, #1
{
 8002312:	b083      	sub	sp, #12
    {
      if (wZ < 0)
      {
        pHandle->Sector = SECTOR_5;
        wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wY - wZ) / (int32_t)262144);
 8002314:	ea4f 0494 	mov.w	r4, r4, lsr #2
    wUBeta = -(Valfa_beta.beta * ((int32_t)pHandle->PWMperiod)) * 2;
 8002318:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
    wY = (wUBeta + wUAlpha) / 2;
 800231c:	ea4f 0e6e 	mov.w	lr, lr, asr #1
    wZ = (wUBeta - wUAlpha) / 2;
 8002320:	ea4f 0161 	mov.w	r1, r1, asr #1
    if (wY < 0)
 8002324:	db6b      	blt.n	80023fe <PWMC_SetPhaseVoltage+0x11a>
        }
        }
    }
    else /* wY > 0 */
    {
      if (wZ >= 0)
 8002326:	1c5d      	adds	r5, r3, #1
 8002328:	db3d      	blt.n	80023a6 <PWMC_SetPhaseVoltage+0xc2>
      {
        pHandle->Sector = SECTOR_2;
        wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wY - wZ) / (int32_t)262144);
 800232a:	ebbe 0e01 	subs.w	lr, lr, r1
 800232e:	bf44      	itt	mi
 8002330:	f50e 3e7f 	addmi.w	lr, lr, #261120	@ 0x3fc00
 8002334:	f20e 3eff 	addwmi	lr, lr, #1023	@ 0x3ff
        wTimePhB = wTimePhA + (wZ / 131072);
 8002338:	2b00      	cmp	r3, #0
 800233a:	bfbc      	itt	lt
 800233c:	f503 337f 	addlt.w	r3, r3, #261120	@ 0x3fc00
 8002340:	f203 33ff 	addwlt	r3, r3, #1023	@ 0x3ff
        wTimePhC = wTimePhA - (wY / 131072);
 8002344:	2a00      	cmp	r2, #0
 8002346:	bfb8      	it	lt
 8002348:	f502 327f 	addlt.w	r2, r2, #261120	@ 0x3fc00

        if(true == pHandle->SingleShuntTopology)
 800234c:	f890 1085 	ldrb.w	r1, [r0, #133]	@ 0x85
        wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wY - wZ) / (int32_t)262144);
 8002350:	eb04 4eae 	add.w	lr, r4, lr, asr #18
        pHandle->Sector = SECTOR_2;
 8002354:	f04f 0501 	mov.w	r5, #1
        wTimePhC = wTimePhA - (wY / 131072);
 8002358:	bfb8      	it	lt
 800235a:	f202 32ff 	addwlt	r2, r2, #1023	@ 0x3ff
        pHandle->Sector = SECTOR_2;
 800235e:	f880 507a 	strb.w	r5, [r0, #122]	@ 0x7a
        wTimePhB = wTimePhA + (wZ / 131072);
 8002362:	eb0e 43a3 	add.w	r3, lr, r3, asr #18
        wTimePhC = wTimePhA - (wY / 131072);
 8002366:	ebae 42a2 	sub.w	r2, lr, r2, asr #18
        if(true == pHandle->SingleShuntTopology)
 800236a:	2900      	cmp	r1, #0
 800236c:	d16e      	bne.n	800244c <PWMC_SetPhaseVoltage+0x168>
          pHandle->midDuty = 0U;
          pHandle->highDuty = 1U;
        }
        else
        {
        pHandle->lowDuty = (uint16_t)wTimePhB;
 800236e:	fa1f fc83 	uxth.w	ip, r3
        pHandle->midDuty = (uint16_t)wTimePhA;
 8002372:	fa1f f48e 	uxth.w	r4, lr
        pHandle->highDuty = (uint16_t)wTimePhC;
 8002376:	b291      	uxth	r1, r2
            pHandle->highDuty = 2U;
 8002378:	f8a0 105c 	strh.w	r1, [r0, #92]	@ 0x5c

    pHandle->CntPhA = (uint16_t)(MAX(wTimePhA, 0));
    pHandle->CntPhB = (uint16_t)(MAX(wTimePhB, 0));
    pHandle->CntPhC = (uint16_t)(MAX(wTimePhC, 0));

    returnValue = pHandle->pFctSetADCSampPointSectX(pHandle);
 800237c:	6941      	ldr	r1, [r0, #20]
            pHandle->lowDuty = 0U;
 800237e:	f8a0 c058 	strh.w	ip, [r0, #88]	@ 0x58
    pHandle->CntPhA = (uint16_t)(MAX(wTimePhA, 0));
 8002382:	ea2e 7eee 	bic.w	lr, lr, lr, asr #31
    pHandle->CntPhB = (uint16_t)(MAX(wTimePhB, 0));
 8002386:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    pHandle->CntPhC = (uint16_t)(MAX(wTimePhC, 0));
 800238a:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
            pHandle->midDuty = 1U;
 800238e:	f8a0 405a 	strh.w	r4, [r0, #90]	@ 0x5a
    pHandle->CntPhA = (uint16_t)(MAX(wTimePhA, 0));
 8002392:	f8a0 e050 	strh.w	lr, [r0, #80]	@ 0x50
    pHandle->CntPhB = (uint16_t)(MAX(wTimePhB, 0));
 8002396:	f8a0 3052 	strh.w	r3, [r0, #82]	@ 0x52
    pHandle->CntPhC = (uint16_t)(MAX(wTimePhC, 0));
 800239a:	f8a0 2054 	strh.w	r2, [r0, #84]	@ 0x54
#ifdef NULL_PTR_CHECK_PWR_CUR_FDB
  }
#endif
  return (returnValue);
}
 800239e:	b003      	add	sp, #12
 80023a0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    returnValue = pHandle->pFctSetADCSampPointSectX(pHandle);
 80023a4:	4708      	bx	r1
        if ( wX <= 0 )
 80023a6:	f1bc 0f00 	cmp.w	ip, #0
 80023aa:	dd7b      	ble.n	80024a4 <PWMC_SetPhaseVoltage+0x1c0>
          wTimePhB = wTimePhA + (wZ / 131072);
 80023ac:	2b00      	cmp	r3, #0
 80023ae:	bfb8      	it	lt
 80023b0:	f503 337f 	addlt.w	r3, r3, #261120	@ 0x3fc00
          wTimePhA = (((int32_t)pHandle->PWMperiod) / 4)+ ((wX - wZ) / (int32_t)262144);
 80023b4:	ebac 0101 	sub.w	r1, ip, r1
          wTimePhB = wTimePhA + (wZ / 131072);
 80023b8:	bfb8      	it	lt
 80023ba:	f203 33ff 	addwlt	r3, r3, #1023	@ 0x3ff
          wTimePhC = wTimePhB - (wX / 131072);
 80023be:	f1bc 0f00 	cmp.w	ip, #0
          wTimePhA = (((int32_t)pHandle->PWMperiod) / 4)+ ((wX - wZ) / (int32_t)262144);
 80023c2:	eb04 4ea1 	add.w	lr, r4, r1, asr #18
          wTimePhC = wTimePhB - (wX / 131072);
 80023c6:	bfb8      	it	lt
 80023c8:	f50c 3cff 	addlt.w	ip, ip, #130560	@ 0x1fe00
          if((pHandle->DPWM_Mode == true) || (pHandle->SingleShuntTopology == true))
 80023cc:	f890 107d 	ldrb.w	r1, [r0, #125]	@ 0x7d
          pHandle->Sector = SECTOR_1;
 80023d0:	f04f 0200 	mov.w	r2, #0
          wTimePhB = wTimePhA + (wZ / 131072);
 80023d4:	eb0e 43a3 	add.w	r3, lr, r3, asr #18
          wTimePhC = wTimePhB - (wX / 131072);
 80023d8:	bfb8      	it	lt
 80023da:	f20c 1cff 	addwlt	ip, ip, #511	@ 0x1ff
          pHandle->Sector = SECTOR_1;
 80023de:	f880 207a 	strb.w	r2, [r0, #122]	@ 0x7a
          wTimePhC = wTimePhB - (wX / 131072);
 80023e2:	eba3 426c 	sub.w	r2, r3, ip, asr #17
          if((pHandle->DPWM_Mode == true) || (pHandle->SingleShuntTopology == true))
 80023e6:	2900      	cmp	r1, #0
 80023e8:	f040 80ae 	bne.w	8002548 <PWMC_SetPhaseVoltage+0x264>
 80023ec:	f890 4085 	ldrb.w	r4, [r0, #133]	@ 0x85
 80023f0:	2c00      	cmp	r4, #0
 80023f2:	f000 80b9 	beq.w	8002568 <PWMC_SetPhaseVoltage+0x284>
 80023f6:	f04f 0c02 	mov.w	ip, #2
 80023fa:	2401      	movs	r4, #1
 80023fc:	e7bc      	b.n	8002378 <PWMC_SetPhaseVoltage+0x94>
      if (wZ < 0)
 80023fe:	f1b3 3fff 	cmp.w	r3, #4294967295
        if(true == pHandle->SingleShuntTopology)
 8002402:	f890 5085 	ldrb.w	r5, [r0, #133]	@ 0x85
      if (wZ < 0)
 8002406:	db70      	blt.n	80024ea <PWMC_SetPhaseVoltage+0x206>
        if (wX <= 0)
 8002408:	f1bc 0f00 	cmp.w	ip, #0
 800240c:	dd23      	ble.n	8002456 <PWMC_SetPhaseVoltage+0x172>
          wTimePhA = (((int32_t )pHandle->PWMperiod) / 4)+ ((wY - wX) / (int32_t)262144);
 800240e:	ebbe 0e0c 	subs.w	lr, lr, ip
 8002412:	bf44      	itt	mi
 8002414:	f50e 3e7f 	addmi.w	lr, lr, #261120	@ 0x3fc00
 8002418:	f20e 3eff 	addwmi	lr, lr, #1023	@ 0x3ff
          wTimePhC = wTimePhA - (wY / 131072);
 800241c:	2a00      	cmp	r2, #0
 800241e:	bfb8      	it	lt
 8002420:	f502 327f 	addlt.w	r2, r2, #261120	@ 0x3fc00
          wTimePhA = (((int32_t )pHandle->PWMperiod) / 4)+ ((wY - wX) / (int32_t)262144);
 8002424:	eb04 4eae 	add.w	lr, r4, lr, asr #18
          wTimePhC = wTimePhA - (wY / 131072);
 8002428:	bfb8      	it	lt
 800242a:	f202 32ff 	addwlt	r2, r2, #1023	@ 0x3ff
          pHandle->Sector = SECTOR_3;
 800242e:	2302      	movs	r3, #2
          wTimePhC = wTimePhA - (wY / 131072);
 8002430:	ebae 42a2 	sub.w	r2, lr, r2, asr #18
          pHandle->Sector = SECTOR_3;
 8002434:	f880 307a 	strb.w	r3, [r0, #122]	@ 0x7a
          wTimePhB = wTimePhC + (wX / 131072);
 8002438:	eb02 436c 	add.w	r3, r2, ip, asr #17
          if(true == pHandle->SingleShuntTopology)
 800243c:	2d00      	cmp	r5, #0
 800243e:	d17e      	bne.n	800253e <PWMC_SetPhaseVoltage+0x25a>
          pHandle->lowDuty = (uint16_t)wTimePhB;
 8002440:	fa1f fc83 	uxth.w	ip, r3
          pHandle->midDuty = (uint16_t)wTimePhC;
 8002444:	b294      	uxth	r4, r2
          pHandle->highDuty = (uint16_t)wTimePhA;
 8002446:	fa1f f18e 	uxth.w	r1, lr
 800244a:	e795      	b.n	8002378 <PWMC_SetPhaseVoltage+0x94>
 800244c:	f04f 0c02 	mov.w	ip, #2
 8002450:	2400      	movs	r4, #0
 8002452:	2101      	movs	r1, #1
 8002454:	e790      	b.n	8002378 <PWMC_SetPhaseVoltage+0x94>
          wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wX - wZ) / (int32_t)262144);
 8002456:	ebbc 0101 	subs.w	r1, ip, r1
 800245a:	bf44      	itt	mi
 800245c:	f501 317f 	addmi.w	r1, r1, #261120	@ 0x3fc00
 8002460:	f201 31ff 	addwmi	r1, r1, #1023	@ 0x3ff
          wTimePhB = wTimePhA + (wZ / 131072);
 8002464:	2b00      	cmp	r3, #0
 8002466:	bfb8      	it	lt
 8002468:	f503 337f 	addlt.w	r3, r3, #261120	@ 0x3fc00
          pHandle->Sector = SECTOR_4;
 800246c:	f04f 0203 	mov.w	r2, #3
          wTimePhB = wTimePhA + (wZ / 131072);
 8002470:	bfb8      	it	lt
 8002472:	f203 33ff 	addwlt	r3, r3, #1023	@ 0x3ff
          pHandle->Sector = SECTOR_4;
 8002476:	f880 207a 	strb.w	r2, [r0, #122]	@ 0x7a
          wTimePhC = wTimePhB - (wX / 131072);
 800247a:	f1bc 0200 	subs.w	r2, ip, #0
 800247e:	bfb8      	it	lt
 8002480:	f502 32ff 	addlt.w	r2, r2, #130560	@ 0x1fe00
          wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wX - wZ) / (int32_t)262144);
 8002484:	eb04 4ea1 	add.w	lr, r4, r1, asr #18
          wTimePhB = wTimePhA + (wZ / 131072);
 8002488:	eb0e 43a3 	add.w	r3, lr, r3, asr #18
          wTimePhC = wTimePhB - (wX / 131072);
 800248c:	bfb8      	it	lt
 800248e:	f202 12ff 	addwlt	r2, r2, #511	@ 0x1ff
 8002492:	eba3 4262 	sub.w	r2, r3, r2, asr #17
          if(true == pHandle->SingleShuntTopology)
 8002496:	2d00      	cmp	r5, #0
 8002498:	d060      	beq.n	800255c <PWMC_SetPhaseVoltage+0x278>
 800249a:	f04f 0c00 	mov.w	ip, #0
 800249e:	2401      	movs	r4, #1
 80024a0:	2102      	movs	r1, #2
 80024a2:	e769      	b.n	8002378 <PWMC_SetPhaseVoltage+0x94>
          wTimePhC = wTimePhA - (wY / 131072);
 80024a4:	2a00      	cmp	r2, #0
 80024a6:	bfb8      	it	lt
 80024a8:	f502 327f 	addlt.w	r2, r2, #261120	@ 0x3fc00
          pHandle->Sector = SECTOR_6;
 80024ac:	f04f 0305 	mov.w	r3, #5
          wTimePhC = wTimePhA - (wY / 131072);
 80024b0:	bfb8      	it	lt
 80024b2:	f202 32ff 	addwlt	r2, r2, #1023	@ 0x3ff
          wTimePhA = (((int32_t )pHandle->PWMperiod) / 4) + ((wY - wX) / (int32_t)262144);
 80024b6:	ebae 0e0c 	sub.w	lr, lr, ip
          pHandle->Sector = SECTOR_6;
 80024ba:	f880 307a 	strb.w	r3, [r0, #122]	@ 0x7a
          wTimePhB = wTimePhC + (wX / 131072);
 80024be:	f1bc 0300 	subs.w	r3, ip, #0
 80024c2:	bfb8      	it	lt
 80024c4:	f503 33ff 	addlt.w	r3, r3, #130560	@ 0x1fe00
          wTimePhA = (((int32_t )pHandle->PWMperiod) / 4) + ((wY - wX) / (int32_t)262144);
 80024c8:	eb04 4eae 	add.w	lr, r4, lr, asr #18
          if(true == pHandle->SingleShuntTopology)
 80024cc:	f890 1085 	ldrb.w	r1, [r0, #133]	@ 0x85
          wTimePhC = wTimePhA - (wY / 131072);
 80024d0:	ebae 42a2 	sub.w	r2, lr, r2, asr #18
          wTimePhB = wTimePhC + (wX / 131072);
 80024d4:	bfb8      	it	lt
 80024d6:	f203 13ff 	addwlt	r3, r3, #511	@ 0x1ff
 80024da:	eb02 4363 	add.w	r3, r2, r3, asr #17
          if(true == pHandle->SingleShuntTopology)
 80024de:	b3c1      	cbz	r1, 8002552 <PWMC_SetPhaseVoltage+0x26e>
 80024e0:	f04f 0c01 	mov.w	ip, #1
 80024e4:	2402      	movs	r4, #2
 80024e6:	2100      	movs	r1, #0
 80024e8:	e746      	b.n	8002378 <PWMC_SetPhaseVoltage+0x94>
        wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wY - wZ) / (int32_t)262144);
 80024ea:	ebbe 0e01 	subs.w	lr, lr, r1
 80024ee:	bf44      	itt	mi
 80024f0:	f50e 3e7f 	addmi.w	lr, lr, #261120	@ 0x3fc00
 80024f4:	f20e 3eff 	addwmi	lr, lr, #1023	@ 0x3ff
        wTimePhB = wTimePhA + (wZ / 131072);
 80024f8:	2b00      	cmp	r3, #0
 80024fa:	bfbc      	itt	lt
 80024fc:	f503 337f 	addlt.w	r3, r3, #261120	@ 0x3fc00
 8002500:	f203 33ff 	addwlt	r3, r3, #1023	@ 0x3ff
        wTimePhC = wTimePhA - (wY / 131072) ;
 8002504:	2a00      	cmp	r2, #0
 8002506:	bfb8      	it	lt
 8002508:	f502 327f 	addlt.w	r2, r2, #261120	@ 0x3fc00
        wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wY - wZ) / (int32_t)262144);
 800250c:	eb04 4eae 	add.w	lr, r4, lr, asr #18
        pHandle->Sector = SECTOR_5;
 8002510:	f04f 0c04 	mov.w	ip, #4
        wTimePhC = wTimePhA - (wY / 131072) ;
 8002514:	bfb8      	it	lt
 8002516:	f202 32ff 	addwlt	r2, r2, #1023	@ 0x3ff
        pHandle->Sector = SECTOR_5;
 800251a:	f880 c07a 	strb.w	ip, [r0, #122]	@ 0x7a
        wTimePhB = wTimePhA + (wZ / 131072);
 800251e:	eb0e 43a3 	add.w	r3, lr, r3, asr #18
        wTimePhC = wTimePhA - (wY / 131072) ;
 8002522:	ebae 42a2 	sub.w	r2, lr, r2, asr #18
        if(true == pHandle->SingleShuntTopology)
 8002526:	b92d      	cbnz	r5, 8002534 <PWMC_SetPhaseVoltage+0x250>
          pHandle->lowDuty = (uint16_t)wTimePhC;
 8002528:	fa1f fc82 	uxth.w	ip, r2
          pHandle->midDuty = (uint16_t)wTimePhA;
 800252c:	fa1f f48e 	uxth.w	r4, lr
          pHandle->highDuty = (uint16_t)wTimePhB;
 8002530:	b299      	uxth	r1, r3
 8002532:	e721      	b.n	8002378 <PWMC_SetPhaseVoltage+0x94>
 8002534:	f04f 0c01 	mov.w	ip, #1
 8002538:	2400      	movs	r4, #0
 800253a:	2102      	movs	r1, #2
 800253c:	e71c      	b.n	8002378 <PWMC_SetPhaseVoltage+0x94>
 800253e:	f04f 0c00 	mov.w	ip, #0
 8002542:	2402      	movs	r4, #2
 8002544:	2101      	movs	r1, #1
 8002546:	e717      	b.n	8002378 <PWMC_SetPhaseVoltage+0x94>
 8002548:	f04f 0c02 	mov.w	ip, #2
 800254c:	2401      	movs	r4, #1
 800254e:	2100      	movs	r1, #0
 8002550:	e712      	b.n	8002378 <PWMC_SetPhaseVoltage+0x94>
            pHandle->lowDuty = (uint16_t)wTimePhA;
 8002552:	fa1f fc8e 	uxth.w	ip, lr
            pHandle->midDuty = (uint16_t)wTimePhC;
 8002556:	b294      	uxth	r4, r2
            pHandle->highDuty = (uint16_t)wTimePhB;
 8002558:	b299      	uxth	r1, r3
 800255a:	e70d      	b.n	8002378 <PWMC_SetPhaseVoltage+0x94>
          pHandle->lowDuty = (uint16_t)wTimePhC;
 800255c:	fa1f fc82 	uxth.w	ip, r2
          pHandle->midDuty = (uint16_t)wTimePhB;
 8002560:	b29c      	uxth	r4, r3
          pHandle->highDuty = (uint16_t)wTimePhA;
 8002562:	fa1f f18e 	uxth.w	r1, lr
 8002566:	e707      	b.n	8002378 <PWMC_SetPhaseVoltage+0x94>
            pHandle->lowDuty = (uint16_t)wTimePhA;
 8002568:	fa1f fc8e 	uxth.w	ip, lr
            pHandle->midDuty = (uint16_t)wTimePhB;
 800256c:	b29c      	uxth	r4, r3
            pHandle->highDuty = (uint16_t)wTimePhC;
 800256e:	b291      	uxth	r1, r2
 8002570:	e702      	b.n	8002378 <PWMC_SetPhaseVoltage+0x94>
 8002572:	bf00      	nop

08002574 <PWMC_SwitchOffPWM>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->pFctSwitchOffPwm(pHandle);
 8002574:	6843      	ldr	r3, [r0, #4]
 8002576:	4718      	bx	r3

08002578 <PWMC_SwitchOnPWM>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->pFctSwitchOnPwm(pHandle);
 8002578:	6883      	ldr	r3, [r0, #8]
 800257a:	4718      	bx	r3

0800257c <PWMC_CurrentReadingCalibr>:
  *         #CRC_EXEC to execute the offset calibration.
  * @retval true if the current calibration has been completed, **false** if it is
  *         still ongoing.
  */
__weak bool PWMC_CurrentReadingCalibr(PWMC_Handle_t *pHandle, CRCAction_t action)
{
 800257c:	b510      	push	{r4, lr}
 800257e:	4604      	mov	r4, r0
    /* Nothing to do */
  }
  else
  {
#endif
    if (CRC_START == action)
 8002580:	b179      	cbz	r1, 80025a2 <PWMC_CurrentReadingCalibr+0x26>
    {
      PWMC_SwitchOffPWM(pHandle);
      pHandle->pFctCurrReadingCalib(pHandle);
      retVal = true;
    }
    else if (CRC_EXEC == action)
 8002582:	2901      	cmp	r1, #1
 8002584:	d001      	beq.n	800258a <PWMC_CurrentReadingCalibr+0xe>
  bool retVal = false;
 8002586:	2000      	movs	r0, #0
    }
#ifdef NULL_PTR_CHECK_PWR_CUR_FDB
  }
#endif
  return (retVal);
}
 8002588:	bd10      	pop	{r4, pc}
      if (pHandle->OffCalibrWaitTimeCounter > 0u)
 800258a:	f8b0 3060 	ldrh.w	r3, [r0, #96]	@ 0x60
 800258e:	b16b      	cbz	r3, 80025ac <PWMC_CurrentReadingCalibr+0x30>
        pHandle->OffCalibrWaitTimeCounter--;
 8002590:	3b01      	subs	r3, #1
 8002592:	b29b      	uxth	r3, r3
 8002594:	f8a0 3060 	strh.w	r3, [r0, #96]	@ 0x60
        if (0U == pHandle->OffCalibrWaitTimeCounter)
 8002598:	2b00      	cmp	r3, #0
 800259a:	d1f4      	bne.n	8002586 <PWMC_CurrentReadingCalibr+0xa>
          pHandle->pFctCurrReadingCalib(pHandle);
 800259c:	68c3      	ldr	r3, [r0, #12]
 800259e:	4798      	blx	r3
          retVal = true;
 80025a0:	e004      	b.n	80025ac <PWMC_CurrentReadingCalibr+0x30>
      PWMC_SwitchOffPWM(pHandle);
 80025a2:	f7ff ffe7 	bl	8002574 <PWMC_SwitchOffPWM>
      pHandle->pFctCurrReadingCalib(pHandle);
 80025a6:	68e3      	ldr	r3, [r4, #12]
 80025a8:	4620      	mov	r0, r4
 80025aa:	4798      	blx	r3
      retVal = true;
 80025ac:	2001      	movs	r0, #1
}
 80025ae:	bd10      	pop	{r4, pc}

080025b0 <PWMC_OCP_Handler>:
    tempPointer = MC_NULL;
  }
  else
  {
#endif
    if (false == pHandle->BrakeActionLock)
 80025b0:	f890 3083 	ldrb.w	r3, [r0, #131]	@ 0x83
 80025b4:	b91b      	cbnz	r3, 80025be <PWMC_OCP_Handler+0xe>
    {
      if (ES_GPIO == pHandle->LowSideOutputs)
 80025b6:	f890 307b 	ldrb.w	r3, [r0, #123]	@ 0x7b
 80025ba:	2b02      	cmp	r3, #2
 80025bc:	d004      	beq.n	80025c8 <PWMC_OCP_Handler+0x18>
    }
    else
    {
      /* Nothing to do */
    }
    pHandle->OverCurrentFlag = true;
 80025be:	2301      	movs	r3, #1
 80025c0:	f880 3080 	strb.w	r3, [r0, #128]	@ 0x80
    tempPointer = &(pHandle->Motor);
#ifdef NULL_PTR_CHECK_PWR_CUR_FDB
  }
#endif
  return (tempPointer);
}
 80025c4:	3078      	adds	r0, #120	@ 0x78
 80025c6:	4770      	bx	lr
        LL_GPIO_ResetOutputPin(pHandle->pwm_en_v_port, pHandle->pwm_en_v_pin);
 80025c8:	e9d0 210f 	ldrd	r2, r1, [r0, #60]	@ 0x3c
{
 80025cc:	b410      	push	{r4}
        LL_GPIO_ResetOutputPin(pHandle->pwm_en_w_port, pHandle->pwm_en_w_pin);
 80025ce:	6c43      	ldr	r3, [r0, #68]	@ 0x44
        LL_GPIO_ResetOutputPin(pHandle->pwm_en_u_port, pHandle->pwm_en_u_pin);
 80025d0:	f8b0 4048 	ldrh.w	r4, [r0, #72]	@ 0x48
  *         @arg @ref LL_GPIO_PIN_ALL
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_ResetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
{
  WRITE_REG(GPIOx->BRR, PinMask);
 80025d4:	6294      	str	r4, [r2, #40]	@ 0x28
        LL_GPIO_ResetOutputPin(pHandle->pwm_en_v_port, pHandle->pwm_en_v_pin);
 80025d6:	f8b0 404a 	ldrh.w	r4, [r0, #74]	@ 0x4a
        LL_GPIO_ResetOutputPin(pHandle->pwm_en_w_port, pHandle->pwm_en_w_pin);
 80025da:	f8b0 204c 	ldrh.w	r2, [r0, #76]	@ 0x4c
 80025de:	628c      	str	r4, [r1, #40]	@ 0x28
 80025e0:	629a      	str	r2, [r3, #40]	@ 0x28
    pHandle->OverCurrentFlag = true;
 80025e2:	2301      	movs	r3, #1
 80025e4:	f880 3080 	strb.w	r3, [r0, #128]	@ 0x80
}
 80025e8:	f85d 4b04 	ldr.w	r4, [sp], #4
 80025ec:	3078      	adds	r0, #120	@ 0x78
 80025ee:	4770      	bx	lr

080025f0 <PWMC_OVP_Handler>:
    tempPointer = MC_NULL;
  }
  else
  {
#endif
    TIMx->BDTR |= LL_TIM_OSSI_ENABLE;
 80025f0:	6c4a      	ldr	r2, [r1, #68]	@ 0x44
{
 80025f2:	4603      	mov	r3, r0
    pHandle->OverVoltageFlag = true;
 80025f4:	f04f 0c01 	mov.w	ip, #1
    TIMx->BDTR |= LL_TIM_OSSI_ENABLE;
 80025f8:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 80025fc:	644a      	str	r2, [r1, #68]	@ 0x44
    tempPointer = &(pHandle->Motor);
#ifdef NULL_PTR_CHECK_PWR_CUR_FDB
  }
#endif
  return (tempPointer);
}
 80025fe:	3078      	adds	r0, #120	@ 0x78
    pHandle->OverVoltageFlag = true;
 8002600:	f883 c081 	strb.w	ip, [r3, #129]	@ 0x81
    pHandle->BrakeActionLock = true;
 8002604:	f883 c083 	strb.w	ip, [r3, #131]	@ 0x83
}
 8002608:	4770      	bx	lr
 800260a:	bf00      	nop

0800260c <PWMC_IsFaultOccurred>:
  * @param  pHdl: Handler of the current instance of the PWM component.
  * @retval uint16_t Returns #MC_OVER_CURR if an overcurrent has been
  *                  detected since last method call, #MC_NO_FAULTS otherwise.
  */
__weak uint16_t PWMC_IsFaultOccurred(PWMC_Handle_t *pHandle)
{
 800260c:	4603      	mov	r3, r0
  uint16_t retVal = MC_NO_FAULTS;

  if (true == pHandle->OverVoltageFlag)
 800260e:	f890 0081 	ldrb.w	r0, [r0, #129]	@ 0x81
 8002612:	b1a8      	cbz	r0, 8002640 <PWMC_IsFaultOccurred+0x34>
  {
    retVal = MC_OVER_VOLT;
    pHandle->OverVoltageFlag = false;
 8002614:	2200      	movs	r2, #0
 8002616:	f883 2081 	strb.w	r2, [r3, #129]	@ 0x81
 800261a:	2142      	movs	r1, #66	@ 0x42
    retVal = MC_OVER_VOLT;
 800261c:	2002      	movs	r0, #2
  else
  {
    /* Nothing to do */
  }

  if (true == pHandle->OverCurrentFlag)
 800261e:	f893 2080 	ldrb.w	r2, [r3, #128]	@ 0x80
 8002622:	b11a      	cbz	r2, 800262c <PWMC_IsFaultOccurred+0x20>
  {
    retVal |= MC_OVER_CURR;
    pHandle->OverCurrentFlag = false;
 8002624:	2200      	movs	r2, #0
 8002626:	f883 2080 	strb.w	r2, [r3, #128]	@ 0x80
    retVal |= MC_OVER_CURR;
 800262a:	4608      	mov	r0, r1
  else
  {
    /* Nothing to do */
  }

  if (true == pHandle->driverProtectionFlag)
 800262c:	f893 2082 	ldrb.w	r2, [r3, #130]	@ 0x82
 8002630:	b12a      	cbz	r2, 800263e <PWMC_IsFaultOccurred+0x32>
  {
    retVal |= MC_DP_FAULT;
 8002632:	f440 6080 	orr.w	r0, r0, #1024	@ 0x400
    pHandle->driverProtectionFlag = false;
 8002636:	2200      	movs	r2, #0
    retVal |= MC_DP_FAULT;
 8002638:	b280      	uxth	r0, r0
    pHandle->driverProtectionFlag = false;
 800263a:	f883 2082 	strb.w	r2, [r3, #130]	@ 0x82
  {
    /* Nothing to do */
  }

  return (retVal);
}
 800263e:	4770      	bx	lr
 8002640:	2140      	movs	r1, #64	@ 0x40
 8002642:	e7ec      	b.n	800261e <PWMC_IsFaultOccurred+0x12>

08002644 <RI_SetRegisterGlobal>:
#include "mcp_config.h"
#include "mcpa.h"
#include "mc_configuration_registers.h"

uint8_t RI_SetRegisterGlobal(uint16_t regID, uint8_t typeID, uint8_t *data, uint16_t *size, int16_t dataAvailable)
{
 8002644:	b410      	push	{r4}
  uint8_t retVal = MCP_CMD_OK;
  switch(typeID)
 8002646:	3908      	subs	r1, #8
{
 8002648:	f9bd c004 	ldrsh.w	ip, [sp, #4]
  switch(typeID)
 800264c:	2920      	cmp	r1, #32
 800264e:	d812      	bhi.n	8002676 <RI_SetRegisterGlobal+0x32>
 8002650:	e8df f001 	tbb	[pc, r1]
 8002654:	11111117 	.word	0x11111117
 8002658:	11111111 	.word	0x11111111
 800265c:	11111121 	.word	0x11111121
 8002660:	11111111 	.word	0x11111111
 8002664:	11111133 	.word	0x11111133
 8002668:	11111111 	.word	0x11111111
 800266c:	1111113d 	.word	0x1111113d
 8002670:	11111111 	.word	0x11111111
 8002674:	51          	.byte	0x51
 8002675:	00          	.byte	0x00
    }

    default:
    {
      retVal = MCP_ERROR_BAD_DATA_TYPE;
      *size =0; /* From this point we are not able anymore to decode the RX buffer */
 8002676:	2200      	movs	r2, #0
 8002678:	801a      	strh	r2, [r3, #0]
      retVal = MCP_ERROR_BAD_DATA_TYPE;
 800267a:	2007      	movs	r0, #7
      break;
    }
  }
  return (retVal);
}
 800267c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002680:	4770      	bx	lr
          retVal = MCP_ERROR_RO_REG;
 8002682:	2848      	cmp	r0, #72	@ 0x48
      *size = 1;
 8002684:	f04f 0201 	mov.w	r2, #1
          retVal = MCP_ERROR_RO_REG;
 8002688:	bf14      	ite	ne
 800268a:	2005      	movne	r0, #5
 800268c:	2004      	moveq	r0, #4
}
 800268e:	f85d 4b04 	ldr.w	r4, [sp], #4
      *size = 1;
 8002692:	801a      	strh	r2, [r3, #0]
}
 8002694:	4770      	bx	lr
      switch (regID)
 8002696:	f5b0 6f65 	cmp.w	r0, #3664	@ 0xe50
 800269a:	d04e      	beq.n	800273a <RI_SetRegisterGlobal+0xf6>
 800269c:	d93e      	bls.n	800271c <RI_SetRegisterGlobal+0xd8>
 800269e:	f5b0 6f69 	cmp.w	r0, #3728	@ 0xe90
 80026a2:	d04a      	beq.n	800273a <RI_SetRegisterGlobal+0xf6>
 80026a4:	f641 3258 	movw	r2, #7000	@ 0x1b58
          retVal = MCP_ERROR_UNKNOWN_REG;
 80026a8:	4290      	cmp	r0, r2
 80026aa:	bf0c      	ite	eq
 80026ac:	2004      	moveq	r0, #4
 80026ae:	2005      	movne	r0, #5
      *size = 2;
 80026b0:	2202      	movs	r2, #2
}
 80026b2:	f85d 4b04 	ldr.w	r4, [sp], #4
      *size = 2;
 80026b6:	801a      	strh	r2, [r3, #0]
}
 80026b8:	4770      	bx	lr
          retVal = MCP_ERROR_RO_REG;
 80026ba:	2818      	cmp	r0, #24
      *size = 4;
 80026bc:	f04f 0204 	mov.w	r2, #4
          retVal = MCP_ERROR_RO_REG;
 80026c0:	bf14      	ite	ne
 80026c2:	2005      	movne	r0, #5
 80026c4:	4610      	moveq	r0, r2
}
 80026c6:	f85d 4b04 	ldr.w	r4, [sp], #4
      *size = 4;
 80026ca:	801a      	strh	r2, [r3, #0]
}
 80026cc:	4770      	bx	lr
uint8_t RI_MovString(const char_t *srcString, char_t *destString, uint16_t *size, int16_t maxSize)
{
  uint8_t retVal = MCP_CMD_OK;
  const char_t *tempsrcString = srcString;
  char_t *tempdestString = destString;
  *size= 1U ; /* /0 is the min String size */
 80026ce:	2101      	movs	r1, #1
 80026d0:	8019      	strh	r1, [r3, #0]

  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 80026d2:	f992 0000 	ldrsb.w	r0, [r2]
 80026d6:	b348      	cbz	r0, 800272c <RI_SetRegisterGlobal+0xe8>
 80026d8:	fa1f f08c 	uxth.w	r0, ip
 80026dc:	e003      	b.n	80026e6 <RI_SetRegisterGlobal+0xa2>
  {
    *tempdestString = *tempsrcString;
    tempdestString++;
    tempsrcString++;
    *size = *size + 1U;
 80026de:	8019      	strh	r1, [r3, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 80026e0:	f912 4f01 	ldrsb.w	r4, [r2, #1]!
 80026e4:	b314      	cbz	r4, 800272c <RI_SetRegisterGlobal+0xe8>
    *size = *size + 1U;
 80026e6:	f101 0c01 	add.w	ip, r1, #1
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 80026ea:	4281      	cmp	r1, r0
    *size = *size + 1U;
 80026ec:	fa1f f18c 	uxth.w	r1, ip
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 80026f0:	d3f5      	bcc.n	80026de <RI_SetRegisterGlobal+0x9a>
      retVal = MCP_ERROR_RO_REG;
 80026f2:	2004      	movs	r0, #4
 80026f4:	e7c2      	b.n	800267c <RI_SetRegisterGlobal+0x38>
      *size = rawSize + 2U;
 80026f6:	8812      	ldrh	r2, [r2, #0]
 80026f8:	3202      	adds	r2, #2
 80026fa:	b292      	uxth	r2, r2
      if (*size > (uint16_t)dataAvailable)
 80026fc:	fa1f fc8c 	uxth.w	ip, ip
 8002700:	4562      	cmp	r2, ip
      *size = rawSize + 2U;
 8002702:	801a      	strh	r2, [r3, #0]
      if (*size > (uint16_t)dataAvailable)
 8002704:	d81b      	bhi.n	800273e <RI_SetRegisterGlobal+0xfa>
        switch (regID)
 8002706:	28a8      	cmp	r0, #168	@ 0xa8
 8002708:	d0f3      	beq.n	80026f2 <RI_SetRegisterGlobal+0xae>
 800270a:	d813      	bhi.n	8002734 <RI_SetRegisterGlobal+0xf0>
 800270c:	f020 0040 	bic.w	r0, r0, #64	@ 0x40
 8002710:	2828      	cmp	r0, #40	@ 0x28
 8002712:	d0ee      	beq.n	80026f2 <RI_SetRegisterGlobal+0xae>
 8002714:	2005      	movs	r0, #5
}
 8002716:	f85d 4b04 	ldr.w	r4, [sp], #4
 800271a:	4770      	bx	lr
 800271c:	f020 0040 	bic.w	r0, r0, #64	@ 0x40
          retVal = MCP_ERROR_UNKNOWN_REG;
 8002720:	f5b0 6fb2 	cmp.w	r0, #1424	@ 0x590
 8002724:	bf0c      	ite	eq
 8002726:	2004      	moveq	r0, #4
 8002728:	2005      	movne	r0, #5
 800272a:	e7c1      	b.n	80026b0 <RI_SetRegisterGlobal+0x6c>
  { /* Last string char must be 0 */
    retVal = MCP_ERROR_STRING_FORMAT;
  }
  else
  {
    *tempdestString = (int8_t)0;
 800272c:	2300      	movs	r3, #0
 800272e:	7013      	strb	r3, [r2, #0]
      retVal = MCP_ERROR_RO_REG;
 8002730:	2004      	movs	r0, #4
 8002732:	e7a3      	b.n	800267c <RI_SetRegisterGlobal+0x38>
 8002734:	28e8      	cmp	r0, #232	@ 0xe8
 8002736:	d1ed      	bne.n	8002714 <RI_SetRegisterGlobal+0xd0>
 8002738:	e7db      	b.n	80026f2 <RI_SetRegisterGlobal+0xae>
  uint8_t retVal = MCP_CMD_OK;
 800273a:	2000      	movs	r0, #0
 800273c:	e7b8      	b.n	80026b0 <RI_SetRegisterGlobal+0x6c>
        *size = 0;
 800273e:	2200      	movs	r2, #0
 8002740:	801a      	strh	r2, [r3, #0]
        retVal = MCP_ERROR_BAD_RAW_FORMAT; /* This error stop the parsing of the CMD buffer */
 8002742:	200a      	movs	r0, #10
 8002744:	e79a      	b.n	800267c <RI_SetRegisterGlobal+0x38>
 8002746:	bf00      	nop

08002748 <RI_SetRegisterMotor1>:
{
 8002748:	b530      	push	{r4, r5, lr}
 800274a:	b083      	sub	sp, #12
  switch(typeID)
 800274c:	3908      	subs	r1, #8
{
 800274e:	f9bd c018 	ldrsh.w	ip, [sp, #24]
 8002752:	4696      	mov	lr, r2
 8002754:	461c      	mov	r4, r3
  switch(typeID)
 8002756:	2920      	cmp	r1, #32
 8002758:	d812      	bhi.n	8002780 <RI_SetRegisterMotor1+0x38>
 800275a:	e8df f001 	tbb	[pc, r1]
 800275e:	1116      	.short	0x1116
 8002760:	11111111 	.word	0x11111111
 8002764:	11231111 	.word	0x11231111
 8002768:	11111111 	.word	0x11111111
 800276c:	117d1111 	.word	0x117d1111
 8002770:	11111111 	.word	0x11111111
 8002774:	11441111 	.word	0x11441111
 8002778:	11111111 	.word	0x11111111
 800277c:	1111      	.short	0x1111
 800277e:	5b          	.byte	0x5b
 800277f:	00          	.byte	0x00
      *size =0; /* From this point we are not able anymore to decode the RX buffer */
 8002780:	2300      	movs	r3, #0
 8002782:	8023      	strh	r3, [r4, #0]
      retVal = MCP_ERROR_BAD_DATA_TYPE;
 8002784:	2007      	movs	r0, #7
}
 8002786:	b003      	add	sp, #12
 8002788:	bd30      	pop	{r4, r5, pc}
      switch (regID)
 800278a:	2888      	cmp	r0, #136	@ 0x88
 800278c:	f000 81b4 	beq.w	8002af8 <RI_SetRegisterMotor1+0x3b0>
 8002790:	f020 0080 	bic.w	r0, r0, #128	@ 0x80
 8002794:	2848      	cmp	r0, #72	@ 0x48
 8002796:	bf0c      	ite	eq
 8002798:	2004      	moveq	r0, #4
 800279a:	2005      	movne	r0, #5
      *size = 1;
 800279c:	2301      	movs	r3, #1
 800279e:	8023      	strh	r3, [r4, #0]
}
 80027a0:	b003      	add	sp, #12
 80027a2:	bd30      	pop	{r4, r5, pc}
      uint16_t regdata16 = *(uint16_t *)data; //cstat !MISRAC2012-Rule-11.3
 80027a4:	f5b0 6f19 	cmp.w	r0, #2448	@ 0x990
 80027a8:	8815      	ldrh	r5, [r2, #0]
      switch (regID)
 80027aa:	f000 8251 	beq.w	8002c50 <RI_SetRegisterMotor1+0x508>
 80027ae:	f200 809f 	bhi.w	80028f0 <RI_SetRegisterMotor1+0x1a8>
 80027b2:	f5b0 7f24 	cmp.w	r0, #656	@ 0x290
 80027b6:	f000 826a 	beq.w	8002c8e <RI_SetRegisterMotor1+0x546>
 80027ba:	d874      	bhi.n	80028a6 <RI_SetRegisterMotor1+0x15e>
 80027bc:	f5b0 7fc8 	cmp.w	r0, #400	@ 0x190
 80027c0:	f000 8260 	beq.w	8002c84 <RI_SetRegisterMotor1+0x53c>
 80027c4:	d964      	bls.n	8002890 <RI_SetRegisterMotor1+0x148>
 80027c6:	f5b0 7fe8 	cmp.w	r0, #464	@ 0x1d0
 80027ca:	f000 8273 	beq.w	8002cb4 <RI_SetRegisterMotor1+0x56c>
 80027ce:	f5b0 7f04 	cmp.w	r0, #528	@ 0x210
 80027d2:	d14f      	bne.n	8002874 <RI_SetRegisterMotor1+0x12c>
          PID_SetKD(&PIDIqHandle_M1, (int16_t)regdata16);
 80027d4:	48a8      	ldr	r0, [pc, #672]	@ (8002a78 <RI_SetRegisterMotor1+0x330>)
 80027d6:	b229      	sxth	r1, r5
 80027d8:	f005 fe18 	bl	800840c <PID_SetKD>
  uint8_t retVal = MCP_CMD_OK;
 80027dc:	2000      	movs	r0, #0
      *size = 2;
 80027de:	2302      	movs	r3, #2
 80027e0:	8023      	strh	r3, [r4, #0]
}
 80027e2:	b003      	add	sp, #12
 80027e4:	bd30      	pop	{r4, r5, pc}
  *size= 1U ; /* /0 is the min String size */
 80027e6:	2001      	movs	r0, #1
 80027e8:	8020      	strh	r0, [r4, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 80027ea:	f992 3000 	ldrsb.w	r3, [r2]
 80027ee:	2b00      	cmp	r3, #0
 80027f0:	f000 8165 	beq.w	8002abe <RI_SetRegisterMotor1+0x376>
 80027f4:	fa1f f38c 	uxth.w	r3, ip
 80027f8:	e005      	b.n	8002806 <RI_SetRegisterMotor1+0xbe>
    *size = *size + 1U;
 80027fa:	8020      	strh	r0, [r4, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 80027fc:	f91e 1f01 	ldrsb.w	r1, [lr, #1]!
 8002800:	2900      	cmp	r1, #0
 8002802:	f000 815c 	beq.w	8002abe <RI_SetRegisterMotor1+0x376>
    *size = *size + 1U;
 8002806:	f100 0c01 	add.w	ip, r0, #1
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 800280a:	4283      	cmp	r3, r0
    *size = *size + 1U;
 800280c:	fa1f f08c 	uxth.w	r0, ip
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8002810:	d8f3      	bhi.n	80027fa <RI_SetRegisterMotor1+0xb2>
 8002812:	e157      	b.n	8002ac4 <RI_SetRegisterMotor1+0x37c>
      uint16_t rawSize = *(uint16_t *)data; //cstat !MISRAC2012-Rule-11.3
 8002814:	8811      	ldrh	r1, [r2, #0]
      *size = rawSize + 2U;
 8002816:	1c8a      	adds	r2, r1, #2
 8002818:	b292      	uxth	r2, r2
      if (*size > (uint16_t)dataAvailable)
 800281a:	fa1f f38c 	uxth.w	r3, ip
 800281e:	429a      	cmp	r2, r3
      *size = rawSize + 2U;
 8002820:	8022      	strh	r2, [r4, #0]
      if (*size > (uint16_t)dataAvailable)
 8002822:	f200 8165 	bhi.w	8002af0 <RI_SetRegisterMotor1+0x3a8>
        switch (regID)
 8002826:	f5b0 7f0a 	cmp.w	r0, #552	@ 0x228
 800282a:	f000 81a3 	beq.w	8002b74 <RI_SetRegisterMotor1+0x42c>
 800282e:	f200 8151 	bhi.w	8002ad4 <RI_SetRegisterMotor1+0x38c>
 8002832:	f5b0 7fd4 	cmp.w	r0, #424	@ 0x1a8
 8002836:	f000 818f 	beq.w	8002b58 <RI_SetRegisterMotor1+0x410>
 800283a:	f240 8145 	bls.w	8002ac8 <RI_SetRegisterMotor1+0x380>
 800283e:	f5b0 7ff4 	cmp.w	r0, #488	@ 0x1e8
 8002842:	f040 8139 	bne.w	8002ab8 <RI_SetRegisterMotor1+0x370>
            MCI_ExecTorqueRamp(pMCIN, (int16_t)torque, duration);
 8002846:	f8be 2006 	ldrh.w	r2, [lr, #6]
 800284a:	f9be 1002 	ldrsh.w	r1, [lr, #2]
 800284e:	488b      	ldr	r0, [pc, #556]	@ (8002a7c <RI_SetRegisterMotor1+0x334>)
 8002850:	f7fe fbec 	bl	800102c <MCI_ExecTorqueRamp>
  uint8_t retVal = MCP_CMD_OK;
 8002854:	2000      	movs	r0, #0
 8002856:	e796      	b.n	8002786 <RI_SetRegisterMotor1+0x3e>
      switch (regID)
 8002858:	2898      	cmp	r0, #152	@ 0x98
 800285a:	f000 815d 	beq.w	8002b18 <RI_SetRegisterMotor1+0x3d0>
 800285e:	d80d      	bhi.n	800287c <RI_SetRegisterMotor1+0x134>
 8002860:	f020 0040 	bic.w	r0, r0, #64	@ 0x40
 8002864:	2818      	cmp	r0, #24
 8002866:	bf0c      	ite	eq
 8002868:	2004      	moveq	r0, #4
 800286a:	2005      	movne	r0, #5
      *size = 4;
 800286c:	2304      	movs	r3, #4
 800286e:	8023      	strh	r3, [r4, #0]
}
 8002870:	b003      	add	sp, #12
 8002872:	bd30      	pop	{r4, r5, pc}
      *size = 2;
 8002874:	2302      	movs	r3, #2
          retVal = MCP_ERROR_UNKNOWN_REG;
 8002876:	2005      	movs	r0, #5
      *size = 2;
 8002878:	8023      	strh	r3, [r4, #0]
      break;
 800287a:	e7b2      	b.n	80027e2 <RI_SetRegisterMotor1+0x9a>
 800287c:	f5b0 7fac 	cmp.w	r0, #344	@ 0x158
 8002880:	f000 8161 	beq.w	8002b46 <RI_SetRegisterMotor1+0x3fe>
 8002884:	f5b0 7fcc 	cmp.w	r0, #408	@ 0x198
 8002888:	bf0c      	ite	eq
 800288a:	2004      	moveq	r0, #4
 800288c:	2005      	movne	r0, #5
 800288e:	e7ed      	b.n	800286c <RI_SetRegisterMotor1+0x124>
 8002890:	28d0      	cmp	r0, #208	@ 0xd0
 8002892:	f000 8214 	beq.w	8002cbe <RI_SetRegisterMotor1+0x576>
 8002896:	f5b0 7f88 	cmp.w	r0, #272	@ 0x110
 800289a:	d15d      	bne.n	8002958 <RI_SetRegisterMotor1+0x210>
          PID_SetKD(&PIDSpeedHandle_M1, (int16_t)regdata16);
 800289c:	4878      	ldr	r0, [pc, #480]	@ (8002a80 <RI_SetRegisterMotor1+0x338>)
 800289e:	b229      	sxth	r1, r5
 80028a0:	f005 fdb4 	bl	800840c <PID_SetKD>
          break;
 80028a4:	e79a      	b.n	80027dc <RI_SetRegisterMotor1+0x94>
 80028a6:	f5b0 7f74 	cmp.w	r0, #976	@ 0x3d0
 80028aa:	f000 81c4 	beq.w	8002c36 <RI_SetRegisterMotor1+0x4ee>
 80028ae:	d913      	bls.n	80028d8 <RI_SetRegisterMotor1+0x190>
 80028b0:	f5b0 6f01 	cmp.w	r0, #2064	@ 0x810
 80028b4:	d00e      	beq.n	80028d4 <RI_SetRegisterMotor1+0x18c>
 80028b6:	d93f      	bls.n	8002938 <RI_SetRegisterMotor1+0x1f0>
 80028b8:	f5b0 6f15 	cmp.w	r0, #2384	@ 0x950
 80028bc:	d131      	bne.n	8002922 <RI_SetRegisterMotor1+0x1da>
          currComp = MCI_GetIqdref(pMCIN);
 80028be:	486f      	ldr	r0, [pc, #444]	@ (8002a7c <RI_SetRegisterMotor1+0x334>)
 80028c0:	f7fe fd1e 	bl	8001300 <MCI_GetIqdref>
 80028c4:	9001      	str	r0, [sp, #4]
          currComp.q = (int16_t)regdata16;
 80028c6:	f8ad 5004 	strh.w	r5, [sp, #4]
          MCI_SetCurrentReferences(pMCIN,currComp);
 80028ca:	9901      	ldr	r1, [sp, #4]
 80028cc:	486b      	ldr	r0, [pc, #428]	@ (8002a7c <RI_SetRegisterMotor1+0x334>)
 80028ce:	f7fe fc97 	bl	8001200 <MCI_SetCurrentReferences>
          break;
 80028d2:	e783      	b.n	80027dc <RI_SetRegisterMotor1+0x94>
 80028d4:	2004      	movs	r0, #4
 80028d6:	e782      	b.n	80027de <RI_SetRegisterMotor1+0x96>
 80028d8:	f5b0 7f34 	cmp.w	r0, #720	@ 0x2d0
 80028dc:	f000 81f4 	beq.w	8002cc8 <RI_SetRegisterMotor1+0x580>
 80028e0:	f5b0 7f44 	cmp.w	r0, #784	@ 0x310
 80028e4:	d1c6      	bne.n	8002874 <RI_SetRegisterMotor1+0x12c>
          PID_SetKD(&PIDIdHandle_M1, (int16_t)regdata16);
 80028e6:	4867      	ldr	r0, [pc, #412]	@ (8002a84 <RI_SetRegisterMotor1+0x33c>)
 80028e8:	b229      	sxth	r1, r5
 80028ea:	f005 fd8f 	bl	800840c <PID_SetKD>
          break;
 80028ee:	e775      	b.n	80027dc <RI_SetRegisterMotor1+0x94>
 80028f0:	f241 5350 	movw	r3, #5456	@ 0x1550
 80028f4:	4298      	cmp	r0, r3
 80028f6:	f000 81c0 	beq.w	8002c7a <RI_SetRegisterMotor1+0x532>
 80028fa:	d94c      	bls.n	8002996 <RI_SetRegisterMotor1+0x24e>
 80028fc:	f241 6310 	movw	r3, #5648	@ 0x1610
 8002900:	4298      	cmp	r0, r3
 8002902:	f000 81b5 	beq.w	8002c70 <RI_SetRegisterMotor1+0x528>
 8002906:	d937      	bls.n	8002978 <RI_SetRegisterMotor1+0x230>
 8002908:	f641 23d0 	movw	r3, #6864	@ 0x1ad0
 800290c:	4298      	cmp	r0, r3
 800290e:	f000 81c8 	beq.w	8002ca2 <RI_SetRegisterMotor1+0x55a>
 8002912:	d928      	bls.n	8002966 <RI_SetRegisterMotor1+0x21e>
 8002914:	f641 3358 	movw	r3, #7000	@ 0x1b58
          retVal = MCP_ERROR_UNKNOWN_REG;
 8002918:	4298      	cmp	r0, r3
 800291a:	bf0c      	ite	eq
 800291c:	2004      	moveq	r0, #4
 800291e:	2005      	movne	r0, #5
 8002920:	e75d      	b.n	80027de <RI_SetRegisterMotor1+0x96>
 8002922:	d8a7      	bhi.n	8002874 <RI_SetRegisterMotor1+0x12c>
 8002924:	f5b0 6f0d 	cmp.w	r0, #2256	@ 0x8d0
 8002928:	d0d4      	beq.n	80028d4 <RI_SetRegisterMotor1+0x18c>
 800292a:	d95f      	bls.n	80029ec <RI_SetRegisterMotor1+0x2a4>
 800292c:	f5b0 6f11 	cmp.w	r0, #2320	@ 0x910
 8002930:	bf0c      	ite	eq
 8002932:	2004      	moveq	r0, #4
 8002934:	2005      	movne	r0, #5
 8002936:	e752      	b.n	80027de <RI_SetRegisterMotor1+0x96>
 8002938:	f5b0 6f82 	cmp.w	r0, #1040	@ 0x410
 800293c:	d176      	bne.n	8002a2c <RI_SetRegisterMotor1+0x2e4>
          STO_CR_GetObserverGains(&STO_CR_M1, &hC1, &hC2);
 800293e:	aa01      	add	r2, sp, #4
 8002940:	f10d 0102 	add.w	r1, sp, #2
 8002944:	4850      	ldr	r0, [pc, #320]	@ (8002a88 <RI_SetRegisterMotor1+0x340>)
 8002946:	f007 fa6f 	bl	8009e28 <STO_CR_GetObserverGains>
          STO_CR_SetObserverGains(&STO_CR_M1, hC1, (int16_t)regdata16);
 800294a:	f9bd 1002 	ldrsh.w	r1, [sp, #2]
 800294e:	484e      	ldr	r0, [pc, #312]	@ (8002a88 <RI_SetRegisterMotor1+0x340>)
 8002950:	b22a      	sxth	r2, r5
 8002952:	f007 fa71 	bl	8009e38 <STO_CR_SetObserverGains>
          break;
 8002956:	e741      	b.n	80027dc <RI_SetRegisterMotor1+0x94>
 8002958:	2890      	cmp	r0, #144	@ 0x90
 800295a:	d18b      	bne.n	8002874 <RI_SetRegisterMotor1+0x12c>
          PID_SetKP(&PIDSpeedHandle_M1, (int16_t)regdata16);
 800295c:	4848      	ldr	r0, [pc, #288]	@ (8002a80 <RI_SetRegisterMotor1+0x338>)
 800295e:	b229      	sxth	r1, r5
 8002960:	f005 fd22 	bl	80083a8 <PID_SetKP>
          break;
 8002964:	e73a      	b.n	80027dc <RI_SetRegisterMotor1+0x94>
 8002966:	f241 6350 	movw	r3, #5712	@ 0x1650
 800296a:	4298      	cmp	r0, r3
 800296c:	d128      	bne.n	80029c0 <RI_SetRegisterMotor1+0x278>
          PID_SetKDDivisorPOW2(&PIDIqHandle_M1, regdata16);
 800296e:	4842      	ldr	r0, [pc, #264]	@ (8002a78 <RI_SetRegisterMotor1+0x330>)
 8002970:	4629      	mov	r1, r5
 8002972:	f005 fd53 	bl	800841c <PID_SetKDDivisorPOW2>
          break;
 8002976:	e731      	b.n	80027dc <RI_SetRegisterMotor1+0x94>
 8002978:	f241 5390 	movw	r3, #5520	@ 0x1590
 800297c:	4298      	cmp	r0, r3
 800297e:	f000 818b 	beq.w	8002c98 <RI_SetRegisterMotor1+0x550>
 8002982:	f241 53d0 	movw	r3, #5584	@ 0x15d0
 8002986:	4298      	cmp	r0, r3
 8002988:	f47f af74 	bne.w	8002874 <RI_SetRegisterMotor1+0x12c>
          PID_SetKPDivisorPOW2(&PIDIqHandle_M1, regdata16);
 800298c:	483a      	ldr	r0, [pc, #232]	@ (8002a78 <RI_SetRegisterMotor1+0x330>)
 800298e:	4629      	mov	r1, r5
 8002990:	f005 fd1a 	bl	80083c8 <PID_SetKPDivisorPOW2>
          break;
 8002994:	e722      	b.n	80027dc <RI_SetRegisterMotor1+0x94>
 8002996:	f241 4390 	movw	r3, #5264	@ 0x1490
 800299a:	4298      	cmp	r0, r3
 800299c:	f000 8163 	beq.w	8002c66 <RI_SetRegisterMotor1+0x51e>
 80029a0:	d915      	bls.n	80029ce <RI_SetRegisterMotor1+0x286>
 80029a2:	f241 43d0 	movw	r3, #5328	@ 0x14d0
 80029a6:	4298      	cmp	r0, r3
 80029a8:	f000 8193 	beq.w	8002cd2 <RI_SetRegisterMotor1+0x58a>
 80029ac:	f241 5310 	movw	r3, #5392	@ 0x1510
 80029b0:	4298      	cmp	r0, r3
 80029b2:	f47f af5f 	bne.w	8002874 <RI_SetRegisterMotor1+0x12c>
          PID_SetKPDivisorPOW2(&PIDIdHandle_M1, regdata16);
 80029b6:	4833      	ldr	r0, [pc, #204]	@ (8002a84 <RI_SetRegisterMotor1+0x33c>)
 80029b8:	4629      	mov	r1, r5
 80029ba:	f005 fd05 	bl	80083c8 <PID_SetKPDivisorPOW2>
          break;
 80029be:	e70d      	b.n	80027dc <RI_SetRegisterMotor1+0x94>
 80029c0:	f641 2390 	movw	r3, #6800	@ 0x1a90
          retVal = MCP_ERROR_UNKNOWN_REG;
 80029c4:	4298      	cmp	r0, r3
 80029c6:	bf0c      	ite	eq
 80029c8:	2004      	moveq	r0, #4
 80029ca:	2005      	movne	r0, #5
 80029cc:	e707      	b.n	80027de <RI_SetRegisterMotor1+0x96>
 80029ce:	f5b0 6f69 	cmp.w	r0, #3728	@ 0xe90
 80029d2:	f43f af03 	beq.w	80027dc <RI_SetRegisterMotor1+0x94>
 80029d6:	d913      	bls.n	8002a00 <RI_SetRegisterMotor1+0x2b8>
 80029d8:	f241 4350 	movw	r3, #5200	@ 0x1450
 80029dc:	4298      	cmp	r0, r3
 80029de:	f47f af49 	bne.w	8002874 <RI_SetRegisterMotor1+0x12c>
          PID_SetKPDivisorPOW2(&PIDSpeedHandle_M1, regdata16);
 80029e2:	4827      	ldr	r0, [pc, #156]	@ (8002a80 <RI_SetRegisterMotor1+0x338>)
 80029e4:	4629      	mov	r1, r5
 80029e6:	f005 fcef 	bl	80083c8 <PID_SetKPDivisorPOW2>
          break;
 80029ea:	e6f7      	b.n	80027dc <RI_SetRegisterMotor1+0x94>
 80029ec:	f5b0 6f05 	cmp.w	r0, #2128	@ 0x850
 80029f0:	f43f af70 	beq.w	80028d4 <RI_SetRegisterMotor1+0x18c>
          retVal = MCP_ERROR_UNKNOWN_REG;
 80029f4:	f5b0 6f09 	cmp.w	r0, #2192	@ 0x890
 80029f8:	bf0c      	ite	eq
 80029fa:	2004      	moveq	r0, #4
 80029fc:	2005      	movne	r0, #5
 80029fe:	e6ee      	b.n	80027de <RI_SetRegisterMotor1+0x96>
 8002a00:	f5b0 6f65 	cmp.w	r0, #3664	@ 0xe50
 8002a04:	f43f aeea 	beq.w	80027dc <RI_SetRegisterMotor1+0x94>
 8002a08:	f63f af34 	bhi.w	8002874 <RI_SetRegisterMotor1+0x12c>
 8002a0c:	f5b0 6f51 	cmp.w	r0, #3344	@ 0xd10
 8002a10:	f43f af60 	beq.w	80028d4 <RI_SetRegisterMotor1+0x18c>
 8002a14:	d921      	bls.n	8002a5a <RI_SetRegisterMotor1+0x312>
 8002a16:	f5b0 6f5d 	cmp.w	r0, #3536	@ 0xdd0
 8002a1a:	f43f af5b 	beq.w	80028d4 <RI_SetRegisterMotor1+0x18c>
 8002a1e:	d912      	bls.n	8002a46 <RI_SetRegisterMotor1+0x2fe>
 8002a20:	f5b0 6f61 	cmp.w	r0, #3600	@ 0xe10
 8002a24:	bf0c      	ite	eq
 8002a26:	2004      	moveq	r0, #4
 8002a28:	2005      	movne	r0, #5
 8002a2a:	e6d8      	b.n	80027de <RI_SetRegisterMotor1+0x96>
 8002a2c:	f4ff af22 	bcc.w	8002874 <RI_SetRegisterMotor1+0x12c>
 8002a30:	f5b0 6ff2 	cmp.w	r0, #1936	@ 0x790
 8002a34:	f43f af4e 	beq.w	80028d4 <RI_SetRegisterMotor1+0x18c>
 8002a38:	d928      	bls.n	8002a8c <RI_SetRegisterMotor1+0x344>
 8002a3a:	f5b0 6ffa 	cmp.w	r0, #2000	@ 0x7d0
 8002a3e:	bf0c      	ite	eq
 8002a40:	2004      	moveq	r0, #4
 8002a42:	2005      	movne	r0, #5
 8002a44:	e6cb      	b.n	80027de <RI_SetRegisterMotor1+0x96>
 8002a46:	f5b0 6f55 	cmp.w	r0, #3408	@ 0xd50
 8002a4a:	f43f af43 	beq.w	80028d4 <RI_SetRegisterMotor1+0x18c>
 8002a4e:	f5b0 6f59 	cmp.w	r0, #3472	@ 0xd90
 8002a52:	bf0c      	ite	eq
 8002a54:	2004      	moveq	r0, #4
 8002a56:	2005      	movne	r0, #5
 8002a58:	e6c1      	b.n	80027de <RI_SetRegisterMotor1+0x96>
 8002a5a:	f5b0 6f25 	cmp.w	r0, #2640	@ 0xa50
 8002a5e:	f43f af39 	beq.w	80028d4 <RI_SetRegisterMotor1+0x18c>
 8002a62:	d91b      	bls.n	8002a9c <RI_SetRegisterMotor1+0x354>
 8002a64:	f5b0 6f29 	cmp.w	r0, #2704	@ 0xa90
 8002a68:	f43f af34 	beq.w	80028d4 <RI_SetRegisterMotor1+0x18c>
 8002a6c:	f5b0 6f4d 	cmp.w	r0, #3280	@ 0xcd0
 8002a70:	bf0c      	ite	eq
 8002a72:	2004      	moveq	r0, #4
 8002a74:	2005      	movne	r0, #5
 8002a76:	e6b2      	b.n	80027de <RI_SetRegisterMotor1+0x96>
 8002a78:	2000037c 	.word	0x2000037c
 8002a7c:	20000000 	.word	0x20000000
 8002a80:	200003a8 	.word	0x200003a8
 8002a84:	20000350 	.word	0x20000350
 8002a88:	2000007c 	.word	0x2000007c
 8002a8c:	f020 0040 	bic.w	r0, r0, #64	@ 0x40
 8002a90:	f5b0 6fb2 	cmp.w	r0, #1424	@ 0x590
 8002a94:	bf0c      	ite	eq
 8002a96:	2004      	moveq	r0, #4
 8002a98:	2005      	movne	r0, #5
 8002a9a:	e6a0      	b.n	80027de <RI_SetRegisterMotor1+0x96>
 8002a9c:	f5b0 6f1d 	cmp.w	r0, #2512	@ 0x9d0
 8002aa0:	f43f af18 	beq.w	80028d4 <RI_SetRegisterMotor1+0x18c>
 8002aa4:	f5b0 6f21 	cmp.w	r0, #2576	@ 0xa10
 8002aa8:	bf0c      	ite	eq
 8002aaa:	2004      	moveq	r0, #4
 8002aac:	2005      	movne	r0, #5
 8002aae:	e696      	b.n	80027de <RI_SetRegisterMotor1+0x96>
 8002ab0:	f020 0040 	bic.w	r0, r0, #64	@ 0x40
 8002ab4:	2828      	cmp	r0, #40	@ 0x28
 8002ab6:	d005      	beq.n	8002ac4 <RI_SetRegisterMotor1+0x37c>
 8002ab8:	2005      	movs	r0, #5
}
 8002aba:	b003      	add	sp, #12
 8002abc:	bd30      	pop	{r4, r5, pc}
    *tempdestString = (int8_t)0;
 8002abe:	2300      	movs	r3, #0
 8002ac0:	f88e 3000 	strb.w	r3, [lr]
      retVal = MCP_ERROR_RO_REG;
 8002ac4:	2004      	movs	r0, #4
 8002ac6:	e65e      	b.n	8002786 <RI_SetRegisterMotor1+0x3e>
 8002ac8:	28a8      	cmp	r0, #168	@ 0xa8
 8002aca:	d0fb      	beq.n	8002ac4 <RI_SetRegisterMotor1+0x37c>
 8002acc:	d9f0      	bls.n	8002ab0 <RI_SetRegisterMotor1+0x368>
 8002ace:	28e8      	cmp	r0, #232	@ 0xe8
 8002ad0:	d0f8      	beq.n	8002ac4 <RI_SetRegisterMotor1+0x37c>
 8002ad2:	e7f1      	b.n	8002ab8 <RI_SetRegisterMotor1+0x370>
 8002ad4:	f5b0 7f5a 	cmp.w	r0, #872	@ 0x368
 8002ad8:	d037      	beq.n	8002b4a <RI_SetRegisterMotor1+0x402>
 8002ada:	f5b0 6fa5 	cmp.w	r0, #1320	@ 0x528
 8002ade:	d1eb      	bne.n	8002ab8 <RI_SetRegisterMotor1+0x370>
            retVal =  MCPA_cfgLog (&MCPA_UART_A, rawData);
 8002ae0:	487e      	ldr	r0, [pc, #504]	@ (8002cdc <RI_SetRegisterMotor1+0x594>)
 8002ae2:	f10e 0102 	add.w	r1, lr, #2
}
 8002ae6:	b003      	add	sp, #12
 8002ae8:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
            retVal =  MCPA_cfgLog (&MCPA_UART_A, rawData);
 8002aec:	f005 bb6e 	b.w	80081cc <MCPA_cfgLog>
        *size = 0;
 8002af0:	2300      	movs	r3, #0
 8002af2:	8023      	strh	r3, [r4, #0]
              retVal = MCP_ERROR_BAD_RAW_FORMAT;
 8002af4:	200a      	movs	r0, #10
 8002af6:	e646      	b.n	8002786 <RI_SetRegisterMotor1+0x3e>
          uint8_t regdata8 = *data;
 8002af8:	7813      	ldrb	r3, [r2, #0]
          if ((uint8_t)MCM_TORQUE_MODE == regdata8)
 8002afa:	2b04      	cmp	r3, #4
 8002afc:	d01a      	beq.n	8002b34 <RI_SetRegisterMotor1+0x3ec>
          if ((uint8_t)MCM_SPEED_MODE == regdata8)
 8002afe:	2b03      	cmp	r3, #3
 8002b00:	f000 8095 	beq.w	8002c2e <RI_SetRegisterMotor1+0x4e6>
          if ((uint8_t)regdata8 == MCM_OPEN_LOOP_CURRENT_MODE)
 8002b04:	2b02      	cmp	r3, #2
 8002b06:	f000 808e 	beq.w	8002c26 <RI_SetRegisterMotor1+0x4de>
          if ((uint8_t)regdata8 == MCM_OPEN_LOOP_VOLTAGE_MODE)
 8002b0a:	2b01      	cmp	r3, #1
 8002b0c:	d102      	bne.n	8002b14 <RI_SetRegisterMotor1+0x3cc>
            MCI_SetOpenLoopVoltageMode(pMCIN);
 8002b0e:	4874      	ldr	r0, [pc, #464]	@ (8002ce0 <RI_SetRegisterMotor1+0x598>)
 8002b10:	f7fe fab2 	bl	8001078 <MCI_SetOpenLoopVoltageMode>
  uint8_t retVal = MCP_CMD_OK;
 8002b14:	2000      	movs	r0, #0
 8002b16:	e641      	b.n	800279c <RI_SetRegisterMotor1+0x54>
          MCI_ExecSpeedRamp(pMCIN,((((int16_t)regdata32) * ((int16_t)SPEED_UNIT)) / (int16_t)U_RPM), 0);
 8002b18:	f9b2 3000 	ldrsh.w	r3, [r2]
 8002b1c:	4971      	ldr	r1, [pc, #452]	@ (8002ce4 <RI_SetRegisterMotor1+0x59c>)
 8002b1e:	4870      	ldr	r0, [pc, #448]	@ (8002ce0 <RI_SetRegisterMotor1+0x598>)
 8002b20:	fb81 2103 	smull	r2, r1, r1, r3
 8002b24:	eba1 71e3 	sub.w	r1, r1, r3, asr #31
 8002b28:	2200      	movs	r2, #0
 8002b2a:	b209      	sxth	r1, r1
 8002b2c:	f7fe fa76 	bl	800101c <MCI_ExecSpeedRamp>
  uint8_t retVal = MCP_CMD_OK;
 8002b30:	2000      	movs	r0, #0
          break;
 8002b32:	e69b      	b.n	800286c <RI_SetRegisterMotor1+0x124>
            MCI_ExecTorqueRamp(pMCIN, MCI_GetTeref(pMCIN), 0);
 8002b34:	486a      	ldr	r0, [pc, #424]	@ (8002ce0 <RI_SetRegisterMotor1+0x598>)
 8002b36:	f7fe fc0d 	bl	8001354 <MCI_GetTeref>
 8002b3a:	2200      	movs	r2, #0
 8002b3c:	4601      	mov	r1, r0
 8002b3e:	4868      	ldr	r0, [pc, #416]	@ (8002ce0 <RI_SetRegisterMotor1+0x598>)
 8002b40:	f7fe fa74 	bl	800102c <MCI_ExecTorqueRamp>
          if ((uint8_t)regdata8 == MCM_OPEN_LOOP_VOLTAGE_MODE)
 8002b44:	e7e6      	b.n	8002b14 <RI_SetRegisterMotor1+0x3cc>
          retVal = MCP_ERROR_RO_REG;
 8002b46:	2004      	movs	r0, #4
 8002b48:	e690      	b.n	800286c <RI_SetRegisterMotor1+0x124>
            currComp.q = *((int16_t *) rawData); //cstat !MISRAC2012-Rule-11.3
 8002b4a:	f8de 1002 	ldr.w	r1, [lr, #2]
            MCI_SetCurrentReferences(pMCIN, currComp);
 8002b4e:	4864      	ldr	r0, [pc, #400]	@ (8002ce0 <RI_SetRegisterMotor1+0x598>)
            currComp.q = *((int16_t *) rawData); //cstat !MISRAC2012-Rule-11.3
 8002b50:	9101      	str	r1, [sp, #4]
            MCI_SetCurrentReferences(pMCIN, currComp);
 8002b52:	f7fe fb55 	bl	8001200 <MCI_SetCurrentReferences>
            break;
 8002b56:	e67d      	b.n	8002854 <RI_SetRegisterMotor1+0x10c>
            MCI_ExecSpeedRamp(pMCIN, (int16_t)((rpm * SPEED_UNIT) / U_RPM), duration);
 8002b58:	f8de 1002 	ldr.w	r1, [lr, #2]
 8002b5c:	4b61      	ldr	r3, [pc, #388]	@ (8002ce4 <RI_SetRegisterMotor1+0x59c>)
 8002b5e:	f8be 2006 	ldrh.w	r2, [lr, #6]
 8002b62:	fb83 0301 	smull	r0, r3, r3, r1
 8002b66:	eba3 71e1 	sub.w	r1, r3, r1, asr #31
 8002b6a:	485d      	ldr	r0, [pc, #372]	@ (8002ce0 <RI_SetRegisterMotor1+0x598>)
 8002b6c:	b209      	sxth	r1, r1
 8002b6e:	f7fe fa55 	bl	800101c <MCI_ExecSpeedRamp>
            break;
 8002b72:	e66f      	b.n	8002854 <RI_SetRegisterMotor1+0x10c>
            if (((0U != ((rawSize) % 8U))) || ((nbrOfPhase > RUC_MAX_PHASE_NUMBER) != 0))
 8002b74:	074b      	lsls	r3, r1, #29
 8002b76:	d1bd      	bne.n	8002af4 <RI_SetRegisterMotor1+0x3ac>
            uint8_t nbrOfPhase = (((uint8_t)rawSize) / 8U);
 8002b78:	b2c9      	uxtb	r1, r1
            if (((0U != ((rawSize) % 8U))) || ((nbrOfPhase > RUC_MAX_PHASE_NUMBER) != 0))
 8002b7a:	292f      	cmp	r1, #47	@ 0x2f
 8002b7c:	d8ba      	bhi.n	8002af4 <RI_SetRegisterMotor1+0x3ac>
              for (i = 0; i <nbrOfPhase; i++)
 8002b7e:	08c9      	lsrs	r1, r1, #3
 8002b80:	f43f ae68 	beq.w	8002854 <RI_SetRegisterMotor1+0x10c>
              revUpPhase.hFinalMecSpeedUnit = (((int16_t)rpm) * ((int16_t)SPEED_UNIT)) / ((int16_t)U_RPM);
 8002b84:	f9be 3002 	ldrsh.w	r3, [lr, #2]
 8002b88:	4a56      	ldr	r2, [pc, #344]	@ (8002ce4 <RI_SetRegisterMotor1+0x59c>)
              revUpPhase.hDurationms  = *((uint16_t *) &rawData[6U +(i * 8U)]); //cstat !MISRAC2012-Rule-11.3
 8002b8a:	f8be 5008 	ldrh.w	r5, [lr, #8]
              revUpPhase.hFinalMecSpeedUnit = (((int16_t)rpm) * ((int16_t)SPEED_UNIT)) / ((int16_t)U_RPM);
 8002b8e:	fb82 4003 	smull	r4, r0, r2, r3
 8002b92:	eba0 70e3 	sub.w	r0, r0, r3, asr #31
    retValue = false;
  }
  else
  {
#endif
    pHandle->ParamsData[phaseNumber].hFinalTorque = phaseData->hFinalTorque;
 8002b96:	4b54      	ldr	r3, [pc, #336]	@ (8002ce8 <RI_SetRegisterMotor1+0x5a0>)
              revUpPhase.hFinalTorque = *((int16_t *) &rawData[4U + (i * 8U)]); //cstat !MISRAC2012-Rule-11.3
 8002b98:	f9be 4006 	ldrsh.w	r4, [lr, #6]
 8002b9c:	821c      	strh	r4, [r3, #16]
              for (i = 0; i <nbrOfPhase; i++)
 8002b9e:	2901      	cmp	r1, #1
    pHandle->ParamsData[phaseNumber].hFinalMecSpeedUnit = phaseData->hFinalMecSpeedUnit;
    pHandle->ParamsData[phaseNumber].hDurationms = phaseData->hDurationms;
 8002ba0:	819d      	strh	r5, [r3, #12]
    pHandle->ParamsData[phaseNumber].hFinalMecSpeedUnit = phaseData->hFinalMecSpeedUnit;
 8002ba2:	81d8      	strh	r0, [r3, #14]
 8002ba4:	f43f ae56 	beq.w	8002854 <RI_SetRegisterMotor1+0x10c>
              revUpPhase.hFinalMecSpeedUnit = (((int16_t)rpm) * ((int16_t)SPEED_UNIT)) / ((int16_t)U_RPM);
 8002ba8:	f9be 400a 	ldrsh.w	r4, [lr, #10]
              revUpPhase.hFinalTorque = *((int16_t *) &rawData[4U + (i * 8U)]); //cstat !MISRAC2012-Rule-11.3
 8002bac:	f9be 500e 	ldrsh.w	r5, [lr, #14]
              revUpPhase.hFinalMecSpeedUnit = (((int16_t)rpm) * ((int16_t)SPEED_UNIT)) / ((int16_t)U_RPM);
 8002bb0:	fb82 c004 	smull	ip, r0, r2, r4
 8002bb4:	eba0 70e4 	sub.w	r0, r0, r4, asr #31
              for (i = 0; i <nbrOfPhase; i++)
 8002bb8:	2902      	cmp	r1, #2
              revUpPhase.hDurationms  = *((uint16_t *) &rawData[6U +(i * 8U)]); //cstat !MISRAC2012-Rule-11.3
 8002bba:	f8be 4010 	ldrh.w	r4, [lr, #16]
    pHandle->ParamsData[phaseNumber].hDurationms = phaseData->hDurationms;
 8002bbe:	831c      	strh	r4, [r3, #24]
    pHandle->ParamsData[phaseNumber].hFinalTorque = phaseData->hFinalTorque;
 8002bc0:	839d      	strh	r5, [r3, #28]
    pHandle->ParamsData[phaseNumber].hFinalMecSpeedUnit = phaseData->hFinalMecSpeedUnit;
 8002bc2:	8358      	strh	r0, [r3, #26]
              for (i = 0; i <nbrOfPhase; i++)
 8002bc4:	f43f ae46 	beq.w	8002854 <RI_SetRegisterMotor1+0x10c>
              revUpPhase.hFinalMecSpeedUnit = (((int16_t)rpm) * ((int16_t)SPEED_UNIT)) / ((int16_t)U_RPM);
 8002bc8:	f9be 4012 	ldrsh.w	r4, [lr, #18]
              revUpPhase.hFinalTorque = *((int16_t *) &rawData[4U + (i * 8U)]); //cstat !MISRAC2012-Rule-11.3
 8002bcc:	f9be 5016 	ldrsh.w	r5, [lr, #22]
              revUpPhase.hFinalMecSpeedUnit = (((int16_t)rpm) * ((int16_t)SPEED_UNIT)) / ((int16_t)U_RPM);
 8002bd0:	fb82 c004 	smull	ip, r0, r2, r4
 8002bd4:	eba0 70e4 	sub.w	r0, r0, r4, asr #31
              for (i = 0; i <nbrOfPhase; i++)
 8002bd8:	2903      	cmp	r1, #3
              revUpPhase.hDurationms  = *((uint16_t *) &rawData[6U +(i * 8U)]); //cstat !MISRAC2012-Rule-11.3
 8002bda:	f8be 4018 	ldrh.w	r4, [lr, #24]
    pHandle->ParamsData[phaseNumber].hDurationms = phaseData->hDurationms;
 8002bde:	849c      	strh	r4, [r3, #36]	@ 0x24
    pHandle->ParamsData[phaseNumber].hFinalTorque = phaseData->hFinalTorque;
 8002be0:	851d      	strh	r5, [r3, #40]	@ 0x28
    pHandle->ParamsData[phaseNumber].hFinalMecSpeedUnit = phaseData->hFinalMecSpeedUnit;
 8002be2:	84d8      	strh	r0, [r3, #38]	@ 0x26
              for (i = 0; i <nbrOfPhase; i++)
 8002be4:	f43f ae36 	beq.w	8002854 <RI_SetRegisterMotor1+0x10c>
              revUpPhase.hFinalMecSpeedUnit = (((int16_t)rpm) * ((int16_t)SPEED_UNIT)) / ((int16_t)U_RPM);
 8002be8:	f9be 401a 	ldrsh.w	r4, [lr, #26]
              revUpPhase.hFinalTorque = *((int16_t *) &rawData[4U + (i * 8U)]); //cstat !MISRAC2012-Rule-11.3
 8002bec:	f9be 501e 	ldrsh.w	r5, [lr, #30]
              revUpPhase.hFinalMecSpeedUnit = (((int16_t)rpm) * ((int16_t)SPEED_UNIT)) / ((int16_t)U_RPM);
 8002bf0:	fb82 c004 	smull	ip, r0, r2, r4
 8002bf4:	eba0 70e4 	sub.w	r0, r0, r4, asr #31
              for (i = 0; i <nbrOfPhase; i++)
 8002bf8:	2905      	cmp	r1, #5
              revUpPhase.hDurationms  = *((uint16_t *) &rawData[6U +(i * 8U)]); //cstat !MISRAC2012-Rule-11.3
 8002bfa:	f8be 4020 	ldrh.w	r4, [lr, #32]
    pHandle->ParamsData[phaseNumber].hDurationms = phaseData->hDurationms;
 8002bfe:	861c      	strh	r4, [r3, #48]	@ 0x30
    pHandle->ParamsData[phaseNumber].hFinalTorque = phaseData->hFinalTorque;
 8002c00:	869d      	strh	r5, [r3, #52]	@ 0x34
    pHandle->ParamsData[phaseNumber].hFinalMecSpeedUnit = phaseData->hFinalMecSpeedUnit;
 8002c02:	8658      	strh	r0, [r3, #50]	@ 0x32
              for (i = 0; i <nbrOfPhase; i++)
 8002c04:	f47f ae26 	bne.w	8002854 <RI_SetRegisterMotor1+0x10c>
              revUpPhase.hFinalMecSpeedUnit = (((int16_t)rpm) * ((int16_t)SPEED_UNIT)) / ((int16_t)U_RPM);
 8002c08:	f9be 1022 	ldrsh.w	r1, [lr, #34]	@ 0x22
              revUpPhase.hFinalTorque = *((int16_t *) &rawData[4U + (i * 8U)]); //cstat !MISRAC2012-Rule-11.3
 8002c0c:	f9be 0026 	ldrsh.w	r0, [lr, #38]	@ 0x26
              revUpPhase.hFinalMecSpeedUnit = (((int16_t)rpm) * ((int16_t)SPEED_UNIT)) / ((int16_t)U_RPM);
 8002c10:	fb82 4201 	smull	r4, r2, r2, r1
 8002c14:	eba2 72e1 	sub.w	r2, r2, r1, asr #31
              revUpPhase.hDurationms  = *((uint16_t *) &rawData[6U +(i * 8U)]); //cstat !MISRAC2012-Rule-11.3
 8002c18:	f8be 4028 	ldrh.w	r4, [lr, #40]	@ 0x28
    pHandle->ParamsData[phaseNumber].hDurationms = phaseData->hDurationms;
 8002c1c:	879c      	strh	r4, [r3, #60]	@ 0x3c
    pHandle->ParamsData[phaseNumber].hFinalTorque = phaseData->hFinalTorque;
 8002c1e:	f8a3 0040 	strh.w	r0, [r3, #64]	@ 0x40
    pHandle->ParamsData[phaseNumber].hFinalMecSpeedUnit = phaseData->hFinalMecSpeedUnit;
 8002c22:	87da      	strh	r2, [r3, #62]	@ 0x3e
              for (i = 0; i <nbrOfPhase; i++)
 8002c24:	e616      	b.n	8002854 <RI_SetRegisterMotor1+0x10c>
            MCI_SetOpenLoopCurrentMode(pMCIN);
 8002c26:	482e      	ldr	r0, [pc, #184]	@ (8002ce0 <RI_SetRegisterMotor1+0x598>)
 8002c28:	f7fe fa18 	bl	800105c <MCI_SetOpenLoopCurrentMode>
          if ((uint8_t)regdata8 == MCM_OPEN_LOOP_VOLTAGE_MODE)
 8002c2c:	e772      	b.n	8002b14 <RI_SetRegisterMotor1+0x3cc>
            MCI_SetSpeedMode(pMCIN);
 8002c2e:	482c      	ldr	r0, [pc, #176]	@ (8002ce0 <RI_SetRegisterMotor1+0x598>)
 8002c30:	f7fe fa06 	bl	8001040 <MCI_SetSpeedMode>
          if ((uint8_t)regdata8 == MCM_OPEN_LOOP_VOLTAGE_MODE)
 8002c34:	e76e      	b.n	8002b14 <RI_SetRegisterMotor1+0x3cc>
          STO_CR_GetObserverGains(&STO_CR_M1, &hC1,&hC2);
 8002c36:	aa01      	add	r2, sp, #4
 8002c38:	f10d 0102 	add.w	r1, sp, #2
 8002c3c:	482b      	ldr	r0, [pc, #172]	@ (8002cec <RI_SetRegisterMotor1+0x5a4>)
 8002c3e:	f007 f8f3 	bl	8009e28 <STO_CR_GetObserverGains>
          STO_CR_SetObserverGains(&STO_CR_M1, (int16_t)regdata16, hC2);
 8002c42:	f9bd 2004 	ldrsh.w	r2, [sp, #4]
 8002c46:	4829      	ldr	r0, [pc, #164]	@ (8002cec <RI_SetRegisterMotor1+0x5a4>)
 8002c48:	b229      	sxth	r1, r5
 8002c4a:	f007 f8f5 	bl	8009e38 <STO_CR_SetObserverGains>
           break;
 8002c4e:	e5c5      	b.n	80027dc <RI_SetRegisterMotor1+0x94>
          currComp = MCI_GetIqdref(pMCIN);
 8002c50:	4823      	ldr	r0, [pc, #140]	@ (8002ce0 <RI_SetRegisterMotor1+0x598>)
 8002c52:	f7fe fb55 	bl	8001300 <MCI_GetIqdref>
 8002c56:	9001      	str	r0, [sp, #4]
          currComp.d = (int16_t)regdata16;
 8002c58:	f8ad 5006 	strh.w	r5, [sp, #6]
          MCI_SetCurrentReferences(pMCIN,currComp);
 8002c5c:	9901      	ldr	r1, [sp, #4]
 8002c5e:	4820      	ldr	r0, [pc, #128]	@ (8002ce0 <RI_SetRegisterMotor1+0x598>)
 8002c60:	f7fe face 	bl	8001200 <MCI_SetCurrentReferences>
          break;
 8002c64:	e5ba      	b.n	80027dc <RI_SetRegisterMotor1+0x94>
          PID_SetKIDivisorPOW2(&PIDSpeedHandle_M1, regdata16);
 8002c66:	4822      	ldr	r0, [pc, #136]	@ (8002cf0 <RI_SetRegisterMotor1+0x5a8>)
 8002c68:	4629      	mov	r1, r5
 8002c6a:	f005 fbbb 	bl	80083e4 <PID_SetKIDivisorPOW2>
          break;
 8002c6e:	e5b5      	b.n	80027dc <RI_SetRegisterMotor1+0x94>
          PID_SetKIDivisorPOW2(&PIDIqHandle_M1, regdata16);
 8002c70:	4820      	ldr	r0, [pc, #128]	@ (8002cf4 <RI_SetRegisterMotor1+0x5ac>)
 8002c72:	4629      	mov	r1, r5
 8002c74:	f005 fbb6 	bl	80083e4 <PID_SetKIDivisorPOW2>
          break;
 8002c78:	e5b0      	b.n	80027dc <RI_SetRegisterMotor1+0x94>
          PID_SetKIDivisorPOW2(&PIDIdHandle_M1, regdata16);
 8002c7a:	481f      	ldr	r0, [pc, #124]	@ (8002cf8 <RI_SetRegisterMotor1+0x5b0>)
 8002c7c:	4629      	mov	r1, r5
 8002c7e:	f005 fbb1 	bl	80083e4 <PID_SetKIDivisorPOW2>
          break;
 8002c82:	e5ab      	b.n	80027dc <RI_SetRegisterMotor1+0x94>
          PID_SetKP(&PIDIqHandle_M1, (int16_t)regdata16);
 8002c84:	481b      	ldr	r0, [pc, #108]	@ (8002cf4 <RI_SetRegisterMotor1+0x5ac>)
 8002c86:	b229      	sxth	r1, r5
 8002c88:	f005 fb8e 	bl	80083a8 <PID_SetKP>
          break;
 8002c8c:	e5a6      	b.n	80027dc <RI_SetRegisterMotor1+0x94>
          PID_SetKP(&PIDIdHandle_M1, (int16_t)regdata16);
 8002c8e:	481a      	ldr	r0, [pc, #104]	@ (8002cf8 <RI_SetRegisterMotor1+0x5b0>)
 8002c90:	b229      	sxth	r1, r5
 8002c92:	f005 fb89 	bl	80083a8 <PID_SetKP>
          break;
 8002c96:	e5a1      	b.n	80027dc <RI_SetRegisterMotor1+0x94>
          PID_SetKDDivisorPOW2(&PIDIdHandle_M1, regdata16);
 8002c98:	4817      	ldr	r0, [pc, #92]	@ (8002cf8 <RI_SetRegisterMotor1+0x5b0>)
 8002c9a:	4629      	mov	r1, r5
 8002c9c:	f005 fbbe 	bl	800841c <PID_SetKDDivisorPOW2>
          break;
 8002ca0:	e59c      	b.n	80027dc <RI_SetRegisterMotor1+0x94>
          OL_UpdateVoltage(&OpenLoop_ParamsM1, ((regdata16 * 32767) / 100));
 8002ca2:	4a16      	ldr	r2, [pc, #88]	@ (8002cfc <RI_SetRegisterMotor1+0x5b4>)
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->hVoltage = hNewVoltage;
 8002ca4:	4916      	ldr	r1, [pc, #88]	@ (8002d00 <RI_SetRegisterMotor1+0x5b8>)
 8002ca6:	ebc5 33c5 	rsb	r3, r5, r5, lsl #15
 8002caa:	fba2 2303 	umull	r2, r3, r2, r3
 8002cae:	095b      	lsrs	r3, r3, #5
 8002cb0:	810b      	strh	r3, [r1, #8]
#ifdef NULL_PTR_CHECK_OPEN_LOOP
  }
#endif
}
 8002cb2:	e593      	b.n	80027dc <RI_SetRegisterMotor1+0x94>
          PID_SetKI(&PIDIqHandle_M1, (int16_t)regdata16);
 8002cb4:	480f      	ldr	r0, [pc, #60]	@ (8002cf4 <RI_SetRegisterMotor1+0x5ac>)
 8002cb6:	b229      	sxth	r1, r5
 8002cb8:	f005 fb78 	bl	80083ac <PID_SetKI>
          break;
 8002cbc:	e58e      	b.n	80027dc <RI_SetRegisterMotor1+0x94>
          PID_SetKI(&PIDSpeedHandle_M1, (int16_t)regdata16);
 8002cbe:	480c      	ldr	r0, [pc, #48]	@ (8002cf0 <RI_SetRegisterMotor1+0x5a8>)
 8002cc0:	b229      	sxth	r1, r5
 8002cc2:	f005 fb73 	bl	80083ac <PID_SetKI>
          break;
 8002cc6:	e589      	b.n	80027dc <RI_SetRegisterMotor1+0x94>
          PID_SetKI(&PIDIdHandle_M1, (int16_t)regdata16);
 8002cc8:	480b      	ldr	r0, [pc, #44]	@ (8002cf8 <RI_SetRegisterMotor1+0x5b0>)
 8002cca:	b229      	sxth	r1, r5
 8002ccc:	f005 fb6e 	bl	80083ac <PID_SetKI>
          break;
 8002cd0:	e584      	b.n	80027dc <RI_SetRegisterMotor1+0x94>
          PID_SetKDDivisorPOW2(&PIDSpeedHandle_M1, regdata16);
 8002cd2:	4807      	ldr	r0, [pc, #28]	@ (8002cf0 <RI_SetRegisterMotor1+0x5a8>)
 8002cd4:	4629      	mov	r1, r5
 8002cd6:	f005 fba1 	bl	800841c <PID_SetKDDivisorPOW2>
          break;
 8002cda:	e57f      	b.n	80027dc <RI_SetRegisterMotor1+0x94>
 8002cdc:	20000494 	.word	0x20000494
 8002ce0:	20000000 	.word	0x20000000
 8002ce4:	2aaaaaab 	.word	0x2aaaaaab
 8002ce8:	200002a4 	.word	0x200002a4
 8002cec:	2000007c 	.word	0x2000007c
 8002cf0:	200003a8 	.word	0x200003a8
 8002cf4:	2000037c 	.word	0x2000037c
 8002cf8:	20000350 	.word	0x20000350
 8002cfc:	51eb851f 	.word	0x51eb851f
 8002d00:	20000058 	.word	0x20000058

08002d04 <RI_GetRegisterGlobal>:
uint8_t RI_GetRegisterGlobal(uint16_t regID,uint8_t typeID,uint8_t * data,uint16_t *size,int16_t freeSpace){
 8002d04:	b510      	push	{r4, lr}
    switch (typeID)
 8002d06:	f1a1 0c08 	sub.w	ip, r1, #8
uint8_t RI_GetRegisterGlobal(uint16_t regID,uint8_t typeID,uint8_t * data,uint16_t *size,int16_t freeSpace){
 8002d0a:	f9bd e008 	ldrsh.w	lr, [sp, #8]
    switch (typeID)
 8002d0e:	f1bc 0f20 	cmp.w	ip, #32
 8002d12:	d812      	bhi.n	8002d3a <RI_GetRegisterGlobal+0x36>
 8002d14:	e8df f00c 	tbb	[pc, ip]
 8002d18:	1111111b 	.word	0x1111111b
 8002d1c:	11111111 	.word	0x11111111
 8002d20:	11111127 	.word	0x11111127
 8002d24:	11111111 	.word	0x11111111
 8002d28:	11111122 	.word	0x11111122
 8002d2c:	11111111 	.word	0x11111111
 8002d30:	11111135 	.word	0x11111135
 8002d34:	11111111 	.word	0x11111111
 8002d38:	13          	.byte	0x13
 8002d39:	00          	.byte	0x00
 8002d3a:	2007      	movs	r0, #7
}
 8002d3c:	bd10      	pop	{r4, pc}
        switch (regID)
 8002d3e:	2828      	cmp	r0, #40	@ 0x28
 8002d40:	d044      	beq.n	8002dcc <RI_GetRegisterGlobal+0xc8>
        *size = (*rawSize) + 2U;
 8002d42:	8812      	ldrh	r2, [r2, #0]
 8002d44:	3202      	adds	r2, #2
            retVal = MCP_ERROR_UNKNOWN_REG;
 8002d46:	2005      	movs	r0, #5
        *size = (*rawSize) + 2U;
 8002d48:	b292      	uxth	r2, r2
 8002d4a:	801a      	strh	r2, [r3, #0]
}
 8002d4c:	bd10      	pop	{r4, pc}
        if (freeSpace > 0)
 8002d4e:	f1be 0f00 	cmp.w	lr, #0
 8002d52:	dd39      	ble.n	8002dc8 <RI_GetRegisterGlobal+0xc4>
 8002d54:	2201      	movs	r2, #1
            *size= 0 ; /* */
 8002d56:	801a      	strh	r2, [r3, #0]
              retVal = MCP_ERROR_UNKNOWN_REG;
 8002d58:	2005      	movs	r0, #5
}
 8002d5a:	bd10      	pop	{r4, pc}
        if (freeSpace >= 4)
 8002d5c:	f1be 0f03 	cmp.w	lr, #3
 8002d60:	dd2a      	ble.n	8002db8 <RI_GetRegisterGlobal+0xb4>
 8002d62:	2204      	movs	r2, #4
 8002d64:	e7f7      	b.n	8002d56 <RI_GetRegisterGlobal+0x52>
        if (freeSpace >= 2)
 8002d66:	f1be 0f01 	cmp.w	lr, #1
 8002d6a:	dd25      	ble.n	8002db8 <RI_GetRegisterGlobal+0xb4>
          switch (regID)
 8002d6c:	f5b0 6f65 	cmp.w	r0, #3664	@ 0xe50
 8002d70:	d05a      	beq.n	8002e28 <RI_GetRegisterGlobal+0x124>
 8002d72:	f5b0 6f69 	cmp.w	r0, #3728	@ 0xe90
 8002d76:	bf0c      	ite	eq
 8002d78:	2000      	moveq	r0, #0
 8002d7a:	2005      	movne	r0, #5
          *size = 2;
 8002d7c:	2202      	movs	r2, #2
 8002d7e:	801a      	strh	r2, [r3, #0]
}
 8002d80:	bd10      	pop	{r4, pc}
        switch (regID)
 8002d82:	2820      	cmp	r0, #32
 8002d84:	d02c      	beq.n	8002de0 <RI_GetRegisterGlobal+0xdc>
 8002d86:	2860      	cmp	r0, #96	@ 0x60
 8002d88:	d118      	bne.n	8002dbc <RI_GetRegisterGlobal+0xb8>
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8002d8a:	4c28      	ldr	r4, [pc, #160]	@ (8002e2c <RI_GetRegisterGlobal+0x128>)
 8002d8c:	f994 0000 	ldrsb.w	r0, [r4]
  *size= 1U ; /* /0 is the min String size */
 8002d90:	2101      	movs	r1, #1
 8002d92:	8019      	strh	r1, [r3, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8002d94:	b1a0      	cbz	r0, 8002dc0 <RI_GetRegisterGlobal+0xbc>
 8002d96:	fa1f fe8e 	uxth.w	lr, lr
  const char_t *tempsrcString = srcString;
 8002d9a:	46a4      	mov	ip, r4
 8002d9c:	e008      	b.n	8002db0 <RI_GetRegisterGlobal+0xac>
    *tempdestString = *tempsrcString;
 8002d9e:	f802 0b01 	strb.w	r0, [r2], #1
    *size = *size + 1U;
 8002da2:	8819      	ldrh	r1, [r3, #0]
 8002da4:	3101      	adds	r1, #1
 8002da6:	b289      	uxth	r1, r1
 8002da8:	8019      	strh	r1, [r3, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8002daa:	f91c 0f01 	ldrsb.w	r0, [ip, #1]!
 8002dae:	b138      	cbz	r0, 8002dc0 <RI_GetRegisterGlobal+0xbc>
 8002db0:	4571      	cmp	r1, lr
 8002db2:	d3f4      	bcc.n	8002d9e <RI_GetRegisterGlobal+0x9a>
    retVal = MCP_ERROR_STRING_FORMAT;
 8002db4:	2006      	movs	r0, #6
}
 8002db6:	bd10      	pop	{r4, pc}
          retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 8002db8:	2008      	movs	r0, #8
}
 8002dba:	bd10      	pop	{r4, pc}
 8002dbc:	2200      	movs	r2, #0
 8002dbe:	e7ca      	b.n	8002d56 <RI_GetRegisterGlobal+0x52>
    *tempdestString = (int8_t)0;
 8002dc0:	2300      	movs	r3, #0
 8002dc2:	7013      	strb	r3, [r2, #0]
  uint8_t retVal = MCP_CMD_OK;
 8002dc4:	2000      	movs	r0, #0
}
 8002dc6:	bd10      	pop	{r4, pc}
          retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 8002dc8:	4608      	mov	r0, r1
}
 8002dca:	bd10      	pop	{r4, pc}
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8002dcc:	fa1f fe8e 	uxth.w	lr, lr
            *rawSize = (uint16_t)sizeof(GlobalConfig_reg_t);
 8002dd0:	210a      	movs	r1, #10
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8002dd2:	f1be 0f0b 	cmp.w	lr, #11
            *rawSize = (uint16_t)sizeof(GlobalConfig_reg_t);
 8002dd6:	8011      	strh	r1, [r2, #0]
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8002dd8:	d81a      	bhi.n	8002e10 <RI_GetRegisterGlobal+0x10c>
 8002dda:	220c      	movs	r2, #12
              retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 8002ddc:	2008      	movs	r0, #8
 8002dde:	e7b4      	b.n	8002d4a <RI_GetRegisterGlobal+0x46>
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8002de0:	4c13      	ldr	r4, [pc, #76]	@ (8002e30 <RI_GetRegisterGlobal+0x12c>)
 8002de2:	f994 0000 	ldrsb.w	r0, [r4]
  *size= 1U ; /* /0 is the min String size */
 8002de6:	2101      	movs	r1, #1
 8002de8:	8019      	strh	r1, [r3, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8002dea:	2800      	cmp	r0, #0
 8002dec:	d0e8      	beq.n	8002dc0 <RI_GetRegisterGlobal+0xbc>
 8002dee:	fa1f fe8e 	uxth.w	lr, lr
  const char_t *tempsrcString = srcString;
 8002df2:	46a4      	mov	ip, r4
 8002df4:	e009      	b.n	8002e0a <RI_GetRegisterGlobal+0x106>
    *tempdestString = *tempsrcString;
 8002df6:	f802 0b01 	strb.w	r0, [r2], #1
    *size = *size + 1U;
 8002dfa:	8819      	ldrh	r1, [r3, #0]
 8002dfc:	3101      	adds	r1, #1
 8002dfe:	b289      	uxth	r1, r1
 8002e00:	8019      	strh	r1, [r3, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8002e02:	f91c 0f01 	ldrsb.w	r0, [ip, #1]!
 8002e06:	2800      	cmp	r0, #0
 8002e08:	d0da      	beq.n	8002dc0 <RI_GetRegisterGlobal+0xbc>
 8002e0a:	458e      	cmp	lr, r1
 8002e0c:	d8f3      	bhi.n	8002df6 <RI_GetRegisterGlobal+0xf2>
 8002e0e:	e7d1      	b.n	8002db4 <RI_GetRegisterGlobal+0xb0>
              (void)memcpy(rawData, &globalConfig_reg, sizeof(GlobalConfig_reg_t));
 8002e10:	4908      	ldr	r1, [pc, #32]	@ (8002e34 <RI_GetRegisterGlobal+0x130>)
 8002e12:	6848      	ldr	r0, [r1, #4]
 8002e14:	680c      	ldr	r4, [r1, #0]
 8002e16:	8909      	ldrh	r1, [r1, #8]
 8002e18:	f8c2 0006 	str.w	r0, [r2, #6]
 8002e1c:	f8c2 4002 	str.w	r4, [r2, #2]
 8002e20:	8151      	strh	r1, [r2, #10]
    uint8_t retVal = MCP_CMD_OK;
 8002e22:	2000      	movs	r0, #0
              (void)memcpy(rawData, &globalConfig_reg, sizeof(GlobalConfig_reg_t));
 8002e24:	220c      	movs	r2, #12
 8002e26:	e790      	b.n	8002d4a <RI_GetRegisterGlobal+0x46>
    uint8_t retVal = MCP_CMD_OK;
 8002e28:	2000      	movs	r0, #0
 8002e2a:	e7a7      	b.n	8002d7c <RI_GetRegisterGlobal+0x78>
 8002e2c:	0800a350 	.word	0x0800a350
 8002e30:	0800a328 	.word	0x0800a328
 8002e34:	0800a31c 	.word	0x0800a31c

08002e38 <RI_GetRegisterMotor1>:
  uint8_t RI_GetRegisterMotor1(uint16_t regID,uint8_t typeID,uint8_t * data,uint16_t *size,int16_t freeSpace) {
 8002e38:	b530      	push	{r4, r5, lr}
 8002e3a:	b095      	sub	sp, #84	@ 0x54
 8002e3c:	461d      	mov	r5, r3
    switch (typeID)
 8002e3e:	f1a1 0308 	sub.w	r3, r1, #8
  uint8_t RI_GetRegisterMotor1(uint16_t regID,uint8_t typeID,uint8_t * data,uint16_t *size,int16_t freeSpace) {
 8002e42:	f9bd c060 	ldrsh.w	ip, [sp, #96]	@ 0x60
 8002e46:	4614      	mov	r4, r2
    switch (typeID)
 8002e48:	2b20      	cmp	r3, #32
 8002e4a:	d812      	bhi.n	8002e72 <RI_GetRegisterMotor1+0x3a>
 8002e4c:	e8df f003 	tbb	[pc, r3]
 8002e50:	11111133 	.word	0x11111133
 8002e54:	11111111 	.word	0x11111111
 8002e58:	1111116b 	.word	0x1111116b
 8002e5c:	11111111 	.word	0x11111111
 8002e60:	11111145 	.word	0x11111145
 8002e64:	11111111 	.word	0x11111111
 8002e68:	11111161 	.word	0x11111161
 8002e6c:	11111111 	.word	0x11111111
 8002e70:	14          	.byte	0x14
 8002e71:	00          	.byte	0x00
 8002e72:	2007      	movs	r0, #7
  }
 8002e74:	b015      	add	sp, #84	@ 0x54
 8002e76:	bd30      	pop	{r4, r5, pc}
        rawData++;
 8002e78:	f5b0 7fd4 	cmp.w	r0, #424	@ 0x1a8
 8002e7c:	f104 0302 	add.w	r3, r4, #2
        switch (regID)
 8002e80:	f000 8280 	beq.w	8003384 <RI_GetRegisterMotor1+0x54c>
 8002e84:	f200 8083 	bhi.w	8002f8e <RI_GetRegisterMotor1+0x156>
 8002e88:	28e8      	cmp	r0, #232	@ 0xe8
 8002e8a:	f000 82e3 	beq.w	8003454 <RI_GetRegisterMotor1+0x61c>
 8002e8e:	d86f      	bhi.n	8002f70 <RI_GetRegisterMotor1+0x138>
 8002e90:	2868      	cmp	r0, #104	@ 0x68
 8002e92:	f000 8288 	beq.w	80033a6 <RI_GetRegisterMotor1+0x56e>
 8002e96:	28a8      	cmp	r0, #168	@ 0xa8
 8002e98:	f040 8290 	bne.w	80033bc <RI_GetRegisterMotor1+0x584>
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8002e9c:	fa1f fc8c 	uxth.w	ip, ip
            *rawSize = (uint16_t)sizeof(ApplicationConfig_reg_t);
 8002ea0:	2210      	movs	r2, #16
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8002ea2:	f1bc 0f11 	cmp.w	ip, #17
            *rawSize = (uint16_t)sizeof(ApplicationConfig_reg_t);
 8002ea6:	8022      	strh	r2, [r4, #0]
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8002ea8:	f200 824b 	bhi.w	8003342 <RI_GetRegisterMotor1+0x50a>
 8002eac:	2312      	movs	r3, #18
              retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 8002eae:	2008      	movs	r0, #8
        *size = (*rawSize) + 2U;
 8002eb0:	802b      	strh	r3, [r5, #0]
  }
 8002eb2:	b015      	add	sp, #84	@ 0x54
 8002eb4:	bd30      	pop	{r4, r5, pc}
        if (freeSpace > 0)
 8002eb6:	f1bc 0f00 	cmp.w	ip, #0
 8002eba:	f340 824f 	ble.w	800335c <RI_GetRegisterMotor1+0x524>
          switch (regID)
 8002ebe:	2888      	cmp	r0, #136	@ 0x88
 8002ec0:	f000 825a 	beq.w	8003378 <RI_GetRegisterMotor1+0x540>
 8002ec4:	28c8      	cmp	r0, #200	@ 0xc8
 8002ec6:	f000 8253 	beq.w	8003370 <RI_GetRegisterMotor1+0x538>
 8002eca:	2848      	cmp	r0, #72	@ 0x48
 8002ecc:	f000 824a 	beq.w	8003364 <RI_GetRegisterMotor1+0x52c>
 8002ed0:	2005      	movs	r0, #5
          *size = 1;
 8002ed2:	2301      	movs	r3, #1
 8002ed4:	802b      	strh	r3, [r5, #0]
  }
 8002ed6:	b015      	add	sp, #84	@ 0x54
 8002ed8:	bd30      	pop	{r4, r5, pc}
        if (freeSpace >= 4)
 8002eda:	f1bc 0f03 	cmp.w	ip, #3
 8002ede:	f340 81ec 	ble.w	80032ba <RI_GetRegisterMotor1+0x482>
          switch (regID)
 8002ee2:	f5b0 7fac 	cmp.w	r0, #344	@ 0x158
 8002ee6:	f000 82cc 	beq.w	8003482 <RI_GetRegisterMotor1+0x64a>
 8002eea:	f200 81ce 	bhi.w	800328a <RI_GetRegisterMotor1+0x452>
 8002eee:	2858      	cmp	r0, #88	@ 0x58
 8002ef0:	f000 82ba 	beq.w	8003468 <RI_GetRegisterMotor1+0x630>
 8002ef4:	2898      	cmp	r0, #152	@ 0x98
 8002ef6:	f040 81d9 	bne.w	80032ac <RI_GetRegisterMotor1+0x474>
              *regdata32 = (((int32_t)MCI_GetMecSpeedRefUnit(pMCIN) * U_RPM) / SPEED_UNIT);
 8002efa:	48ae      	ldr	r0, [pc, #696]	@ (80031b4 <RI_GetRegisterMotor1+0x37c>)
 8002efc:	f7fe f9d2 	bl	80012a4 <MCI_GetMecSpeedRefUnit>
 8002f00:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8002f04:	0040      	lsls	r0, r0, #1
 8002f06:	6020      	str	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8002f08:	2000      	movs	r0, #0
          *size = 4;
 8002f0a:	2304      	movs	r3, #4
 8002f0c:	802b      	strh	r3, [r5, #0]
  }
 8002f0e:	b015      	add	sp, #84	@ 0x54
 8002f10:	bd30      	pop	{r4, r5, pc}
        switch (regID)
 8002f12:	28a0      	cmp	r0, #160	@ 0xa0
 8002f14:	f000 81f1 	beq.w	80032fa <RI_GetRegisterMotor1+0x4c2>
 8002f18:	28e0      	cmp	r0, #224	@ 0xe0
 8002f1a:	f000 81d1 	beq.w	80032c0 <RI_GetRegisterMotor1+0x488>
            *size= 0 ; /* */
 8002f1e:	2300      	movs	r3, #0
 8002f20:	802b      	strh	r3, [r5, #0]
            retVal = MCP_ERROR_UNKNOWN_REG;
 8002f22:	2005      	movs	r0, #5
            break;
 8002f24:	e7a6      	b.n	8002e74 <RI_GetRegisterMotor1+0x3c>
        if (freeSpace >= 2)
 8002f26:	f1bc 0f01 	cmp.w	ip, #1
 8002f2a:	f340 81c6 	ble.w	80032ba <RI_GetRegisterMotor1+0x482>
          switch (regID)
 8002f2e:	f5b0 6f1d 	cmp.w	r0, #2512	@ 0x9d0
 8002f32:	f000 8322 	beq.w	800357a <RI_GetRegisterMotor1+0x742>
 8002f36:	f200 80a3 	bhi.w	8003080 <RI_GetRegisterMotor1+0x248>
 8002f3a:	f5b0 6f82 	cmp.w	r0, #1040	@ 0x410
 8002f3e:	f000 832d 	beq.w	800359c <RI_GetRegisterMotor1+0x764>
 8002f42:	f240 8084 	bls.w	800304e <RI_GetRegisterMotor1+0x216>
 8002f46:	f5b0 6f09 	cmp.w	r0, #2192	@ 0x890
 8002f4a:	f000 8320 	beq.w	800358e <RI_GetRegisterMotor1+0x756>
 8002f4e:	d953      	bls.n	8002ff8 <RI_GetRegisterMotor1+0x1c0>
 8002f50:	f5b0 6f15 	cmp.w	r0, #2384	@ 0x950
 8002f54:	f000 8316 	beq.w	8003584 <RI_GetRegisterMotor1+0x74c>
 8002f58:	d946      	bls.n	8002fe8 <RI_GetRegisterMotor1+0x1b0>
 8002f5a:	f5b0 6f19 	cmp.w	r0, #2448	@ 0x990
 8002f5e:	f040 820f 	bne.w	8003380 <RI_GetRegisterMotor1+0x548>
              *regdata16 = MCI_GetIqdref(pMCIN).d;
 8002f62:	4894      	ldr	r0, [pc, #592]	@ (80031b4 <RI_GetRegisterMotor1+0x37c>)
 8002f64:	f7fe f9cc 	bl	8001300 <MCI_GetIqdref>
 8002f68:	f3c0 430f 	ubfx	r3, r0, #16, #16
 8002f6c:	8023      	strh	r3, [r4, #0]
              break;
 8002f6e:	e0f0      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
 8002f70:	f5b0 7f94 	cmp.w	r0, #296	@ 0x128
 8002f74:	f040 8222 	bne.w	80033bc <RI_GetRegisterMotor1+0x584>
            if ((*rawSize) +2U > (uint16_t)freeSpace)
 8002f78:	fa1f fc8c 	uxth.w	ip, ip
            *rawSize = 12;
 8002f7c:	220c      	movs	r2, #12
            if ((*rawSize) +2U > (uint16_t)freeSpace)
 8002f7e:	f1bc 0f0d 	cmp.w	ip, #13
            *rawSize = 12;
 8002f82:	8022      	strh	r2, [r4, #0]
            if ((*rawSize) +2U > (uint16_t)freeSpace)
 8002f84:	f200 81d1 	bhi.w	800332a <RI_GetRegisterMotor1+0x4f2>
 8002f88:	230e      	movs	r3, #14
              retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 8002f8a:	2008      	movs	r0, #8
 8002f8c:	e790      	b.n	8002eb0 <RI_GetRegisterMotor1+0x78>
 8002f8e:	f5b0 7f0a 	cmp.w	r0, #552	@ 0x228
 8002f92:	f000 8218 	beq.w	80033c6 <RI_GetRegisterMotor1+0x58e>
 8002f96:	f5b0 7f5a 	cmp.w	r0, #872	@ 0x368
 8002f9a:	d112      	bne.n	8002fc2 <RI_GetRegisterMotor1+0x18a>
            *rawSize = 4;
 8002f9c:	2304      	movs	r3, #4
 8002f9e:	8023      	strh	r3, [r4, #0]
            *iqref = (uint16_t)MCI_GetIqdref(pMCIN).q;
 8002fa0:	4884      	ldr	r0, [pc, #528]	@ (80031b4 <RI_GetRegisterMotor1+0x37c>)
 8002fa2:	f7fe f9ad 	bl	8001300 <MCI_GetIqdref>
 8002fa6:	4603      	mov	r3, r0
 8002fa8:	8063      	strh	r3, [r4, #2]
            *idref = (uint16_t)MCI_GetIqdref(pMCIN).d;
 8002faa:	4882      	ldr	r0, [pc, #520]	@ (80031b4 <RI_GetRegisterMotor1+0x37c>)
            *iqref = (uint16_t)MCI_GetIqdref(pMCIN).q;
 8002fac:	9312      	str	r3, [sp, #72]	@ 0x48
            *idref = (uint16_t)MCI_GetIqdref(pMCIN).d;
 8002fae:	f7fe f9a7 	bl	8001300 <MCI_GetIqdref>
        *size = (*rawSize) + 2U;
 8002fb2:	8823      	ldrh	r3, [r4, #0]
            *idref = (uint16_t)MCI_GetIqdref(pMCIN).d;
 8002fb4:	f3c0 400f 	ubfx	r0, r0, #16, #16
        *size = (*rawSize) + 2U;
 8002fb8:	3302      	adds	r3, #2
            *idref = (uint16_t)MCI_GetIqdref(pMCIN).d;
 8002fba:	80a0      	strh	r0, [r4, #4]
        *size = (*rawSize) + 2U;
 8002fbc:	b29b      	uxth	r3, r3
    uint8_t retVal = MCP_CMD_OK;
 8002fbe:	2000      	movs	r0, #0
            break;
 8002fc0:	e776      	b.n	8002eb0 <RI_GetRegisterMotor1+0x78>
 8002fc2:	f5b0 7ff4 	cmp.w	r0, #488	@ 0x1e8
 8002fc6:	f040 81f9 	bne.w	80033bc <RI_GetRegisterMotor1+0x584>
            *rawSize = 4;
 8002fca:	2304      	movs	r3, #4
 8002fcc:	8023      	strh	r3, [r4, #0]
            *torque = MCI_GetLastRampFinalTorque(pMCIN);
 8002fce:	4879      	ldr	r0, [pc, #484]	@ (80031b4 <RI_GetRegisterMotor1+0x37c>)
 8002fd0:	f7fe f958 	bl	8001284 <MCI_GetLastRampFinalTorque>
 8002fd4:	8060      	strh	r0, [r4, #2]
            *duration = MCI_GetLastRampFinalDuration(pMCIN) ;
 8002fd6:	4877      	ldr	r0, [pc, #476]	@ (80031b4 <RI_GetRegisterMotor1+0x37c>)
 8002fd8:	f7fe f958 	bl	800128c <MCI_GetLastRampFinalDuration>
        *size = (*rawSize) + 2U;
 8002fdc:	8823      	ldrh	r3, [r4, #0]
            *duration = MCI_GetLastRampFinalDuration(pMCIN) ;
 8002fde:	80a0      	strh	r0, [r4, #4]
        *size = (*rawSize) + 2U;
 8002fe0:	3302      	adds	r3, #2
 8002fe2:	b29b      	uxth	r3, r3
    uint8_t retVal = MCP_CMD_OK;
 8002fe4:	2000      	movs	r0, #0
            break;
 8002fe6:	e763      	b.n	8002eb0 <RI_GetRegisterMotor1+0x78>
 8002fe8:	f5b0 6f0d 	cmp.w	r0, #2256	@ 0x8d0
 8002fec:	d113      	bne.n	8003016 <RI_GetRegisterMotor1+0x1de>
              *regdata16 = MCI_GetIqd(pMCIN).q;
 8002fee:	4871      	ldr	r0, [pc, #452]	@ (80031b4 <RI_GetRegisterMotor1+0x37c>)
 8002ff0:	f7fe f978 	bl	80012e4 <MCI_GetIqd>
 8002ff4:	8020      	strh	r0, [r4, #0]
              break;
 8002ff6:	e0ac      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
 8002ff8:	f5b0 6ffa 	cmp.w	r0, #2000	@ 0x7d0
 8002ffc:	f000 82a7 	beq.w	800354e <RI_GetRegisterMotor1+0x716>
 8003000:	d91d      	bls.n	800303e <RI_GetRegisterMotor1+0x206>
 8003002:	f5b0 6f01 	cmp.w	r0, #2064	@ 0x810
 8003006:	d111      	bne.n	800302c <RI_GetRegisterMotor1+0x1f4>
              *regdata16 = MCI_GetIab(pMCIN).b;
 8003008:	486a      	ldr	r0, [pc, #424]	@ (80031b4 <RI_GetRegisterMotor1+0x37c>)
 800300a:	f7fe f94f 	bl	80012ac <MCI_GetIab>
 800300e:	f3c0 430f 	ubfx	r3, r0, #16, #16
 8003012:	8023      	strh	r3, [r4, #0]
              break;
 8003014:	e09d      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
 8003016:	f5b0 6f11 	cmp.w	r0, #2320	@ 0x910
 800301a:	f040 81b1 	bne.w	8003380 <RI_GetRegisterMotor1+0x548>
              *regdata16 = MCI_GetIqd(pMCIN).d;
 800301e:	4865      	ldr	r0, [pc, #404]	@ (80031b4 <RI_GetRegisterMotor1+0x37c>)
 8003020:	f7fe f960 	bl	80012e4 <MCI_GetIqd>
 8003024:	f3c0 430f 	ubfx	r3, r0, #16, #16
 8003028:	8023      	strh	r3, [r4, #0]
              break;
 800302a:	e092      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
 800302c:	f5b0 6f05 	cmp.w	r0, #2128	@ 0x850
 8003030:	f040 81a6 	bne.w	8003380 <RI_GetRegisterMotor1+0x548>
              *regdata16 = MCI_GetIalphabeta(pMCIN).alpha;
 8003034:	485f      	ldr	r0, [pc, #380]	@ (80031b4 <RI_GetRegisterMotor1+0x37c>)
 8003036:	f7fe f947 	bl	80012c8 <MCI_GetIalphabeta>
 800303a:	8020      	strh	r0, [r4, #0]
              break;
 800303c:	e089      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
 800303e:	f5b0 6fb2 	cmp.w	r0, #1424	@ 0x590
 8003042:	d143      	bne.n	80030cc <RI_GetRegisterMotor1+0x294>
              *regdataU16 = VBS_GetAvBusVoltage_V(BusVoltageSensor);
 8003044:	485c      	ldr	r0, [pc, #368]	@ (80031b8 <RI_GetRegisterMotor1+0x380>)
 8003046:	f004 ff9f 	bl	8007f88 <VBS_GetAvBusVoltage_V>
 800304a:	8020      	strh	r0, [r4, #0]
              break;
 800304c:	e081      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
 800304e:	f5b0 7f04 	cmp.w	r0, #528	@ 0x210
 8003052:	f000 8277 	beq.w	8003544 <RI_GetRegisterMotor1+0x70c>
 8003056:	f240 80eb 	bls.w	8003230 <RI_GetRegisterMotor1+0x3f8>
 800305a:	f5b0 7f44 	cmp.w	r0, #784	@ 0x310
 800305e:	f000 826c 	beq.w	800353a <RI_GetRegisterMotor1+0x702>
 8003062:	f240 80dd 	bls.w	8003220 <RI_GetRegisterMotor1+0x3e8>
 8003066:	f5b0 7f74 	cmp.w	r0, #976	@ 0x3d0
 800306a:	f040 8189 	bne.w	8003380 <RI_GetRegisterMotor1+0x548>
              STO_CR_GetObserverGains(&STO_CR_M1, &hC1, &hC2);
 800306e:	4853      	ldr	r0, [pc, #332]	@ (80031bc <RI_GetRegisterMotor1+0x384>)
 8003070:	aa13      	add	r2, sp, #76	@ 0x4c
 8003072:	a912      	add	r1, sp, #72	@ 0x48
 8003074:	f006 fed8 	bl	8009e28 <STO_CR_GetObserverGains>
              *regdata16 = hC1;
 8003078:	f8bd 3048 	ldrh.w	r3, [sp, #72]	@ 0x48
 800307c:	8023      	strh	r3, [r4, #0]
              break;
 800307e:	e068      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
 8003080:	f5b0 6f69 	cmp.w	r0, #3728	@ 0xe90
 8003084:	d065      	beq.n	8003152 <RI_GetRegisterMotor1+0x31a>
 8003086:	d942      	bls.n	800310e <RI_GetRegisterMotor1+0x2d6>
 8003088:	f241 5390 	movw	r3, #5520	@ 0x1590
 800308c:	4298      	cmp	r0, r3
 800308e:	f000 824f 	beq.w	8003530 <RI_GetRegisterMotor1+0x6f8>
 8003092:	d92d      	bls.n	80030f0 <RI_GetRegisterMotor1+0x2b8>
 8003094:	f241 6350 	movw	r3, #5712	@ 0x1650
 8003098:	4298      	cmp	r0, r3
 800309a:	f000 8244 	beq.w	8003526 <RI_GetRegisterMotor1+0x6ee>
 800309e:	d91e      	bls.n	80030de <RI_GetRegisterMotor1+0x2a6>
 80030a0:	f641 23d0 	movw	r3, #6864	@ 0x1ad0
 80030a4:	4298      	cmp	r0, r3
 80030a6:	f040 816b 	bne.w	8003380 <RI_GetRegisterMotor1+0x548>
{
  int16_t hVoltage;
#ifdef NULL_PTR_CHECK_OPEN_LOOP
  hVoltage = ((MC_NULL == pHandle) ? 0 : pHandle->hVoltage);
#else
  hVoltage = pHandle->hVoltage;
 80030aa:	4b45      	ldr	r3, [pc, #276]	@ (80031c0 <RI_GetRegisterMotor1+0x388>)
            *regdata16 = ((OL_GetVoltage(&OpenLoop_ParamsM1)*100)/32767);
 80030ac:	4a45      	ldr	r2, [pc, #276]	@ (80031c4 <RI_GetRegisterMotor1+0x38c>)
 80030ae:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 80030b2:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80030b6:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80030ba:	009b      	lsls	r3, r3, #2
 80030bc:	fb82 1203 	smull	r1, r2, r2, r3
 80030c0:	441a      	add	r2, r3
 80030c2:	17db      	asrs	r3, r3, #31
 80030c4:	ebc3 33a2 	rsb	r3, r3, r2, asr #14
 80030c8:	8023      	strh	r3, [r4, #0]
              break;
 80030ca:	e042      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
 80030cc:	f5b0 6fba 	cmp.w	r0, #1488	@ 0x5d0
 80030d0:	f040 8156 	bne.w	8003380 <RI_GetRegisterMotor1+0x548>
              *regdata16 = NTC_GetAvTemp_C(&TempSensor_M1);
 80030d4:	483c      	ldr	r0, [pc, #240]	@ (80031c8 <RI_GetRegisterMotor1+0x390>)
 80030d6:	f005 f933 	bl	8008340 <NTC_GetAvTemp_C>
 80030da:	8020      	strh	r0, [r4, #0]
              break;
 80030dc:	e039      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
 80030de:	f241 53d0 	movw	r3, #5584	@ 0x15d0
 80030e2:	4298      	cmp	r0, r3
 80030e4:	d127      	bne.n	8003136 <RI_GetRegisterMotor1+0x2fe>
              *regdataU16 = PID_GetKPDivisorPOW2(&PIDIqHandle_M1);
 80030e6:	4839      	ldr	r0, [pc, #228]	@ (80031cc <RI_GetRegisterMotor1+0x394>)
 80030e8:	f005 f96c 	bl	80083c4 <PID_GetKPDivisorPOW2>
 80030ec:	8020      	strh	r0, [r4, #0]
              break;
 80030ee:	e030      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
 80030f0:	f241 43d0 	movw	r3, #5328	@ 0x14d0
 80030f4:	4298      	cmp	r0, r3
 80030f6:	f000 8211 	beq.w	800351c <RI_GetRegisterMotor1+0x6e4>
 80030fa:	d975      	bls.n	80031e8 <RI_GetRegisterMotor1+0x3b0>
 80030fc:	f241 5310 	movw	r3, #5392	@ 0x1510
 8003100:	4298      	cmp	r0, r3
 8003102:	d167      	bne.n	80031d4 <RI_GetRegisterMotor1+0x39c>
              *regdataU16 = PID_GetKPDivisorPOW2(&PIDIdHandle_M1);
 8003104:	4832      	ldr	r0, [pc, #200]	@ (80031d0 <RI_GetRegisterMotor1+0x398>)
 8003106:	f005 f95d 	bl	80083c4 <PID_GetKPDivisorPOW2>
 800310a:	8020      	strh	r0, [r4, #0]
              break;
 800310c:	e021      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
 800310e:	f5b0 6f51 	cmp.w	r0, #3344	@ 0xd10
 8003112:	f000 81fe 	beq.w	8003512 <RI_GetRegisterMotor1+0x6da>
 8003116:	d929      	bls.n	800316c <RI_GetRegisterMotor1+0x334>
 8003118:	f5b0 6f5d 	cmp.w	r0, #3536	@ 0xdd0
 800311c:	f000 8221 	beq.w	8003562 <RI_GetRegisterMotor1+0x72a>
 8003120:	d91c      	bls.n	800315c <RI_GetRegisterMotor1+0x324>
 8003122:	f5b0 6f61 	cmp.w	r0, #3600	@ 0xe10
 8003126:	d110      	bne.n	800314a <RI_GetRegisterMotor1+0x312>
              *regdata16 = STO_CR_GetEstimatedBemf(&STO_CR_M1).beta;
 8003128:	4824      	ldr	r0, [pc, #144]	@ (80031bc <RI_GetRegisterMotor1+0x384>)
 800312a:	f006 fe5f 	bl	8009dec <STO_CR_GetEstimatedBemf>
 800312e:	f3c0 430f 	ubfx	r3, r0, #16, #16
 8003132:	8023      	strh	r3, [r4, #0]
              break;
 8003134:	e00d      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
 8003136:	f241 6310 	movw	r3, #5648	@ 0x1610
 800313a:	4298      	cmp	r0, r3
 800313c:	f040 8120 	bne.w	8003380 <RI_GetRegisterMotor1+0x548>
              *regdataU16 = PID_GetKIDivisorPOW2(&PIDIqHandle_M1);
 8003140:	4822      	ldr	r0, [pc, #136]	@ (80031cc <RI_GetRegisterMotor1+0x394>)
 8003142:	f005 f949 	bl	80083d8 <PID_GetKIDivisorPOW2>
 8003146:	8020      	strh	r0, [r4, #0]
              break;
 8003148:	e003      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
 800314a:	f5b0 6f65 	cmp.w	r0, #3664	@ 0xe50
 800314e:	f040 8117 	bne.w	8003380 <RI_GetRegisterMotor1+0x548>
    uint8_t retVal = MCP_CMD_OK;
 8003152:	2000      	movs	r0, #0
          *size = 2;
 8003154:	2302      	movs	r3, #2
 8003156:	802b      	strh	r3, [r5, #0]
  }
 8003158:	b015      	add	sp, #84	@ 0x54
 800315a:	bd30      	pop	{r4, r5, pc}
 800315c:	f5b0 6f55 	cmp.w	r0, #3408	@ 0xd50
 8003160:	d112      	bne.n	8003188 <RI_GetRegisterMotor1+0x350>
              *regdata16 = STO_CR_GetEstimatedCurrent(&STO_CR_M1).alpha;
 8003162:	4816      	ldr	r0, [pc, #88]	@ (80031bc <RI_GetRegisterMotor1+0x384>)
 8003164:	f006 fe4e 	bl	8009e04 <STO_CR_GetEstimatedCurrent>
 8003168:	8020      	strh	r0, [r4, #0]
              break;
 800316a:	e7f2      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
 800316c:	f5b0 6f29 	cmp.w	r0, #2704	@ 0xa90
 8003170:	f000 81fc 	beq.w	800356c <RI_GetRegisterMotor1+0x734>
 8003174:	d913      	bls.n	800319e <RI_GetRegisterMotor1+0x366>
 8003176:	f5b0 6f4d 	cmp.w	r0, #3280	@ 0xcd0
 800317a:	f040 8101 	bne.w	8003380 <RI_GetRegisterMotor1+0x548>
 800317e:	4b0f      	ldr	r3, [pc, #60]	@ (80031bc <RI_GetRegisterMotor1+0x384>)
 8003180:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
              *regdata16 = SPD_GetElAngle((SpeednPosFdbk_Handle_t *)&STO_CR_M1);
 8003184:	8023      	strh	r3, [r4, #0]
              break;
 8003186:	e7e4      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
 8003188:	f5b0 6f59 	cmp.w	r0, #3472	@ 0xd90
 800318c:	f040 80f8 	bne.w	8003380 <RI_GetRegisterMotor1+0x548>
              *regdata16 = STO_CR_GetEstimatedCurrent(&STO_CR_M1).beta;
 8003190:	480a      	ldr	r0, [pc, #40]	@ (80031bc <RI_GetRegisterMotor1+0x384>)
 8003192:	f006 fe37 	bl	8009e04 <STO_CR_GetEstimatedCurrent>
 8003196:	f3c0 430f 	ubfx	r3, r0, #16, #16
 800319a:	8023      	strh	r3, [r4, #0]
              break;
 800319c:	e7d9      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
 800319e:	f5b0 6f21 	cmp.w	r0, #2576	@ 0xa10
 80031a2:	d12a      	bne.n	80031fa <RI_GetRegisterMotor1+0x3c2>
              *regdata16 = MCI_GetVqd(pMCIN).d;
 80031a4:	4803      	ldr	r0, [pc, #12]	@ (80031b4 <RI_GetRegisterMotor1+0x37c>)
 80031a6:	f7fe f8b9 	bl	800131c <MCI_GetVqd>
 80031aa:	f3c0 430f 	ubfx	r3, r0, #16, #16
 80031ae:	8023      	strh	r3, [r4, #0]
              break;
 80031b0:	e7cf      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
 80031b2:	bf00      	nop
 80031b4:	20000000 	.word	0x20000000
 80031b8:	200003e4 	.word	0x200003e4
 80031bc:	2000007c 	.word	0x2000007c
 80031c0:	20000058 	.word	0x20000058
 80031c4:	80010003 	.word	0x80010003
 80031c8:	20000410 	.word	0x20000410
 80031cc:	2000037c 	.word	0x2000037c
 80031d0:	20000350 	.word	0x20000350
 80031d4:	f241 5350 	movw	r3, #5456	@ 0x1550
 80031d8:	4298      	cmp	r0, r3
 80031da:	f040 80d1 	bne.w	8003380 <RI_GetRegisterMotor1+0x548>
              *regdataU16 = PID_GetKIDivisorPOW2(&PIDIdHandle_M1);
 80031de:	48ad      	ldr	r0, [pc, #692]	@ (8003494 <RI_GetRegisterMotor1+0x65c>)
 80031e0:	f005 f8fa 	bl	80083d8 <PID_GetKIDivisorPOW2>
 80031e4:	8020      	strh	r0, [r4, #0]
              break;
 80031e6:	e7b4      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
 80031e8:	f241 4350 	movw	r3, #5200	@ 0x1450
 80031ec:	4298      	cmp	r0, r3
 80031ee:	d10d      	bne.n	800320c <RI_GetRegisterMotor1+0x3d4>
              *regdataU16 = (uint16_t)PID_GetKPDivisorPOW2(&PIDSpeedHandle_M1);
 80031f0:	48a9      	ldr	r0, [pc, #676]	@ (8003498 <RI_GetRegisterMotor1+0x660>)
 80031f2:	f005 f8e7 	bl	80083c4 <PID_GetKPDivisorPOW2>
 80031f6:	8020      	strh	r0, [r4, #0]
              break;
 80031f8:	e7ab      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
 80031fa:	f5b0 6f25 	cmp.w	r0, #2640	@ 0xa50
 80031fe:	f040 80bf 	bne.w	8003380 <RI_GetRegisterMotor1+0x548>
              *regdata16 = MCI_GetValphabeta(pMCIN).alpha;
 8003202:	48a6      	ldr	r0, [pc, #664]	@ (800349c <RI_GetRegisterMotor1+0x664>)
 8003204:	f7fe f898 	bl	8001338 <MCI_GetValphabeta>
 8003208:	8020      	strh	r0, [r4, #0]
              break;
 800320a:	e7a2      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
 800320c:	f241 4390 	movw	r3, #5264	@ 0x1490
 8003210:	4298      	cmp	r0, r3
 8003212:	f040 80b5 	bne.w	8003380 <RI_GetRegisterMotor1+0x548>
              *regdataU16 = (uint16_t)PID_GetKIDivisorPOW2(&PIDSpeedHandle_M1);
 8003216:	48a0      	ldr	r0, [pc, #640]	@ (8003498 <RI_GetRegisterMotor1+0x660>)
 8003218:	f005 f8de 	bl	80083d8 <PID_GetKIDivisorPOW2>
 800321c:	8020      	strh	r0, [r4, #0]
              break;
 800321e:	e798      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
 8003220:	f5b0 7f24 	cmp.w	r0, #656	@ 0x290
 8003224:	d111      	bne.n	800324a <RI_GetRegisterMotor1+0x412>
              *regdata16 = PID_GetKP(&PIDIdHandle_M1);
 8003226:	489b      	ldr	r0, [pc, #620]	@ (8003494 <RI_GetRegisterMotor1+0x65c>)
 8003228:	f005 f8c2 	bl	80083b0 <PID_GetKP>
 800322c:	8020      	strh	r0, [r4, #0]
              break;
 800322e:	e790      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
 8003230:	f5b0 7f88 	cmp.w	r0, #272	@ 0x110
 8003234:	f000 8190 	beq.w	8003558 <RI_GetRegisterMotor1+0x720>
 8003238:	d919      	bls.n	800326e <RI_GetRegisterMotor1+0x436>
 800323a:	f5b0 7fc8 	cmp.w	r0, #400	@ 0x190
 800323e:	d10d      	bne.n	800325c <RI_GetRegisterMotor1+0x424>
              *regdata16 = PID_GetKP(&PIDIqHandle_M1);
 8003240:	4897      	ldr	r0, [pc, #604]	@ (80034a0 <RI_GetRegisterMotor1+0x668>)
 8003242:	f005 f8b5 	bl	80083b0 <PID_GetKP>
 8003246:	8020      	strh	r0, [r4, #0]
              break;
 8003248:	e783      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
 800324a:	f5b0 7f34 	cmp.w	r0, #720	@ 0x2d0
 800324e:	f040 8097 	bne.w	8003380 <RI_GetRegisterMotor1+0x548>
              *regdata16 = PID_GetKI(&PIDIdHandle_M1);
 8003252:	4890      	ldr	r0, [pc, #576]	@ (8003494 <RI_GetRegisterMotor1+0x65c>)
 8003254:	f005 f8b0 	bl	80083b8 <PID_GetKI>
 8003258:	8020      	strh	r0, [r4, #0]
              break;
 800325a:	e77a      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
 800325c:	f5b0 7fe8 	cmp.w	r0, #464	@ 0x1d0
 8003260:	f040 808e 	bne.w	8003380 <RI_GetRegisterMotor1+0x548>
              *regdata16 = PID_GetKI(&PIDIqHandle_M1);
 8003264:	488e      	ldr	r0, [pc, #568]	@ (80034a0 <RI_GetRegisterMotor1+0x668>)
 8003266:	f005 f8a7 	bl	80083b8 <PID_GetKI>
 800326a:	8020      	strh	r0, [r4, #0]
              break;
 800326c:	e771      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
 800326e:	2890      	cmp	r0, #144	@ 0x90
 8003270:	d104      	bne.n	800327c <RI_GetRegisterMotor1+0x444>
              *regdata16 = PID_GetKP(&PIDSpeedHandle_M1);
 8003272:	4889      	ldr	r0, [pc, #548]	@ (8003498 <RI_GetRegisterMotor1+0x660>)
 8003274:	f005 f89c 	bl	80083b0 <PID_GetKP>
 8003278:	8020      	strh	r0, [r4, #0]
              break;
 800327a:	e76a      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
 800327c:	28d0      	cmp	r0, #208	@ 0xd0
 800327e:	d17f      	bne.n	8003380 <RI_GetRegisterMotor1+0x548>
              *regdata16 = PID_GetKI(&PIDSpeedHandle_M1);
 8003280:	4885      	ldr	r0, [pc, #532]	@ (8003498 <RI_GetRegisterMotor1+0x660>)
 8003282:	f005 f899 	bl	80083b8 <PID_GetKI>
 8003286:	8020      	strh	r0, [r4, #0]
              break;
 8003288:	e763      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
 800328a:	f5b0 7fcc 	cmp.w	r0, #408	@ 0x198
 800328e:	f000 80f3 	beq.w	8003478 <RI_GetRegisterMotor1+0x640>
 8003292:	f641 3358 	movw	r3, #7000	@ 0x1b58
 8003296:	4298      	cmp	r0, r3
 8003298:	d162      	bne.n	8003360 <RI_GetRegisterMotor1+0x528>
              ReadVal.Float_Val = PQD_GetAvrgElMotorPowerW(pMPM[M1]);
 800329a:	4b82      	ldr	r3, [pc, #520]	@ (80034a4 <RI_GetRegisterMotor1+0x66c>)
 800329c:	6818      	ldr	r0, [r3, #0]
 800329e:	f005 f91f 	bl	80084e0 <PQD_GetAvrgElMotorPowerW>
 80032a2:	ed8d 0a01 	vstr	s0, [sp, #4]
              *regdataU32 = ReadVal.U32_Val; //cstat !UNION-type-punning
 80032a6:	9b01      	ldr	r3, [sp, #4]
 80032a8:	6023      	str	r3, [r4, #0]
              break;
 80032aa:	e62d      	b.n	8002f08 <RI_GetRegisterMotor1+0xd0>
 80032ac:	2818      	cmp	r0, #24
 80032ae:	d157      	bne.n	8003360 <RI_GetRegisterMotor1+0x528>
              *regdataU32 = MCI_GetFaultState(pMCIN);
 80032b0:	487a      	ldr	r0, [pc, #488]	@ (800349c <RI_GetRegisterMotor1+0x664>)
 80032b2:	f7fd ff9b 	bl	80011ec <MCI_GetFaultState>
 80032b6:	6020      	str	r0, [r4, #0]
              break;
 80032b8:	e626      	b.n	8002f08 <RI_GetRegisterMotor1+0xd0>
          retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 80032ba:	2008      	movs	r0, #8
  }
 80032bc:	b015      	add	sp, #84	@ 0x54
 80032be:	bd30      	pop	{r4, r5, pc}
            retVal = RI_MovString (MotorConfig_reg[motorID]->name ,charData, size, freeSpace);
 80032c0:	4b79      	ldr	r3, [pc, #484]	@ (80034a8 <RI_GetRegisterMotor1+0x670>)
 80032c2:	681a      	ldr	r2, [r3, #0]
  *size= 1U ; /* /0 is the min String size */
 80032c4:	2301      	movs	r3, #1
 80032c6:	802b      	strh	r3, [r5, #0]
            retVal = RI_MovString (MotorConfig_reg[motorID]->name ,charData, size, freeSpace);
 80032c8:	f102 0124 	add.w	r1, r2, #36	@ 0x24
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 80032cc:	f992 2024 	ldrsb.w	r2, [r2, #36]	@ 0x24
 80032d0:	b17a      	cbz	r2, 80032f2 <RI_GetRegisterMotor1+0x4ba>
 80032d2:	fa1f fc8c 	uxth.w	ip, ip
 80032d6:	e008      	b.n	80032ea <RI_GetRegisterMotor1+0x4b2>
    *tempdestString = *tempsrcString;
 80032d8:	f804 2b01 	strb.w	r2, [r4], #1
    *size = *size + 1U;
 80032dc:	882b      	ldrh	r3, [r5, #0]
 80032de:	3301      	adds	r3, #1
 80032e0:	b29b      	uxth	r3, r3
 80032e2:	802b      	strh	r3, [r5, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 80032e4:	f911 2f01 	ldrsb.w	r2, [r1, #1]!
 80032e8:	b11a      	cbz	r2, 80032f2 <RI_GetRegisterMotor1+0x4ba>
 80032ea:	459c      	cmp	ip, r3
 80032ec:	d8f4      	bhi.n	80032d8 <RI_GetRegisterMotor1+0x4a0>
    retVal = MCP_ERROR_STRING_FORMAT;
 80032ee:	2006      	movs	r0, #6
 80032f0:	e5c0      	b.n	8002e74 <RI_GetRegisterMotor1+0x3c>
    *tempdestString = (int8_t)0;
 80032f2:	2300      	movs	r3, #0
 80032f4:	7023      	strb	r3, [r4, #0]
  uint8_t retVal = MCP_CMD_OK;
 80032f6:	2000      	movs	r0, #0
 80032f8:	e5bc      	b.n	8002e74 <RI_GetRegisterMotor1+0x3c>
            retVal = RI_MovString (PWR_BOARD_NAME[motorID], charData, size, freeSpace);
 80032fa:	4a6c      	ldr	r2, [pc, #432]	@ (80034ac <RI_GetRegisterMotor1+0x674>)
  *size= 1U ; /* /0 is the min String size */
 80032fc:	2301      	movs	r3, #1
            retVal = RI_MovString (PWR_BOARD_NAME[motorID], charData, size, freeSpace);
 80032fe:	6811      	ldr	r1, [r2, #0]
  *size= 1U ; /* /0 is the min String size */
 8003300:	802b      	strh	r3, [r5, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8003302:	f991 2000 	ldrsb.w	r2, [r1]
 8003306:	2a00      	cmp	r2, #0
 8003308:	d0f3      	beq.n	80032f2 <RI_GetRegisterMotor1+0x4ba>
 800330a:	fa1f fc8c 	uxth.w	ip, ip
 800330e:	e009      	b.n	8003324 <RI_GetRegisterMotor1+0x4ec>
    *tempdestString = *tempsrcString;
 8003310:	f804 2b01 	strb.w	r2, [r4], #1
    *size = *size + 1U;
 8003314:	882b      	ldrh	r3, [r5, #0]
 8003316:	3301      	adds	r3, #1
 8003318:	b29b      	uxth	r3, r3
 800331a:	802b      	strh	r3, [r5, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 800331c:	f911 2f01 	ldrsb.w	r2, [r1, #1]!
 8003320:	2a00      	cmp	r2, #0
 8003322:	d0e6      	beq.n	80032f2 <RI_GetRegisterMotor1+0x4ba>
 8003324:	459c      	cmp	ip, r3
 8003326:	d8f3      	bhi.n	8003310 <RI_GetRegisterMotor1+0x4d8>
 8003328:	e7e1      	b.n	80032ee <RI_GetRegisterMotor1+0x4b6>
              memcpy(rawData, &scaleParams_M1, sizeof(ScaleParams_t) );
 800332a:	4a61      	ldr	r2, [pc, #388]	@ (80034b0 <RI_GetRegisterMotor1+0x678>)
 800332c:	6850      	ldr	r0, [r2, #4]
 800332e:	6814      	ldr	r4, [r2, #0]
 8003330:	6891      	ldr	r1, [r2, #8]
 8003332:	68d2      	ldr	r2, [r2, #12]
 8003334:	60da      	str	r2, [r3, #12]
 8003336:	6058      	str	r0, [r3, #4]
 8003338:	601c      	str	r4, [r3, #0]
 800333a:	6099      	str	r1, [r3, #8]
    uint8_t retVal = MCP_CMD_OK;
 800333c:	2000      	movs	r0, #0
              memcpy(rawData, &scaleParams_M1, sizeof(ScaleParams_t) );
 800333e:	230e      	movs	r3, #14
 8003340:	e5b6      	b.n	8002eb0 <RI_GetRegisterMotor1+0x78>
              ApplicationConfig_reg_t const *pApplicationConfig_reg = ApplicationConfig_reg[motorID];
 8003342:	4a5c      	ldr	r2, [pc, #368]	@ (80034b4 <RI_GetRegisterMotor1+0x67c>)
              (void)memcpy(rawData, (const uint8_t *)pApplicationConfig_reg, sizeof(ApplicationConfig_reg_t));
 8003344:	6812      	ldr	r2, [r2, #0]
 8003346:	6850      	ldr	r0, [r2, #4]
 8003348:	6814      	ldr	r4, [r2, #0]
 800334a:	6891      	ldr	r1, [r2, #8]
 800334c:	68d2      	ldr	r2, [r2, #12]
 800334e:	60da      	str	r2, [r3, #12]
 8003350:	6058      	str	r0, [r3, #4]
 8003352:	601c      	str	r4, [r3, #0]
 8003354:	6099      	str	r1, [r3, #8]
    uint8_t retVal = MCP_CMD_OK;
 8003356:	2000      	movs	r0, #0
              (void)memcpy(rawData, (const uint8_t *)pApplicationConfig_reg, sizeof(ApplicationConfig_reg_t));
 8003358:	2312      	movs	r3, #18
 800335a:	e5a9      	b.n	8002eb0 <RI_GetRegisterMotor1+0x78>
          retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 800335c:	4608      	mov	r0, r1
 800335e:	e589      	b.n	8002e74 <RI_GetRegisterMotor1+0x3c>
 8003360:	2005      	movs	r0, #5
 8003362:	e5d2      	b.n	8002f0a <RI_GetRegisterMotor1+0xd2>
              *data = (uint8_t)MCI_GetSTMState(pMCIN);
 8003364:	484d      	ldr	r0, [pc, #308]	@ (800349c <RI_GetRegisterMotor1+0x664>)
 8003366:	f7fd fef1 	bl	800114c <MCI_GetSTMState>
              *data = (uint8_t)MCI_GetControlMode(pMCIN);
 800336a:	7020      	strb	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 800336c:	2000      	movs	r0, #0
 800336e:	e5b0      	b.n	8002ed2 <RI_GetRegisterMotor1+0x9a>
static inline uint8_t RUC_GetNumberOfPhases(RevUpCtrl_Handle_t *pHandle)
{
#ifdef NULL_PTR_CHECK_REV_UP_CTL
  return ((MC_NULL == pHandle) ? 0U : (uint8_t)pHandle->bPhaseNbr);
#else
  return ((uint8_t)pHandle->bPhaseNbr);
 8003370:	4b51      	ldr	r3, [pc, #324]	@ (80034b8 <RI_GetRegisterMotor1+0x680>)
 8003372:	f893 0048 	ldrb.w	r0, [r3, #72]	@ 0x48
              break;
 8003376:	e7f8      	b.n	800336a <RI_GetRegisterMotor1+0x532>
              *data = (uint8_t)MCI_GetControlMode(pMCIN);
 8003378:	4848      	ldr	r0, [pc, #288]	@ (800349c <RI_GetRegisterMotor1+0x664>)
 800337a:	f7fd ff3d 	bl	80011f8 <MCI_GetControlMode>
              break;
 800337e:	e7f4      	b.n	800336a <RI_GetRegisterMotor1+0x532>
 8003380:	2005      	movs	r0, #5
 8003382:	e6e7      	b.n	8003154 <RI_GetRegisterMotor1+0x31c>
            *rpm = (((int32_t)MCI_GetLastRampFinalSpeed(pMCIN) * U_RPM) / (int32_t)SPEED_UNIT);
 8003384:	4845      	ldr	r0, [pc, #276]	@ (800349c <RI_GetRegisterMotor1+0x664>)
 8003386:	f7fd ff79 	bl	800127c <MCI_GetLastRampFinalSpeed>
 800338a:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 800338e:	0043      	lsls	r3, r0, #1
 8003390:	f8c4 3002 	str.w	r3, [r4, #2]
            *duration = MCI_GetLastRampFinalDuration(pMCIN);
 8003394:	4841      	ldr	r0, [pc, #260]	@ (800349c <RI_GetRegisterMotor1+0x664>)
 8003396:	f7fd ff79 	bl	800128c <MCI_GetLastRampFinalDuration>
            *rawSize = 6;
 800339a:	2306      	movs	r3, #6
            *duration = MCI_GetLastRampFinalDuration(pMCIN);
 800339c:	80e0      	strh	r0, [r4, #6]
            *rawSize = 6;
 800339e:	8023      	strh	r3, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 80033a0:	2000      	movs	r0, #0
            break;
 80033a2:	2308      	movs	r3, #8
 80033a4:	e584      	b.n	8002eb0 <RI_GetRegisterMotor1+0x78>
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 80033a6:	fa1f fc8c 	uxth.w	ip, ip
            *rawSize = (uint16_t)sizeof(MotorConfig_reg_t);
 80033aa:	223c      	movs	r2, #60	@ 0x3c
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 80033ac:	f1bc 0f3d 	cmp.w	ip, #61	@ 0x3d
            *rawSize = (uint16_t)sizeof(MotorConfig_reg_t);
 80033b0:	8022      	strh	r2, [r4, #0]
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 80033b2:	f200 8092 	bhi.w	80034da <RI_GetRegisterMotor1+0x6a2>
 80033b6:	233e      	movs	r3, #62	@ 0x3e
              retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 80033b8:	2008      	movs	r0, #8
 80033ba:	e579      	b.n	8002eb0 <RI_GetRegisterMotor1+0x78>
        *size = (*rawSize) + 2U;
 80033bc:	8823      	ldrh	r3, [r4, #0]
 80033be:	3302      	adds	r3, #2
            retVal = MCP_ERROR_UNKNOWN_REG;
 80033c0:	2005      	movs	r0, #5
        *size = (*rawSize) + 2U;
 80033c2:	b29b      	uxth	r3, r3
 80033c4:	e574      	b.n	8002eb0 <RI_GetRegisterMotor1+0x78>
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 80033c6:	fa1f fc8c 	uxth.w	ip, ip
            *rawSize = (uint16_t)RUC_MAX_PHASE_NUMBER*8U;
 80033ca:	2328      	movs	r3, #40	@ 0x28
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 80033cc:	f1bc 0f29 	cmp.w	ip, #41	@ 0x29
            *rawSize = (uint16_t)RUC_MAX_PHASE_NUMBER*8U;
 80033d0:	8023      	strh	r3, [r4, #0]
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 80033d2:	d95b      	bls.n	800348c <RI_GetRegisterMotor1+0x654>
    retValue = false;
  }
  else
  {
#endif
    phaseData->hFinalTorque = (int16_t)pHandle->ParamsData[phaseNumber].hFinalTorque;
 80033d4:	4b38      	ldr	r3, [pc, #224]	@ (80034b8 <RI_GetRegisterMotor1+0x680>)
                *rpm = (((int32_t)revUpPhase.hFinalMecSpeedUnit) * U_RPM) / SPEED_UNIT; //cstat !MISRAC2012-Rule-11.3
 80033d6:	f9b3 200e 	ldrsh.w	r2, [r3, #14]
 80033da:	f9b3 0010 	ldrsh.w	r0, [r3, #16]
    phaseData->hFinalMecSpeedUnit = (int16_t)pHandle->ParamsData[phaseNumber].hFinalMecSpeedUnit;
    phaseData->hDurationms = (uint16_t)pHandle->ParamsData[phaseNumber].hDurationms;
 80033de:	8999      	ldrh	r1, [r3, #12]
                *durationms  = revUpPhase.hDurationms;
 80033e0:	8121      	strh	r1, [r4, #8]
                *rpm = (((int32_t)revUpPhase.hFinalMecSpeedUnit) * U_RPM) / SPEED_UNIT; //cstat !MISRAC2012-Rule-11.3
 80033e2:	eb02 0242 	add.w	r2, r2, r2, lsl #1
                *finalTorque = (uint16_t)revUpPhase.hFinalTorque; //cstat !MISRAC2012-Rule-11.3
 80033e6:	80e0      	strh	r0, [r4, #6]
                *rpm = (((int32_t)revUpPhase.hFinalMecSpeedUnit) * U_RPM) / SPEED_UNIT; //cstat !MISRAC2012-Rule-11.3
 80033e8:	0052      	lsls	r2, r2, #1
    phaseData->hFinalTorque = (int16_t)pHandle->ParamsData[phaseNumber].hFinalTorque;
 80033ea:	f9b3 001c 	ldrsh.w	r0, [r3, #28]
 80033ee:	f8c4 2002 	str.w	r2, [r4, #2]
 80033f2:	f9b3 201a 	ldrsh.w	r2, [r3, #26]
    phaseData->hDurationms = (uint16_t)pHandle->ParamsData[phaseNumber].hDurationms;
 80033f6:	8b19      	ldrh	r1, [r3, #24]
                *durationms  = revUpPhase.hDurationms;
 80033f8:	8221      	strh	r1, [r4, #16]
                *rpm = (((int32_t)revUpPhase.hFinalMecSpeedUnit) * U_RPM) / SPEED_UNIT; //cstat !MISRAC2012-Rule-11.3
 80033fa:	eb02 0242 	add.w	r2, r2, r2, lsl #1
                *finalTorque = (uint16_t)revUpPhase.hFinalTorque; //cstat !MISRAC2012-Rule-11.3
 80033fe:	81e0      	strh	r0, [r4, #14]
                *rpm = (((int32_t)revUpPhase.hFinalMecSpeedUnit) * U_RPM) / SPEED_UNIT; //cstat !MISRAC2012-Rule-11.3
 8003400:	0052      	lsls	r2, r2, #1
    phaseData->hFinalTorque = (int16_t)pHandle->ParamsData[phaseNumber].hFinalTorque;
 8003402:	f9b3 0028 	ldrsh.w	r0, [r3, #40]	@ 0x28
 8003406:	f8c4 200a 	str.w	r2, [r4, #10]
 800340a:	f9b3 2026 	ldrsh.w	r2, [r3, #38]	@ 0x26
    phaseData->hDurationms = (uint16_t)pHandle->ParamsData[phaseNumber].hDurationms;
 800340e:	8c99      	ldrh	r1, [r3, #36]	@ 0x24
                *durationms  = revUpPhase.hDurationms;
 8003410:	8321      	strh	r1, [r4, #24]
                *rpm = (((int32_t)revUpPhase.hFinalMecSpeedUnit) * U_RPM) / SPEED_UNIT; //cstat !MISRAC2012-Rule-11.3
 8003412:	eb02 0242 	add.w	r2, r2, r2, lsl #1
                *finalTorque = (uint16_t)revUpPhase.hFinalTorque; //cstat !MISRAC2012-Rule-11.3
 8003416:	82e0      	strh	r0, [r4, #22]
                *rpm = (((int32_t)revUpPhase.hFinalMecSpeedUnit) * U_RPM) / SPEED_UNIT; //cstat !MISRAC2012-Rule-11.3
 8003418:	0052      	lsls	r2, r2, #1
    phaseData->hFinalTorque = (int16_t)pHandle->ParamsData[phaseNumber].hFinalTorque;
 800341a:	f9b3 0034 	ldrsh.w	r0, [r3, #52]	@ 0x34
 800341e:	f8c4 2012 	str.w	r2, [r4, #18]
 8003422:	f9b3 2032 	ldrsh.w	r2, [r3, #50]	@ 0x32
    phaseData->hDurationms = (uint16_t)pHandle->ParamsData[phaseNumber].hDurationms;
 8003426:	8e19      	ldrh	r1, [r3, #48]	@ 0x30
                *durationms  = revUpPhase.hDurationms;
 8003428:	8421      	strh	r1, [r4, #32]
                *rpm = (((int32_t)revUpPhase.hFinalMecSpeedUnit) * U_RPM) / SPEED_UNIT; //cstat !MISRAC2012-Rule-11.3
 800342a:	eb02 0242 	add.w	r2, r2, r2, lsl #1
                *finalTorque = (uint16_t)revUpPhase.hFinalTorque; //cstat !MISRAC2012-Rule-11.3
 800342e:	83e0      	strh	r0, [r4, #30]
                *rpm = (((int32_t)revUpPhase.hFinalMecSpeedUnit) * U_RPM) / SPEED_UNIT; //cstat !MISRAC2012-Rule-11.3
 8003430:	0052      	lsls	r2, r2, #1
    phaseData->hFinalTorque = (int16_t)pHandle->ParamsData[phaseNumber].hFinalTorque;
 8003432:	f9b3 0040 	ldrsh.w	r0, [r3, #64]	@ 0x40
 8003436:	f8c4 201a 	str.w	r2, [r4, #26]
 800343a:	f9b3 203e 	ldrsh.w	r2, [r3, #62]	@ 0x3e
    phaseData->hDurationms = (uint16_t)pHandle->ParamsData[phaseNumber].hDurationms;
 800343e:	8f99      	ldrh	r1, [r3, #60]	@ 0x3c
                *durationms  = revUpPhase.hDurationms;
 8003440:	8521      	strh	r1, [r4, #40]	@ 0x28
                *rpm = (((int32_t)revUpPhase.hFinalMecSpeedUnit) * U_RPM) / SPEED_UNIT; //cstat !MISRAC2012-Rule-11.3
 8003442:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8003446:	0052      	lsls	r2, r2, #1
                *finalTorque = (uint16_t)revUpPhase.hFinalTorque; //cstat !MISRAC2012-Rule-11.3
 8003448:	84e0      	strh	r0, [r4, #38]	@ 0x26
                *rpm = (((int32_t)revUpPhase.hFinalMecSpeedUnit) * U_RPM) / SPEED_UNIT; //cstat !MISRAC2012-Rule-11.3
 800344a:	f8c4 2022 	str.w	r2, [r4, #34]	@ 0x22
                *durationms  = revUpPhase.hDurationms;
 800344e:	232a      	movs	r3, #42	@ 0x2a
    uint8_t retVal = MCP_CMD_OK;
 8003450:	2000      	movs	r0, #0
 8003452:	e52d      	b.n	8002eb0 <RI_GetRegisterMotor1+0x78>
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8003454:	fa1f fc8c 	uxth.w	ip, ip
            *rawSize = (uint16_t)sizeof(FOCFwConfig_reg_t);
 8003458:	220e      	movs	r2, #14
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 800345a:	f1bc 0f0f 	cmp.w	ip, #15
            *rawSize = (uint16_t)sizeof(FOCFwConfig_reg_t);
 800345e:	8022      	strh	r2, [r4, #0]
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8003460:	d82e      	bhi.n	80034c0 <RI_GetRegisterMotor1+0x688>
 8003462:	2310      	movs	r3, #16
              retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 8003464:	2008      	movs	r0, #8
 8003466:	e523      	b.n	8002eb0 <RI_GetRegisterMotor1+0x78>
              *regdata32 = (((int32_t)MCI_GetAvrgMecSpeedUnit(pMCIN) * U_RPM) / SPEED_UNIT);
 8003468:	480c      	ldr	r0, [pc, #48]	@ (800349c <RI_GetRegisterMotor1+0x664>)
 800346a:	f7fd ff17 	bl	800129c <MCI_GetAvrgMecSpeedUnit>
 800346e:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8003472:	0040      	lsls	r0, r0, #1
 8003474:	6020      	str	r0, [r4, #0]
              break;
 8003476:	e547      	b.n	8002f08 <RI_GetRegisterMotor1+0xd0>
static inline int32_t STO_CR_GetObservedBemfLevel(const STO_CR_Handle_t *pHandle)
{
#ifdef NULL_PTR_CHECK_STO_COR_SPD_POS_FDB
  return ((NULL == pHandle) ? 0 : pHandle->Obs_Bemf_Level);
#else
  return (pHandle->Obs_Bemf_Level);
 8003478:	4b10      	ldr	r3, [pc, #64]	@ (80034bc <RI_GetRegisterMotor1+0x684>)
 800347a:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
              *regdata32 = STO_CR_GetObservedBemfLevel(&STO_CR_M1);
 800347e:	6023      	str	r3, [r4, #0]
              break;
 8003480:	e542      	b.n	8002f08 <RI_GetRegisterMotor1+0xd0>
  return (pHandle->Est_Bemf_Level);
 8003482:	4b0e      	ldr	r3, [pc, #56]	@ (80034bc <RI_GetRegisterMotor1+0x684>)
 8003484:	f8d3 3158 	ldr.w	r3, [r3, #344]	@ 0x158
              *regdata32 = STO_CR_GetEstimatedBemfLevel(&STO_CR_M1);
 8003488:	6023      	str	r3, [r4, #0]
              break;
 800348a:	e53d      	b.n	8002f08 <RI_GetRegisterMotor1+0xd0>
 800348c:	232a      	movs	r3, #42	@ 0x2a
              retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 800348e:	2008      	movs	r0, #8
 8003490:	e50e      	b.n	8002eb0 <RI_GetRegisterMotor1+0x78>
 8003492:	bf00      	nop
 8003494:	20000350 	.word	0x20000350
 8003498:	200003a8 	.word	0x200003a8
 800349c:	20000000 	.word	0x20000000
 80034a0:	2000037c 	.word	0x2000037c
 80034a4:	2000002c 	.word	0x2000002c
 80034a8:	20000478 	.word	0x20000478
 80034ac:	20000480 	.word	0x20000480
 80034b0:	20000484 	.word	0x20000484
 80034b4:	20000474 	.word	0x20000474
 80034b8:	200002a4 	.word	0x200002a4
 80034bc:	2000007c 	.word	0x2000007c
              FOCFwConfig_reg_t const *pFOCConfig_reg = FOCConfig_reg[motorID];
 80034c0:	4a3b      	ldr	r2, [pc, #236]	@ (80035b0 <RI_GetRegisterMotor1+0x778>)
              (void)memcpy(rawData, (const uint8_t *)pFOCConfig_reg, sizeof(FOCFwConfig_reg_t));
 80034c2:	6812      	ldr	r2, [r2, #0]
 80034c4:	6810      	ldr	r0, [r2, #0]
 80034c6:	6851      	ldr	r1, [r2, #4]
 80034c8:	6894      	ldr	r4, [r2, #8]
 80034ca:	609c      	str	r4, [r3, #8]
 80034cc:	6018      	str	r0, [r3, #0]
 80034ce:	6059      	str	r1, [r3, #4]
 80034d0:	8992      	ldrh	r2, [r2, #12]
 80034d2:	819a      	strh	r2, [r3, #12]
    uint8_t retVal = MCP_CMD_OK;
 80034d4:	2000      	movs	r0, #0
              (void)memcpy(rawData, (const uint8_t *)pFOCConfig_reg, sizeof(FOCFwConfig_reg_t));
 80034d6:	2310      	movs	r3, #16
 80034d8:	e4ea      	b.n	8002eb0 <RI_GetRegisterMotor1+0x78>
              MotorConfig_reg_t const *pMotorConfig_reg = MotorConfig_reg[motorID];
 80034da:	4a36      	ldr	r2, [pc, #216]	@ (80035b4 <RI_GetRegisterMotor1+0x77c>)
              (void)memcpy(rawData, (const uint8_t *)pMotorConfig_reg, sizeof(MotorConfig_reg_t));
 80034dc:	6812      	ldr	r2, [r2, #0]
 80034de:	f102 0e30 	add.w	lr, r2, #48	@ 0x30
 80034e2:	6814      	ldr	r4, [r2, #0]
 80034e4:	6850      	ldr	r0, [r2, #4]
 80034e6:	6891      	ldr	r1, [r2, #8]
 80034e8:	f8d2 c00c 	ldr.w	ip, [r2, #12]
 80034ec:	f8c3 c00c 	str.w	ip, [r3, #12]
 80034f0:	3210      	adds	r2, #16
 80034f2:	4572      	cmp	r2, lr
 80034f4:	601c      	str	r4, [r3, #0]
 80034f6:	6058      	str	r0, [r3, #4]
 80034f8:	6099      	str	r1, [r3, #8]
 80034fa:	f103 0310 	add.w	r3, r3, #16
 80034fe:	d1f0      	bne.n	80034e2 <RI_GetRegisterMotor1+0x6aa>
 8003500:	6810      	ldr	r0, [r2, #0]
 8003502:	6851      	ldr	r1, [r2, #4]
 8003504:	6892      	ldr	r2, [r2, #8]
 8003506:	609a      	str	r2, [r3, #8]
 8003508:	6018      	str	r0, [r3, #0]
 800350a:	6059      	str	r1, [r3, #4]
    uint8_t retVal = MCP_CMD_OK;
 800350c:	2000      	movs	r0, #0
              (void)memcpy(rawData, (const uint8_t *)pMotorConfig_reg, sizeof(MotorConfig_reg_t));
 800350e:	233e      	movs	r3, #62	@ 0x3e
 8003510:	e4ce      	b.n	8002eb0 <RI_GetRegisterMotor1+0x78>
              *regdata16 = SPD_GetS16Speed((SpeednPosFdbk_Handle_t*) &STO_CR_M1);
 8003512:	4829      	ldr	r0, [pc, #164]	@ (80035b8 <RI_GetRegisterMotor1+0x780>)
 8003514:	f006 f90c 	bl	8009730 <SPD_GetS16Speed>
 8003518:	8020      	strh	r0, [r4, #0]
              break;
 800351a:	e61a      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
              *regdataU16 = PID_GetKDDivisorPOW2(&PIDSpeedHandle_M1);
 800351c:	4827      	ldr	r0, [pc, #156]	@ (80035bc <RI_GetRegisterMotor1+0x784>)
 800351e:	f004 ff7b 	bl	8008418 <PID_GetKDDivisorPOW2>
 8003522:	8020      	strh	r0, [r4, #0]
              break;
 8003524:	e615      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
              *regdataU16 = PID_GetKDDivisorPOW2(&PIDIqHandle_M1);
 8003526:	4826      	ldr	r0, [pc, #152]	@ (80035c0 <RI_GetRegisterMotor1+0x788>)
 8003528:	f004 ff76 	bl	8008418 <PID_GetKDDivisorPOW2>
 800352c:	8020      	strh	r0, [r4, #0]
              break;
 800352e:	e610      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
              *regdataU16 = PID_GetKDDivisorPOW2(&PIDIdHandle_M1);
 8003530:	4824      	ldr	r0, [pc, #144]	@ (80035c4 <RI_GetRegisterMotor1+0x78c>)
 8003532:	f004 ff71 	bl	8008418 <PID_GetKDDivisorPOW2>
 8003536:	8020      	strh	r0, [r4, #0]
              break;
 8003538:	e60b      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
              *regdata16 = PID_GetKD(&PIDIdHandle_M1);
 800353a:	4822      	ldr	r0, [pc, #136]	@ (80035c4 <RI_GetRegisterMotor1+0x78c>)
 800353c:	f004 ff68 	bl	8008410 <PID_GetKD>
 8003540:	8020      	strh	r0, [r4, #0]
              break;
 8003542:	e606      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
              *regdata16 = PID_GetKD(&PIDIqHandle_M1);
 8003544:	481e      	ldr	r0, [pc, #120]	@ (80035c0 <RI_GetRegisterMotor1+0x788>)
 8003546:	f004 ff63 	bl	8008410 <PID_GetKD>
 800354a:	8020      	strh	r0, [r4, #0]
              break;
 800354c:	e601      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
              *regdata16 = MCI_GetIab(pMCIN).a;
 800354e:	481e      	ldr	r0, [pc, #120]	@ (80035c8 <RI_GetRegisterMotor1+0x790>)
 8003550:	f7fd feac 	bl	80012ac <MCI_GetIab>
 8003554:	8020      	strh	r0, [r4, #0]
              break;
 8003556:	e5fc      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
              *regdata16 = PID_GetKD(&PIDSpeedHandle_M1);
 8003558:	4818      	ldr	r0, [pc, #96]	@ (80035bc <RI_GetRegisterMotor1+0x784>)
 800355a:	f004 ff59 	bl	8008410 <PID_GetKD>
 800355e:	8020      	strh	r0, [r4, #0]
              break;
 8003560:	e5f7      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
              *regdata16 = STO_CR_GetEstimatedBemf(&STO_CR_M1).alpha;
 8003562:	4815      	ldr	r0, [pc, #84]	@ (80035b8 <RI_GetRegisterMotor1+0x780>)
 8003564:	f006 fc42 	bl	8009dec <STO_CR_GetEstimatedBemf>
 8003568:	8020      	strh	r0, [r4, #0]
              break;
 800356a:	e5f2      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
              *regdata16 = MCI_GetValphabeta(pMCIN).beta;
 800356c:	4816      	ldr	r0, [pc, #88]	@ (80035c8 <RI_GetRegisterMotor1+0x790>)
 800356e:	f7fd fee3 	bl	8001338 <MCI_GetValphabeta>
 8003572:	f3c0 430f 	ubfx	r3, r0, #16, #16
 8003576:	8023      	strh	r3, [r4, #0]
              break;
 8003578:	e5eb      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
              *regdata16 = MCI_GetVqd(pMCIN).q;
 800357a:	4813      	ldr	r0, [pc, #76]	@ (80035c8 <RI_GetRegisterMotor1+0x790>)
 800357c:	f7fd fece 	bl	800131c <MCI_GetVqd>
 8003580:	8020      	strh	r0, [r4, #0]
              break;
 8003582:	e5e6      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
              *regdata16 = MCI_GetIqdref(pMCIN).q;
 8003584:	4810      	ldr	r0, [pc, #64]	@ (80035c8 <RI_GetRegisterMotor1+0x790>)
 8003586:	f7fd febb 	bl	8001300 <MCI_GetIqdref>
 800358a:	8020      	strh	r0, [r4, #0]
              break;
 800358c:	e5e1      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
              *regdata16 = MCI_GetIalphabeta(pMCIN).beta;
 800358e:	480e      	ldr	r0, [pc, #56]	@ (80035c8 <RI_GetRegisterMotor1+0x790>)
 8003590:	f7fd fe9a 	bl	80012c8 <MCI_GetIalphabeta>
 8003594:	f3c0 430f 	ubfx	r3, r0, #16, #16
 8003598:	8023      	strh	r3, [r4, #0]
              break;
 800359a:	e5da      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
              STO_CR_GetObserverGains(&STO_CR_M1, &hC1, &hC2);
 800359c:	4806      	ldr	r0, [pc, #24]	@ (80035b8 <RI_GetRegisterMotor1+0x780>)
 800359e:	aa13      	add	r2, sp, #76	@ 0x4c
 80035a0:	a912      	add	r1, sp, #72	@ 0x48
 80035a2:	f006 fc41 	bl	8009e28 <STO_CR_GetObserverGains>
              *regdata16 = hC2;
 80035a6:	f8bd 304c 	ldrh.w	r3, [sp, #76]	@ 0x4c
 80035aa:	8023      	strh	r3, [r4, #0]
              break;
 80035ac:	e5d1      	b.n	8003152 <RI_GetRegisterMotor1+0x31a>
 80035ae:	bf00      	nop
 80035b0:	2000047c 	.word	0x2000047c
 80035b4:	20000478 	.word	0x20000478
 80035b8:	2000007c 	.word	0x2000007c
 80035bc:	200003a8 	.word	0x200003a8
 80035c0:	2000037c 	.word	0x2000037c
 80035c4:	20000350 	.word	0x20000350
 80035c8:	20000000 	.word	0x20000000

080035cc <RI_GetIDSize>:
  return (retVal);
}

uint8_t RI_GetIDSize(uint16_t dataID)
{
  uint8_t typeID = ((uint8_t)dataID) & TYPE_MASK;
 80035cc:	f000 0038 	and.w	r0, r0, #56	@ 0x38
 80035d0:	3808      	subs	r0, #8
 80035d2:	b2c0      	uxtb	r0, r0
 80035d4:	2810      	cmp	r0, #16
 80035d6:	bf9a      	itte	ls
 80035d8:	4b01      	ldrls	r3, [pc, #4]	@ (80035e0 <RI_GetIDSize+0x14>)
 80035da:	5c18      	ldrbls	r0, [r3, r0]
 80035dc:	2000      	movhi	r0, #0
      break;
    }
  }

  return (result);
}
 80035de:	4770      	bx	lr
 80035e0:	0800a3cc 	.word	0x0800a3cc

080035e4 <RI_GetPtrReg>:

    MCI_Handle_t *pMCIN = &Mci[0];
    uint16_t regID = dataID & REG_MASK;
    uint8_t typeID = ((uint8_t)dataID) & TYPE_MASK;

    switch (typeID)
 80035e4:	f000 0338 	and.w	r3, r0, #56	@ 0x38
 80035e8:	2b10      	cmp	r3, #16
 80035ea:	d003      	beq.n	80035f4 <RI_GetPtrReg+0x10>
 80035ec:	4a43      	ldr	r2, [pc, #268]	@ (80036fc <RI_GetPtrReg+0x118>)
      }

      default:
      {
        *dataPtr = &nullData16;
        retVal = MCP_ERROR_UNKNOWN_REG;
 80035ee:	2005      	movs	r0, #5
            *dataPtr = &(pMCIN->pFOCVars->Iab.a);
 80035f0:	600a      	str	r2, [r1, #0]
    }
#ifdef NULL_PTR_CHECK_REG_INT
  }
#endif
  return (retVal);
}
 80035f2:	4770      	bx	lr
    uint16_t regID = dataID & REG_MASK;
 80035f4:	f020 0007 	bic.w	r0, r0, #7
 80035f8:	f5b0 6f1d 	cmp.w	r0, #2512	@ 0x9d0
 80035fc:	b283      	uxth	r3, r0
 80035fe:	d073      	beq.n	80036e8 <RI_GetPtrReg+0x104>
 8003600:	d80f      	bhi.n	8003622 <RI_GetPtrReg+0x3e>
 8003602:	f5b3 6f0d 	cmp.w	r3, #2256	@ 0x8d0
 8003606:	d074      	beq.n	80036f2 <RI_GetPtrReg+0x10e>
 8003608:	d824      	bhi.n	8003654 <RI_GetPtrReg+0x70>
 800360a:	f5b3 6f05 	cmp.w	r3, #2128	@ 0x850
 800360e:	d058      	beq.n	80036c2 <RI_GetPtrReg+0xde>
 8003610:	d915      	bls.n	800363e <RI_GetPtrReg+0x5a>
 8003612:	f5b3 6f09 	cmp.w	r3, #2192	@ 0x890
 8003616:	d1e9      	bne.n	80035ec <RI_GetPtrReg+0x8>
            *dataPtr = &(pMCIN->pFOCVars->Ialphabeta.beta);
 8003618:	4b39      	ldr	r3, [pc, #228]	@ (8003700 <RI_GetPtrReg+0x11c>)
 800361a:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 800361c:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Ialphabeta.beta);
 800361e:	3206      	adds	r2, #6
            break;
 8003620:	e7e6      	b.n	80035f0 <RI_GetPtrReg+0xc>
 8003622:	f5b3 6f4d 	cmp.w	r3, #3280	@ 0xcd0
 8003626:	d049      	beq.n	80036bc <RI_GetPtrReg+0xd8>
 8003628:	d929      	bls.n	800367e <RI_GetPtrReg+0x9a>
 800362a:	f5b3 6f5d 	cmp.w	r3, #3536	@ 0xdd0
 800362e:	d041      	beq.n	80036b4 <RI_GetPtrReg+0xd0>
 8003630:	f5b3 6f61 	cmp.w	r3, #3600	@ 0xe10
 8003634:	d119      	bne.n	800366a <RI_GetPtrReg+0x86>
 8003636:	4a33      	ldr	r2, [pc, #204]	@ (8003704 <RI_GetPtrReg+0x120>)
            *dataPtr = &(pMCIN->pFOCVars->Iab.a);
 8003638:	600a      	str	r2, [r1, #0]
  uint8_t retVal = MCP_CMD_OK;
 800363a:	2000      	movs	r0, #0
}
 800363c:	4770      	bx	lr
 800363e:	f5b3 6ffa 	cmp.w	r3, #2000	@ 0x7d0
 8003642:	d04d      	beq.n	80036e0 <RI_GetPtrReg+0xfc>
 8003644:	f5b3 6f01 	cmp.w	r3, #2064	@ 0x810
 8003648:	d1d0      	bne.n	80035ec <RI_GetPtrReg+0x8>
            *dataPtr = &(pMCIN->pFOCVars->Iab.b);
 800364a:	4b2d      	ldr	r3, [pc, #180]	@ (8003700 <RI_GetPtrReg+0x11c>)
 800364c:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 800364e:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Iab.b);
 8003650:	3202      	adds	r2, #2
            break;
 8003652:	e7cd      	b.n	80035f0 <RI_GetPtrReg+0xc>
 8003654:	f5b3 6f15 	cmp.w	r3, #2384	@ 0x950
 8003658:	d038      	beq.n	80036cc <RI_GetPtrReg+0xe8>
 800365a:	f5b3 6f19 	cmp.w	r3, #2448	@ 0x990
 800365e:	d119      	bne.n	8003694 <RI_GetPtrReg+0xb0>
            *dataPtr = &(pMCIN->pFOCVars->Iqdref.d);
 8003660:	4b27      	ldr	r3, [pc, #156]	@ (8003700 <RI_GetPtrReg+0x11c>)
 8003662:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 8003664:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Iqdref.d);
 8003666:	3212      	adds	r2, #18
            break;
 8003668:	e7c2      	b.n	80035f0 <RI_GetPtrReg+0xc>
 800366a:	4824      	ldr	r0, [pc, #144]	@ (80036fc <RI_GetPtrReg+0x118>)
 800366c:	4a26      	ldr	r2, [pc, #152]	@ (8003708 <RI_GetPtrReg+0x124>)
 800366e:	f5b3 6f51 	cmp.w	r3, #3344	@ 0xd10
 8003672:	bf16      	itet	ne
 8003674:	4602      	movne	r2, r0
 8003676:	2000      	moveq	r0, #0
 8003678:	2005      	movne	r0, #5
            *dataPtr = &(pMCIN->pFOCVars->Iab.a);
 800367a:	600a      	str	r2, [r1, #0]
}
 800367c:	4770      	bx	lr
 800367e:	f5b3 6f25 	cmp.w	r3, #2640	@ 0xa50
 8003682:	d028      	beq.n	80036d6 <RI_GetPtrReg+0xf2>
 8003684:	f5b3 6f29 	cmp.w	r3, #2704	@ 0xa90
 8003688:	d10c      	bne.n	80036a4 <RI_GetPtrReg+0xc0>
            *dataPtr = &(pMCIN->pFOCVars->Valphabeta.beta);
 800368a:	4b1d      	ldr	r3, [pc, #116]	@ (8003700 <RI_GetPtrReg+0x11c>)
 800368c:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 800368e:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Valphabeta.beta);
 8003690:	321c      	adds	r2, #28
            break;
 8003692:	e7ad      	b.n	80035f0 <RI_GetPtrReg+0xc>
 8003694:	f5b3 6f11 	cmp.w	r3, #2320	@ 0x910
 8003698:	d1a8      	bne.n	80035ec <RI_GetPtrReg+0x8>
            *dataPtr = &(pMCIN->pFOCVars->Iqd.d);
 800369a:	4b19      	ldr	r3, [pc, #100]	@ (8003700 <RI_GetPtrReg+0x11c>)
 800369c:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 800369e:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Iqd.d);
 80036a0:	320e      	adds	r2, #14
            break;
 80036a2:	e7a5      	b.n	80035f0 <RI_GetPtrReg+0xc>
 80036a4:	f5b3 6f21 	cmp.w	r3, #2576	@ 0xa10
 80036a8:	d1a0      	bne.n	80035ec <RI_GetPtrReg+0x8>
            *dataPtr = &(pMCIN->pFOCVars->Vqd.d);
 80036aa:	4b15      	ldr	r3, [pc, #84]	@ (8003700 <RI_GetPtrReg+0x11c>)
 80036ac:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 80036ae:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Vqd.d);
 80036b0:	3218      	adds	r2, #24
            break;
 80036b2:	e79d      	b.n	80035f0 <RI_GetPtrReg+0xc>
 80036b4:	4a15      	ldr	r2, [pc, #84]	@ (800370c <RI_GetPtrReg+0x128>)
            *dataPtr = &(pMCIN->pFOCVars->Iab.a);
 80036b6:	600a      	str	r2, [r1, #0]
  uint8_t retVal = MCP_CMD_OK;
 80036b8:	2000      	movs	r0, #0
}
 80036ba:	4770      	bx	lr
 80036bc:	4a14      	ldr	r2, [pc, #80]	@ (8003710 <RI_GetPtrReg+0x12c>)
  uint8_t retVal = MCP_CMD_OK;
 80036be:	2000      	movs	r0, #0
 80036c0:	e796      	b.n	80035f0 <RI_GetPtrReg+0xc>
            *dataPtr = &(pMCIN->pFOCVars->Ialphabeta.alpha);
 80036c2:	4b0f      	ldr	r3, [pc, #60]	@ (8003700 <RI_GetPtrReg+0x11c>)
 80036c4:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 80036c6:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Ialphabeta.alpha);
 80036c8:	3204      	adds	r2, #4
            break;
 80036ca:	e791      	b.n	80035f0 <RI_GetPtrReg+0xc>
            *dataPtr = &(pMCIN->pFOCVars->Iqdref.q);
 80036cc:	4b0c      	ldr	r3, [pc, #48]	@ (8003700 <RI_GetPtrReg+0x11c>)
 80036ce:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 80036d0:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Iqdref.q);
 80036d2:	3210      	adds	r2, #16
            break;
 80036d4:	e78c      	b.n	80035f0 <RI_GetPtrReg+0xc>
            *dataPtr = &(pMCIN->pFOCVars->Valphabeta.alpha);
 80036d6:	4b0a      	ldr	r3, [pc, #40]	@ (8003700 <RI_GetPtrReg+0x11c>)
 80036d8:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 80036da:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Valphabeta.alpha);
 80036dc:	321a      	adds	r2, #26
            break;
 80036de:	e787      	b.n	80035f0 <RI_GetPtrReg+0xc>
            *dataPtr = &(pMCIN->pFOCVars->Iab.a);
 80036e0:	4b07      	ldr	r3, [pc, #28]	@ (8003700 <RI_GetPtrReg+0x11c>)
  uint8_t retVal = MCP_CMD_OK;
 80036e2:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Iab.a);
 80036e4:	685a      	ldr	r2, [r3, #4]
             break;
 80036e6:	e783      	b.n	80035f0 <RI_GetPtrReg+0xc>
            *dataPtr = &(pMCIN->pFOCVars->Vqd.q);
 80036e8:	4b05      	ldr	r3, [pc, #20]	@ (8003700 <RI_GetPtrReg+0x11c>)
 80036ea:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 80036ec:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Vqd.q);
 80036ee:	3216      	adds	r2, #22
            break;
 80036f0:	e77e      	b.n	80035f0 <RI_GetPtrReg+0xc>
            *dataPtr = &(pMCIN->pFOCVars->Iqd.q);
 80036f2:	4b03      	ldr	r3, [pc, #12]	@ (8003700 <RI_GetPtrReg+0x11c>)
 80036f4:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 80036f6:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Iqd.q);
 80036f8:	320c      	adds	r2, #12
            break;
 80036fa:	e779      	b.n	80035f0 <RI_GetPtrReg+0xc>
 80036fc:	20001998 	.word	0x20001998
 8003700:	20000000 	.word	0x20000000
 8003704:	200000c2 	.word	0x200000c2
 8003708:	20000088 	.word	0x20000088
 800370c:	200000c0 	.word	0x200000c0
 8003710:	20000080 	.word	0x20000080

08003714 <RCM_RegisterRegConv>:
  * @param  regConv Pointer to the regular conversion parameters.
  *         Contains ADC, Channel and sampling time to be used.
  *
  */
void RCM_RegisterRegConv(RegConv_t *regConv)
{
 8003714:	b470      	push	{r4, r5, r6}

    /* Parse the array to be sure that same
     * conversion does not already exist*/
    while (i < RCM_MAX_CONV)
    {
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 8003716:	4e79      	ldr	r6, [pc, #484]	@ (80038fc <RCM_RegisterRegConv+0x1e8>)
 8003718:	6832      	ldr	r2, [r6, #0]
 800371a:	2a00      	cmp	r2, #0
 800371c:	d035      	beq.n	800378a <RCM_RegisterRegConv+0x76>
        /* Nothing to do */
      }
      /* Ticket 64042 : If RCM_handle_array [i] is null access to data member will cause Memory Fault */
      if (RCM_handle_array [i] != 0)
      {
        if ((RCM_handle_array [i]->channel == regConv->channel)
 800371e:	7901      	ldrb	r1, [r0, #4]
 8003720:	7913      	ldrb	r3, [r2, #4]
 8003722:	4299      	cmp	r1, r3
 8003724:	d01f      	beq.n	8003766 <RCM_RegisterRegConv+0x52>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 8003726:	6874      	ldr	r4, [r6, #4]
 8003728:	2c00      	cmp	r4, #0
 800372a:	f000 80c5 	beq.w	80038b8 <RCM_RegisterRegConv+0x1a4>
        if ((RCM_handle_array [i]->channel == regConv->channel)
 800372e:	7923      	ldrb	r3, [r4, #4]
 8003730:	428b      	cmp	r3, r1
  uint8_t handle = 255U;
 8003732:	f04f 02ff 	mov.w	r2, #255	@ 0xff
        if ((RCM_handle_array [i]->channel == regConv->channel)
 8003736:	d030      	beq.n	800379a <RCM_RegisterRegConv+0x86>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 8003738:	68b5      	ldr	r5, [r6, #8]
 800373a:	2d00      	cmp	r5, #0
 800373c:	f000 80a2 	beq.w	8003884 <RCM_RegisterRegConv+0x170>
        if ((RCM_handle_array [i]->channel == regConv->channel)
 8003740:	792b      	ldrb	r3, [r5, #4]
 8003742:	428b      	cmp	r3, r1
 8003744:	d02f      	beq.n	80037a6 <RCM_RegisterRegConv+0x92>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 8003746:	68f4      	ldr	r4, [r6, #12]
 8003748:	2c00      	cmp	r4, #0
 800374a:	f000 80a7 	beq.w	800389c <RCM_RegisterRegConv+0x188>
        if ((RCM_handle_array [i]->channel == regConv->channel)
 800374e:	7923      	ldrb	r3, [r4, #4]
 8003750:	428b      	cmp	r3, r1
 8003752:	f000 80aa 	beq.w	80038aa <RCM_RegisterRegConv+0x196>
      {
        /* Nothing to do */
      }
      i++;
    }
    if (handle < RCM_MAX_CONV)
 8003756:	2a03      	cmp	r2, #3
 8003758:	bf88      	it	hi
 800375a:	22ff      	movhi	r2, #255	@ 0xff
 800375c:	f240 80b6 	bls.w	80038cc <RCM_RegisterRegConv+0x1b8>
    }
#ifdef NULL_PTR_CHECK_REG_CON_MNG
  }
#endif
  regConv->convHandle = handle;
}
 8003760:	bc70      	pop	{r4, r5, r6}
  regConv->convHandle = handle;
 8003762:	7302      	strb	r2, [r0, #12]
}
 8003764:	4770      	bx	lr
         && (RCM_handle_array [i]->regADC == regConv->regADC))
 8003766:	6803      	ldr	r3, [r0, #0]
 8003768:	6812      	ldr	r2, [r2, #0]
 800376a:	4293      	cmp	r3, r2
 800376c:	d021      	beq.n	80037b2 <RCM_RegisterRegConv+0x9e>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 800376e:	6874      	ldr	r4, [r6, #4]
 8003770:	2c00      	cmp	r4, #0
 8003772:	d1dc      	bne.n	800372e <RCM_RegisterRegConv+0x1a>
 8003774:	68b5      	ldr	r5, [r6, #8]
      i++;
 8003776:	2201      	movs	r2, #1
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 8003778:	2d00      	cmp	r5, #0
 800377a:	d1e1      	bne.n	8003740 <RCM_RegisterRegConv+0x2c>
 800377c:	68f4      	ldr	r4, [r6, #12]
 800377e:	b1dc      	cbz	r4, 80037b8 <RCM_RegisterRegConv+0xa4>
        if ((RCM_handle_array [i]->channel == regConv->channel)
 8003780:	7925      	ldrb	r5, [r4, #4]
 8003782:	7901      	ldrb	r1, [r0, #4]
 8003784:	428d      	cmp	r5, r1
 8003786:	d115      	bne.n	80037b4 <RCM_RegisterRegConv+0xa0>
 8003788:	e090      	b.n	80038ac <RCM_RegisterRegConv+0x198>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 800378a:	6874      	ldr	r4, [r6, #4]
 800378c:	2c00      	cmp	r4, #0
 800378e:	f000 80a5 	beq.w	80038dc <RCM_RegisterRegConv+0x1c8>
 8003792:	7901      	ldrb	r1, [r0, #4]
        if ((RCM_handle_array [i]->channel == regConv->channel)
 8003794:	7923      	ldrb	r3, [r4, #4]
 8003796:	428b      	cmp	r3, r1
 8003798:	d1ce      	bne.n	8003738 <RCM_RegisterRegConv+0x24>
         && (RCM_handle_array [i]->regADC == regConv->regADC))
 800379a:	6824      	ldr	r4, [r4, #0]
 800379c:	6803      	ldr	r3, [r0, #0]
 800379e:	42a3      	cmp	r3, r4
 80037a0:	d1ca      	bne.n	8003738 <RCM_RegisterRegConv+0x24>
      i++;
 80037a2:	2201      	movs	r2, #1
 80037a4:	e006      	b.n	80037b4 <RCM_RegisterRegConv+0xa0>
         && (RCM_handle_array [i]->regADC == regConv->regADC))
 80037a6:	682c      	ldr	r4, [r5, #0]
 80037a8:	6803      	ldr	r3, [r0, #0]
 80037aa:	429c      	cmp	r4, r3
 80037ac:	d1cb      	bne.n	8003746 <RCM_RegisterRegConv+0x32>
      i++;
 80037ae:	2202      	movs	r2, #2
 80037b0:	e000      	b.n	80037b4 <RCM_RegisterRegConv+0xa0>
    uint8_t i = 0;
 80037b2:	2200      	movs	r2, #0
    while (i < RCM_MAX_CONV)
 80037b4:	f04f 0400 	mov.w	r4, #0
 80037b8:	f362 0407 	bfi	r4, r2, #0, #8
 80037bc:	f362 240f 	bfi	r4, r2, #8, #8
      RCM_CB_array [handle].cb = NULL; /* If a previous callback was attached, it is cleared */
 80037c0:	4d4f      	ldr	r5, [pc, #316]	@ (8003900 <RCM_RegisterRegConv+0x1ec>)
  * @param  ADCx ADC instance
  * @retval 0: ADC is disabled, 1: ADC is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsEnabled(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 80037c2:	6899      	ldr	r1, [r3, #8]
      RCM_handle_array [handle] = regConv;
 80037c4:	f846 0022 	str.w	r0, [r6, r2, lsl #2]
      RCM_CB_array [handle].cb = NULL; /* If a previous callback was attached, it is cleared */
 80037c8:	2600      	movs	r6, #0
 80037ca:	f845 6032 	str.w	r6, [r5, r2, lsl #3]
 80037ce:	07ce      	lsls	r6, r1, #31
 80037d0:	d422      	bmi.n	8003818 <RCM_RegisterRegConv+0x104>
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableIT_EOC(ADC_TypeDef *ADCx)
{
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_EOC);
 80037d2:	6859      	ldr	r1, [r3, #4]
 80037d4:	f021 0104 	bic.w	r1, r1, #4
 80037d8:	6059      	str	r1, [r3, #4]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_EOC);
 80037da:	2104      	movs	r1, #4
 80037dc:	6019      	str	r1, [r3, #0]
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableIT_JEOC(ADC_TypeDef *ADCx)
{
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_JEOC);
 80037de:	6859      	ldr	r1, [r3, #4]
 80037e0:	f021 0120 	bic.w	r1, r1, #32
 80037e4:	6059      	str	r1, [r3, #4]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_JEOC);
 80037e6:	2120      	movs	r1, #32
 80037e8:	6019      	str	r1, [r3, #0]
  MODIFY_REG(ADCx->CR,
 80037ea:	6899      	ldr	r1, [r3, #8]
 80037ec:	f021 4140 	bic.w	r1, r1, #3221225472	@ 0xc0000000
 80037f0:	f021 013f 	bic.w	r1, r1, #63	@ 0x3f
 80037f4:	f041 4100 	orr.w	r1, r1, #2147483648	@ 0x80000000
 80037f8:	6099      	str	r1, [r3, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADCAL) == (ADC_CR_ADCAL)) ? 1UL : 0UL);
 80037fa:	6899      	ldr	r1, [r3, #8]
 80037fc:	2900      	cmp	r1, #0
 80037fe:	dbfc      	blt.n	80037fa <RCM_RegisterRegConv+0xe6>
  return ((READ_BIT(ADCx->ISR, LL_ADC_FLAG_ADRDY) == (LL_ADC_FLAG_ADRDY)) ? 1UL : 0UL);
 8003800:	6819      	ldr	r1, [r3, #0]
 8003802:	07cd      	lsls	r5, r1, #31
 8003804:	d408      	bmi.n	8003818 <RCM_RegisterRegConv+0x104>
  MODIFY_REG(ADCx->CR,
 8003806:	4d3f      	ldr	r5, [pc, #252]	@ (8003904 <RCM_RegisterRegConv+0x1f0>)
 8003808:	6899      	ldr	r1, [r3, #8]
 800380a:	4029      	ands	r1, r5
 800380c:	f041 0101 	orr.w	r1, r1, #1
 8003810:	6099      	str	r1, [r3, #8]
  return ((READ_BIT(ADCx->ISR, LL_ADC_FLAG_ADRDY) == (LL_ADC_FLAG_ADRDY)) ? 1UL : 0UL);
 8003812:	6819      	ldr	r1, [r3, #0]
 8003814:	07c9      	lsls	r1, r1, #31
 8003816:	d5f7      	bpl.n	8003808 <RCM_RegisterRegConv+0xf4>
      RCM_NoInj_array[handle].enable = false;
 8003818:	4d3b      	ldr	r5, [pc, #236]	@ (8003908 <RCM_RegisterRegConv+0x1f4>)
 800381a:	eb02 0142 	add.w	r1, r2, r2, lsl #1
 800381e:	0049      	lsls	r1, r1, #1
      RCM_NoInj_array[handle].prev = handle;
 8003820:	1d2e      	adds	r6, r5, #4
 8003822:	5274      	strh	r4, [r6, r1]
      RCM_NoInj_array[handle].enable = false;
 8003824:	2400      	movs	r4, #0
 8003826:	546c      	strb	r4, [r5, r1]
  MODIFY_REG(ADCx->SQR1, ADC_SQR1_L, SequencerNbRanks);
 8003828:	6b1c      	ldr	r4, [r3, #48]	@ 0x30
 800382a:	f024 040f 	bic.w	r4, r4, #15
 800382e:	631c      	str	r4, [r3, #48]	@ 0x30
      LL_ADC_SetChannelSamplingTime(regConv->regADC, __LL_ADC_DECIMAL_NB_TO_CHANNEL(regConv->channel),
 8003830:	f890 c004 	ldrb.w	ip, [r0, #4]
 8003834:	2101      	movs	r1, #1
 8003836:	fa01 f10c 	lsl.w	r1, r1, ip
 800383a:	f1bc 0f09 	cmp.w	ip, #9
 800383e:	ea41 618c 	orr.w	r1, r1, ip, lsl #26
 8003842:	eb0c 044c 	add.w	r4, ip, ip, lsl #1
 8003846:	d817      	bhi.n	8003878 <RCM_RegisterRegConv+0x164>
 8003848:	ea41 5104 	orr.w	r1, r1, r4, lsl #20
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1,
 800384c:	0dcc      	lsrs	r4, r1, #23
 800384e:	f004 0404 	and.w	r4, r4, #4
 8003852:	f103 0c14 	add.w	ip, r3, #20
  MODIFY_REG(*preg,
 8003856:	6885      	ldr	r5, [r0, #8]
 8003858:	f85c 3004 	ldr.w	r3, [ip, r4]
 800385c:	f3c1 5104 	ubfx	r1, r1, #20, #5
 8003860:	2607      	movs	r6, #7
 8003862:	408d      	lsls	r5, r1
 8003864:	fa06 f101 	lsl.w	r1, r6, r1
 8003868:	ea23 0101 	bic.w	r1, r3, r1
 800386c:	4329      	orrs	r1, r5
 800386e:	f84c 1004 	str.w	r1, [ip, r4]
}
 8003872:	bc70      	pop	{r4, r5, r6}
  regConv->convHandle = handle;
 8003874:	7302      	strb	r2, [r0, #12]
}
 8003876:	4770      	bx	lr
      LL_ADC_SetChannelSamplingTime(regConv->regADC, __LL_ADC_DECIMAL_NB_TO_CHANNEL(regConv->channel),
 8003878:	3c1e      	subs	r4, #30
 800387a:	ea41 5104 	orr.w	r1, r1, r4, lsl #20
 800387e:	f041 7100 	orr.w	r1, r1, #33554432	@ 0x2000000
 8003882:	e7e3      	b.n	800384c <RCM_RegisterRegConv+0x138>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 8003884:	2a04      	cmp	r2, #4
 8003886:	d92e      	bls.n	80038e6 <RCM_RegisterRegConv+0x1d2>
 8003888:	68f2      	ldr	r2, [r6, #12]
 800388a:	b372      	cbz	r2, 80038ea <RCM_RegisterRegConv+0x1d6>
        if ((RCM_handle_array [i]->channel == regConv->channel)
 800388c:	7913      	ldrb	r3, [r2, #4]
 800388e:	4299      	cmp	r1, r3
         && (RCM_handle_array [i]->regADC == regConv->regADC))
 8003890:	6803      	ldr	r3, [r0, #0]
        if ((RCM_handle_array [i]->channel == regConv->channel)
 8003892:	d02f      	beq.n	80038f4 <RCM_RegisterRegConv+0x1e0>
      i++;
 8003894:	2202      	movs	r2, #2
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 8003896:	f240 2402 	movw	r4, #514	@ 0x202
 800389a:	e791      	b.n	80037c0 <RCM_RegisterRegConv+0xac>
 800389c:	2a04      	cmp	r2, #4
 800389e:	d917      	bls.n	80038d0 <RCM_RegisterRegConv+0x1bc>
 80038a0:	6803      	ldr	r3, [r0, #0]
 80038a2:	2203      	movs	r2, #3
 80038a4:	f240 3403 	movw	r4, #771	@ 0x303
 80038a8:	e78a      	b.n	80037c0 <RCM_RegisterRegConv+0xac>
 80038aa:	6803      	ldr	r3, [r0, #0]
         && (RCM_handle_array [i]->regADC == regConv->regADC))
 80038ac:	6821      	ldr	r1, [r4, #0]
 80038ae:	4299      	cmp	r1, r3
 80038b0:	f47f af51 	bne.w	8003756 <RCM_RegisterRegConv+0x42>
      i++;
 80038b4:	2203      	movs	r2, #3
 80038b6:	e77d      	b.n	80037b4 <RCM_RegisterRegConv+0xa0>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 80038b8:	68b5      	ldr	r5, [r6, #8]
      i++;
 80038ba:	2201      	movs	r2, #1
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 80038bc:	2d00      	cmp	r5, #0
 80038be:	f47f af3f 	bne.w	8003740 <RCM_RegisterRegConv+0x2c>
 80038c2:	68f4      	ldr	r4, [r6, #12]
 80038c4:	b124      	cbz	r4, 80038d0 <RCM_RegisterRegConv+0x1bc>
        if ((RCM_handle_array [i]->channel == regConv->channel)
 80038c6:	7923      	ldrb	r3, [r4, #4]
 80038c8:	428b      	cmp	r3, r1
 80038ca:	d0ee      	beq.n	80038aa <RCM_RegisterRegConv+0x196>
 80038cc:	f04f 0400 	mov.w	r4, #0
 80038d0:	f362 0407 	bfi	r4, r2, #0, #8
 80038d4:	6803      	ldr	r3, [r0, #0]
 80038d6:	f362 240f 	bfi	r4, r2, #8, #8
 80038da:	e771      	b.n	80037c0 <RCM_RegisterRegConv+0xac>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 80038dc:	68b5      	ldr	r5, [r6, #8]
 80038de:	b135      	cbz	r5, 80038ee <RCM_RegisterRegConv+0x1da>
 80038e0:	7901      	ldrb	r1, [r0, #4]
    uint8_t i = 0;
 80038e2:	4622      	mov	r2, r4
 80038e4:	e72c      	b.n	8003740 <RCM_RegisterRegConv+0x2c>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 80038e6:	462a      	mov	r2, r5
 80038e8:	e7eb      	b.n	80038c2 <RCM_RegisterRegConv+0x1ae>
 80038ea:	6803      	ldr	r3, [r0, #0]
 80038ec:	e7d2      	b.n	8003894 <RCM_RegisterRegConv+0x180>
 80038ee:	6803      	ldr	r3, [r0, #0]
    uint8_t i = 0;
 80038f0:	462a      	mov	r2, r5
 80038f2:	e743      	b.n	800377c <RCM_RegisterRegConv+0x68>
         && (RCM_handle_array [i]->regADC == regConv->regADC))
 80038f4:	6812      	ldr	r2, [r2, #0]
 80038f6:	4293      	cmp	r3, r2
 80038f8:	d0dc      	beq.n	80038b4 <RCM_RegisterRegConv+0x1a0>
 80038fa:	e7cb      	b.n	8003894 <RCM_RegisterRegConv+0x180>
 80038fc:	200019e0 	.word	0x200019e0
 8003900:	200019c0 	.word	0x200019c0
 8003904:	7fffffc0 	.word	0x7fffffc0
 8003908:	200019a8 	.word	0x200019a8

0800390c <RCM_ExecRegularConv>:
 * Otherwise, the latest stored conversion result will be returned.
 *
 * NOTE: This function is not part of the public API and users should not call it.
 */
uint16_t RCM_ExecRegularConv (RegConv_t *regConv)
{
 800390c:	b510      	push	{r4, lr}
  uint16_t retVal;
  uint8_t handle = regConv->convHandle;
 800390e:	7b03      	ldrb	r3, [r0, #12]
  uint8_t formerNext;
  uint8_t i=0;
  uint8_t LastEnable = RCM_MAX_CONV;

  if (false == RCM_NoInj_array [handle].enable)
 8003910:	4a5e      	ldr	r2, [pc, #376]	@ (8003a8c <RCM_ExecRegularConv+0x180>)
 8003912:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 8003916:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 800391a:	f812 0011 	ldrb.w	r0, [r2, r1, lsl #1]
 800391e:	2800      	cmp	r0, #0
 8003920:	d139      	bne.n	8003996 <RCM_ExecRegularConv+0x8a>
  {
    /* Find position in the list */
    while (i < RCM_MAX_CONV)
    {
      if (true == RCM_NoInj_array [i].enable)
 8003922:	7811      	ldrb	r1, [r2, #0]
 8003924:	b991      	cbnz	r1, 800394c <RCM_ExecRegularConv+0x40>
  uint8_t LastEnable = RCM_MAX_CONV;
 8003926:	2004      	movs	r0, #4
      if (true == RCM_NoInj_array [i].enable)
 8003928:	7991      	ldrb	r1, [r2, #6]
 800392a:	2900      	cmp	r1, #0
 800392c:	d175      	bne.n	8003a1a <RCM_ExecRegularConv+0x10e>
 800392e:	7b11      	ldrb	r1, [r2, #12]
 8003930:	2900      	cmp	r1, #0
 8003932:	d177      	bne.n	8003a24 <RCM_ExecRegularConv+0x118>
 8003934:	7c91      	ldrb	r1, [r2, #18]
 8003936:	2900      	cmp	r1, #0
 8003938:	f000 809a 	beq.w	8003a70 <RCM_ExecRegularConv+0x164>
      {
        if (RCM_NoInj_array[i].next > handle)
 800393c:	7dd1      	ldrb	r1, [r2, #23]
 800393e:	4299      	cmp	r1, r3
 8003940:	f240 80a0 	bls.w	8003a84 <RCM_ExecRegularConv+0x178>
 8003944:	f04f 0e03 	mov.w	lr, #3
      if (true == RCM_NoInj_array [i].enable)
 8003948:	4670      	mov	r0, lr
 800394a:	e003      	b.n	8003954 <RCM_ExecRegularConv+0x48>
        if (RCM_NoInj_array[i].next > handle)
 800394c:	7951      	ldrb	r1, [r2, #5]
 800394e:	428b      	cmp	r3, r1
 8003950:	d2ea      	bcs.n	8003928 <RCM_ExecRegularConv+0x1c>
  uint8_t i=0;
 8003952:	4686      	mov	lr, r0
        /* We found a previous reg conv to link with */
        {
          formerNext = RCM_NoInj_array [i].next;
          RCM_NoInj_array[handle].next = formerNext;
 8003954:	eb0c 0403 	add.w	r4, ip, r3
 8003958:	eb02 0444 	add.w	r4, r2, r4, lsl #1
          RCM_NoInj_array[handle].prev = i;
          RCM_NoInj_array[i].next = handle;
 800395c:	eb00 0040 	add.w	r0, r0, r0, lsl #1
          RCM_NoInj_array[handle].next = formerNext;
 8003960:	7161      	strb	r1, [r4, #5]
          RCM_NoInj_array[formerNext].prev = handle;
 8003962:	eb01 0141 	add.w	r1, r1, r1, lsl #1
          RCM_NoInj_array[handle].prev = i;
 8003966:	f884 e004 	strb.w	lr, [r4, #4]
          RCM_NoInj_array[formerNext].prev = handle;
 800396a:	eb02 0141 	add.w	r1, r2, r1, lsl #1
      }
    }
    /* The handle is now linked with others, we can set the enable flag */
    RCM_NoInj_array[handle].enable = true;
    RCM_NoInj_array[handle].status = notvalid;
    if (RCM_NoInj_array[RCM_currentHandle].status != ongoing)
 800396e:	4c48      	ldr	r4, [pc, #288]	@ (8003a90 <RCM_ExecRegularConv+0x184>)
          RCM_NoInj_array[formerNext].prev = handle;
 8003970:	710b      	strb	r3, [r1, #4]
          RCM_NoInj_array[i].next = handle;
 8003972:	eb02 0040 	add.w	r0, r2, r0, lsl #1
    if (RCM_NoInj_array[RCM_currentHandle].status != ongoing)
 8003976:	7821      	ldrb	r1, [r4, #0]
          RCM_NoInj_array[i].next = handle;
 8003978:	7143      	strb	r3, [r0, #5]
    RCM_NoInj_array[handle].enable = true;
 800397a:	eb0c 0003 	add.w	r0, ip, r3
 800397e:	f04f 0e01 	mov.w	lr, #1
    if (RCM_NoInj_array[RCM_currentHandle].status != ongoing)
 8003982:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    RCM_NoInj_array[handle].enable = true;
 8003986:	f822 e010 	strh.w	lr, [r2, r0, lsl #1]
    if (RCM_NoInj_array[RCM_currentHandle].status != ongoing)
 800398a:	eb02 0141 	add.w	r1, r2, r1, lsl #1
 800398e:	7849      	ldrb	r1, [r1, #1]
 8003990:	4571      	cmp	r1, lr
    {/* Select the new conversion to be the next scheduled only if a conversion is not ongoing */
      RCM_currentHandle = handle;
 8003992:	bf18      	it	ne
 8003994:	7023      	strbne	r3, [r4, #0]
  }
  else
  {
    /* Nothing to do the current handle is already scheduled */
  }
  if (false == PWM_Handle_M1.ADCRegularLocked)
 8003996:	493f      	ldr	r1, [pc, #252]	@ (8003a94 <RCM_ExecRegularConv+0x188>)
 8003998:	f891 10a0 	ldrb.w	r1, [r1, #160]	@ 0xa0
 800399c:	2900      	cmp	r1, #0
 800399e:	d137      	bne.n	8003a10 <RCM_ExecRegularConv+0x104>
  /* The ADC is free to be used asynchronously */
  {
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[handle]->regADC,
 80039a0:	493d      	ldr	r1, [pc, #244]	@ (8003a98 <RCM_ExecRegularConv+0x18c>)
 80039a2:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
                                 LL_ADC_REG_RANK_1,
                                 __LL_ADC_DECIMAL_NB_TO_CHANNEL(RCM_handle_array[handle]->channel));
 80039a6:	790c      	ldrb	r4, [r1, #4]
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[handle]->regADC,
 80039a8:	6808      	ldr	r0, [r1, #0]
                                 __LL_ADC_DECIMAL_NB_TO_CHANNEL(RCM_handle_array[handle]->channel));
 80039aa:	2101      	movs	r1, #1
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[handle]->regADC,
 80039ac:	2c09      	cmp	r4, #9
                                 __LL_ADC_DECIMAL_NB_TO_CHANNEL(RCM_handle_array[handle]->channel));
 80039ae:	eb04 0e44 	add.w	lr, r4, r4, lsl #1
 80039b2:	fa01 f104 	lsl.w	r1, r1, r4
 80039b6:	ea41 6184 	orr.w	r1, r1, r4, lsl #26
 80039ba:	bf84      	itt	hi
 80039bc:	f1ae 0e1e 	subhi.w	lr, lr, #30
 80039c0:	ea41 510e 	orrhi.w	r1, r1, lr, lsl #20
  MODIFY_REG(*preg,
 80039c4:	6b04      	ldr	r4, [r0, #48]	@ 0x30
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[handle]->regADC,
 80039c6:	bf94      	ite	ls
 80039c8:	ea41 510e 	orrls.w	r1, r1, lr, lsl #20
 80039cc:	f041 7100 	orrhi.w	r1, r1, #33554432	@ 0x2000000
 80039d0:	0d09      	lsrs	r1, r1, #20
 80039d2:	f401 61f8 	and.w	r1, r1, #1984	@ 0x7c0
 80039d6:	f424 64f8 	bic.w	r4, r4, #1984	@ 0x7c0
 80039da:	4321      	orrs	r1, r4
 80039dc:	6301      	str	r1, [r0, #48]	@ 0x30
* param  ADCx ADC instance
* retval Value between Min_Data=0x0000 and Max_Data=0xFFF0
*/
__STATIC_INLINE uint16_t LL_ADC_REG_ReadConversionData12L(const ADC_TypeDef *ADCx)
{
  return (uint16_t)(READ_REG(ADCx->DR) & 0x0000FFF0UL);
 80039de:	6c01      	ldr	r1, [r0, #64]	@ 0x40
  MODIFY_REG(ADCx->CR,
 80039e0:	6881      	ldr	r1, [r0, #8]
 80039e2:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 80039e6:	f021 013f 	bic.w	r1, r1, #63	@ 0x3f
 80039ea:	f041 0104 	orr.w	r1, r1, #4
 80039ee:	6081      	str	r1, [r0, #8]
  return ((READ_BIT(ADCx->ISR, ADC_ISR_EOC) == (ADC_ISR_EOC)) ? 1UL : 0UL);
 80039f0:	6801      	ldr	r1, [r0, #0]
 80039f2:	0749      	lsls	r1, r1, #29
 80039f4:	d5fc      	bpl.n	80039f0 <RCM_ExecRegularConv+0xe4>
 80039f6:	6c00      	ldr	r0, [r0, #64]	@ 0x40
    {
      /* Nothing to do */
    }

    /* Read the "Regular" conversion (Not related to current sampling) */
    RCM_NoInj_array[handle].value = LL_ADC_REG_ReadConversionData12L(RCM_handle_array[handle]->regADC);
 80039f8:	eb0c 0103 	add.w	r1, ip, r3
 80039fc:	eb02 0141 	add.w	r1, r2, r1, lsl #1
 8003a00:	f020 000f 	bic.w	r0, r0, #15
 8003a04:	8048      	strh	r0, [r1, #2]
    RCM_currentHandle = RCM_NoInj_array[handle].next;
 8003a06:	4822      	ldr	r0, [pc, #136]	@ (8003a90 <RCM_ExecRegularConv+0x184>)
 8003a08:	794c      	ldrb	r4, [r1, #5]
 8003a0a:	7004      	strb	r4, [r0, #0]
    RCM_NoInj_array[handle].status = valid;
 8003a0c:	2002      	movs	r0, #2
 8003a0e:	7048      	strb	r0, [r1, #1]
  }
  else
  {
    /* Nothing to do */
  }
  retVal = RCM_NoInj_array[handle].value;
 8003a10:	449c      	add	ip, r3
 8003a12:	eb02 024c 	add.w	r2, r2, ip, lsl #1
  return (retVal);
}
 8003a16:	8850      	ldrh	r0, [r2, #2]
 8003a18:	bd10      	pop	{r4, pc}
        if (RCM_NoInj_array[i].next > handle)
 8003a1a:	7ad1      	ldrb	r1, [r2, #11]
 8003a1c:	428b      	cmp	r3, r1
 8003a1e:	d31d      	bcc.n	8003a5c <RCM_ExecRegularConv+0x150>
      if (true == RCM_NoInj_array [i].enable)
 8003a20:	7b11      	ldrb	r1, [r2, #12]
 8003a22:	b1f9      	cbz	r1, 8003a64 <RCM_ExecRegularConv+0x158>
        if (RCM_NoInj_array[i].next > handle)
 8003a24:	7c51      	ldrb	r1, [r2, #17]
 8003a26:	4299      	cmp	r1, r3
 8003a28:	d828      	bhi.n	8003a7c <RCM_ExecRegularConv+0x170>
      if (true == RCM_NoInj_array [i].enable)
 8003a2a:	7c91      	ldrb	r1, [r2, #18]
 8003a2c:	2900      	cmp	r1, #0
 8003a2e:	d185      	bne.n	800393c <RCM_ExecRegularConv+0x30>
 8003a30:	2102      	movs	r1, #2
         formerNext = RCM_NoInj_array[LastEnable].next;
 8003a32:	4608      	mov	r0, r1
 8003a34:	eb00 0040 	add.w	r0, r0, r0, lsl #1
         RCM_NoInj_array[handle].next = formerNext;
 8003a38:	eb0c 0403 	add.w	r4, ip, r3
 8003a3c:	eb02 0444 	add.w	r4, r2, r4, lsl #1
         formerNext = RCM_NoInj_array[LastEnable].next;
 8003a40:	eb02 0040 	add.w	r0, r2, r0, lsl #1
         RCM_NoInj_array[handle].prev = LastEnable;
 8003a44:	7121      	strb	r1, [r4, #4]
         formerNext = RCM_NoInj_array[LastEnable].next;
 8003a46:	7941      	ldrb	r1, [r0, #5]
         RCM_NoInj_array[handle].next = formerNext;
 8003a48:	7161      	strb	r1, [r4, #5]
         RCM_NoInj_array[formerNext].prev = handle;
 8003a4a:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 8003a4e:	eb02 0141 	add.w	r1, r2, r1, lsl #1
    if (RCM_NoInj_array[RCM_currentHandle].status != ongoing)
 8003a52:	4c0f      	ldr	r4, [pc, #60]	@ (8003a90 <RCM_ExecRegularConv+0x184>)
         RCM_NoInj_array[formerNext].prev = handle;
 8003a54:	710b      	strb	r3, [r1, #4]
         RCM_NoInj_array[LastEnable].next = handle;
 8003a56:	7143      	strb	r3, [r0, #5]
    if (RCM_NoInj_array[RCM_currentHandle].status != ongoing)
 8003a58:	7821      	ldrb	r1, [r4, #0]
 8003a5a:	e78e      	b.n	800397a <RCM_ExecRegularConv+0x6e>
        if (RCM_NoInj_array[i].next > handle)
 8003a5c:	f04f 0e01 	mov.w	lr, #1
      if (true == RCM_NoInj_array [i].enable)
 8003a60:	4670      	mov	r0, lr
 8003a62:	e777      	b.n	8003954 <RCM_ExecRegularConv+0x48>
 8003a64:	7c91      	ldrb	r1, [r2, #18]
 8003a66:	2900      	cmp	r1, #0
 8003a68:	f47f af68 	bne.w	800393c <RCM_ExecRegularConv+0x30>
 8003a6c:	2101      	movs	r1, #1
 8003a6e:	e7e0      	b.n	8003a32 <RCM_ExecRegularConv+0x126>
       if (LastEnable != RCM_MAX_CONV )
 8003a70:	2800      	cmp	r0, #0
 8003a72:	d0de      	beq.n	8003a32 <RCM_ExecRegularConv+0x126>
         RCM_currentHandle = handle;
 8003a74:	4c06      	ldr	r4, [pc, #24]	@ (8003a90 <RCM_ExecRegularConv+0x184>)
 8003a76:	4619      	mov	r1, r3
 8003a78:	7023      	strb	r3, [r4, #0]
    while (i < RCM_MAX_CONV)
 8003a7a:	e77e      	b.n	800397a <RCM_ExecRegularConv+0x6e>
        if (RCM_NoInj_array[i].next > handle)
 8003a7c:	f04f 0e02 	mov.w	lr, #2
      if (true == RCM_NoInj_array [i].enable)
 8003a80:	4670      	mov	r0, lr
 8003a82:	e767      	b.n	8003954 <RCM_ExecRegularConv+0x48>
 8003a84:	2003      	movs	r0, #3
 8003a86:	4601      	mov	r1, r0
 8003a88:	e7d4      	b.n	8003a34 <RCM_ExecRegularConv+0x128>
 8003a8a:	bf00      	nop
 8003a8c:	200019a8 	.word	0x200019a8
 8003a90:	200019a4 	.word	0x200019a4
 8003a94:	20000200 	.word	0x20000200
 8003a98:	200019e0 	.word	0x200019e0

08003a9c <RCM_ExecUserConv>:
 * NOTE: This function is not part of the public API and users should not call it.
 */
void RCM_ExecUserConv()
{
  uint8_t handle;
  if (RCM_UserConvHandle != NULL)
 8003a9c:	4b14      	ldr	r3, [pc, #80]	@ (8003af0 <RCM_ExecUserConv+0x54>)
{
 8003a9e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (RCM_UserConvHandle != NULL)
 8003aa2:	681c      	ldr	r4, [r3, #0]
 8003aa4:	b124      	cbz	r4, 8003ab0 <RCM_ExecUserConv+0x14>
  {
    handle = RCM_UserConvHandle->convHandle;
    if (RCM_USERCONV_REQUESTED == RCM_UserConvState)
 8003aa6:	4d13      	ldr	r5, [pc, #76]	@ (8003af4 <RCM_ExecUserConv+0x58>)
    handle = RCM_UserConvHandle->convHandle;
 8003aa8:	7b26      	ldrb	r6, [r4, #12]
    if (RCM_USERCONV_REQUESTED == RCM_UserConvState)
 8003aaa:	782b      	ldrb	r3, [r5, #0]
 8003aac:	2b01      	cmp	r3, #1
 8003aae:	d001      	beq.n	8003ab4 <RCM_ExecUserConv+0x18>
  }
  else
  {
     /* Nothing to do */
  }
}
 8003ab0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      RCM_UserConvValue = RCM_ExecRegularConv(RCM_UserConvHandle);
 8003ab4:	4620      	mov	r0, r4
 8003ab6:	f7ff ff29 	bl	800390c <RCM_ExecRegularConv>
 8003aba:	4b0f      	ldr	r3, [pc, #60]	@ (8003af8 <RCM_ExecUserConv+0x5c>)
 8003abc:	8018      	strh	r0, [r3, #0]
      if (RCM_NoInj_array [handle].status != notvalid)
 8003abe:	4b0f      	ldr	r3, [pc, #60]	@ (8003afc <RCM_ExecUserConv+0x60>)
 8003ac0:	eb06 0246 	add.w	r2, r6, r6, lsl #1
 8003ac4:	eb03 0342 	add.w	r3, r3, r2, lsl #1
      RCM_UserConvValue = RCM_ExecRegularConv(RCM_UserConvHandle);
 8003ac8:	4601      	mov	r1, r0
      if (RCM_NoInj_array [handle].status != notvalid)
 8003aca:	785b      	ldrb	r3, [r3, #1]
 8003acc:	b10b      	cbz	r3, 8003ad2 <RCM_ExecUserConv+0x36>
        RCM_UserConvState = RCM_USERCONV_EOC;
 8003ace:	2302      	movs	r3, #2
 8003ad0:	702b      	strb	r3, [r5, #0]
      if (RCM_CB_array[handle].cb != NULL)
 8003ad2:	4b0b      	ldr	r3, [pc, #44]	@ (8003b00 <RCM_ExecUserConv+0x64>)
 8003ad4:	f853 7036 	ldr.w	r7, [r3, r6, lsl #3]
 8003ad8:	2f00      	cmp	r7, #0
 8003ada:	d0e9      	beq.n	8003ab0 <RCM_ExecUserConv+0x14>
        RCM_CB_array[handle].cb(RCM_UserConvHandle, RCM_UserConvValue,
 8003adc:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
 8003ae0:	4620      	mov	r0, r4
 8003ae2:	685a      	ldr	r2, [r3, #4]
        RCM_UserConvState = RCM_USERCONV_IDLE;
 8003ae4:	2300      	movs	r3, #0
 8003ae6:	702b      	strb	r3, [r5, #0]
        RCM_CB_array[handle].cb(RCM_UserConvHandle, RCM_UserConvValue,
 8003ae8:	463b      	mov	r3, r7
}
 8003aea:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        RCM_CB_array[handle].cb(RCM_UserConvHandle, RCM_UserConvValue,
 8003aee:	4718      	bx	r3
 8003af0:	2000199c 	.word	0x2000199c
 8003af4:	200019a0 	.word	0x200019a0
 8003af8:	200019a2 	.word	0x200019a2
 8003afc:	200019a8 	.word	0x200019a8
 8003b00:	200019c0 	.word	0x200019c0

08003b04 <RCM_ExecNextConv>:
 *
 * NOTE: This function is not part of the public API and users should not call it.
 */
void RCM_ExecNextConv(void)
{
  if (true == RCM_NoInj_array [RCM_currentHandle].enable)
 8003b04:	4b1e      	ldr	r3, [pc, #120]	@ (8003b80 <RCM_ExecNextConv+0x7c>)
 8003b06:	491f      	ldr	r1, [pc, #124]	@ (8003b84 <RCM_ExecNextConv+0x80>)
 8003b08:	781a      	ldrb	r2, [r3, #0]
 8003b0a:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 8003b0e:	f811 3013 	ldrb.w	r3, [r1, r3, lsl #1]
 8003b12:	b3a3      	cbz	r3, 8003b7e <RCM_ExecNextConv+0x7a>
    /* When this function is called, the ADC conversions triggered by External
       event for current reading has been completed.
       ADC is therefore ready to be started because already stopped */

    /* Clear EOC */
    LL_ADC_ClearFlag_EOC(RCM_handle_array[RCM_currentHandle]->regADC);
 8003b14:	4b1c      	ldr	r3, [pc, #112]	@ (8003b88 <RCM_ExecNextConv+0x84>)
{
 8003b16:	b510      	push	{r4, lr}
    LL_ADC_ClearFlag_EOC(RCM_handle_array[RCM_currentHandle]->regADC);
 8003b18:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8003b1c:	6818      	ldr	r0, [r3, #0]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_EOC);
 8003b1e:	2404      	movs	r4, #4
 8003b20:	6004      	str	r4, [r0, #0]
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[RCM_currentHandle]->regADC,
                                 LL_ADC_REG_RANK_1,
                                 __LL_ADC_DECIMAL_NB_TO_CHANNEL(RCM_handle_array[RCM_currentHandle]->channel));
 8003b22:	f893 c004 	ldrb.w	ip, [r3, #4]
 8003b26:	2301      	movs	r3, #1
 8003b28:	eb0c 044c 	add.w	r4, ip, ip, lsl #1
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[RCM_currentHandle]->regADC,
 8003b2c:	f1bc 0f09 	cmp.w	ip, #9
                                 __LL_ADC_DECIMAL_NB_TO_CHANNEL(RCM_handle_array[RCM_currentHandle]->channel));
 8003b30:	fa03 f30c 	lsl.w	r3, r3, ip
 8003b34:	ea43 638c 	orr.w	r3, r3, ip, lsl #26
 8003b38:	bf84      	itt	hi
 8003b3a:	3c1e      	subhi	r4, #30
 8003b3c:	ea43 5304 	orrhi.w	r3, r3, r4, lsl #20
 8003b40:	ea4f 0e42 	mov.w	lr, r2, lsl #1
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[RCM_currentHandle]->regADC,
 8003b44:	bf98      	it	ls
 8003b46:	ea43 5304 	orrls.w	r3, r3, r4, lsl #20

    (void)LL_ADC_REG_ReadConversionData12L(RCM_handle_array[RCM_currentHandle]->regADC);

    /* Start ADC for regular conversion */
    LL_ADC_REG_StartConversion(RCM_handle_array[RCM_currentHandle]->regADC);
    RCM_NoInj_array[RCM_currentHandle].status = ongoing;
 8003b4a:	4496      	add	lr, r2
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[RCM_currentHandle]->regADC,
 8003b4c:	bf88      	it	hi
 8003b4e:	f043 7300 	orrhi.w	r3, r3, #33554432	@ 0x2000000
  MODIFY_REG(*preg,
 8003b52:	6b02      	ldr	r2, [r0, #48]	@ 0x30
 8003b54:	0d1b      	lsrs	r3, r3, #20
 8003b56:	f403 63f8 	and.w	r3, r3, #1984	@ 0x7c0
 8003b5a:	f422 62f8 	bic.w	r2, r2, #1984	@ 0x7c0
 8003b5e:	4313      	orrs	r3, r2
 8003b60:	6303      	str	r3, [r0, #48]	@ 0x30
 8003b62:	6c03      	ldr	r3, [r0, #64]	@ 0x40
  MODIFY_REG(ADCx->CR,
 8003b64:	6883      	ldr	r3, [r0, #8]
 8003b66:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
    RCM_NoInj_array[RCM_currentHandle].status = ongoing;
 8003b6a:	eb01 014e 	add.w	r1, r1, lr, lsl #1
 8003b6e:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
 8003b72:	2401      	movs	r4, #1
 8003b74:	f043 0304 	orr.w	r3, r3, #4
 8003b78:	6083      	str	r3, [r0, #8]
 8003b7a:	704c      	strb	r4, [r1, #1]
  }
  else
  {
    /* Nothing to do, conversion not enabled have already notvalid status */
  }
}
 8003b7c:	bd10      	pop	{r4, pc}
 8003b7e:	4770      	bx	lr
 8003b80:	200019a4 	.word	0x200019a4
 8003b84:	200019a8 	.word	0x200019a8
 8003b88:	200019e0 	.word	0x200019e0

08003b8c <RCM_ReadOngoingConv>:
 * and user conversion.
 *
 * NOTE: This function is not part of the public API and users should not call it.
 */
void RCM_ReadOngoingConv(void)
{
 8003b8c:	b430      	push	{r4, r5}
  uint32_t result;
  RCM_status_t status;

  if (true == RCM_NoInj_array [RCM_currentHandle].enable)
 8003b8e:	4812      	ldr	r0, [pc, #72]	@ (8003bd8 <RCM_ReadOngoingConv+0x4c>)
 8003b90:	4a12      	ldr	r2, [pc, #72]	@ (8003bdc <RCM_ReadOngoingConv+0x50>)
 8003b92:	7803      	ldrb	r3, [r0, #0]
 8003b94:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 8003b98:	f812 4011 	ldrb.w	r4, [r2, r1, lsl #1]
 8003b9c:	eb02 0141 	add.w	r1, r2, r1, lsl #1
 8003ba0:	b16c      	cbz	r4, 8003bbe <RCM_ReadOngoingConv+0x32>
  {
    status = RCM_NoInj_array[RCM_currentHandle].status;
    result = LL_ADC_IsActiveFlag_EOC(RCM_handle_array[RCM_currentHandle]->regADC);
 8003ba2:	4c0f      	ldr	r4, [pc, #60]	@ (8003be0 <RCM_ReadOngoingConv+0x54>)
 8003ba4:	f854 4023 	ldr.w	r4, [r4, r3, lsl #2]
 8003ba8:	6824      	ldr	r4, [r4, #0]
  return ((READ_BIT(ADCx->ISR, ADC_ISR_EOC) == (ADC_ISR_EOC)) ? 1UL : 0UL);
 8003baa:	6825      	ldr	r5, [r4, #0]
 8003bac:	076d      	lsls	r5, r5, #29
 8003bae:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8003bb2:	d406      	bmi.n	8003bc2 <RCM_ReadOngoingConv+0x36>
      RCM_NoInj_array[RCM_currentHandle].status = valid;
      /* Restore back DMA configuration */
    }

    /* Prepare next conversion */
    RCM_currentHandle = RCM_NoInj_array [RCM_currentHandle].next;
 8003bb4:	449c      	add	ip, r3
 8003bb6:	eb02 024c 	add.w	r2, r2, ip, lsl #1
 8003bba:	7953      	ldrb	r3, [r2, #5]
 8003bbc:	7003      	strb	r3, [r0, #0]
    }
    else
    {
      /* Nothing to do */
    }
}
 8003bbe:	bc30      	pop	{r4, r5}
 8003bc0:	4770      	bx	lr
    if (( valid == status ) || ( notvalid == status ) || ( 0U == result ))
 8003bc2:	784d      	ldrb	r5, [r1, #1]
 8003bc4:	f015 0ffd 	tst.w	r5, #253	@ 0xfd
 8003bc8:	d0f4      	beq.n	8003bb4 <RCM_ReadOngoingConv+0x28>
 8003bca:	6c24      	ldr	r4, [r4, #64]	@ 0x40
 8003bcc:	f024 040f 	bic.w	r4, r4, #15
                    = LL_ADC_REG_ReadConversionData12L(RCM_handle_array[RCM_currentHandle]->regADC);
 8003bd0:	804c      	strh	r4, [r1, #2]
      RCM_NoInj_array[RCM_currentHandle].status = valid;
 8003bd2:	2402      	movs	r4, #2
 8003bd4:	704c      	strb	r4, [r1, #1]
 8003bd6:	e7ed      	b.n	8003bb4 <RCM_ReadOngoingConv+0x28>
 8003bd8:	200019a4 	.word	0x200019a4
 8003bdc:	200019a8 	.word	0x200019a8
 8003be0:	200019e0 	.word	0x200019e0

08003be4 <USART2_IRQHandler>:
  * @param  USARTx USART Instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_TC(const USART_TypeDef *USARTx)
{
  return ((READ_BIT(USARTx->ISR, USART_ISR_TC) == (USART_ISR_TC)) ? 1UL : 0UL);
 8003be4:	4b43      	ldr	r3, [pc, #268]	@ (8003cf4 <USART2_IRQHandler+0x110>)
 8003be6:	69da      	ldr	r2, [r3, #28]
 8003be8:	0652      	lsls	r2, r2, #25
  * @brief  This function handles USART interrupt request.
  * @param  None
  */
//cstat !MISRAC2012-Rule-8.4
void USART2_IRQHandler(void)
{
 8003bea:	b510      	push	{r4, lr}
 8003bec:	d509      	bpl.n	8003c02 <USART2_IRQHandler+0x1e>
  * @retval None
  */
__STATIC_INLINE void LL_DMA_DisableChannel(DMA_TypeDef *DMAx, uint32_t Channel)
{
  uint32_t dma_base_addr = (uint32_t)DMAx;
  CLEAR_BIT(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CCR, DMA_CCR_EN);
 8003bee:	4942      	ldr	r1, [pc, #264]	@ (8003cf8 <USART2_IRQHandler+0x114>)
    /* Disable the DMA channel to prepare the next chunck of data*/
    LL_DMA_DisableChannel(DMA_TX_A, DMACH_TX_A);
    LL_USART_ClearFlag_TC(USARTA);
    /* Data Sent by UART*/
    /* Need to free the buffer, and to check pending transfer*/
    ASPEP_HWDataTransmittedIT(&aspepOverUartA);
 8003bf0:	4842      	ldr	r0, [pc, #264]	@ (8003cfc <USART2_IRQHandler+0x118>)
 8003bf2:	69ca      	ldr	r2, [r1, #28]
  * @param  USARTx USART Instance
  * @retval None
  */
__STATIC_INLINE void LL_USART_ClearFlag_TC(USART_TypeDef *USARTx)
{
  WRITE_REG(USARTx->ICR, USART_ICR_TCCF);
 8003bf4:	2440      	movs	r4, #64	@ 0x40
 8003bf6:	f022 0201 	bic.w	r2, r2, #1
 8003bfa:	61ca      	str	r2, [r1, #28]
 8003bfc:	621c      	str	r4, [r3, #32]
 8003bfe:	f7fc fe0d 	bl	800081c <ASPEP_HWDataTransmittedIT>
  return ((READ_BIT(USARTx->ISR, USART_ISR_ORE) == (USART_ISR_ORE)) ? 1UL : 0UL);
 8003c02:	4b3c      	ldr	r3, [pc, #240]	@ (8003cf4 <USART2_IRQHandler+0x110>)
 8003c04:	69d8      	ldr	r0, [r3, #28]
  return ((READ_BIT(USARTx->ISR, USART_ISR_FE) == (USART_ISR_FE)) ? 1UL : 0UL);
 8003c06:	69da      	ldr	r2, [r3, #28]
  return ((READ_BIT(USARTx->ISR, USART_ISR_NE) == (USART_ISR_NE)) ? 1UL : 0UL);
 8003c08:	69d9      	ldr	r1, [r3, #28]
  * @param  USARTx USART Instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_USART_IsEnabledIT_ERROR(const USART_TypeDef *USARTx)
{
  return ((READ_BIT(USARTx->CR3, USART_CR3_EIE) == (USART_CR3_EIE)) ? 1UL : 0UL);
 8003c0a:	689c      	ldr	r4, [r3, #8]
 8003c0c:	07e4      	lsls	r4, r4, #31
 8003c0e:	d526      	bpl.n	8003c5e <USART2_IRQHandler+0x7a>
  return ((READ_BIT(USARTx->ISR, USART_ISR_FE) == (USART_ISR_FE)) ? 1UL : 0UL);
 8003c10:	f002 0202 	and.w	r2, r2, #2
  return ((READ_BIT(USARTx->ISR, USART_ISR_ORE) == (USART_ISR_ORE)) ? 1UL : 0UL);
 8003c14:	f000 0008 	and.w	r0, r0, #8
  feFlag = LL_USART_IsActiveFlag_FE(USARTA);
  neFlag = LL_USART_IsActiveFlag_NE(USARTA);
  errorMask = LL_USART_IsEnabledIT_ERROR(USARTA);

  flags = ((oreFlag | feFlag | neFlag) & errorMask);
  if (0U == flags)
 8003c18:	4302      	orrs	r2, r0
  return ((READ_BIT(USARTx->ISR, USART_ISR_NE) == (USART_ISR_NE)) ? 1UL : 0UL);
 8003c1a:	f001 0104 	and.w	r1, r1, #4
 8003c1e:	430a      	orrs	r2, r1
 8003c20:	d01d      	beq.n	8003c5e <USART2_IRQHandler+0x7a>
  {
    /* Nothing to do */
  }
  else
  { /* Stopping the debugger will generate an OverRun error*/
    WRITE_REG(USARTA->ICR, USART_ICR_FECF | USART_ICR_ORECF | USART_ICR_NECF);
 8003c22:	220e      	movs	r2, #14
 8003c24:	621a      	str	r2, [r3, #32]
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8003c26:	f04f 2240 	mov.w	r2, #1073758208	@ 0x40004000
 8003c2a:	f502 6381 	add.w	r3, r2, #1032	@ 0x408
 8003c2e:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_EIE);
 8003c32:	f023 0301 	bic.w	r3, r3, #1
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8003c36:	f502 6081 	add.w	r0, r2, #1032	@ 0x408
 8003c3a:	e840 3100 	strex	r1, r3, [r0]
 8003c3e:	2900      	cmp	r1, #0
 8003c40:	d1f3      	bne.n	8003c2a <USART2_IRQHandler+0x46>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8003c42:	f04f 2240 	mov.w	r2, #1073758208	@ 0x40004000
 8003c46:	f502 6380 	add.w	r3, r2, #1024	@ 0x400
 8003c4a:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 8003c4e:	f043 0310 	orr.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8003c52:	f502 6080 	add.w	r0, r2, #1024	@ 0x400
 8003c56:	e840 3100 	strex	r1, r3, [r0]
 8003c5a:	2900      	cmp	r1, #0
 8003c5c:	d1f3      	bne.n	8003c46 <USART2_IRQHandler+0x62>
  return ((READ_BIT(USARTx->ISR, USART_ISR_IDLE) == (USART_ISR_IDLE)) ? 1UL : 0UL);
 8003c5e:	4b25      	ldr	r3, [pc, #148]	@ (8003cf4 <USART2_IRQHandler+0x110>)
 8003c60:	69da      	ldr	r2, [r3, #28]
  return ((READ_BIT(USARTx->CR1, USART_CR1_IDLEIE) == (USART_CR1_IDLEIE)) ? 1UL : 0UL);
 8003c62:	681b      	ldr	r3, [r3, #0]
  return ((READ_BIT(USARTx->ISR, USART_ISR_IDLE) == (USART_ISR_IDLE)) ? 1UL : 0UL);
 8003c64:	06d2      	lsls	r2, r2, #27
 8003c66:	d543      	bpl.n	8003cf0 <USART2_IRQHandler+0x10c>
  return ((READ_BIT(USARTx->CR1, USART_CR1_IDLEIE) == (USART_CR1_IDLEIE)) ? 1UL : 0UL);
 8003c68:	06db      	lsls	r3, r3, #27
 8003c6a:	d541      	bpl.n	8003cf0 <USART2_IRQHandler+0x10c>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8003c6c:	f04f 2240 	mov.w	r2, #1073758208	@ 0x40004000
 8003c70:	f502 6380 	add.w	r3, r2, #1024	@ 0x400
 8003c74:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 8003c78:	f023 0310 	bic.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8003c7c:	f502 6080 	add.w	r0, r2, #1024	@ 0x400
 8003c80:	e840 3100 	strex	r1, r3, [r0]
 8003c84:	2900      	cmp	r1, #0
 8003c86:	d1f3      	bne.n	8003c70 <USART2_IRQHandler+0x8c>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8003c88:	f04f 2240 	mov.w	r2, #1073758208	@ 0x40004000
 8003c8c:	f502 6381 	add.w	r3, r2, #1032	@ 0x408
 8003c90:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_EIE);
 8003c94:	f043 0301 	orr.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8003c98:	f502 6081 	add.w	r0, r2, #1032	@ 0x408
 8003c9c:	e840 3100 	strex	r1, r3, [r0]
 8003ca0:	2900      	cmp	r1, #0
 8003ca2:	d1f3      	bne.n	8003c8c <USART2_IRQHandler+0xa8>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8003ca4:	f04f 2240 	mov.w	r2, #1073758208	@ 0x40004000
 8003ca8:	f502 6381 	add.w	r3, r2, #1032	@ 0x408
 8003cac:	e853 3f00 	ldrex	r3, [r3]
  * @param  USARTx USART Instance
  * @retval None
  */
__STATIC_INLINE void LL_USART_DisableDMAReq_RX(USART_TypeDef *USARTx)
{
  ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_DMAR);
 8003cb0:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8003cb4:	f502 6081 	add.w	r0, r2, #1032	@ 0x408
 8003cb8:	e840 3100 	strex	r1, r3, [r0]
 8003cbc:	2900      	cmp	r1, #0
 8003cbe:	d1f3      	bne.n	8003ca8 <USART2_IRQHandler+0xc4>
  * @param  USARTx USART Instance
  * @retval Value between Min_Data=0x00 and Max_Data=0xFF
  */
__STATIC_INLINE uint8_t LL_USART_ReceiveData8(const USART_TypeDef *USARTx)
{
  return (uint8_t)(READ_BIT(USARTx->RDR, USART_RDR_RDR) & 0xFFU);
 8003cc0:	4b0c      	ldr	r3, [pc, #48]	@ (8003cf4 <USART2_IRQHandler+0x110>)
 8003cc2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8003cc4:	f04f 2240 	mov.w	r2, #1073758208	@ 0x40004000
 8003cc8:	f502 6381 	add.w	r3, r2, #1032	@ 0x408
 8003ccc:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAR);
 8003cd0:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8003cd4:	f502 6081 	add.w	r0, r2, #1032	@ 0x408
 8003cd8:	e840 3100 	strex	r1, r3, [r0]
 8003cdc:	2900      	cmp	r1, #0
 8003cde:	d1f3      	bne.n	8003cc8 <USART2_IRQHandler+0xe4>
    WRITE_REG (DMAx->IFCR, DMA_IFCR_CTCIF1 << ((Channel-LL_DMA_CHANNEL_1)<<2));
 8003ce0:	4b05      	ldr	r3, [pc, #20]	@ (8003cf8 <USART2_IRQHandler+0x114>)
    LL_USART_DisableDMAReq_RX(USARTA);
    (void)LL_USART_ReceiveData8(USARTA);
    LL_USART_EnableDMAReq_RX(USARTA);
    /* Clear pending DMA TC to process only new received packet */
    LL_DMA_ClearFlag_TC(DMA_RX_A, DMACH_RX_A);
    ASPEP_HWReset(&aspepOverUartA);
 8003ce2:	4806      	ldr	r0, [pc, #24]	@ (8003cfc <USART2_IRQHandler+0x118>)
 8003ce4:	2202      	movs	r2, #2
  }

  /* USER CODE BEGIN USART2_IRQHandler 1 */

  /* USER CODE END USART2_IRQHandler 1 */
}
 8003ce6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8003cea:	605a      	str	r2, [r3, #4]
    ASPEP_HWReset(&aspepOverUartA);
 8003cec:	f7fc bf42 	b.w	8000b74 <ASPEP_HWReset>
}
 8003cf0:	bd10      	pop	{r4, pc}
 8003cf2:	bf00      	nop
 8003cf4:	40004400 	.word	0x40004400
 8003cf8:	40020000 	.word	0x40020000
 8003cfc:	200004d0 	.word	0x200004d0

08003d00 <HardFault_Handler>:
/**
  * @brief  This function handles Hard Fault exception.
  * @param  None
  */
void HardFault_Handler(void)
{
 8003d00:	b508      	push	{r3, lr}
 /* USER CODE BEGIN HardFault_IRQn 0 */

 /* USER CODE END HardFault_IRQn 0 */

  TSK_HardwareFaultTask();
 8003d02:	f7fd fcff 	bl	8001704 <TSK_HardwareFaultTask>

  /* Go to infinite loop when Hard Fault exception occurs */
  while (true)
 8003d06:	e7fe      	b.n	8003d06 <HardFault_Handler+0x6>

08003d08 <HAL_MspInit>:

  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8003d08:	4b0f      	ldr	r3, [pc, #60]	@ (8003d48 <HAL_MspInit+0x40>)
{
 8003d0a:	b510      	push	{r4, lr}
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8003d0c:	6e18      	ldr	r0, [r3, #96]	@ 0x60
 8003d0e:	f040 0001 	orr.w	r0, r0, #1
 8003d12:	6618      	str	r0, [r3, #96]	@ 0x60
 8003d14:	6e1c      	ldr	r4, [r3, #96]	@ 0x60
{
 8003d16:	b082      	sub	sp, #8
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8003d18:	f004 0401 	and.w	r4, r4, #1
 8003d1c:	9400      	str	r4, [sp, #0]
 8003d1e:	9c00      	ldr	r4, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 8003d20:	6d9c      	ldr	r4, [r3, #88]	@ 0x58
 8003d22:	f044 5480 	orr.w	r4, r4, #268435456	@ 0x10000000
 8003d26:	659c      	str	r4, [r3, #88]	@ 0x58
 8003d28:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8003d2a:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8003d2e:	9301      	str	r3, [sp, #4]

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 8003d30:	2200      	movs	r2, #0
 8003d32:	210f      	movs	r1, #15
 8003d34:	f06f 0001 	mvn.w	r0, #1
  __HAL_RCC_PWR_CLK_ENABLE();
 8003d38:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 8003d3a:	f001 f97d 	bl	8005038 <HAL_NVIC_SetPriority>
  HAL_PWREx_DisableUCPDDeadBattery();

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8003d3e:	b002      	add	sp, #8
 8003d40:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_PWREx_DisableUCPDDeadBattery();
 8003d44:	f001 bbe8 	b.w	8005518 <HAL_PWREx_DisableUCPDDeadBattery>
 8003d48:	40021000 	.word	0x40021000

08003d4c <HAL_ADC_MspInit>:
* This function configures the hardware resources used in this example
* @param hadc: ADC handle pointer
* @retval None
*/
void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
 8003d4c:	b510      	push	{r4, lr}
 8003d4e:	4604      	mov	r4, r0
 8003d50:	b09a      	sub	sp, #104	@ 0x68
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8003d52:	2100      	movs	r1, #0
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8003d54:	2244      	movs	r2, #68	@ 0x44
 8003d56:	a809      	add	r0, sp, #36	@ 0x24
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8003d58:	e9cd 1104 	strd	r1, r1, [sp, #16]
 8003d5c:	e9cd 1106 	strd	r1, r1, [sp, #24]
 8003d60:	9108      	str	r1, [sp, #32]
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8003d62:	f006 f9bf 	bl	800a0e4 <memset>
  if(hadc->Instance==ADC1)
 8003d66:	6823      	ldr	r3, [r4, #0]
 8003d68:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 8003d6c:	d001      	beq.n	8003d72 <HAL_ADC_MspInit+0x26>

  /* USER CODE END ADC1_MspInit 1 */

  }

}
 8003d6e:	b01a      	add	sp, #104	@ 0x68
 8003d70:	bd10      	pop	{r4, pc}
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC12;
 8003d72:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
    PeriphClkInit.Adc12ClockSelection = RCC_ADC12CLKSOURCE_PLL;
 8003d76:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8003d7a:	a809      	add	r0, sp, #36	@ 0x24
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC12;
 8003d7c:	9209      	str	r2, [sp, #36]	@ 0x24
    PeriphClkInit.Adc12ClockSelection = RCC_ADC12CLKSOURCE_PLL;
 8003d7e:	9318      	str	r3, [sp, #96]	@ 0x60
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8003d80:	f001 ffa8 	bl	8005cd4 <HAL_RCCEx_PeriphCLKConfig>
 8003d84:	2800      	cmp	r0, #0
 8003d86:	d131      	bne.n	8003dec <HAL_ADC_MspInit+0xa0>
    __HAL_RCC_ADC12_CLK_ENABLE();
 8003d88:	4b1a      	ldr	r3, [pc, #104]	@ (8003df4 <HAL_ADC_MspInit+0xa8>)
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8003d8a:	481b      	ldr	r0, [pc, #108]	@ (8003df8 <HAL_ADC_MspInit+0xac>)
    __HAL_RCC_ADC12_CLK_ENABLE();
 8003d8c:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8003d8e:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
 8003d92:	64da      	str	r2, [r3, #76]	@ 0x4c
 8003d94:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8003d96:	f402 5200 	and.w	r2, r2, #8192	@ 0x2000
 8003d9a:	9201      	str	r2, [sp, #4]
 8003d9c:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8003d9e:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8003da0:	f042 0204 	orr.w	r2, r2, #4
 8003da4:	64da      	str	r2, [r3, #76]	@ 0x4c
 8003da6:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8003da8:	f002 0204 	and.w	r2, r2, #4
 8003dac:	9202      	str	r2, [sp, #8]
 8003dae:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8003db0:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8003db2:	f042 0201 	orr.w	r2, r2, #1
 8003db6:	64da      	str	r2, [r3, #76]	@ 0x4c
 8003db8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8003dba:	f003 0301 	and.w	r3, r3, #1
 8003dbe:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8003dc0:	2400      	movs	r4, #0
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8003dc2:	a904      	add	r1, sp, #16
    GPIO_InitStruct.Pin = M1_CURR_AMPL_W_Pin|M1_CURR_AMPL_V_Pin|M1_TEMPERATURE_Pin;
 8003dc4:	2207      	movs	r2, #7
 8003dc6:	2303      	movs	r3, #3
 8003dc8:	e9cd 2304 	strd	r2, r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8003dcc:	9406      	str	r4, [sp, #24]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8003dce:	9b03      	ldr	r3, [sp, #12]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8003dd0:	f001 fa28 	bl	8005224 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = M1_CURR_AMPL_U_Pin|M1_BUS_VOLTAGE_Pin;
 8003dd4:	2203      	movs	r2, #3
 8003dd6:	2303      	movs	r3, #3
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8003dd8:	a904      	add	r1, sp, #16
 8003dda:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
    GPIO_InitStruct.Pin = M1_CURR_AMPL_U_Pin|M1_BUS_VOLTAGE_Pin;
 8003dde:	e9cd 2304 	strd	r2, r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8003de2:	9406      	str	r4, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8003de4:	f001 fa1e 	bl	8005224 <HAL_GPIO_Init>
}
 8003de8:	b01a      	add	sp, #104	@ 0x68
 8003dea:	bd10      	pop	{r4, pc}
      Error_Handler();
 8003dec:	f7fd f908 	bl	8001000 <Error_Handler>
 8003df0:	e7ca      	b.n	8003d88 <HAL_ADC_MspInit+0x3c>
 8003df2:	bf00      	nop
 8003df4:	40021000 	.word	0x40021000
 8003df8:	48000800 	.word	0x48000800

08003dfc <HAL_CORDIC_MspInit>:
* @param hcordic: CORDIC handle pointer
* @retval None
*/
void HAL_CORDIC_MspInit(CORDIC_HandleTypeDef* hcordic)
{
  if(hcordic->Instance==CORDIC)
 8003dfc:	4b0a      	ldr	r3, [pc, #40]	@ (8003e28 <HAL_CORDIC_MspInit+0x2c>)
 8003dfe:	6802      	ldr	r2, [r0, #0]
 8003e00:	429a      	cmp	r2, r3
 8003e02:	d000      	beq.n	8003e06 <HAL_CORDIC_MspInit+0xa>
 8003e04:	4770      	bx	lr
  {
  /* USER CODE BEGIN CORDIC_MspInit 0 */

  /* USER CODE END CORDIC_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_CORDIC_CLK_ENABLE();
 8003e06:	f8d3 2448 	ldr.w	r2, [r3, #1096]	@ 0x448
 8003e0a:	f042 0208 	orr.w	r2, r2, #8
 8003e0e:	f8c3 2448 	str.w	r2, [r3, #1096]	@ 0x448
 8003e12:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
{
 8003e16:	b082      	sub	sp, #8
    __HAL_RCC_CORDIC_CLK_ENABLE();
 8003e18:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8003e1a:	f003 0308 	and.w	r3, r3, #8
 8003e1e:	9301      	str	r3, [sp, #4]
 8003e20:	9b01      	ldr	r3, [sp, #4]

  /* USER CODE END CORDIC_MspInit 1 */

  }

}
 8003e22:	b002      	add	sp, #8
 8003e24:	4770      	bx	lr
 8003e26:	bf00      	nop
 8003e28:	40020c00 	.word	0x40020c00
 8003e2c:	00000000 	.word	0x00000000

08003e30 <HAL_TIM_PWM_MspInit>:
* This function configures the hardware resources used in this example
* @param htim_pwm: TIM_PWM handle pointer
* @retval None
*/
void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef* htim_pwm)
{
 8003e30:	b510      	push	{r4, lr}
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(htim_pwm->Instance==TIM1)
 8003e32:	4a1b      	ldr	r2, [pc, #108]	@ (8003ea0 <HAL_TIM_PWM_MspInit+0x70>)
 8003e34:	6801      	ldr	r1, [r0, #0]
{
 8003e36:	b088      	sub	sp, #32
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8003e38:	2300      	movs	r3, #0
  if(htim_pwm->Instance==TIM1)
 8003e3a:	4291      	cmp	r1, r2
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8003e3c:	e9cd 3302 	strd	r3, r3, [sp, #8]
 8003e40:	e9cd 3304 	strd	r3, r3, [sp, #16]
 8003e44:	9306      	str	r3, [sp, #24]
  if(htim_pwm->Instance==TIM1)
 8003e46:	d001      	beq.n	8003e4c <HAL_TIM_PWM_MspInit+0x1c>

  /* USER CODE END TIM1_MspInit 1 */

  }

}
 8003e48:	b008      	add	sp, #32
 8003e4a:	bd10      	pop	{r4, pc}
    __HAL_RCC_TIM1_CLK_ENABLE();
 8003e4c:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 8003e50:	f503 3304 	add.w	r3, r3, #135168	@ 0x21000
    GPIO_InitStruct.Pin = M1_OCP_Pin;
 8003e54:	ed9f 7b10 	vldr	d7, [pc, #64]	@ 8003e98 <HAL_TIM_PWM_MspInit+0x68>
    __HAL_RCC_TIM1_CLK_ENABLE();
 8003e58:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
 8003e5a:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 8003e5e:	661a      	str	r2, [r3, #96]	@ 0x60
 8003e60:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
 8003e62:	f402 6200 	and.w	r2, r2, #2048	@ 0x800
 8003e66:	9200      	str	r2, [sp, #0]
 8003e68:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8003e6a:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8003e6c:	f042 0201 	orr.w	r2, r2, #1
 8003e70:	64da      	str	r2, [r3, #76]	@ 0x4c
 8003e72:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8003e74:	f003 0301 	and.w	r3, r3, #1
 8003e78:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8003e7a:	2201      	movs	r2, #1
    GPIO_InitStruct.Alternate = GPIO_AF6_TIM1;
 8003e7c:	2306      	movs	r3, #6
    HAL_GPIO_Init(M1_OCP_GPIO_Port, &GPIO_InitStruct);
 8003e7e:	a902      	add	r1, sp, #8
 8003e80:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
    GPIO_InitStruct.Pin = M1_OCP_Pin;
 8003e84:	ed8d 7b02 	vstr	d7, [sp, #8]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8003e88:	9c01      	ldr	r4, [sp, #4]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8003e8a:	9204      	str	r2, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF6_TIM1;
 8003e8c:	9306      	str	r3, [sp, #24]
    HAL_GPIO_Init(M1_OCP_GPIO_Port, &GPIO_InitStruct);
 8003e8e:	f001 f9c9 	bl	8005224 <HAL_GPIO_Init>
}
 8003e92:	b008      	add	sp, #32
 8003e94:	bd10      	pop	{r4, pc}
 8003e96:	bf00      	nop
 8003e98:	00000040 	.word	0x00000040
 8003e9c:	00000012 	.word	0x00000012
 8003ea0:	40012c00 	.word	0x40012c00

08003ea4 <HAL_TIM_MspPostInit>:

void HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim)
{
 8003ea4:	b5d0      	push	{r4, r6, r7, lr}
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(htim->Instance==TIM1)
 8003ea6:	4a27      	ldr	r2, [pc, #156]	@ (8003f44 <HAL_TIM_MspPostInit+0xa0>)
 8003ea8:	6801      	ldr	r1, [r0, #0]
{
 8003eaa:	b088      	sub	sp, #32
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8003eac:	2300      	movs	r3, #0
  if(htim->Instance==TIM1)
 8003eae:	4291      	cmp	r1, r2
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8003eb0:	e9cd 3302 	strd	r3, r3, [sp, #8]
 8003eb4:	e9cd 3304 	strd	r3, r3, [sp, #16]
 8003eb8:	9306      	str	r3, [sp, #24]
  if(htim->Instance==TIM1)
 8003eba:	d001      	beq.n	8003ec0 <HAL_TIM_MspPostInit+0x1c>
  /* USER CODE BEGIN TIM1_MspPostInit 1 */

  /* USER CODE END TIM1_MspPostInit 1 */
  }

}
 8003ebc:	b008      	add	sp, #32
 8003ebe:	bdd0      	pop	{r4, r6, r7, pc}
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8003ec0:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 8003ec4:	f503 3304 	add.w	r3, r3, #135168	@ 0x21000
    GPIO_InitStruct.Alternate = GPIO_AF6_TIM1;
 8003ec8:	2406      	movs	r4, #6
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8003eca:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8003ecc:	f042 0201 	orr.w	r2, r2, #1
 8003ed0:	64da      	str	r2, [r3, #76]	@ 0x4c
 8003ed2:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8003ed4:	f002 0201 	and.w	r2, r2, #1
 8003ed8:	9200      	str	r2, [sp, #0]
 8003eda:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8003edc:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8003ede:	f042 0202 	orr.w	r2, r2, #2
 8003ee2:	64da      	str	r2, [r3, #76]	@ 0x4c
 8003ee4:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
    GPIO_InitStruct.Alternate = GPIO_AF6_TIM1;
 8003ee6:	9406      	str	r4, [sp, #24]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8003ee8:	f003 0302 	and.w	r3, r3, #2
 8003eec:	9301      	str	r3, [sp, #4]
    HAL_GPIO_Init(M1_PWM_UL_GPIO_Port, &GPIO_InitStruct);
 8003eee:	a902      	add	r1, sp, #8
    GPIO_InitStruct.Pin = M1_PWM_UL_Pin;
 8003ef0:	2280      	movs	r2, #128	@ 0x80
 8003ef2:	2601      	movs	r6, #1
 8003ef4:	2702      	movs	r7, #2
    HAL_GPIO_Init(M1_PWM_UL_GPIO_Port, &GPIO_InitStruct);
 8003ef6:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
    GPIO_InitStruct.Pin = M1_PWM_UL_Pin;
 8003efa:	2302      	movs	r3, #2
 8003efc:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8003f00:	e9cd 6704 	strd	r6, r7, [sp, #16]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8003f04:	9b01      	ldr	r3, [sp, #4]
    HAL_GPIO_Init(M1_PWM_UL_GPIO_Port, &GPIO_InitStruct);
 8003f06:	f001 f98d 	bl	8005224 <HAL_GPIO_Init>
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8003f0a:	a902      	add	r1, sp, #8
    GPIO_InitStruct.Pin = M1_PWM_VL_Pin|M1_PWM_WL_Pin;
 8003f0c:	2203      	movs	r2, #3
 8003f0e:	2302      	movs	r3, #2
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8003f10:	480d      	ldr	r0, [pc, #52]	@ (8003f48 <HAL_TIM_MspPostInit+0xa4>)
    GPIO_InitStruct.Alternate = GPIO_AF6_TIM1;
 8003f12:	9406      	str	r4, [sp, #24]
    GPIO_InitStruct.Pin = M1_PWM_VL_Pin|M1_PWM_WL_Pin;
 8003f14:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8003f18:	e9cd 6704 	strd	r6, r7, [sp, #16]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8003f1c:	f001 f982 	bl	8005224 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = M1_PWM_UH_Pin|M1_PWM_VH_Pin|M1_PWM_WH_Pin;
 8003f20:	f44f 62e0 	mov.w	r2, #1792	@ 0x700
 8003f24:	2302      	movs	r3, #2
 8003f26:	e9cd 2302 	strd	r2, r3, [sp, #8]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8003f2a:	a902      	add	r1, sp, #8
    GPIO_InitStruct.Pin = M1_PWM_UH_Pin|M1_PWM_VH_Pin|M1_PWM_WH_Pin;
 8003f2c:	2202      	movs	r2, #2
 8003f2e:	2302      	movs	r3, #2
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8003f30:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
    GPIO_InitStruct.Pin = M1_PWM_UH_Pin|M1_PWM_VH_Pin|M1_PWM_WH_Pin;
 8003f34:	e9cd 2304 	strd	r2, r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF6_TIM1;
 8003f38:	9406      	str	r4, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8003f3a:	f001 f973 	bl	8005224 <HAL_GPIO_Init>
}
 8003f3e:	b008      	add	sp, #32
 8003f40:	bdd0      	pop	{r4, r6, r7, pc}
 8003f42:	bf00      	nop
 8003f44:	40012c00 	.word	0x40012c00
 8003f48:	48000400 	.word	0x48000400

08003f4c <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 8003f4c:	b570      	push	{r4, r5, r6, lr}
 8003f4e:	4604      	mov	r4, r0
 8003f50:	b098      	sub	sp, #96	@ 0x60
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8003f52:	2100      	movs	r1, #0
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8003f54:	2244      	movs	r2, #68	@ 0x44
 8003f56:	a807      	add	r0, sp, #28
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8003f58:	e9cd 1102 	strd	r1, r1, [sp, #8]
 8003f5c:	e9cd 1104 	strd	r1, r1, [sp, #16]
 8003f60:	9106      	str	r1, [sp, #24]
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8003f62:	f006 f8bf 	bl	800a0e4 <memset>
  if(huart->Instance==USART2)
 8003f66:	4b32      	ldr	r3, [pc, #200]	@ (8004030 <HAL_UART_MspInit+0xe4>)
 8003f68:	6822      	ldr	r2, [r4, #0]
 8003f6a:	429a      	cmp	r2, r3
 8003f6c:	d001      	beq.n	8003f72 <HAL_UART_MspInit+0x26>

  /* USER CODE END USART2_MspInit 1 */

  }

}
 8003f6e:	b018      	add	sp, #96	@ 0x60
 8003f70:	bd70      	pop	{r4, r5, r6, pc}
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2;
 8003f72:	2302      	movs	r3, #2
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8003f74:	a807      	add	r0, sp, #28
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2;
 8003f76:	9307      	str	r3, [sp, #28]
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8003f78:	f001 feac 	bl	8005cd4 <HAL_RCCEx_PeriphCLKConfig>
 8003f7c:	2800      	cmp	r0, #0
 8003f7e:	d14d      	bne.n	800401c <HAL_UART_MspInit+0xd0>
    __HAL_RCC_USART2_CLK_ENABLE();
 8003f80:	4b2c      	ldr	r3, [pc, #176]	@ (8004034 <HAL_UART_MspInit+0xe8>)
    hdma_usart2_rx.Instance = DMA1_Channel1;
 8003f82:	4e2d      	ldr	r6, [pc, #180]	@ (8004038 <HAL_UART_MspInit+0xec>)
    __HAL_RCC_USART2_CLK_ENABLE();
 8003f84:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 8003f86:	f442 3200 	orr.w	r2, r2, #131072	@ 0x20000
 8003f8a:	659a      	str	r2, [r3, #88]	@ 0x58
 8003f8c:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 8003f8e:	f402 3200 	and.w	r2, r2, #131072	@ 0x20000
 8003f92:	9200      	str	r2, [sp, #0]
 8003f94:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8003f96:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8003f98:	f042 0201 	orr.w	r2, r2, #1
 8003f9c:	64da      	str	r2, [r3, #76]	@ 0x4c
 8003f9e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8003fa0:	f003 0301 	and.w	r3, r3, #1
 8003fa4:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Pin = UART_TX_Pin|UART_RX_Pin;
 8003fa6:	220c      	movs	r2, #12
 8003fa8:	2302      	movs	r3, #2
 8003faa:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8003fae:	2200      	movs	r2, #0
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8003fb0:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = UART_TX_Pin|UART_RX_Pin;
 8003fb2:	2300      	movs	r3, #0
 8003fb4:	e9cd 2304 	strd	r2, r3, [sp, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8003fb8:	a902      	add	r1, sp, #8
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 8003fba:	2307      	movs	r3, #7
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8003fbc:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 8003fc0:	9306      	str	r3, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8003fc2:	f001 f92f 	bl	8005224 <HAL_GPIO_Init>
    hdma_usart2_rx.Init.Request = DMA_REQUEST_USART2_RX;
 8003fc6:	491d      	ldr	r1, [pc, #116]	@ (800403c <HAL_UART_MspInit+0xf0>)
 8003fc8:	221a      	movs	r2, #26
 8003fca:	2300      	movs	r3, #0
 8003fcc:	e9c6 1200 	strd	r1, r2, [r6]
    if (HAL_DMA_Init(&hdma_usart2_rx) != HAL_OK)
 8003fd0:	4630      	mov	r0, r6
    hdma_usart2_rx.Init.Request = DMA_REQUEST_USART2_RX;
 8003fd2:	2280      	movs	r2, #128	@ 0x80
 8003fd4:	e9c6 3302 	strd	r3, r3, [r6, #8]
 8003fd8:	e9c6 2304 	strd	r2, r3, [r6, #16]
 8003fdc:	e9c6 3306 	strd	r3, r3, [r6, #24]
 8003fe0:	6233      	str	r3, [r6, #32]
    if (HAL_DMA_Init(&hdma_usart2_rx) != HAL_OK)
 8003fe2:	f001 f88d 	bl	8005100 <HAL_DMA_Init>
 8003fe6:	b9f8      	cbnz	r0, 8004028 <HAL_UART_MspInit+0xdc>
    hdma_usart2_tx.Instance = DMA1_Channel2;
 8003fe8:	4d15      	ldr	r5, [pc, #84]	@ (8004040 <HAL_UART_MspInit+0xf4>)
 8003fea:	4916      	ldr	r1, [pc, #88]	@ (8004044 <HAL_UART_MspInit+0xf8>)
    __HAL_LINKDMA(huart,hdmarx,hdma_usart2_rx);
 8003fec:	f8c4 6080 	str.w	r6, [r4, #128]	@ 0x80
    hdma_usart2_tx.Init.Request = DMA_REQUEST_USART2_TX;
 8003ff0:	221b      	movs	r2, #27
 8003ff2:	2300      	movs	r3, #0
 8003ff4:	e9c5 1200 	strd	r1, r2, [r5]
    if (HAL_DMA_Init(&hdma_usart2_tx) != HAL_OK)
 8003ff8:	4628      	mov	r0, r5
    hdma_usart2_tx.Init.Request = DMA_REQUEST_USART2_TX;
 8003ffa:	2110      	movs	r1, #16
 8003ffc:	2280      	movs	r2, #128	@ 0x80
 8003ffe:	e9c5 1302 	strd	r1, r3, [r5, #8]
 8004002:	e9c5 3305 	strd	r3, r3, [r5, #20]
 8004006:	e9c5 3307 	strd	r3, r3, [r5, #28]
    __HAL_LINKDMA(huart,hdmarx,hdma_usart2_rx);
 800400a:	62b4      	str	r4, [r6, #40]	@ 0x28
    hdma_usart2_tx.Init.Request = DMA_REQUEST_USART2_TX;
 800400c:	612a      	str	r2, [r5, #16]
    if (HAL_DMA_Init(&hdma_usart2_tx) != HAL_OK)
 800400e:	f001 f877 	bl	8005100 <HAL_DMA_Init>
 8004012:	b930      	cbnz	r0, 8004022 <HAL_UART_MspInit+0xd6>
    __HAL_LINKDMA(huart,hdmatx,hdma_usart2_tx);
 8004014:	67e5      	str	r5, [r4, #124]	@ 0x7c
 8004016:	62ac      	str	r4, [r5, #40]	@ 0x28
}
 8004018:	b018      	add	sp, #96	@ 0x60
 800401a:	bd70      	pop	{r4, r5, r6, pc}
      Error_Handler();
 800401c:	f7fc fff0 	bl	8001000 <Error_Handler>
 8004020:	e7ae      	b.n	8003f80 <HAL_UART_MspInit+0x34>
      Error_Handler();
 8004022:	f7fc ffed 	bl	8001000 <Error_Handler>
 8004026:	e7f5      	b.n	8004014 <HAL_UART_MspInit+0xc8>
      Error_Handler();
 8004028:	f7fc ffea 	bl	8001000 <Error_Handler>
 800402c:	e7dc      	b.n	8003fe8 <HAL_UART_MspInit+0x9c>
 800402e:	bf00      	nop
 8004030:	40004400 	.word	0x40004400
 8004034:	40021000 	.word	0x40021000
 8004038:	200005ec 	.word	0x200005ec
 800403c:	40020008 	.word	0x40020008
 8004040:	2000058c 	.word	0x2000058c
 8004044:	4002001c 	.word	0x4002001c

08004048 <HAL_InitTick>:
  uint32_t              uwPrescalerValue = 0;
  uint32_t              pFLatency;
  HAL_StatusTypeDef     status;

  /* Enable TIM6 clock */
  __HAL_RCC_TIM6_CLK_ENABLE();
 8004048:	4b1f      	ldr	r3, [pc, #124]	@ (80040c8 <HAL_InitTick+0x80>)
{
 800404a:	b570      	push	{r4, r5, r6, lr}
  __HAL_RCC_TIM6_CLK_ENABLE();
 800404c:	6d9a      	ldr	r2, [r3, #88]	@ 0x58

  /* Compute the prescaler value to have TIM6 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);

  /* Initialize TIM6 */
  htim6.Instance = TIM6;
 800404e:	4c1f      	ldr	r4, [pc, #124]	@ (80040cc <HAL_InitTick+0x84>)
  __HAL_RCC_TIM6_CLK_ENABLE();
 8004050:	f042 0210 	orr.w	r2, r2, #16
 8004054:	659a      	str	r2, [r3, #88]	@ 0x58
 8004056:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
{
 8004058:	b088      	sub	sp, #32
  __HAL_RCC_TIM6_CLK_ENABLE();
 800405a:	f003 0310 	and.w	r3, r3, #16
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 800405e:	a901      	add	r1, sp, #4
  __HAL_RCC_TIM6_CLK_ENABLE();
 8004060:	9302      	str	r3, [sp, #8]
{
 8004062:	4606      	mov	r6, r0
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8004064:	a803      	add	r0, sp, #12
  __HAL_RCC_TIM6_CLK_ENABLE();
 8004066:	9b02      	ldr	r3, [sp, #8]
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8004068:	f001 fe0a 	bl	8005c80 <HAL_RCC_GetClockConfig>
  uwTimclock = HAL_RCC_GetPCLK1Freq();
 800406c:	f001 fde4 	bl	8005c38 <HAL_RCC_GetPCLK1Freq>
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 8004070:	4a17      	ldr	r2, [pc, #92]	@ (80040d0 <HAL_InitTick+0x88>)
  htim6.Instance = TIM6;
 8004072:	4918      	ldr	r1, [pc, #96]	@ (80040d4 <HAL_InitTick+0x8c>)
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 8004074:	fba2 2300 	umull	r2, r3, r2, r0
 8004078:	0c9b      	lsrs	r3, r3, #18
 800407a:	3b01      	subs	r3, #1
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim6.Init.Period = (1000000U / 1000U) - 1U;
  htim6.Init.Prescaler = uwPrescalerValue;
  htim6.Init.ClockDivision = 0;
 800407c:	2200      	movs	r2, #0
  htim6.Init.Prescaler = uwPrescalerValue;
 800407e:	e9c4 1300 	strd	r1, r3, [r4]
  htim6.Init.CounterMode = TIM_COUNTERMODE_UP;

  status = HAL_TIM_Base_Init(&htim6);
 8004082:	4620      	mov	r0, r4
  htim6.Init.Period = (1000000U / 1000U) - 1U;
 8004084:	f240 33e7 	movw	r3, #999	@ 0x3e7
  htim6.Init.ClockDivision = 0;
 8004088:	6122      	str	r2, [r4, #16]
  htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
 800408a:	60a2      	str	r2, [r4, #8]
  htim6.Init.Period = (1000000U / 1000U) - 1U;
 800408c:	60e3      	str	r3, [r4, #12]
  status = HAL_TIM_Base_Init(&htim6);
 800408e:	f002 f831 	bl	80060f4 <HAL_TIM_Base_Init>
  if (status == HAL_OK)
 8004092:	4605      	mov	r5, r0
 8004094:	b110      	cbz	r0, 800409c <HAL_InitTick+0x54>
    }
  }

 /* Return function status */
  return status;
}
 8004096:	4628      	mov	r0, r5
 8004098:	b008      	add	sp, #32
 800409a:	bd70      	pop	{r4, r5, r6, pc}
    status = HAL_TIM_Base_Start_IT(&htim6);
 800409c:	4620      	mov	r0, r4
 800409e:	f002 f8a7 	bl	80061f0 <HAL_TIM_Base_Start_IT>
    if (status == HAL_OK)
 80040a2:	4605      	mov	r5, r0
 80040a4:	2800      	cmp	r0, #0
 80040a6:	d1f6      	bne.n	8004096 <HAL_InitTick+0x4e>
        HAL_NVIC_EnableIRQ(TIM6_DAC_IRQn);
 80040a8:	2036      	movs	r0, #54	@ 0x36
 80040aa:	f001 f801 	bl	80050b0 <HAL_NVIC_EnableIRQ>
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 80040ae:	2e0f      	cmp	r6, #15
 80040b0:	d901      	bls.n	80040b6 <HAL_InitTick+0x6e>
        status = HAL_ERROR;
 80040b2:	2501      	movs	r5, #1
 80040b4:	e7ef      	b.n	8004096 <HAL_InitTick+0x4e>
        HAL_NVIC_SetPriority(TIM6_DAC_IRQn, TickPriority, 0U);
 80040b6:	462a      	mov	r2, r5
 80040b8:	4631      	mov	r1, r6
 80040ba:	2036      	movs	r0, #54	@ 0x36
 80040bc:	f000 ffbc 	bl	8005038 <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 80040c0:	4b05      	ldr	r3, [pc, #20]	@ (80040d8 <HAL_InitTick+0x90>)
 80040c2:	601e      	str	r6, [r3, #0]
 80040c4:	e7e7      	b.n	8004096 <HAL_InitTick+0x4e>
 80040c6:	bf00      	nop
 80040c8:	40021000 	.word	0x40021000
 80040cc:	200019f0 	.word	0x200019f0
 80040d0:	431bde83 	.word	0x431bde83
 80040d4:	40001000 	.word	0x40001000
 80040d8:	20000560 	.word	0x20000560

080040dc <TIM6_DAC_IRQHandler>:
void TIM6_DAC_IRQHandler(void)
{
  /* USER CODE BEGIN TIM6_DAC_IRQn 0 */

  /* USER CODE END TIM6_DAC_IRQn 0 */
  HAL_TIM_IRQHandler(&htim6);
 80040dc:	4801      	ldr	r0, [pc, #4]	@ (80040e4 <TIM6_DAC_IRQHandler+0x8>)
 80040de:	f002 b945 	b.w	800636c <HAL_TIM_IRQHandler>
 80040e2:	bf00      	nop
 80040e4:	200019f0 	.word	0x200019f0

080040e8 <ADC1_2_IRQHandler>:
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_JEOS);
 80040e8:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
 80040ec:	2240      	movs	r2, #64	@ 0x40
 80040ee:	601a      	str	r2, [r3, #0]

    /* Clear Flags M1 */
    LL_ADC_ClearFlag_JEOS(ADC1);

  /* Highfrequency task */
  (void)TSK_HighFrequencyTask();
 80040f0:	f7fd ba8c 	b.w	800160c <TSK_HighFrequencyTask>

080040f4 <TIM1_UP_TIM16_IRQHandler>:
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 80040f4:	4b03      	ldr	r3, [pc, #12]	@ (8004104 <TIM1_UP_TIM16_IRQHandler+0x10>)
 /* USER CODE BEGIN TIMx_UP_M1_IRQn 0 */

 /* USER CODE END  TIMx_UP_M1_IRQn 0 */

  LL_TIM_ClearFlag_UPDATE(TIM1);
  (void)R3_1_TIMx_UP_IRQHandler(&PWM_Handle_M1);
 80040f6:	4804      	ldr	r0, [pc, #16]	@ (8004108 <TIM1_UP_TIM16_IRQHandler+0x14>)
 80040f8:	f06f 0201 	mvn.w	r2, #1
 80040fc:	611a      	str	r2, [r3, #16]
 80040fe:	f004 bf4b 	b.w	8008f98 <R3_1_TIMx_UP_IRQHandler>
 8004102:	bf00      	nop
 8004104:	40012c00 	.word	0x40012c00
 8004108:	20000200 	.word	0x20000200

0800410c <TIM1_BRK_TIM15_IRQHandler>:

 /* USER CODE END  TIMx_UP_M1_IRQn 1 */
}

void TIMx_BRK_M1_IRQHandler(void)
{
 800410c:	b508      	push	{r3, lr}
  return ((READ_BIT(TIMx->SR, TIM_SR_BIF) == (TIM_SR_BIF)) ? 1UL : 0UL);
 800410e:	4b0c      	ldr	r3, [pc, #48]	@ (8004140 <TIM1_BRK_TIM15_IRQHandler+0x34>)
 8004110:	691a      	ldr	r2, [r3, #16]
 8004112:	0612      	lsls	r2, r2, #24
 8004114:	d505      	bpl.n	8004122 <TIM1_BRK_TIM15_IRQHandler+0x16>
  WRITE_REG(TIMx->SR, ~(TIM_SR_BIF));
 8004116:	f06f 0280 	mvn.w	r2, #128	@ 0x80
    /* Nothing to do */
  }
  else
  {
    LL_TIM_ClearFlag_BRK(TIM1);
    PWMC_OCP_Handler(&PWM_Handle_M1._Super);
 800411a:	480a      	ldr	r0, [pc, #40]	@ (8004144 <TIM1_BRK_TIM15_IRQHandler+0x38>)
 800411c:	611a      	str	r2, [r3, #16]
 800411e:	f7fe fa47 	bl	80025b0 <PWMC_OCP_Handler>
  return ((READ_BIT(TIMx->SR, TIM_SR_B2IF) == (TIM_SR_B2IF)) ? 1UL : 0UL);
 8004122:	4907      	ldr	r1, [pc, #28]	@ (8004140 <TIM1_BRK_TIM15_IRQHandler+0x34>)
 8004124:	690b      	ldr	r3, [r1, #16]
 8004126:	05db      	lsls	r3, r3, #23
 8004128:	d505      	bpl.n	8004136 <TIM1_BRK_TIM15_IRQHandler+0x2a>
  WRITE_REG(TIMx->SR, ~(TIM_SR_B2IF));
 800412a:	f46f 7380 	mvn.w	r3, #256	@ 0x100
    /* Nothing to do */
  }
  else
  {
    LL_TIM_ClearFlag_BRK2(TIM1);
    PWMC_OVP_Handler(&PWM_Handle_M1._Super, TIM1);
 800412e:	4805      	ldr	r0, [pc, #20]	@ (8004144 <TIM1_BRK_TIM15_IRQHandler+0x38>)
 8004130:	610b      	str	r3, [r1, #16]
 8004132:	f7fe fa5d 	bl	80025f0 <PWMC_OVP_Handler>
  MC_RunMotorControlTasks();

  /* USER CODE BEGIN TIMx_BRK_M1_IRQn 1 */

  /* USER CODE END TIMx_BRK_M1_IRQn 1 */
}
 8004136:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  MC_RunMotorControlTasks();
 800413a:	f7fd ba01 	b.w	8001540 <MC_RunMotorControlTasks>
 800413e:	bf00      	nop
 8004140:	40012c00 	.word	0x40012c00
 8004144:	20000200 	.word	0x20000200

08004148 <UASPEP_INIT>:
  * @brief  Initialization of the Hardware used for data transmission and reception.
  *
  * @param  pHandle Handler of the current instance of the UASPEP component
  */
void UASPEP_INIT(void *pHWHandle)
{
 8004148:	b430      	push	{r4, r5}
  ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_EIE);
 800414a:	6802      	ldr	r2, [r0, #0]
 800414c:	f102 0108 	add.w	r1, r2, #8
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004150:	e851 3f00 	ldrex	r3, [r1]
 8004154:	f043 0301 	orr.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004158:	e841 3400 	strex	r4, r3, [r1]
 800415c:	2c00      	cmp	r4, #0
 800415e:	d1f7      	bne.n	8004150 <UASPEP_INIT+0x8>
  * @retval None
  */
__STATIC_INLINE void LL_DMA_SetPeriphAddress(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphAddress)
{
  uint32_t dma_base_addr = (uint32_t)DMAx;
  WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CPAR, PeriphAddress);
 8004160:	68c1      	ldr	r1, [r0, #12]
 8004162:	4d19      	ldr	r5, [pc, #100]	@ (80041c8 <UASPEP_INIT+0x80>)
 8004164:	6843      	ldr	r3, [r0, #4]
 8004166:	5c6c      	ldrb	r4, [r5, r1]
 8004168:	4423      	add	r3, r4
    LL_USART_EnableIT_ERROR(pHandle->USARTx);

    /* Write the USART_RDR register address in the DMA control register to configure it as
     * the source of the transfer */
    //cstat !MISRAC2012-Rule-11.4
    LL_DMA_SetPeriphAddress(pHandle->rxDMA, pHandle->rxChannel, (uint32_t)&pHandle->USARTx->RDR);
 800416a:	f102 0124 	add.w	r1, r2, #36	@ 0x24
 800416e:	6099      	str	r1, [r3, #8]
  WRITE_REG(USARTx->ICR, USART_ICR_TCCF);
 8004170:	2340      	movs	r3, #64	@ 0x40
 8004172:	6213      	str	r3, [r2, #32]
  ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAR);
 8004174:	f102 0108 	add.w	r1, r2, #8
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004178:	e851 3f00 	ldrex	r3, [r1]
 800417c:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004180:	e841 3400 	strex	r4, r3, [r1]
 8004184:	2c00      	cmp	r4, #0
 8004186:	d1f7      	bne.n	8004178 <UASPEP_INIT+0x30>
  WRITE_REG(USARTx->ICR, USART_ICR_TCCF);
 8004188:	2340      	movs	r3, #64	@ 0x40
 800418a:	6213      	str	r3, [r2, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800418c:	e852 3f00 	ldrex	r3, [r2]
  ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_TCIE);
 8004190:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004194:	e842 3100 	strex	r1, r3, [r2]
 8004198:	2900      	cmp	r1, #0
 800419a:	d1f7      	bne.n	800418c <UASPEP_INIT+0x44>
  ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAT);
 800419c:	f102 0108 	add.w	r1, r2, #8
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80041a0:	e851 3f00 	ldrex	r3, [r1]
 80041a4:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80041a8:	e841 3400 	strex	r4, r3, [r1]
 80041ac:	2c00      	cmp	r4, #0
 80041ae:	d1f7      	bne.n	80041a0 <UASPEP_INIT+0x58>
 80041b0:	6901      	ldr	r1, [r0, #16]
 80041b2:	6883      	ldr	r3, [r0, #8]
 80041b4:	5c69      	ldrb	r1, [r5, r1]
 80041b6:	440b      	add	r3, r1
    LL_DMA_SetPeriphAddress(pHandle->txDMA, pHandle->txChannel, (uint32_t)&pHandle->USARTx->TDR);
 80041b8:	f102 0028 	add.w	r0, r2, #40	@ 0x28
  WRITE_REG(USARTx->ICR, USART_ICR_TCCF);
 80041bc:	2140      	movs	r1, #64	@ 0x40
 80041be:	6098      	str	r0, [r3, #8]
}
 80041c0:	bc30      	pop	{r4, r5}
 80041c2:	6211      	str	r1, [r2, #32]
 80041c4:	4770      	bx	lr
 80041c6:	bf00      	nop
 80041c8:	0800a3e0 	.word	0x0800a3e0

080041cc <UASPEP_CFG_TRANSMISSION>:
  return ((READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CCR,
 80041cc:	6903      	ldr	r3, [r0, #16]
 80041ce:	6880      	ldr	r0, [r0, #8]
  * @param  pHWHandle Hardware components chosen for communication
  * @param  data Data to be transmitted to controller
  * @param  length Length of the data to be transmitted
  */
void UASPEP_CFG_TRANSMISSION(void *pHWHandle, void *data, uint16_t length)
{
 80041d0:	b410      	push	{r4}
 80041d2:	4c0b      	ldr	r4, [pc, #44]	@ (8004200 <UASPEP_CFG_TRANSMISSION+0x34>)
 80041d4:	5ce3      	ldrb	r3, [r4, r3]
 80041d6:	58c4      	ldr	r4, [r0, r3]
                    DMA_CCR_EN) == (DMA_CCR_EN)) ? 1UL : 0UL);
 80041d8:	07e4      	lsls	r4, r4, #31
  return ((READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CCR,
 80041da:	eb00 0c03 	add.w	ip, r0, r3
                    DMA_CCR_EN) == (DMA_CCR_EN)) ? 1UL : 0UL);
 80041de:	d40c      	bmi.n	80041fa <UASPEP_CFG_TRANSMISSION+0x2e>
  WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CMAR, MemoryAddress);
 80041e0:	f8cc 100c 	str.w	r1, [ip, #12]
  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CNDTR,
 80041e4:	f8dc 1004 	ldr.w	r1, [ip, #4]
 80041e8:	0c09      	lsrs	r1, r1, #16
 80041ea:	0409      	lsls	r1, r1, #16
 80041ec:	430a      	orrs	r2, r1
 80041ee:	f8cc 2004 	str.w	r2, [ip, #4]
  SET_BIT(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CCR, DMA_CCR_EN);
 80041f2:	58c2      	ldr	r2, [r0, r3]
 80041f4:	f042 0201 	orr.w	r2, r2, #1
 80041f8:	50c2      	str	r2, [r0, r3]
  }
  else
  {
    /* Nothing to do */
  }
}
 80041fa:	f85d 4b04 	ldr.w	r4, [sp], #4
 80041fe:	4770      	bx	lr
 8004200:	0800a3e0 	.word	0x0800a3e0

08004204 <UASPEP_CFG_RECEPTION>:
  * @param  pHWHandle Hardware components chosen for communication
  * @param  buffer Buffer which will receive the communicated data
  * @param  length Length of the received data
  */
void UASPEP_CFG_RECEPTION(void *pHWHandle, void* buffer, uint16_t length)
{
 8004204:	b430      	push	{r4, r5}
  CLEAR_BIT(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CCR, DMA_CCR_EN);
 8004206:	68c3      	ldr	r3, [r0, #12]
 8004208:	4d0b      	ldr	r5, [pc, #44]	@ (8004238 <UASPEP_CFG_RECEPTION+0x34>)
 800420a:	6844      	ldr	r4, [r0, #4]
 800420c:	5ce8      	ldrb	r0, [r5, r3]
 800420e:	5823      	ldr	r3, [r4, r0]
 8004210:	eb04 0c00 	add.w	ip, r4, r0
 8004214:	f023 0301 	bic.w	r3, r3, #1
 8004218:	5023      	str	r3, [r4, r0]
  WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CMAR, MemoryAddress);
 800421a:	f8cc 100c 	str.w	r1, [ip, #12]
  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CNDTR,
 800421e:	f8dc 3004 	ldr.w	r3, [ip, #4]
 8004222:	0c1b      	lsrs	r3, r3, #16
 8004224:	041b      	lsls	r3, r3, #16
 8004226:	4313      	orrs	r3, r2
 8004228:	f8cc 3004 	str.w	r3, [ip, #4]
  SET_BIT(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CCR, DMA_CCR_EN);
 800422c:	5823      	ldr	r3, [r4, r0]
 800422e:	f043 0301 	orr.w	r3, r3, #1
 8004232:	5023      	str	r3, [r4, r0]
  //cstat !MISRAC2012-Rule-11.4 !MISRAC2012-Rule-11.6
  LL_DMA_SetMemoryAddress(pHandle->rxDMA, pHandle->rxChannel, (uint32_t)buffer);
  LL_DMA_SetDataLength(pHandle->rxDMA, pHandle->rxChannel, length);

  LL_DMA_EnableChannel(pHandle->rxDMA, pHandle->rxChannel);
}
 8004234:	bc30      	pop	{r4, r5}
 8004236:	4770      	bx	lr
 8004238:	0800a3e0 	.word	0x0800a3e0

0800423c <UASPEP_IDLE_ENABLE>:
  * @param  pHandle Handler of the current instance of the UASPEP component
  */
void UASPEP_IDLE_ENABLE(void *pHWHandle)
{
  UASPEP_Handle_t *pHandle = (UASPEP_Handle_t *)pHWHandle; //cstat !MISRAC2012-Rule-11.5
  LL_USART_ClearFlag_IDLE(pHandle->USARTx);
 800423c:	6802      	ldr	r2, [r0, #0]
  WRITE_REG(USARTx->ICR, USART_ICR_IDLECF);
 800423e:	2310      	movs	r3, #16
 8004240:	6213      	str	r3, [r2, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004242:	e852 3f00 	ldrex	r3, [r2]
  ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 8004246:	f043 0310 	orr.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800424a:	e842 3100 	strex	r1, r3, [r2]
 800424e:	2900      	cmp	r1, #0
 8004250:	d1f7      	bne.n	8004242 <UASPEP_IDLE_ENABLE+0x6>
  LL_USART_EnableIT_IDLE(pHandle->USARTx);
}
 8004252:	4770      	bx	lr

08004254 <SystemInit>:

void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 8004254:	4a03      	ldr	r2, [pc, #12]	@ (8004264 <SystemInit+0x10>)
 8004256:	f8d2 3088 	ldr.w	r3, [r2, #136]	@ 0x88
 800425a:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 800425e:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  /* Configure the Vector Table location add offset address ------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 8004262:	4770      	bx	lr
 8004264:	e000ed00 	.word	0xe000ed00

08004268 <HAL_Init>:
#if (DATA_CACHE_ENABLE == 0U)
  __HAL_FLASH_DATA_CACHE_DISABLE();
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8004268:	4a0a      	ldr	r2, [pc, #40]	@ (8004294 <HAL_Init+0x2c>)
 800426a:	6813      	ldr	r3, [r2, #0]
 800426c:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
{
 8004270:	b510      	push	{r4, lr}
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8004272:	2003      	movs	r0, #3
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8004274:	6013      	str	r3, [r2, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8004276:	f000 fecd 	bl	8005014 <HAL_NVIC_SetPriorityGrouping>

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 800427a:	2000      	movs	r0, #0
 800427c:	f7ff fee4 	bl	8004048 <HAL_InitTick>
 8004280:	b110      	cbz	r0, 8004288 <HAL_Init+0x20>
  {
    status = HAL_ERROR;
 8004282:	2401      	movs	r4, #1
  }

  /* Return function status */
  return status;

}
 8004284:	4620      	mov	r0, r4
 8004286:	bd10      	pop	{r4, pc}
 8004288:	4604      	mov	r4, r0
    HAL_MspInit();
 800428a:	f7ff fd3d 	bl	8003d08 <HAL_MspInit>
}
 800428e:	4620      	mov	r0, r4
 8004290:	bd10      	pop	{r4, pc}
 8004292:	bf00      	nop
 8004294:	40022000 	.word	0x40022000

08004298 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 8004298:	4a03      	ldr	r2, [pc, #12]	@ (80042a8 <HAL_IncTick+0x10>)
 800429a:	4904      	ldr	r1, [pc, #16]	@ (80042ac <HAL_IncTick+0x14>)
 800429c:	6813      	ldr	r3, [r2, #0]
 800429e:	6809      	ldr	r1, [r1, #0]
 80042a0:	440b      	add	r3, r1
 80042a2:	6013      	str	r3, [r2, #0]
}
 80042a4:	4770      	bx	lr
 80042a6:	bf00      	nop
 80042a8:	20001a3c 	.word	0x20001a3c
 80042ac:	2000055c 	.word	0x2000055c

080042b0 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 80042b0:	4b01      	ldr	r3, [pc, #4]	@ (80042b8 <HAL_GetTick+0x8>)
 80042b2:	6818      	ldr	r0, [r3, #0]
}
 80042b4:	4770      	bx	lr
 80042b6:	bf00      	nop
 80042b8:	20001a3c 	.word	0x20001a3c

080042bc <HAL_ADC_Init>:
  *         without  disabling the other ADCs.
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef *hadc)
{
 80042bc:	b530      	push	{r4, r5, lr}
 80042be:	b083      	sub	sp, #12
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  uint32_t tmp_cfgr;
  uint32_t tmp_adc_is_conversion_on_going_regular;
  uint32_t tmp_adc_is_conversion_on_going_injected;
  __IO uint32_t wait_loop_index = 0UL;
 80042c0:	2300      	movs	r3, #0
 80042c2:	9301      	str	r3, [sp, #4]

  /* Check ADC handle */
  if (hadc == NULL)
 80042c4:	2800      	cmp	r0, #0
 80042c6:	f000 80ac 	beq.w	8004422 <HAL_ADC_Init+0x166>
  /* DISCEN and CONT bits cannot be set at the same time */
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));

  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if (hadc->State == HAL_ADC_STATE_RESET)
 80042ca:	6dc5      	ldr	r5, [r0, #92]	@ 0x5c
 80042cc:	4604      	mov	r4, r0
 80042ce:	2d00      	cmp	r5, #0
 80042d0:	f000 80ac 	beq.w	800442c <HAL_ADC_Init+0x170>
    /* Initialize Lock */
    hadc->Lock = HAL_UNLOCKED;
  }

  /* - Exit from deep-power-down mode and ADC voltage regulator enable        */
  if (LL_ADC_IsDeepPowerDownEnabled(hadc->Instance) != 0UL)
 80042d4:	6822      	ldr	r2, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_DEEPPWD) == (ADC_CR_DEEPPWD)) ? 1UL : 0UL);
 80042d6:	6893      	ldr	r3, [r2, #8]
 80042d8:	009d      	lsls	r5, r3, #2
 80042da:	d505      	bpl.n	80042e8 <HAL_ADC_Init+0x2c>
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
 80042dc:	6893      	ldr	r3, [r2, #8]
 80042de:	f023 4320 	bic.w	r3, r3, #2684354560	@ 0xa0000000
 80042e2:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
 80042e6:	6093      	str	r3, [r2, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 80042e8:	6893      	ldr	r3, [r2, #8]
 80042ea:	00d8      	lsls	r0, r3, #3
 80042ec:	d419      	bmi.n	8004322 <HAL_ADC_Init+0x66>
    LL_ADC_EnableInternalRegulator(hadc->Instance);

    /* Note: Variable divided by 2 to compensate partially              */
    /*       CPU processing cycles, scaling in us split to not          */
    /*       exceed 32 bits register capacity and handle low frequency. */
    wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 80042ee:	4b6b      	ldr	r3, [pc, #428]	@ (800449c <HAL_ADC_Init+0x1e0>)
 80042f0:	486b      	ldr	r0, [pc, #428]	@ (80044a0 <HAL_ADC_Init+0x1e4>)
 80042f2:	681b      	ldr	r3, [r3, #0]
  MODIFY_REG(ADCx->CR,
 80042f4:	6891      	ldr	r1, [r2, #8]
 80042f6:	099b      	lsrs	r3, r3, #6
 80042f8:	fba0 0303 	umull	r0, r3, r0, r3
 80042fc:	f021 4110 	bic.w	r1, r1, #2415919104	@ 0x90000000
 8004300:	099b      	lsrs	r3, r3, #6
 8004302:	f021 013f 	bic.w	r1, r1, #63	@ 0x3f
 8004306:	3301      	adds	r3, #1
 8004308:	005b      	lsls	r3, r3, #1
 800430a:	f041 5180 	orr.w	r1, r1, #268435456	@ 0x10000000
 800430e:	6091      	str	r1, [r2, #8]
 8004310:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 8004312:	9b01      	ldr	r3, [sp, #4]
 8004314:	b12b      	cbz	r3, 8004322 <HAL_ADC_Init+0x66>
    {
      wait_loop_index--;
 8004316:	9b01      	ldr	r3, [sp, #4]
 8004318:	3b01      	subs	r3, #1
 800431a:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 800431c:	9b01      	ldr	r3, [sp, #4]
 800431e:	2b00      	cmp	r3, #0
 8004320:	d1f9      	bne.n	8004316 <HAL_ADC_Init+0x5a>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 8004322:	6893      	ldr	r3, [r2, #8]
 8004324:	00d9      	lsls	r1, r3, #3
 8004326:	d47f      	bmi.n	8004428 <HAL_ADC_Init+0x16c>
  /* or not ADC is coming from state reset (if any potential problem of       */
  /* clocking, voltage regulator would not be enabled).                       */
  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8004328:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 800432a:	f043 0310 	orr.w	r3, r3, #16
 800432e:	65e3      	str	r3, [r4, #92]	@ 0x5c

    /* Set ADC error code to ADC peripheral internal error */
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8004330:	6e23      	ldr	r3, [r4, #96]	@ 0x60

    tmp_hal_status = HAL_ERROR;
 8004332:	2001      	movs	r0, #1
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8004334:	4303      	orrs	r3, r0
 8004336:	6623      	str	r3, [r4, #96]	@ 0x60
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8004338:	6893      	ldr	r3, [r2, #8]
 800433a:	f013 0f04 	tst.w	r3, #4
  /* correctly completed and if there is no conversion on going on regular    */
  /* group (ADC may already be enabled at this point if HAL_ADC_Init() is     */
  /* called to update a parameter on the fly).                                */
  tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);

  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 800433e:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 8004340:	d16b      	bne.n	800441a <HAL_ADC_Init+0x15e>
 8004342:	06db      	lsls	r3, r3, #27
 8004344:	d469      	bmi.n	800441a <HAL_ADC_Init+0x15e>
      && (tmp_adc_is_conversion_on_going_regular == 0UL)
     )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 8004346:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 8004348:	f423 7381 	bic.w	r3, r3, #258	@ 0x102
 800434c:	f043 0302 	orr.w	r3, r3, #2
 8004350:	65e3      	str	r3, [r4, #92]	@ 0x5c
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8004352:	6893      	ldr	r3, [r2, #8]
 8004354:	07dd      	lsls	r5, r3, #31
 8004356:	d409      	bmi.n	800436c <HAL_ADC_Init+0xb0>
 8004358:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
 800435c:	689b      	ldr	r3, [r3, #8]
 800435e:	f013 0f01 	tst.w	r3, #1
 8004362:	4b50      	ldr	r3, [pc, #320]	@ (80044a4 <HAL_ADC_Init+0x1e8>)
 8004364:	689b      	ldr	r3, [r3, #8]
 8004366:	d101      	bne.n	800436c <HAL_ADC_Init+0xb0>
 8004368:	07d9      	lsls	r1, r3, #31
 800436a:	d572      	bpl.n	8004452 <HAL_ADC_Init+0x196>
    /*  - overrun                                  Init.Overrun               */
    /*  - discontinuous mode                       Init.DiscontinuousConvMode */
    /*  - discontinuous mode channel count         Init.NbrOfDiscConversion   */
    tmp_cfgr  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
                 hadc->Init.Overrun                                                     |
                 hadc->Init.DataAlign                                                   |
 800436c:	68e5      	ldr	r5, [r4, #12]
 800436e:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
                 hadc->Init.Resolution                                                  |
                 ADC_CFGR_REG_DISCONTINUOUS((uint32_t)hadc->Init.DiscontinuousConvMode));
 8004370:	f894 1024 	ldrb.w	r1, [r4, #36]	@ 0x24
                 hadc->Init.DataAlign                                                   |
 8004374:	432b      	orrs	r3, r5
 8004376:	68a5      	ldr	r5, [r4, #8]
 8004378:	432b      	orrs	r3, r5
    tmp_cfgr  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 800437a:	7f65      	ldrb	r5, [r4, #29]

    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 800437c:	2901      	cmp	r1, #1
                 hadc->Init.DataAlign                                                   |
 800437e:	ea43 3345 	orr.w	r3, r3, r5, lsl #13
    tmp_cfgr  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 8004382:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8004386:	d057      	beq.n	8004438 <HAL_ADC_Init+0x17c>
    /* Enable external trigger if trigger selection is different of software  */
    /* start.                                                                 */
    /* Note: This configuration keeps the hardware feature of parameter       */
    /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    /*       software start.                                                  */
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8004388:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 800438a:	b121      	cbz	r1, 8004396 <HAL_ADC_Init+0xda>
    {
      tmp_cfgr |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
                   | hadc->Init.ExternalTrigConvEdge
 800438c:	6b25      	ldr	r5, [r4, #48]	@ 0x30
      tmp_cfgr |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 800438e:	f401 7178 	and.w	r1, r1, #992	@ 0x3e0
                   | hadc->Init.ExternalTrigConvEdge
 8004392:	4329      	orrs	r1, r5
      tmp_cfgr |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 8004394:	430b      	orrs	r3, r1
                  );
    }

    /* Update Configuration Register CFGR */
    MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_1, tmp_cfgr);
 8004396:	68d5      	ldr	r5, [r2, #12]
 8004398:	4943      	ldr	r1, [pc, #268]	@ (80044a8 <HAL_ADC_Init+0x1ec>)
 800439a:	4029      	ands	r1, r5
 800439c:	4319      	orrs	r1, r3
 800439e:	60d1      	str	r1, [r2, #12]

    /* Configuration of sampling mode */
    MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_BULB | ADC_CFGR2_SMPTRIG, hadc->Init.SamplingMode);
 80043a0:	6913      	ldr	r3, [r2, #16]
 80043a2:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 80043a4:	f023 6340 	bic.w	r3, r3, #201326592	@ 0xc000000
 80043a8:	430b      	orrs	r3, r1
 80043aa:	6113      	str	r3, [r2, #16]
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 80043ac:	6893      	ldr	r3, [r2, #8]
 80043ae:	071b      	lsls	r3, r3, #28
 80043b0:	d424      	bmi.n	80043fc <HAL_ADC_Init+0x140>
    {
      tmp_cfgr = (ADC_CFGR_DFSDM(hadc)                                            |
                   ADC_CFGR_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
                   ADC_CFGR_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests));

      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmp_cfgr);
 80043b2:	68d1      	ldr	r1, [r2, #12]
                   ADC_CFGR_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests));
 80043b4:	f894 3038 	ldrb.w	r3, [r4, #56]	@ 0x38
                   ADC_CFGR_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
 80043b8:	7f25      	ldrb	r5, [r4, #28]
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmp_cfgr);
 80043ba:	f421 4180 	bic.w	r1, r1, #16384	@ 0x4000
                   ADC_CFGR_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests));
 80043be:	005b      	lsls	r3, r3, #1
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmp_cfgr);
 80043c0:	f021 0102 	bic.w	r1, r1, #2
      tmp_cfgr = (ADC_CFGR_DFSDM(hadc)                                            |
 80043c4:	ea43 3385 	orr.w	r3, r3, r5, lsl #14
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmp_cfgr);
 80043c8:	430b      	orrs	r3, r1

      if (hadc->Init.GainCompensation != 0UL)
 80043ca:	6921      	ldr	r1, [r4, #16]
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmp_cfgr);
 80043cc:	60d3      	str	r3, [r2, #12]
      {
        SET_BIT(hadc->Instance->CFGR2, ADC_CFGR2_GCOMP);
 80043ce:	6913      	ldr	r3, [r2, #16]
      if (hadc->Init.GainCompensation != 0UL)
 80043d0:	2900      	cmp	r1, #0
 80043d2:	d046      	beq.n	8004462 <HAL_ADC_Init+0x1a6>
        SET_BIT(hadc->Instance->CFGR2, ADC_CFGR2_GCOMP);
 80043d4:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 80043d8:	6113      	str	r3, [r2, #16]
        MODIFY_REG(hadc->Instance->GCOMP, ADC_GCOMP_GCOMPCOEFF, hadc->Init.GainCompensation);
 80043da:	f8d2 30c0 	ldr.w	r3, [r2, #192]	@ 0xc0
 80043de:	f423 537f 	bic.w	r3, r3, #16320	@ 0x3fc0
 80043e2:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
 80043e6:	430b      	orrs	r3, r1
 80043e8:	f8c2 30c0 	str.w	r3, [r2, #192]	@ 0xc0
      {
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_GCOMP);
        MODIFY_REG(hadc->Instance->GCOMP, ADC_GCOMP_GCOMPCOEFF, 0UL);
      }

      if (hadc->Init.OversamplingMode == ENABLE)
 80043ec:	f894 3040 	ldrb.w	r3, [r4, #64]	@ 0x40
 80043f0:	2b01      	cmp	r3, #1
 80043f2:	d042      	beq.n	800447a <HAL_ADC_Init+0x1be>
                  );
      }
      else
      {
        /* Disable ADC oversampling scope on ADC group regular */
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE);
 80043f4:	6913      	ldr	r3, [r2, #16]
 80043f6:	f023 0301 	bic.w	r3, r3, #1
 80043fa:	6113      	str	r3, [r2, #16]
    /*   Note: Scan mode is not present by hardware on this device, but       */
    /*   emulated by software for alignment over all STM32 devices.           */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion".                                         */

    if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
 80043fc:	6963      	ldr	r3, [r4, #20]
 80043fe:	2b01      	cmp	r3, #1
 8004400:	d01f      	beq.n	8004442 <HAL_ADC_Init+0x186>
      /* Set number of ranks in regular group sequencer */
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
    }
    else
    {
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
 8004402:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 8004404:	f023 030f 	bic.w	r3, r3, #15
 8004408:	6313      	str	r3, [r2, #48]	@ 0x30
    }

    /* Initialize the ADC state */
    /* Clear HAL_ADC_STATE_BUSY_INTERNAL bit, set HAL_ADC_STATE_READY bit */
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
 800440a:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 800440c:	f023 0303 	bic.w	r3, r3, #3
 8004410:	f043 0301 	orr.w	r3, r3, #1
 8004414:	65e3      	str	r3, [r4, #92]	@ 0x5c
    tmp_hal_status = HAL_ERROR;
  }

  /* Return function status */
  return tmp_hal_status;
}
 8004416:	b003      	add	sp, #12
 8004418:	bd30      	pop	{r4, r5, pc}
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800441a:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 800441c:	f043 0310 	orr.w	r3, r3, #16
 8004420:	65e3      	str	r3, [r4, #92]	@ 0x5c
    return HAL_ERROR;
 8004422:	2001      	movs	r0, #1
}
 8004424:	b003      	add	sp, #12
 8004426:	bd30      	pop	{r4, r5, pc}
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8004428:	2000      	movs	r0, #0
 800442a:	e785      	b.n	8004338 <HAL_ADC_Init+0x7c>
    HAL_ADC_MspInit(hadc);
 800442c:	f7ff fc8e 	bl	8003d4c <HAL_ADC_MspInit>
    ADC_CLEAR_ERRORCODE(hadc);
 8004430:	6625      	str	r5, [r4, #96]	@ 0x60
    hadc->Lock = HAL_UNLOCKED;
 8004432:	f884 5058 	strb.w	r5, [r4, #88]	@ 0x58
 8004436:	e74d      	b.n	80042d4 <HAL_ADC_Init+0x18>
      tmp_cfgr |= ADC_CFGR_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion);
 8004438:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 800443a:	3901      	subs	r1, #1
 800443c:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
 8004440:	e7a2      	b.n	8004388 <HAL_ADC_Init+0xcc>
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
 8004442:	6b11      	ldr	r1, [r2, #48]	@ 0x30
 8004444:	6a23      	ldr	r3, [r4, #32]
 8004446:	f021 010f 	bic.w	r1, r1, #15
 800444a:	3b01      	subs	r3, #1
 800444c:	430b      	orrs	r3, r1
 800444e:	6313      	str	r3, [r2, #48]	@ 0x30
 8004450:	e7db      	b.n	800440a <HAL_ADC_Init+0x14e>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_CKMODE | ADC_CCR_PRESC, CommonClock);
 8004452:	4916      	ldr	r1, [pc, #88]	@ (80044ac <HAL_ADC_Init+0x1f0>)
 8004454:	6865      	ldr	r5, [r4, #4]
 8004456:	688b      	ldr	r3, [r1, #8]
 8004458:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
 800445c:	432b      	orrs	r3, r5
 800445e:	608b      	str	r3, [r1, #8]
}
 8004460:	e784      	b.n	800436c <HAL_ADC_Init+0xb0>
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_GCOMP);
 8004462:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8004466:	6113      	str	r3, [r2, #16]
        MODIFY_REG(hadc->Instance->GCOMP, ADC_GCOMP_GCOMPCOEFF, 0UL);
 8004468:	f8d2 30c0 	ldr.w	r3, [r2, #192]	@ 0xc0
 800446c:	f423 537f 	bic.w	r3, r3, #16320	@ 0x3fc0
 8004470:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
 8004474:	f8c2 30c0 	str.w	r3, [r2, #192]	@ 0xc0
 8004478:	e7b8      	b.n	80043ec <HAL_ADC_Init+0x130>
        MODIFY_REG(hadc->Instance->CFGR2,
 800447a:	6911      	ldr	r1, [r2, #16]
 800447c:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 800447e:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
 8004480:	f421 61ff 	bic.w	r1, r1, #2040	@ 0x7f8
 8004484:	f021 0104 	bic.w	r1, r1, #4
 8004488:	432b      	orrs	r3, r5
 800448a:	430b      	orrs	r3, r1
 800448c:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
 800448e:	430b      	orrs	r3, r1
 8004490:	6d21      	ldr	r1, [r4, #80]	@ 0x50
 8004492:	430b      	orrs	r3, r1
 8004494:	f043 0301 	orr.w	r3, r3, #1
 8004498:	6113      	str	r3, [r2, #16]
 800449a:	e7af      	b.n	80043fc <HAL_ADC_Init+0x140>
 800449c:	20000558 	.word	0x20000558
 80044a0:	053e2d63 	.word	0x053e2d63
 80044a4:	50000100 	.word	0x50000100
 80044a8:	fff04007 	.word	0xfff04007
 80044ac:	50000300 	.word	0x50000300

080044b0 <HAL_ADC_ConfigChannel>:
  * @param hadc ADC handle
  * @param pConfig Structure of ADC channel assigned to ADC group regular.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef *hadc, const ADC_ChannelConfTypeDef *pConfig)
{
 80044b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  {
    assert_param(IS_ADC_DIFF_CHANNEL(hadc, pConfig->Channel));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 80044b4:	f890 2058 	ldrb.w	r2, [r0, #88]	@ 0x58
{
 80044b8:	b082      	sub	sp, #8
 80044ba:	4603      	mov	r3, r0
  __HAL_LOCK(hadc);
 80044bc:	2a01      	cmp	r2, #1
  __IO uint32_t wait_loop_index = 0UL;
 80044be:	f04f 0000 	mov.w	r0, #0
 80044c2:	9001      	str	r0, [sp, #4]
  __HAL_LOCK(hadc);
 80044c4:	f000 812c 	beq.w	8004720 <HAL_ADC_ConfigChannel+0x270>
  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel rank                                                          */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 80044c8:	681a      	ldr	r2, [r3, #0]
  __HAL_LOCK(hadc);
 80044ca:	2001      	movs	r0, #1
 80044cc:	f883 0058 	strb.w	r0, [r3, #88]	@ 0x58
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 80044d0:	6894      	ldr	r4, [r2, #8]
 80044d2:	0764      	lsls	r4, r4, #29
 80044d4:	d455      	bmi.n	8004582 <HAL_ADC_ConfigChannel+0xd2>
  {
    /* Set ADC group regular sequence: channel on the selected scan sequence rank */
    LL_ADC_REG_SetSequencerRanks(hadc->Instance, pConfig->Rank, pConfig->Channel);
 80044d6:	6848      	ldr	r0, [r1, #4]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1,
 80044d8:	ea4f 1e90 	mov.w	lr, r0, lsr #6
  MODIFY_REG(*preg,
 80044dc:	f000 0c1f 	and.w	ip, r0, #31
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1,
 80044e0:	f00e 0e0c 	and.w	lr, lr, #12
  MODIFY_REG(*preg,
 80044e4:	6808      	ldr	r0, [r1, #0]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1,
 80044e6:	f102 0430 	add.w	r4, r2, #48	@ 0x30
  MODIFY_REG(*preg,
 80044ea:	f3c0 6084 	ubfx	r0, r0, #26, #5
 80044ee:	f854 500e 	ldr.w	r5, [r4, lr]
 80044f2:	261f      	movs	r6, #31
 80044f4:	fa00 f00c 	lsl.w	r0, r0, ip
 80044f8:	fa06 fc0c 	lsl.w	ip, r6, ip
 80044fc:	ea25 0c0c 	bic.w	ip, r5, ip
 8004500:	ea40 000c 	orr.w	r0, r0, ip
 8004504:	f844 000e 	str.w	r0, [r4, lr]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8004508:	6890      	ldr	r0, [r2, #8]
 800450a:	0747      	lsls	r7, r0, #29
 800450c:	d543      	bpl.n	8004596 <HAL_ADC_ConfigChannel+0xe6>
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 800450e:	6890      	ldr	r0, [r2, #8]
    {
      /* Manage specific case of sampling time 3.5 cycles replacing 2.5 cyles */
      if (pConfig->SamplingTime == ADC_SAMPLETIME_3CYCLES_5)
      {
        /* Set sampling time of the selected ADC channel */
        LL_ADC_SetChannelSamplingTime(hadc->Instance, pConfig->Channel, LL_ADC_SAMPLINGTIME_2CYCLES_5);
 8004510:	6808      	ldr	r0, [r1, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8004512:	6894      	ldr	r4, [r2, #8]
 8004514:	07e5      	lsls	r5, r4, #31
 8004516:	d412      	bmi.n	800453e <HAL_ADC_ConfigChannel+0x8e>
    /* Parameters that can be updated only when ADC is disabled:                */
    /*  - Single or differential mode                                           */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
    {
      /* Set mode single-ended or differential input of the selected ADC channel */
      LL_ADC_SetChannelSingleDiff(hadc->Instance, pConfig->Channel, pConfig->SingleDiff);
 8004518:	68ce      	ldr	r6, [r1, #12]
  MODIFY_REG(ADCx->DIFSEL,
 800451a:	4cc0      	ldr	r4, [pc, #768]	@ (800481c <HAL_ADC_ConfigChannel+0x36c>)
 800451c:	f8d2 50b0 	ldr.w	r5, [r2, #176]	@ 0xb0
 8004520:	f006 0718 	and.w	r7, r6, #24
 8004524:	40fc      	lsrs	r4, r7
 8004526:	f3c0 0712 	ubfx	r7, r0, #0, #19
 800452a:	4004      	ands	r4, r0
 800452c:	ea25 0507 	bic.w	r5, r5, r7
 8004530:	432c      	orrs	r4, r5
 8004532:	f8c2 40b0 	str.w	r4, [r2, #176]	@ 0xb0

      /* Configuration of differential mode */
      if (pConfig->SingleDiff == ADC_DIFFERENTIAL_ENDED)
 8004536:	4cba      	ldr	r4, [pc, #744]	@ (8004820 <HAL_ADC_ConfigChannel+0x370>)
 8004538:	42a6      	cmp	r6, r4
 800453a:	f000 80a1 	beq.w	8004680 <HAL_ADC_ConfigChannel+0x1d0>
    /* If internal channel selected, enable dedicated internal buffers and    */
    /* paths.                                                                 */
    /* Note: these internal measurement paths can be disabled using           */
    /* HAL_ADC_DeInit().                                                      */

    if (__LL_ADC_IS_CHANNEL_INTERNAL(pConfig->Channel))
 800453e:	49b9      	ldr	r1, [pc, #740]	@ (8004824 <HAL_ADC_ConfigChannel+0x374>)
 8004540:	4208      	tst	r0, r1
 8004542:	d01c      	beq.n	800457e <HAL_ADC_ConfigChannel+0xce>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL));
 8004544:	4cb8      	ldr	r4, [pc, #736]	@ (8004828 <HAL_ADC_ConfigChannel+0x378>)
    {
      tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));

      /* If the requested internal measurement path has already been enabled, */
      /* bypass the configuration processing.                                 */
      if (((pConfig->Channel == ADC_CHANNEL_TEMPSENSOR_ADC1) || (pConfig->Channel == ADC_CHANNEL_TEMPSENSOR_ADC5))
 8004546:	4db9      	ldr	r5, [pc, #740]	@ (800482c <HAL_ADC_ConfigChannel+0x37c>)
 8004548:	68a1      	ldr	r1, [r4, #8]
 800454a:	42a8      	cmp	r0, r5
 800454c:	f001 76e0 	and.w	r6, r1, #29360128	@ 0x1c00000
 8004550:	d073      	beq.n	800463a <HAL_ADC_ConfigChannel+0x18a>
 8004552:	4db7      	ldr	r5, [pc, #732]	@ (8004830 <HAL_ADC_ConfigChannel+0x380>)
 8004554:	42a8      	cmp	r0, r5
 8004556:	d070      	beq.n	800463a <HAL_ADC_ConfigChannel+0x18a>
          {
            wait_loop_index--;
          }
        }
      }
      else if ((pConfig->Channel == ADC_CHANNEL_VBAT)
 8004558:	4db6      	ldr	r5, [pc, #728]	@ (8004834 <HAL_ADC_ConfigChannel+0x384>)
 800455a:	42a8      	cmp	r0, r5
 800455c:	f000 80e4 	beq.w	8004728 <HAL_ADC_ConfigChannel+0x278>
        {
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
                                         LL_ADC_PATH_INTERNAL_VBAT | tmp_config_internal_channel);
        }
      }
      else if ((pConfig->Channel == ADC_CHANNEL_VREFINT)
 8004560:	4db5      	ldr	r5, [pc, #724]	@ (8004838 <HAL_ADC_ConfigChannel+0x388>)
 8004562:	42a8      	cmp	r0, r5
 8004564:	d10b      	bne.n	800457e <HAL_ADC_ConfigChannel+0xce>
               && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
 8004566:	0249      	lsls	r1, r1, #9
 8004568:	d409      	bmi.n	800457e <HAL_ADC_ConfigChannel+0xce>
      {
        if (ADC_VREFINT_INSTANCE(hadc))
 800456a:	49b4      	ldr	r1, [pc, #720]	@ (800483c <HAL_ADC_ConfigChannel+0x38c>)
 800456c:	428a      	cmp	r2, r1
 800456e:	d006      	beq.n	800457e <HAL_ADC_ConfigChannel+0xce>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL, PathInternal);
 8004570:	68a2      	ldr	r2, [r4, #8]
 8004572:	f022 72e0 	bic.w	r2, r2, #29360128	@ 0x1c00000
 8004576:	4332      	orrs	r2, r6
 8004578:	f442 0280 	orr.w	r2, r2, #4194304	@ 0x400000
 800457c:	60a2      	str	r2, [r4, #8]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 800457e:	2000      	movs	r0, #0
 8004580:	e003      	b.n	800458a <HAL_ADC_ConfigChannel+0xda>
  /* channel could be done on neither of the channel configuration structure  */
  /* parameters.                                                              */
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8004582:	6dda      	ldr	r2, [r3, #92]	@ 0x5c
 8004584:	f042 0220 	orr.w	r2, r2, #32
 8004588:	65da      	str	r2, [r3, #92]	@ 0x5c

    tmp_hal_status = HAL_ERROR;
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 800458a:	2200      	movs	r2, #0
 800458c:	f883 2058 	strb.w	r2, [r3, #88]	@ 0x58

  /* Return function status */
  return tmp_hal_status;
}
 8004590:	b002      	add	sp, #8
 8004592:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8004596:	6894      	ldr	r4, [r2, #8]
        LL_ADC_SetChannelSamplingTime(hadc->Instance, pConfig->Channel, LL_ADC_SAMPLINGTIME_2CYCLES_5);
 8004598:	6808      	ldr	r0, [r1, #0]
 800459a:	0726      	lsls	r6, r4, #28
 800459c:	d4b9      	bmi.n	8004512 <HAL_ADC_ConfigChannel+0x62>
      if (pConfig->SamplingTime == ADC_SAMPLETIME_3CYCLES_5)
 800459e:	688d      	ldr	r5, [r1, #8]
  MODIFY_REG(*preg,
 80045a0:	f3c0 5604 	ubfx	r6, r0, #20, #5
 80045a4:	2407      	movs	r4, #7
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1,
 80045a6:	0dc0      	lsrs	r0, r0, #23
  MODIFY_REG(*preg,
 80045a8:	40b4      	lsls	r4, r6
 80045aa:	f1b5 4f00 	cmp.w	r5, #2147483648	@ 0x80000000
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1,
 80045ae:	f000 0004 	and.w	r0, r0, #4
  MODIFY_REG(*preg,
 80045b2:	ea6f 0404 	mvn.w	r4, r4
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1,
 80045b6:	f102 0714 	add.w	r7, r2, #20
 80045ba:	f000 8100 	beq.w	80047be <HAL_ADC_ConfigChannel+0x30e>
  MODIFY_REG(*preg,
 80045be:	40b5      	lsls	r5, r6
 80045c0:	583e      	ldr	r6, [r7, r0]
 80045c2:	4034      	ands	r4, r6
 80045c4:	432c      	orrs	r4, r5
 80045c6:	503c      	str	r4, [r7, r0]
  MODIFY_REG(ADCx->SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);
 80045c8:	6950      	ldr	r0, [r2, #20]
 80045ca:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
 80045ce:	6150      	str	r0, [r2, #20]
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)pConfig->Offset);
 80045d0:	e9d1 7504 	ldrd	r7, r5, [r1, #16]
        LL_ADC_SetOffset(hadc->Instance, pConfig->OffsetNumber, pConfig->Channel, tmpOffsetShifted);
 80045d4:	6808      	ldr	r0, [r1, #0]
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)pConfig->Offset);
 80045d6:	68d6      	ldr	r6, [r2, #12]
      if (pConfig->OffsetNumber != ADC_OFFSET_NONE)
 80045d8:	2f04      	cmp	r7, #4
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80045da:	f102 0460 	add.w	r4, r2, #96	@ 0x60
        LL_ADC_SetOffset(hadc->Instance, pConfig->OffsetNumber, pConfig->Channel, tmpOffsetShifted);
 80045de:	4684      	mov	ip, r0
      if (pConfig->OffsetNumber != ADC_OFFSET_NONE)
 80045e0:	f000 80c5 	beq.w	800476e <HAL_ADC_ConfigChannel+0x2be>
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)pConfig->Offset);
 80045e4:	f3c6 06c1 	ubfx	r6, r6, #3, #2
 80045e8:	0076      	lsls	r6, r6, #1
  MODIFY_REG(*preg,
 80045ea:	f854 c027 	ldr.w	ip, [r4, r7, lsl #2]
 80045ee:	40b5      	lsls	r5, r6
 80045f0:	4e93      	ldr	r6, [pc, #588]	@ (8004840 <HAL_ADC_ConfigChannel+0x390>)
 80045f2:	f000 40f8 	and.w	r0, r0, #2080374784	@ 0x7c000000
 80045f6:	ea0c 0606 	and.w	r6, ip, r6
 80045fa:	4306      	orrs	r6, r0
 80045fc:	4335      	orrs	r5, r6
 80045fe:	f045 4500 	orr.w	r5, r5, #2147483648	@ 0x80000000
 8004602:	f844 5027 	str.w	r5, [r4, r7, lsl #2]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8004606:	690d      	ldr	r5, [r1, #16]
  MODIFY_REG(*preg,
 8004608:	698e      	ldr	r6, [r1, #24]
 800460a:	f854 0025 	ldr.w	r0, [r4, r5, lsl #2]
 800460e:	f020 7080 	bic.w	r0, r0, #16777216	@ 0x1000000
 8004612:	4330      	orrs	r0, r6
 8004614:	f844 0025 	str.w	r0, [r4, r5, lsl #2]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8004618:	690e      	ldr	r6, [r1, #16]
        LL_ADC_SetOffsetSaturation(hadc->Instance, pConfig->OffsetNumber,
 800461a:	7f0d      	ldrb	r5, [r1, #28]
  MODIFY_REG(*preg,
 800461c:	f854 0026 	ldr.w	r0, [r4, r6, lsl #2]
 8004620:	f1a5 0501 	sub.w	r5, r5, #1
 8004624:	fab5 f585 	clz	r5, r5
 8004628:	096d      	lsrs	r5, r5, #5
 800462a:	f020 7000 	bic.w	r0, r0, #33554432	@ 0x2000000
 800462e:	ea40 6045 	orr.w	r0, r0, r5, lsl #25
 8004632:	f844 0026 	str.w	r0, [r4, r6, lsl #2]
      LL_ADC_SetChannelSingleDiff(hadc->Instance, pConfig->Channel, pConfig->SingleDiff);
 8004636:	6808      	ldr	r0, [r1, #0]
}
 8004638:	e76b      	b.n	8004512 <HAL_ADC_ConfigChannel+0x62>
          && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
 800463a:	020c      	lsls	r4, r1, #8
 800463c:	d49f      	bmi.n	800457e <HAL_ADC_ConfigChannel+0xce>
        if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 800463e:	f1b2 4fa0 	cmp.w	r2, #1342177280	@ 0x50000000
 8004642:	d19c      	bne.n	800457e <HAL_ADC_ConfigChannel+0xce>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL, PathInternal);
 8004644:	4978      	ldr	r1, [pc, #480]	@ (8004828 <HAL_ADC_ConfigChannel+0x378>)
          wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 8004646:	487f      	ldr	r0, [pc, #508]	@ (8004844 <HAL_ADC_ConfigChannel+0x394>)
 8004648:	688a      	ldr	r2, [r1, #8]
 800464a:	f022 72e0 	bic.w	r2, r2, #29360128	@ 0x1c00000
 800464e:	4332      	orrs	r2, r6
 8004650:	f442 0200 	orr.w	r2, r2, #8388608	@ 0x800000
 8004654:	608a      	str	r2, [r1, #8]
 8004656:	6802      	ldr	r2, [r0, #0]
 8004658:	497b      	ldr	r1, [pc, #492]	@ (8004848 <HAL_ADC_ConfigChannel+0x398>)
 800465a:	0992      	lsrs	r2, r2, #6
 800465c:	fba1 1202 	umull	r1, r2, r1, r2
 8004660:	0992      	lsrs	r2, r2, #6
 8004662:	3201      	adds	r2, #1
 8004664:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8004668:	0092      	lsls	r2, r2, #2
 800466a:	9201      	str	r2, [sp, #4]
          while (wait_loop_index != 0UL)
 800466c:	9a01      	ldr	r2, [sp, #4]
 800466e:	2a00      	cmp	r2, #0
 8004670:	d085      	beq.n	800457e <HAL_ADC_ConfigChannel+0xce>
            wait_loop_index--;
 8004672:	9a01      	ldr	r2, [sp, #4]
 8004674:	3a01      	subs	r2, #1
 8004676:	9201      	str	r2, [sp, #4]
          while (wait_loop_index != 0UL)
 8004678:	9a01      	ldr	r2, [sp, #4]
 800467a:	2a00      	cmp	r2, #0
 800467c:	d1f9      	bne.n	8004672 <HAL_ADC_ConfigChannel+0x1c2>
 800467e:	e77e      	b.n	800457e <HAL_ADC_ConfigChannel+0xce>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL(
 8004680:	2f00      	cmp	r7, #0
 8004682:	d060      	beq.n	8004746 <HAL_ADC_ConfigChannel+0x296>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004684:	fa90 f4a0 	rbit	r4, r0
  if (value == 0U)
 8004688:	2c00      	cmp	r4, #0
 800468a:	f000 80a0 	beq.w	80047ce <HAL_ADC_ConfigChannel+0x31e>
  return __builtin_clz(value);
 800468e:	fab4 f484 	clz	r4, r4
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8004692:	3401      	adds	r4, #1
 8004694:	f004 041f 	and.w	r4, r4, #31
 8004698:	2c09      	cmp	r4, #9
 800469a:	f240 8098 	bls.w	80047ce <HAL_ADC_ConfigChannel+0x31e>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800469e:	fa90 f4a0 	rbit	r4, r0
  if (value == 0U)
 80046a2:	2c00      	cmp	r4, #0
 80046a4:	f000 8148 	beq.w	8004938 <HAL_ADC_ConfigChannel+0x488>
  return __builtin_clz(value);
 80046a8:	fab4 f484 	clz	r4, r4
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL(
 80046ac:	3401      	adds	r4, #1
 80046ae:	06a4      	lsls	r4, r4, #26
 80046b0:	f004 44f8 	and.w	r4, r4, #2080374784	@ 0x7c000000
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80046b4:	fa90 f5a0 	rbit	r5, r0
  if (value == 0U)
 80046b8:	2d00      	cmp	r5, #0
 80046ba:	f000 8142 	beq.w	8004942 <HAL_ADC_ConfigChannel+0x492>
  return __builtin_clz(value);
 80046be:	fab5 f585 	clz	r5, r5
 80046c2:	3501      	adds	r5, #1
 80046c4:	f005 051f 	and.w	r5, r5, #31
 80046c8:	2601      	movs	r6, #1
 80046ca:	fa06 f505 	lsl.w	r5, r6, r5
 80046ce:	432c      	orrs	r4, r5
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80046d0:	fa90 f0a0 	rbit	r0, r0
  if (value == 0U)
 80046d4:	2800      	cmp	r0, #0
 80046d6:	f000 8132 	beq.w	800493e <HAL_ADC_ConfigChannel+0x48e>
  return __builtin_clz(value);
 80046da:	fab0 f080 	clz	r0, r0
 80046de:	1c45      	adds	r5, r0, #1
 80046e0:	f005 051f 	and.w	r5, r5, #31
 80046e4:	2003      	movs	r0, #3
 80046e6:	f06f 061d 	mvn.w	r6, #29
 80046ea:	fb10 6005 	smlabb	r0, r0, r5, r6
 80046ee:	0500      	lsls	r0, r0, #20
 80046f0:	f040 7000 	orr.w	r0, r0, #33554432	@ 0x2000000
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 80046f4:	4320      	orrs	r0, r4
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1,
 80046f6:	0dc5      	lsrs	r5, r0, #23
  MODIFY_REG(*preg,
 80046f8:	688c      	ldr	r4, [r1, #8]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1,
 80046fa:	f005 0504 	and.w	r5, r5, #4
 80046fe:	f102 0614 	add.w	r6, r2, #20
  MODIFY_REG(*preg,
 8004702:	f3c0 5004 	ubfx	r0, r0, #20, #5
 8004706:	fa04 f700 	lsl.w	r7, r4, r0
 800470a:	f04f 0c07 	mov.w	ip, #7
 800470e:	5974      	ldr	r4, [r6, r5]
 8004710:	fa0c f000 	lsl.w	r0, ip, r0
 8004714:	ea24 0000 	bic.w	r0, r4, r0
 8004718:	4338      	orrs	r0, r7
 800471a:	5170      	str	r0, [r6, r5]
    if (__LL_ADC_IS_CHANNEL_INTERNAL(pConfig->Channel))
 800471c:	6808      	ldr	r0, [r1, #0]
}
 800471e:	e70e      	b.n	800453e <HAL_ADC_ConfigChannel+0x8e>
  __HAL_LOCK(hadc);
 8004720:	2002      	movs	r0, #2
}
 8004722:	b002      	add	sp, #8
 8004724:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
               && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 8004728:	01c8      	lsls	r0, r1, #7
 800472a:	f53f af28 	bmi.w	800457e <HAL_ADC_ConfigChannel+0xce>
        if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 800472e:	4943      	ldr	r1, [pc, #268]	@ (800483c <HAL_ADC_ConfigChannel+0x38c>)
 8004730:	428a      	cmp	r2, r1
 8004732:	f43f af24 	beq.w	800457e <HAL_ADC_ConfigChannel+0xce>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL, PathInternal);
 8004736:	68a2      	ldr	r2, [r4, #8]
 8004738:	f022 72e0 	bic.w	r2, r2, #29360128	@ 0x1c00000
 800473c:	4332      	orrs	r2, r6
 800473e:	f042 7280 	orr.w	r2, r2, #16777216	@ 0x1000000
 8004742:	60a2      	str	r2, [r4, #8]
}
 8004744:	e71b      	b.n	800457e <HAL_ADC_ConfigChannel+0xce>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL(
 8004746:	0e80      	lsrs	r0, r0, #26
 8004748:	3001      	adds	r0, #1
 800474a:	f000 051f 	and.w	r5, r0, #31
 800474e:	2401      	movs	r4, #1
 8004750:	0680      	lsls	r0, r0, #26
 8004752:	f000 40f8 	and.w	r0, r0, #2080374784	@ 0x7c000000
 8004756:	40ac      	lsls	r4, r5
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8004758:	2d09      	cmp	r5, #9
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL(
 800475a:	ea44 0400 	orr.w	r4, r4, r0
 800475e:	eb05 0045 	add.w	r0, r5, r5, lsl #1
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8004762:	d959      	bls.n	8004818 <HAL_ADC_ConfigChannel+0x368>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL(
 8004764:	381e      	subs	r0, #30
 8004766:	0500      	lsls	r0, r0, #20
 8004768:	f040 7000 	orr.w	r0, r0, #33554432	@ 0x2000000
 800476c:	e7c2      	b.n	80046f4 <HAL_ADC_ConfigChannel+0x244>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 800476e:	6e15      	ldr	r5, [r2, #96]	@ 0x60
 8004770:	6e15      	ldr	r5, [r2, #96]	@ 0x60
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfig->Channel))
 8004772:	f3c0 0612 	ubfx	r6, r0, #0, #19
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 8004776:	f3c5 6584 	ubfx	r5, r5, #26, #5
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfig->Channel))
 800477a:	2e00      	cmp	r6, #0
 800477c:	d166      	bne.n	800484c <HAL_ADC_ConfigChannel+0x39c>
 800477e:	f3c0 6084 	ubfx	r0, r0, #26, #5
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 8004782:	4285      	cmp	r5, r0
 8004784:	f000 80a8 	beq.w	80048d8 <HAL_ADC_ConfigChannel+0x428>
 8004788:	6e55      	ldr	r5, [r2, #100]	@ 0x64
 800478a:	6e55      	ldr	r5, [r2, #100]	@ 0x64
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 800478c:	f3c5 6584 	ubfx	r5, r5, #26, #5
 8004790:	4285      	cmp	r5, r0
 8004792:	f000 808c 	beq.w	80048ae <HAL_ADC_ConfigChannel+0x3fe>
 8004796:	68a5      	ldr	r5, [r4, #8]
 8004798:	68a5      	ldr	r5, [r4, #8]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 800479a:	f104 0708 	add.w	r7, r4, #8
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 800479e:	f3c5 6584 	ubfx	r5, r5, #26, #5
 80047a2:	4285      	cmp	r5, r0
 80047a4:	f000 80aa 	beq.w	80048fc <HAL_ADC_ConfigChannel+0x44c>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 80047a8:	68e5      	ldr	r5, [r4, #12]
 80047aa:	68e5      	ldr	r5, [r4, #12]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80047ac:	f104 060c 	add.w	r6, r4, #12
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 80047b0:	f3c5 6484 	ubfx	r4, r5, #26, #5
 80047b4:	42a0      	cmp	r0, r4
 80047b6:	f000 80b6 	beq.w	8004926 <HAL_ADC_ConfigChannel+0x476>
      LL_ADC_SetChannelSingleDiff(hadc->Instance, pConfig->Channel, pConfig->SingleDiff);
 80047ba:	4660      	mov	r0, ip
 80047bc:	e6a9      	b.n	8004512 <HAL_ADC_ConfigChannel+0x62>
  MODIFY_REG(*preg,
 80047be:	583d      	ldr	r5, [r7, r0]
 80047c0:	402c      	ands	r4, r5
 80047c2:	503c      	str	r4, [r7, r0]
  MODIFY_REG(ADCx->SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);
 80047c4:	6950      	ldr	r0, [r2, #20]
 80047c6:	f040 4000 	orr.w	r0, r0, #2147483648	@ 0x80000000
 80047ca:	6150      	str	r0, [r2, #20]
}
 80047cc:	e700      	b.n	80045d0 <HAL_ADC_ConfigChannel+0x120>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80047ce:	fa90 f4a0 	rbit	r4, r0
  if (value == 0U)
 80047d2:	2c00      	cmp	r4, #0
 80047d4:	f000 80b9 	beq.w	800494a <HAL_ADC_ConfigChannel+0x49a>
  return __builtin_clz(value);
 80047d8:	fab4 f484 	clz	r4, r4
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL(
 80047dc:	3401      	adds	r4, #1
 80047de:	06a4      	lsls	r4, r4, #26
 80047e0:	f004 44f8 	and.w	r4, r4, #2080374784	@ 0x7c000000
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80047e4:	fa90 f5a0 	rbit	r5, r0
  if (value == 0U)
 80047e8:	2d00      	cmp	r5, #0
 80047ea:	f000 80ac 	beq.w	8004946 <HAL_ADC_ConfigChannel+0x496>
  return __builtin_clz(value);
 80047ee:	fab5 f585 	clz	r5, r5
 80047f2:	3501      	adds	r5, #1
 80047f4:	f005 051f 	and.w	r5, r5, #31
 80047f8:	2601      	movs	r6, #1
 80047fa:	fa06 f505 	lsl.w	r5, r6, r5
 80047fe:	432c      	orrs	r4, r5
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004800:	fa90 f0a0 	rbit	r0, r0
  if (value == 0U)
 8004804:	2800      	cmp	r0, #0
 8004806:	f000 8094 	beq.w	8004932 <HAL_ADC_ConfigChannel+0x482>
  return __builtin_clz(value);
 800480a:	fab0 f080 	clz	r0, r0
 800480e:	3001      	adds	r0, #1
 8004810:	f000 001f 	and.w	r0, r0, #31
 8004814:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8004818:	0500      	lsls	r0, r0, #20
 800481a:	e76b      	b.n	80046f4 <HAL_ADC_ConfigChannel+0x244>
 800481c:	0007ffff 	.word	0x0007ffff
 8004820:	407f0000 	.word	0x407f0000
 8004824:	80080000 	.word	0x80080000
 8004828:	50000300 	.word	0x50000300
 800482c:	c3210000 	.word	0xc3210000
 8004830:	90c00010 	.word	0x90c00010
 8004834:	c7520000 	.word	0xc7520000
 8004838:	cb840000 	.word	0xcb840000
 800483c:	50000100 	.word	0x50000100
 8004840:	03fff000 	.word	0x03fff000
 8004844:	20000558 	.word	0x20000558
 8004848:	053e2d63 	.word	0x053e2d63
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800484c:	fa90 f6a0 	rbit	r6, r0
  if (value == 0U)
 8004850:	b11e      	cbz	r6, 800485a <HAL_ADC_ConfigChannel+0x3aa>
  return __builtin_clz(value);
 8004852:	fab6 f686 	clz	r6, r6
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 8004856:	42b5      	cmp	r5, r6
 8004858:	d03e      	beq.n	80048d8 <HAL_ADC_ConfigChannel+0x428>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 800485a:	6e55      	ldr	r5, [r2, #100]	@ 0x64
 800485c:	6e55      	ldr	r5, [r2, #100]	@ 0x64
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 800485e:	f3c5 6584 	ubfx	r5, r5, #26, #5
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004862:	fa9c f6ac 	rbit	r6, ip
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8004866:	f104 0708 	add.w	r7, r4, #8
 800486a:	46be      	mov	lr, r7
  if (value == 0U)
 800486c:	b11e      	cbz	r6, 8004876 <HAL_ADC_ConfigChannel+0x3c6>
  return __builtin_clz(value);
 800486e:	fab6 f686 	clz	r6, r6
 8004872:	42ae      	cmp	r6, r5
 8004874:	d01d      	beq.n	80048b2 <HAL_ADC_ConfigChannel+0x402>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8004876:	68a5      	ldr	r5, [r4, #8]
 8004878:	68a5      	ldr	r5, [r4, #8]
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 800487a:	f3c5 6584 	ubfx	r5, r5, #26, #5
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800487e:	fa9c feac 	rbit	lr, ip
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8004882:	f104 060c 	add.w	r6, r4, #12
 8004886:	46b0      	mov	r8, r6
  if (value == 0U)
 8004888:	f1be 0f00 	cmp.w	lr, #0
 800488c:	d003      	beq.n	8004896 <HAL_ADC_ConfigChannel+0x3e6>
  return __builtin_clz(value);
 800488e:	fabe fe8e 	clz	lr, lr
 8004892:	45ae      	cmp	lr, r5
 8004894:	d034      	beq.n	8004900 <HAL_ADC_ConfigChannel+0x450>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8004896:	68e5      	ldr	r5, [r4, #12]
 8004898:	68e4      	ldr	r4, [r4, #12]
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 800489a:	f3c4 6484 	ubfx	r4, r4, #26, #5
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800489e:	fa9c f5ac 	rbit	r5, ip
  if (value == 0U)
 80048a2:	2d00      	cmp	r5, #0
 80048a4:	f43f ae35 	beq.w	8004512 <HAL_ADC_ConfigChannel+0x62>
  return __builtin_clz(value);
 80048a8:	fab5 f085 	clz	r0, r5
 80048ac:	e782      	b.n	80047b4 <HAL_ADC_ConfigChannel+0x304>
 80048ae:	f104 0e08 	add.w	lr, r4, #8
  MODIFY_REG(*preg,
 80048b2:	6e50      	ldr	r0, [r2, #100]	@ 0x64
 80048b4:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
 80048b8:	6650      	str	r0, [r2, #100]	@ 0x64
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfig->Channel))
 80048ba:	f8d1 c000 	ldr.w	ip, [r1]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 80048be:	68a0      	ldr	r0, [r4, #8]
 80048c0:	68a5      	ldr	r5, [r4, #8]
 80048c2:	f3cc 0612 	ubfx	r6, ip, #0, #19
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80048c6:	4677      	mov	r7, lr
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 80048c8:	f3c5 6584 	ubfx	r5, r5, #26, #5
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfig->Channel))
 80048cc:	4660      	mov	r0, ip
 80048ce:	2e00      	cmp	r6, #0
 80048d0:	d1d5      	bne.n	800487e <HAL_ADC_ConfigChannel+0x3ce>
 80048d2:	f3cc 6084 	ubfx	r0, ip, #26, #5
 80048d6:	e764      	b.n	80047a2 <HAL_ADC_ConfigChannel+0x2f2>
  MODIFY_REG(*preg,
 80048d8:	6e10      	ldr	r0, [r2, #96]	@ 0x60
 80048da:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
 80048de:	6610      	str	r0, [r2, #96]	@ 0x60
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfig->Channel))
 80048e0:	f8d1 c000 	ldr.w	ip, [r1]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 80048e4:	6e50      	ldr	r0, [r2, #100]	@ 0x64
 80048e6:	6e55      	ldr	r5, [r2, #100]	@ 0x64
 80048e8:	f3cc 0612 	ubfx	r6, ip, #0, #19
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 80048ec:	f3c5 6584 	ubfx	r5, r5, #26, #5
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfig->Channel))
 80048f0:	4660      	mov	r0, ip
 80048f2:	2e00      	cmp	r6, #0
 80048f4:	d1b5      	bne.n	8004862 <HAL_ADC_ConfigChannel+0x3b2>
 80048f6:	f3cc 6084 	ubfx	r0, ip, #26, #5
 80048fa:	e749      	b.n	8004790 <HAL_ADC_ConfigChannel+0x2e0>
 80048fc:	f104 080c 	add.w	r8, r4, #12
  MODIFY_REG(*preg,
 8004900:	6838      	ldr	r0, [r7, #0]
 8004902:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
 8004906:	6038      	str	r0, [r7, #0]
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfig->Channel))
 8004908:	f8d1 c000 	ldr.w	ip, [r1]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 800490c:	68e0      	ldr	r0, [r4, #12]
 800490e:	68e4      	ldr	r4, [r4, #12]
 8004910:	f3cc 0512 	ubfx	r5, ip, #0, #19
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8004914:	4646      	mov	r6, r8
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 8004916:	f3c4 6484 	ubfx	r4, r4, #26, #5
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfig->Channel))
 800491a:	4660      	mov	r0, ip
 800491c:	2d00      	cmp	r5, #0
 800491e:	d1be      	bne.n	800489e <HAL_ADC_ConfigChannel+0x3ee>
 8004920:	f3cc 6084 	ubfx	r0, ip, #26, #5
 8004924:	e746      	b.n	80047b4 <HAL_ADC_ConfigChannel+0x304>
  MODIFY_REG(*preg,
 8004926:	6830      	ldr	r0, [r6, #0]
 8004928:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
 800492c:	6030      	str	r0, [r6, #0]
      LL_ADC_SetChannelSingleDiff(hadc->Instance, pConfig->Channel, pConfig->SingleDiff);
 800492e:	6808      	ldr	r0, [r1, #0]
}
 8004930:	e5ef      	b.n	8004512 <HAL_ADC_ConfigChannel+0x62>
 8004932:	f44f 1040 	mov.w	r0, #3145728	@ 0x300000
 8004936:	e6dd      	b.n	80046f4 <HAL_ADC_ConfigChannel+0x244>
 8004938:	f04f 6480 	mov.w	r4, #67108864	@ 0x4000000
 800493c:	e6ba      	b.n	80046b4 <HAL_ADC_ConfigChannel+0x204>
 800493e:	4804      	ldr	r0, [pc, #16]	@ (8004950 <HAL_ADC_ConfigChannel+0x4a0>)
 8004940:	e6d8      	b.n	80046f4 <HAL_ADC_ConfigChannel+0x244>
 8004942:	2502      	movs	r5, #2
 8004944:	e6c3      	b.n	80046ce <HAL_ADC_ConfigChannel+0x21e>
 8004946:	2502      	movs	r5, #2
 8004948:	e759      	b.n	80047fe <HAL_ADC_ConfigChannel+0x34e>
 800494a:	f04f 6480 	mov.w	r4, #67108864	@ 0x4000000
 800494e:	e749      	b.n	80047e4 <HAL_ADC_ConfigChannel+0x334>
 8004950:	fe500000 	.word	0xfe500000

08004954 <HAL_ADCEx_InjectedConfigChannel>:
  *         injected group.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_InjectedConfigChannel(ADC_HandleTypeDef *hadc,
                                                  const ADC_InjectionConfTypeDef *pConfigInjected)
{
 8004954:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  {
    assert_param(IS_ADC_DIFF_CHANNEL(hadc, pConfigInjected->InjectedChannel));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 8004958:	f890 3058 	ldrb.w	r3, [r0, #88]	@ 0x58
{
 800495c:	4602      	mov	r2, r0
 800495e:	b083      	sub	sp, #12
  __IO uint32_t wait_loop_index = 0;
 8004960:	2000      	movs	r0, #0
  __HAL_LOCK(hadc);
 8004962:	2b01      	cmp	r3, #1
  if (hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
 8004964:	6955      	ldr	r5, [r2, #20]
  __IO uint32_t wait_loop_index = 0;
 8004966:	9001      	str	r0, [sp, #4]
  __HAL_LOCK(hadc);
 8004968:	f000 8174 	beq.w	8004c54 <HAL_ADCEx_InjectedConfigChannel+0x300>
 800496c:	2301      	movs	r3, #1
 800496e:	f882 3058 	strb.w	r3, [r2, #88]	@ 0x58
    /*    related to each channel: channel rank sequence                    */
    /* Clear the old JSQx bits for the selected rank */
    tmp_jsqr_context_queue_being_built &= ~ADC_JSQR_RK(ADC_SQR3_SQ10, pConfigInjected->InjectedRank);

    /* Set the JSQx bits for the selected rank */
    tmp_jsqr_context_queue_being_built |= ADC_JSQR_RK(pConfigInjected->InjectedChannel, pConfigInjected->InjectedRank);
 8004972:	e9d1 4000 	ldrd	r4, r0, [r1]

    /* 4. End of context setting: if this is the last channel set, then write context
        into register JSQR and make it enter into queue                   */
    if (hadc->InjectionConfig.ChannelCount == 0U)
    {
      MODIFY_REG(hadc->Instance->JSQR, ADC_JSQR_FIELDS, hadc->InjectionConfig.ContextQueue);
 8004976:	6813      	ldr	r3, [r2, #0]
  if ((hadc->Init.ScanConvMode == ADC_SCAN_DISABLE)  ||
 8004978:	2d00      	cmp	r5, #0
 800497a:	d072      	beq.n	8004a62 <HAL_ADCEx_InjectedConfigChannel+0x10e>
      (pConfigInjected->InjectedNbrOfConversion == 1U))
 800497c:	6a0d      	ldr	r5, [r1, #32]
  if ((hadc->Init.ScanConvMode == ADC_SCAN_DISABLE)  ||
 800497e:	2d01      	cmp	r5, #1
 8004980:	d06f      	beq.n	8004a62 <HAL_ADCEx_InjectedConfigChannel+0x10e>
    if (hadc->InjectionConfig.ChannelCount == 0U)
 8004982:	6e97      	ldr	r7, [r2, #104]	@ 0x68
    tmp_jsqr_context_queue_being_built |= ADC_JSQR_RK(pConfigInjected->InjectedChannel, pConfigInjected->InjectedRank);
 8004984:	f000 001f 	and.w	r0, r0, #31
 8004988:	f3c4 6684 	ubfx	r6, r4, #26, #5
 800498c:	4086      	lsls	r6, r0
    if (hadc->InjectionConfig.ChannelCount == 0U)
 800498e:	2f00      	cmp	r7, #0
 8004990:	f040 811a 	bne.w	8004bc8 <HAL_ADCEx_InjectedConfigChannel+0x274>
      if (pConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
 8004994:	6a88      	ldr	r0, [r1, #40]	@ 0x28
        tmp_jsqr_context_queue_being_built = ((pConfigInjected->InjectedNbrOfConversion - 1U)
 8004996:	3d01      	subs	r5, #1
      if (pConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
 8004998:	2800      	cmp	r0, #0
 800499a:	f000 8217 	beq.w	8004dcc <HAL_ADCEx_InjectedConfigChannel+0x478>
        tmp_jsqr_context_queue_being_built = ((pConfigInjected->InjectedNbrOfConversion - 1U)
 800499e:	6acf      	ldr	r7, [r1, #44]	@ 0x2c
                                              | (pConfigInjected->ExternalTrigInjecConv & ADC_JSQR_JEXTSEL)
 80049a0:	f000 007c 	and.w	r0, r0, #124	@ 0x7c
 80049a4:	4328      	orrs	r0, r5
        tmp_jsqr_context_queue_being_built = ((pConfigInjected->InjectedNbrOfConversion - 1U)
 80049a6:	4338      	orrs	r0, r7
    hadc->InjectionConfig.ContextQueue |= tmp_jsqr_context_queue_being_built;
 80049a8:	4330      	orrs	r0, r6
 80049aa:	e9c2 0519 	strd	r0, r5, [r2, #100]	@ 0x64
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 80049ae:	6898      	ldr	r0, [r3, #8]
 80049b0:	0700      	lsls	r0, r0, #28
 80049b2:	d410      	bmi.n	80049d6 <HAL_ADCEx_InjectedConfigChannel+0x82>
  if (LL_ADC_INJ_IsConversionOngoing(hadc->Instance) == 0UL)
  {
    /* If auto-injected mode is disabled: no constraint                       */
    if (pConfigInjected->AutoInjectedConv == DISABLE)
    {
      MODIFY_REG(hadc->Instance->CFGR,
 80049b4:	f891 0026 	ldrb.w	r0, [r1, #38]	@ 0x26
    if (pConfigInjected->AutoInjectedConv == DISABLE)
 80049b8:	f891 5025 	ldrb.w	r5, [r1, #37]	@ 0x25
      MODIFY_REG(hadc->Instance->CFGR,
 80049bc:	0540      	lsls	r0, r0, #21
    if (pConfigInjected->AutoInjectedConv == DISABLE)
 80049be:	2d00      	cmp	r5, #0
 80049c0:	f040 80f7 	bne.w	8004bb2 <HAL_ADCEx_InjectedConfigChannel+0x25e>
      MODIFY_REG(hadc->Instance->CFGR,
 80049c4:	68dd      	ldr	r5, [r3, #12]
 80049c6:	f891 6024 	ldrb.w	r6, [r1, #36]	@ 0x24
 80049ca:	f425 1540 	bic.w	r5, r5, #3145728	@ 0x300000
 80049ce:	ea40 5006 	orr.w	r0, r0, r6, lsl #20
 80049d2:	4328      	orrs	r0, r5
 80049d4:	60d8      	str	r0, [r3, #12]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 80049d6:	6898      	ldr	r0, [r3, #8]
 80049d8:	f010 0004 	ands.w	r0, r0, #4
 80049dc:	d057      	beq.n	8004a8e <HAL_ADCEx_InjectedConfigChannel+0x13a>
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 80049de:	6898      	ldr	r0, [r3, #8]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 80049e0:	2000      	movs	r0, #0
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 80049e2:	689d      	ldr	r5, [r3, #8]
 80049e4:	07ee      	lsls	r6, r5, #31
 80049e6:	d414      	bmi.n	8004a12 <HAL_ADCEx_InjectedConfigChannel+0xbe>
  /* Parameters that can be updated only when ADC is disabled:                */
  /*  - Single or differential mode                                           */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
  {
    /* Set mode single-ended or differential input of the selected ADC channel */
    LL_ADC_SetChannelSingleDiff(hadc->Instance, pConfigInjected->InjectedChannel, pConfigInjected->InjectedSingleDiff);
 80049e8:	68cf      	ldr	r7, [r1, #12]
  MODIFY_REG(ADCx->DIFSEL,
 80049ea:	4da4      	ldr	r5, [pc, #656]	@ (8004c7c <HAL_ADCEx_InjectedConfigChannel+0x328>)
 80049ec:	f8d3 60b0 	ldr.w	r6, [r3, #176]	@ 0xb0
 80049f0:	f007 0c18 	and.w	ip, r7, #24
 80049f4:	fa25 f50c 	lsr.w	r5, r5, ip
 80049f8:	f3c4 0e12 	ubfx	lr, r4, #0, #19
 80049fc:	4025      	ands	r5, r4
 80049fe:	ea26 0c0e 	bic.w	ip, r6, lr
 8004a02:	ea45 050c 	orr.w	r5, r5, ip
 8004a06:	f8c3 50b0 	str.w	r5, [r3, #176]	@ 0xb0

    /* Configuration of differential mode */
    /* Note: ADC channel number masked with value "0x1F" to ensure shift value within 32 bits range */
    if (pConfigInjected->InjectedSingleDiff == ADC_DIFFERENTIAL_ENDED)
 8004a0a:	4d9d      	ldr	r5, [pc, #628]	@ (8004c80 <HAL_ADCEx_InjectedConfigChannel+0x32c>)
 8004a0c:	42af      	cmp	r7, r5
 8004a0e:	f000 80f6 	beq.w	8004bfe <HAL_ADCEx_InjectedConfigChannel+0x2aa>
  /* internal measurement paths enable: If internal channel selected,       */
  /* enable dedicated internal buffers and path.                            */
  /* Note: these internal measurement paths can be disabled using           */
  /* HAL_ADC_DeInit().                                                      */

  if (__LL_ADC_IS_CHANNEL_INTERNAL(pConfigInjected->InjectedChannel))
 8004a12:	499c      	ldr	r1, [pc, #624]	@ (8004c84 <HAL_ADCEx_InjectedConfigChannel+0x330>)
 8004a14:	420c      	tst	r4, r1
 8004a16:	d01e      	beq.n	8004a56 <HAL_ADCEx_InjectedConfigChannel+0x102>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL));
 8004a18:	4e9b      	ldr	r6, [pc, #620]	@ (8004c88 <HAL_ADCEx_InjectedConfigChannel+0x334>)
  {
    tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));

    /* If the requested internal measurement path has already been enabled,   */
    /* bypass the configuration processing.                                   */
    if (((pConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR_ADC1)
 8004a1a:	4d9c      	ldr	r5, [pc, #624]	@ (8004c8c <HAL_ADCEx_InjectedConfigChannel+0x338>)
 8004a1c:	68b1      	ldr	r1, [r6, #8]
 8004a1e:	42ac      	cmp	r4, r5
 8004a20:	f001 77e0 	and.w	r7, r1, #29360128	@ 0x1c00000
 8004a24:	f000 809f 	beq.w	8004b66 <HAL_ADCEx_InjectedConfigChannel+0x212>
         || (pConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR_ADC5))
 8004a28:	4d99      	ldr	r5, [pc, #612]	@ (8004c90 <HAL_ADCEx_InjectedConfigChannel+0x33c>)
 8004a2a:	42ac      	cmp	r4, r5
 8004a2c:	f000 809b 	beq.w	8004b66 <HAL_ADCEx_InjectedConfigChannel+0x212>
        {
          wait_loop_index--;
        }
      }
    }
    else if ((pConfigInjected->InjectedChannel == ADC_CHANNEL_VBAT)
 8004a30:	4d98      	ldr	r5, [pc, #608]	@ (8004c94 <HAL_ADCEx_InjectedConfigChannel+0x340>)
 8004a32:	42ac      	cmp	r4, r5
 8004a34:	f000 8112 	beq.w	8004c5c <HAL_ADCEx_InjectedConfigChannel+0x308>
      {
        LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
                                       LL_ADC_PATH_INTERNAL_VBAT | tmp_config_internal_channel);
      }
    }
    else if ((pConfigInjected->InjectedChannel == ADC_CHANNEL_VREFINT)
 8004a38:	4d97      	ldr	r5, [pc, #604]	@ (8004c98 <HAL_ADCEx_InjectedConfigChannel+0x344>)
 8004a3a:	42ac      	cmp	r4, r5
 8004a3c:	d10b      	bne.n	8004a56 <HAL_ADCEx_InjectedConfigChannel+0x102>
             && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
 8004a3e:	0249      	lsls	r1, r1, #9
 8004a40:	d409      	bmi.n	8004a56 <HAL_ADCEx_InjectedConfigChannel+0x102>
    {
      if (ADC_VREFINT_INSTANCE(hadc))
 8004a42:	4996      	ldr	r1, [pc, #600]	@ (8004c9c <HAL_ADCEx_InjectedConfigChannel+0x348>)
 8004a44:	428b      	cmp	r3, r1
 8004a46:	d006      	beq.n	8004a56 <HAL_ADCEx_InjectedConfigChannel+0x102>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL, PathInternal);
 8004a48:	68b3      	ldr	r3, [r6, #8]
 8004a4a:	f023 73e0 	bic.w	r3, r3, #29360128	@ 0x1c00000
 8004a4e:	433b      	orrs	r3, r7
 8004a50:	f443 0380 	orr.w	r3, r3, #4194304	@ 0x400000
 8004a54:	60b3      	str	r3, [r6, #8]
      /* nothing to do */
    }
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8004a56:	2300      	movs	r3, #0
 8004a58:	f882 3058 	strb.w	r3, [r2, #88]	@ 0x58

  /* Return function status */
  return tmp_hal_status;
}
 8004a5c:	b003      	add	sp, #12
 8004a5e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if (pConfigInjected->InjectedRank == ADC_INJECTED_RANK_1)
 8004a62:	2809      	cmp	r0, #9
 8004a64:	d1a3      	bne.n	80049ae <HAL_ADCEx_InjectedConfigChannel+0x5a>
      if (pConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
 8004a66:	6a88      	ldr	r0, [r1, #40]	@ 0x28
        tmp_jsqr_context_queue_being_built = (ADC_JSQR_RK(pConfigInjected->InjectedChannel, ADC_INJECTED_RANK_1)
 8004a68:	0c65      	lsrs	r5, r4, #17
 8004a6a:	f405 5578 	and.w	r5, r5, #15872	@ 0x3e00
      if (pConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
 8004a6e:	b120      	cbz	r0, 8004a7a <HAL_ADCEx_InjectedConfigChannel+0x126>
        tmp_jsqr_context_queue_being_built = (ADC_JSQR_RK(pConfigInjected->InjectedChannel, ADC_INJECTED_RANK_1)
 8004a70:	6ace      	ldr	r6, [r1, #44]	@ 0x2c
                                              | (pConfigInjected->ExternalTrigInjecConv & ADC_JSQR_JEXTSEL)
 8004a72:	f000 007c 	and.w	r0, r0, #124	@ 0x7c
        tmp_jsqr_context_queue_being_built = (ADC_JSQR_RK(pConfigInjected->InjectedChannel, ADC_INJECTED_RANK_1)
 8004a76:	4330      	orrs	r0, r6
 8004a78:	4305      	orrs	r5, r0
      MODIFY_REG(hadc->Instance->JSQR, ADC_JSQR_FIELDS, tmp_jsqr_context_queue_being_built);
 8004a7a:	6cd8      	ldr	r0, [r3, #76]	@ 0x4c
 8004a7c:	4e88      	ldr	r6, [pc, #544]	@ (8004ca0 <HAL_ADCEx_InjectedConfigChannel+0x34c>)
 8004a7e:	4030      	ands	r0, r6
 8004a80:	4328      	orrs	r0, r5
 8004a82:	64d8      	str	r0, [r3, #76]	@ 0x4c
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8004a84:	6898      	ldr	r0, [r3, #8]
      hadc->InjectionConfig.ContextQueue = tmp_jsqr_context_queue_being_built;
 8004a86:	6655      	str	r5, [r2, #100]	@ 0x64
 8004a88:	0700      	lsls	r0, r0, #28
 8004a8a:	d4a4      	bmi.n	80049d6 <HAL_ADCEx_InjectedConfigChannel+0x82>
 8004a8c:	e792      	b.n	80049b4 <HAL_ADCEx_InjectedConfigChannel+0x60>
 8004a8e:	689d      	ldr	r5, [r3, #8]
 8004a90:	072f      	lsls	r7, r5, #28
 8004a92:	d4a6      	bmi.n	80049e2 <HAL_ADCEx_InjectedConfigChannel+0x8e>
    if ((pConfigInjected->ExternalTrigInjecConv == ADC_INJECTED_SOFTWARE_START)
 8004a94:	6a8d      	ldr	r5, [r1, #40]	@ 0x28
    if (pConfigInjected->AutoInjectedConv == DISABLE)
 8004a96:	f891 0025 	ldrb.w	r0, [r1, #37]	@ 0x25
    if ((pConfigInjected->ExternalTrigInjecConv == ADC_INJECTED_SOFTWARE_START)
 8004a9a:	2d00      	cmp	r5, #0
 8004a9c:	f040 80a6 	bne.w	8004bec <HAL_ADCEx_InjectedConfigChannel+0x298>
      if (pConfigInjected->AutoInjectedConv == ENABLE)
 8004aa0:	2801      	cmp	r0, #1
        SET_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO);
 8004aa2:	68d8      	ldr	r0, [r3, #12]
      if (pConfigInjected->AutoInjectedConv == ENABLE)
 8004aa4:	f000 8194 	beq.w	8004dd0 <HAL_ADCEx_InjectedConfigChannel+0x47c>
        CLEAR_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO);
 8004aa8:	f020 7000 	bic.w	r0, r0, #33554432	@ 0x2000000
 8004aac:	60d8      	str	r0, [r3, #12]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8004aae:	2000      	movs	r0, #0
    if (pConfigInjected->InjecOversamplingMode == ENABLE)
 8004ab0:	f891 5030 	ldrb.w	r5, [r1, #48]	@ 0x30
 8004ab4:	2d01      	cmp	r5, #1
 8004ab6:	f000 817e 	beq.w	8004db6 <HAL_ADCEx_InjectedConfigChannel+0x462>
      CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_JOVSE);
 8004aba:	691d      	ldr	r5, [r3, #16]
 8004abc:	f025 0502 	bic.w	r5, r5, #2
 8004ac0:	611d      	str	r5, [r3, #16]
    if (pConfigInjected->InjectedSamplingTime == ADC_SAMPLETIME_3CYCLES_5)
 8004ac2:	688e      	ldr	r6, [r1, #8]
  MODIFY_REG(*preg,
 8004ac4:	f3c4 5704 	ubfx	r7, r4, #20, #5
 8004ac8:	2507      	movs	r5, #7
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1,
 8004aca:	0de4      	lsrs	r4, r4, #23
  MODIFY_REG(*preg,
 8004acc:	40bd      	lsls	r5, r7
 8004ace:	f1b6 4f00 	cmp.w	r6, #2147483648	@ 0x80000000
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1,
 8004ad2:	f004 0404 	and.w	r4, r4, #4
  MODIFY_REG(*preg,
 8004ad6:	ea6f 0505 	mvn.w	r5, r5
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1,
 8004ada:	f103 0c14 	add.w	ip, r3, #20
 8004ade:	f000 8160 	beq.w	8004da2 <HAL_ADCEx_InjectedConfigChannel+0x44e>
  MODIFY_REG(*preg,
 8004ae2:	40be      	lsls	r6, r7
 8004ae4:	f85c 7004 	ldr.w	r7, [ip, r4]
 8004ae8:	403d      	ands	r5, r7
 8004aea:	4335      	orrs	r5, r6
 8004aec:	f84c 5004 	str.w	r5, [ip, r4]
  MODIFY_REG(ADCx->SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);
 8004af0:	695c      	ldr	r4, [r3, #20]
 8004af2:	f024 4400 	bic.w	r4, r4, #2147483648	@ 0x80000000
 8004af6:	615c      	str	r4, [r3, #20]
    if (pConfigInjected->InjectedOffsetNumber != ADC_OFFSET_NONE)
 8004af8:	f8d1 c010 	ldr.w	ip, [r1, #16]
      LL_ADC_SetOffset(hadc->Instance, pConfigInjected->InjectedOffsetNumber, pConfigInjected->InjectedChannel,
 8004afc:	680c      	ldr	r4, [r1, #0]
    tmp_offset_shifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, pConfigInjected->InjectedOffset);
 8004afe:	694e      	ldr	r6, [r1, #20]
 8004b00:	68df      	ldr	r7, [r3, #12]
    if (pConfigInjected->InjectedOffsetNumber != ADC_OFFSET_NONE)
 8004b02:	f1bc 0f04 	cmp.w	ip, #4
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8004b06:	f103 0560 	add.w	r5, r3, #96	@ 0x60
      LL_ADC_SetOffset(hadc->Instance, pConfigInjected->InjectedOffsetNumber, pConfigInjected->InjectedChannel,
 8004b0a:	46a6      	mov	lr, r4
    if (pConfigInjected->InjectedOffsetNumber != ADC_OFFSET_NONE)
 8004b0c:	f000 8109 	beq.w	8004d22 <HAL_ADCEx_InjectedConfigChannel+0x3ce>
    tmp_offset_shifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, pConfigInjected->InjectedOffset);
 8004b10:	f3c7 07c1 	ubfx	r7, r7, #3, #2
 8004b14:	007f      	lsls	r7, r7, #1
  MODIFY_REG(*preg,
 8004b16:	f855 e02c 	ldr.w	lr, [r5, ip, lsl #2]
 8004b1a:	40be      	lsls	r6, r7
 8004b1c:	4f61      	ldr	r7, [pc, #388]	@ (8004ca4 <HAL_ADCEx_InjectedConfigChannel+0x350>)
 8004b1e:	f004 44f8 	and.w	r4, r4, #2080374784	@ 0x7c000000
 8004b22:	ea0e 0707 	and.w	r7, lr, r7
 8004b26:	4327      	orrs	r7, r4
 8004b28:	433e      	orrs	r6, r7
 8004b2a:	f046 4600 	orr.w	r6, r6, #2147483648	@ 0x80000000
 8004b2e:	f845 602c 	str.w	r6, [r5, ip, lsl #2]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8004b32:	690f      	ldr	r7, [r1, #16]
  MODIFY_REG(*preg,
 8004b34:	698e      	ldr	r6, [r1, #24]
 8004b36:	f855 4027 	ldr.w	r4, [r5, r7, lsl #2]
 8004b3a:	f024 7480 	bic.w	r4, r4, #16777216	@ 0x1000000
 8004b3e:	4334      	orrs	r4, r6
 8004b40:	f845 4027 	str.w	r4, [r5, r7, lsl #2]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8004b44:	690f      	ldr	r7, [r1, #16]
      LL_ADC_SetOffsetSaturation(hadc->Instance, pConfigInjected->InjectedOffsetNumber,
 8004b46:	7f0e      	ldrb	r6, [r1, #28]
  MODIFY_REG(*preg,
 8004b48:	f855 4027 	ldr.w	r4, [r5, r7, lsl #2]
 8004b4c:	f1a6 0601 	sub.w	r6, r6, #1
 8004b50:	fab6 f686 	clz	r6, r6
 8004b54:	0976      	lsrs	r6, r6, #5
 8004b56:	f024 7400 	bic.w	r4, r4, #33554432	@ 0x2000000
 8004b5a:	ea44 6446 	orr.w	r4, r4, r6, lsl #25
 8004b5e:	f845 4027 	str.w	r4, [r5, r7, lsl #2]
    LL_ADC_SetChannelSingleDiff(hadc->Instance, pConfigInjected->InjectedChannel, pConfigInjected->InjectedSingleDiff);
 8004b62:	680c      	ldr	r4, [r1, #0]
}
 8004b64:	e73d      	b.n	80049e2 <HAL_ADCEx_InjectedConfigChannel+0x8e>
        && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
 8004b66:	020d      	lsls	r5, r1, #8
 8004b68:	f53f af75 	bmi.w	8004a56 <HAL_ADCEx_InjectedConfigChannel+0x102>
      if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 8004b6c:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 8004b70:	f47f af71 	bne.w	8004a56 <HAL_ADCEx_InjectedConfigChannel+0x102>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL, PathInternal);
 8004b74:	4944      	ldr	r1, [pc, #272]	@ (8004c88 <HAL_ADCEx_InjectedConfigChannel+0x334>)
                           * (((SystemCoreClock / (100000UL * 2UL)) + 1UL) + 1UL));
 8004b76:	4c4c      	ldr	r4, [pc, #304]	@ (8004ca8 <HAL_ADCEx_InjectedConfigChannel+0x354>)
 8004b78:	688b      	ldr	r3, [r1, #8]
 8004b7a:	f023 73e0 	bic.w	r3, r3, #29360128	@ 0x1c00000
 8004b7e:	433b      	orrs	r3, r7
 8004b80:	f443 0300 	orr.w	r3, r3, #8388608	@ 0x800000
 8004b84:	608b      	str	r3, [r1, #8]
 8004b86:	6823      	ldr	r3, [r4, #0]
 8004b88:	4948      	ldr	r1, [pc, #288]	@ (8004cac <HAL_ADCEx_InjectedConfigChannel+0x358>)
 8004b8a:	099b      	lsrs	r3, r3, #6
 8004b8c:	fba1 1303 	umull	r1, r3, r1, r3
 8004b90:	099b      	lsrs	r3, r3, #6
 8004b92:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8004b96:	009b      	lsls	r3, r3, #2
 8004b98:	3318      	adds	r3, #24
        wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL)
 8004b9a:	9301      	str	r3, [sp, #4]
        while (wait_loop_index != 0UL)
 8004b9c:	9b01      	ldr	r3, [sp, #4]
 8004b9e:	2b00      	cmp	r3, #0
 8004ba0:	f43f af59 	beq.w	8004a56 <HAL_ADCEx_InjectedConfigChannel+0x102>
          wait_loop_index--;
 8004ba4:	9b01      	ldr	r3, [sp, #4]
 8004ba6:	3b01      	subs	r3, #1
 8004ba8:	9301      	str	r3, [sp, #4]
        while (wait_loop_index != 0UL)
 8004baa:	9b01      	ldr	r3, [sp, #4]
 8004bac:	2b00      	cmp	r3, #0
 8004bae:	d1f9      	bne.n	8004ba4 <HAL_ADCEx_InjectedConfigChannel+0x250>
 8004bb0:	e751      	b.n	8004a56 <HAL_ADCEx_InjectedConfigChannel+0x102>
      MODIFY_REG(hadc->Instance->CFGR,
 8004bb2:	68dd      	ldr	r5, [r3, #12]
 8004bb4:	f425 1540 	bic.w	r5, r5, #3145728	@ 0x300000
 8004bb8:	4328      	orrs	r0, r5
 8004bba:	60d8      	str	r0, [r3, #12]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8004bbc:	6898      	ldr	r0, [r3, #8]
 8004bbe:	f010 0004 	ands.w	r0, r0, #4
 8004bc2:	f43f af64 	beq.w	8004a8e <HAL_ADCEx_InjectedConfigChannel+0x13a>
 8004bc6:	e70a      	b.n	80049de <HAL_ADCEx_InjectedConfigChannel+0x8a>
    hadc->InjectionConfig.ContextQueue |= tmp_jsqr_context_queue_being_built;
 8004bc8:	6e55      	ldr	r5, [r2, #100]	@ 0x64
    hadc->InjectionConfig.ChannelCount--;
 8004bca:	3f01      	subs	r7, #1
    hadc->InjectionConfig.ContextQueue |= tmp_jsqr_context_queue_being_built;
 8004bcc:	4335      	orrs	r5, r6
    hadc->InjectionConfig.ChannelCount--;
 8004bce:	6697      	str	r7, [r2, #104]	@ 0x68
    hadc->InjectionConfig.ContextQueue |= tmp_jsqr_context_queue_being_built;
 8004bd0:	6655      	str	r5, [r2, #100]	@ 0x64
    if (hadc->InjectionConfig.ChannelCount == 0U)
 8004bd2:	2f00      	cmp	r7, #0
 8004bd4:	f47f aeeb 	bne.w	80049ae <HAL_ADCEx_InjectedConfigChannel+0x5a>
      MODIFY_REG(hadc->Instance->JSQR, ADC_JSQR_FIELDS, hadc->InjectionConfig.ContextQueue);
 8004bd8:	6cd8      	ldr	r0, [r3, #76]	@ 0x4c
 8004bda:	4e31      	ldr	r6, [pc, #196]	@ (8004ca0 <HAL_ADCEx_InjectedConfigChannel+0x34c>)
 8004bdc:	4030      	ands	r0, r6
 8004bde:	4328      	orrs	r0, r5
 8004be0:	64d8      	str	r0, [r3, #76]	@ 0x4c
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8004be2:	6898      	ldr	r0, [r3, #8]
 8004be4:	0700      	lsls	r0, r0, #28
 8004be6:	f53f aef6 	bmi.w	80049d6 <HAL_ADCEx_InjectedConfigChannel+0x82>
 8004bea:	e6e3      	b.n	80049b4 <HAL_ADCEx_InjectedConfigChannel+0x60>
        || (pConfigInjected->ExternalTrigInjecConvEdge == ADC_EXTERNALTRIGINJECCONV_EDGE_NONE))
 8004bec:	6acd      	ldr	r5, [r1, #44]	@ 0x2c
 8004bee:	2d00      	cmp	r5, #0
 8004bf0:	f43f af56 	beq.w	8004aa0 <HAL_ADCEx_InjectedConfigChannel+0x14c>
      if (pConfigInjected->AutoInjectedConv == ENABLE)
 8004bf4:	2801      	cmp	r0, #1
 8004bf6:	f000 810d 	beq.w	8004e14 <HAL_ADCEx_InjectedConfigChannel+0x4c0>
        CLEAR_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO);
 8004bfa:	68d8      	ldr	r0, [r3, #12]
 8004bfc:	e754      	b.n	8004aa8 <HAL_ADCEx_InjectedConfigChannel+0x154>
                                    (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL(
 8004bfe:	f1be 0f00 	cmp.w	lr, #0
 8004c02:	d155      	bne.n	8004cb0 <HAL_ADCEx_InjectedConfigChannel+0x35c>
 8004c04:	0ea4      	lsrs	r4, r4, #26
 8004c06:	3401      	adds	r4, #1
 8004c08:	f004 061f 	and.w	r6, r4, #31
 8004c0c:	2501      	movs	r5, #1
 8004c0e:	06a4      	lsls	r4, r4, #26
 8004c10:	f004 44f8 	and.w	r4, r4, #2080374784	@ 0x7c000000
 8004c14:	40b5      	lsls	r5, r6
      LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8004c16:	2e09      	cmp	r6, #9
                                    (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL(
 8004c18:	ea45 0504 	orr.w	r5, r5, r4
 8004c1c:	eb06 0446 	add.w	r4, r6, r6, lsl #1
      LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8004c20:	f200 80f3 	bhi.w	8004e0a <HAL_ADCEx_InjectedConfigChannel+0x4b6>
                                    (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL(
 8004c24:	0524      	lsls	r4, r4, #20
      LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8004c26:	432c      	orrs	r4, r5
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1,
 8004c28:	0de6      	lsrs	r6, r4, #23
  MODIFY_REG(*preg,
 8004c2a:	688d      	ldr	r5, [r1, #8]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1,
 8004c2c:	f006 0604 	and.w	r6, r6, #4
 8004c30:	f103 0714 	add.w	r7, r3, #20
  MODIFY_REG(*preg,
 8004c34:	f3c4 5404 	ubfx	r4, r4, #20, #5
 8004c38:	fa05 fc04 	lsl.w	ip, r5, r4
 8004c3c:	f04f 0e07 	mov.w	lr, #7
 8004c40:	59bd      	ldr	r5, [r7, r6]
 8004c42:	fa0e f404 	lsl.w	r4, lr, r4
 8004c46:	ea25 0404 	bic.w	r4, r5, r4
 8004c4a:	ea44 040c 	orr.w	r4, r4, ip
 8004c4e:	51bc      	str	r4, [r7, r6]
  if (__LL_ADC_IS_CHANNEL_INTERNAL(pConfigInjected->InjectedChannel))
 8004c50:	680c      	ldr	r4, [r1, #0]
}
 8004c52:	e6de      	b.n	8004a12 <HAL_ADCEx_InjectedConfigChannel+0xbe>
  __HAL_LOCK(hadc);
 8004c54:	2002      	movs	r0, #2
}
 8004c56:	b003      	add	sp, #12
 8004c58:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
             && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 8004c5c:	01cc      	lsls	r4, r1, #7
 8004c5e:	f53f aefa 	bmi.w	8004a56 <HAL_ADCEx_InjectedConfigChannel+0x102>
      if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 8004c62:	490e      	ldr	r1, [pc, #56]	@ (8004c9c <HAL_ADCEx_InjectedConfigChannel+0x348>)
 8004c64:	428b      	cmp	r3, r1
 8004c66:	f43f aef6 	beq.w	8004a56 <HAL_ADCEx_InjectedConfigChannel+0x102>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL, PathInternal);
 8004c6a:	68b3      	ldr	r3, [r6, #8]
 8004c6c:	f023 73e0 	bic.w	r3, r3, #29360128	@ 0x1c00000
 8004c70:	433b      	orrs	r3, r7
 8004c72:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8004c76:	60b3      	str	r3, [r6, #8]
}
 8004c78:	e6ed      	b.n	8004a56 <HAL_ADCEx_InjectedConfigChannel+0x102>
 8004c7a:	bf00      	nop
 8004c7c:	0007ffff 	.word	0x0007ffff
 8004c80:	407f0000 	.word	0x407f0000
 8004c84:	80080000 	.word	0x80080000
 8004c88:	50000300 	.word	0x50000300
 8004c8c:	c3210000 	.word	0xc3210000
 8004c90:	90c00010 	.word	0x90c00010
 8004c94:	c7520000 	.word	0xc7520000
 8004c98:	cb840000 	.word	0xcb840000
 8004c9c:	50000100 	.word	0x50000100
 8004ca0:	04104000 	.word	0x04104000
 8004ca4:	03fff000 	.word	0x03fff000
 8004ca8:	20000558 	.word	0x20000558
 8004cac:	053e2d63 	.word	0x053e2d63
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004cb0:	fa94 f5a4 	rbit	r5, r4
  if (value == 0U)
 8004cb4:	2d00      	cmp	r5, #0
 8004cb6:	f000 80b2 	beq.w	8004e1e <HAL_ADCEx_InjectedConfigChannel+0x4ca>
  return __builtin_clz(value);
 8004cba:	fab5 f585 	clz	r5, r5
      LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8004cbe:	3501      	adds	r5, #1
 8004cc0:	f005 051f 	and.w	r5, r5, #31
 8004cc4:	2d09      	cmp	r5, #9
 8004cc6:	f240 80aa 	bls.w	8004e1e <HAL_ADCEx_InjectedConfigChannel+0x4ca>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004cca:	fa94 f5a4 	rbit	r5, r4
  if (value == 0U)
 8004cce:	2d00      	cmp	r5, #0
 8004cd0:	f000 8111 	beq.w	8004ef6 <HAL_ADCEx_InjectedConfigChannel+0x5a2>
  return __builtin_clz(value);
 8004cd4:	fab5 f585 	clz	r5, r5
                                    (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL(
 8004cd8:	3501      	adds	r5, #1
 8004cda:	06ad      	lsls	r5, r5, #26
 8004cdc:	f005 45f8 	and.w	r5, r5, #2080374784	@ 0x7c000000
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004ce0:	fa94 f6a4 	rbit	r6, r4
  if (value == 0U)
 8004ce4:	2e00      	cmp	r6, #0
 8004ce6:	f000 8104 	beq.w	8004ef2 <HAL_ADCEx_InjectedConfigChannel+0x59e>
  return __builtin_clz(value);
 8004cea:	fab6 f686 	clz	r6, r6
 8004cee:	3601      	adds	r6, #1
 8004cf0:	f006 061f 	and.w	r6, r6, #31
 8004cf4:	2701      	movs	r7, #1
 8004cf6:	fa07 f606 	lsl.w	r6, r7, r6
 8004cfa:	4335      	orrs	r5, r6
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004cfc:	fa94 f4a4 	rbit	r4, r4
  if (value == 0U)
 8004d00:	2c00      	cmp	r4, #0
 8004d02:	f000 80fe 	beq.w	8004f02 <HAL_ADCEx_InjectedConfigChannel+0x5ae>
  return __builtin_clz(value);
 8004d06:	fab4 f484 	clz	r4, r4
 8004d0a:	1c66      	adds	r6, r4, #1
 8004d0c:	f006 061f 	and.w	r6, r6, #31
 8004d10:	2403      	movs	r4, #3
 8004d12:	f06f 071d 	mvn.w	r7, #29
 8004d16:	fb14 7406 	smlabb	r4, r4, r6, r7
 8004d1a:	0524      	lsls	r4, r4, #20
 8004d1c:	f044 7400 	orr.w	r4, r4, #33554432	@ 0x2000000
 8004d20:	e781      	b.n	8004c26 <HAL_ADCEx_InjectedConfigChannel+0x2d2>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8004d22:	6e1e      	ldr	r6, [r3, #96]	@ 0x60
 8004d24:	6e1e      	ldr	r6, [r3, #96]	@ 0x60
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfigInjected->InjectedChannel))
 8004d26:	f3c4 0712 	ubfx	r7, r4, #0, #19
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 8004d2a:	f3c6 6684 	ubfx	r6, r6, #26, #5
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfigInjected->InjectedChannel))
 8004d2e:	2f00      	cmp	r7, #0
 8004d30:	d052      	beq.n	8004dd8 <HAL_ADCEx_InjectedConfigChannel+0x484>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004d32:	fa94 f7a4 	rbit	r7, r4
  if (value == 0U)
 8004d36:	b127      	cbz	r7, 8004d42 <HAL_ADCEx_InjectedConfigChannel+0x3ee>
  return __builtin_clz(value);
 8004d38:	fab7 f787 	clz	r7, r7
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 8004d3c:	42be      	cmp	r6, r7
 8004d3e:	f000 80a7 	beq.w	8004e90 <HAL_ADCEx_InjectedConfigChannel+0x53c>
 8004d42:	6e5e      	ldr	r6, [r3, #100]	@ 0x64
 8004d44:	6e5e      	ldr	r6, [r3, #100]	@ 0x64
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 8004d46:	f3c6 6684 	ubfx	r6, r6, #26, #5
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004d4a:	fa9e f7ae 	rbit	r7, lr
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8004d4e:	f105 0c08 	add.w	ip, r5, #8
 8004d52:	46e0      	mov	r8, ip
  if (value == 0U)
 8004d54:	b127      	cbz	r7, 8004d60 <HAL_ADCEx_InjectedConfigChannel+0x40c>
  return __builtin_clz(value);
 8004d56:	fab7 f787 	clz	r7, r7
 8004d5a:	42b7      	cmp	r7, r6
 8004d5c:	f000 8084 	beq.w	8004e68 <HAL_ADCEx_InjectedConfigChannel+0x514>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8004d60:	68ae      	ldr	r6, [r5, #8]
 8004d62:	68ae      	ldr	r6, [r5, #8]
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 8004d64:	f3c6 6684 	ubfx	r6, r6, #26, #5
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004d68:	fa9e f8ae 	rbit	r8, lr
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8004d6c:	f105 070c 	add.w	r7, r5, #12
 8004d70:	46b9      	mov	r9, r7
  if (value == 0U)
 8004d72:	f1b8 0f00 	cmp.w	r8, #0
 8004d76:	d004      	beq.n	8004d82 <HAL_ADCEx_InjectedConfigChannel+0x42e>
  return __builtin_clz(value);
 8004d78:	fab8 f888 	clz	r8, r8
 8004d7c:	45b0      	cmp	r8, r6
 8004d7e:	f000 809c 	beq.w	8004eba <HAL_ADCEx_InjectedConfigChannel+0x566>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8004d82:	68ee      	ldr	r6, [r5, #12]
 8004d84:	68ed      	ldr	r5, [r5, #12]
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 8004d86:	f3c5 6584 	ubfx	r5, r5, #26, #5
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004d8a:	fa9e f6ae 	rbit	r6, lr
  if (value == 0U)
 8004d8e:	2e00      	cmp	r6, #0
 8004d90:	f43f ae27 	beq.w	80049e2 <HAL_ADCEx_InjectedConfigChannel+0x8e>
  return __builtin_clz(value);
 8004d94:	fab6 f486 	clz	r4, r6
 8004d98:	42ac      	cmp	r4, r5
 8004d9a:	f000 80a4 	beq.w	8004ee6 <HAL_ADCEx_InjectedConfigChannel+0x592>
    LL_ADC_SetChannelSingleDiff(hadc->Instance, pConfigInjected->InjectedChannel, pConfigInjected->InjectedSingleDiff);
 8004d9e:	4674      	mov	r4, lr
 8004da0:	e61f      	b.n	80049e2 <HAL_ADCEx_InjectedConfigChannel+0x8e>
  MODIFY_REG(*preg,
 8004da2:	f85c 6004 	ldr.w	r6, [ip, r4]
 8004da6:	4035      	ands	r5, r6
 8004da8:	f84c 5004 	str.w	r5, [ip, r4]
  MODIFY_REG(ADCx->SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);
 8004dac:	695c      	ldr	r4, [r3, #20]
 8004dae:	f044 4400 	orr.w	r4, r4, #2147483648	@ 0x80000000
 8004db2:	615c      	str	r4, [r3, #20]
}
 8004db4:	e6a0      	b.n	8004af8 <HAL_ADCEx_InjectedConfigChannel+0x1a4>
      MODIFY_REG(hadc->Instance->CFGR2,
 8004db6:	e9d1 570d 	ldrd	r5, r7, [r1, #52]	@ 0x34
 8004dba:	691e      	ldr	r6, [r3, #16]
 8004dbc:	433d      	orrs	r5, r7
 8004dbe:	f426 76ff 	bic.w	r6, r6, #510	@ 0x1fe
 8004dc2:	4335      	orrs	r5, r6
 8004dc4:	f045 0502 	orr.w	r5, r5, #2
 8004dc8:	611d      	str	r5, [r3, #16]
 8004dca:	e67a      	b.n	8004ac2 <HAL_ADCEx_InjectedConfigChannel+0x16e>
        tmp_jsqr_context_queue_being_built = ((pConfigInjected->InjectedNbrOfConversion - 1U));
 8004dcc:	4628      	mov	r0, r5
 8004dce:	e5eb      	b.n	80049a8 <HAL_ADCEx_InjectedConfigChannel+0x54>
        SET_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO);
 8004dd0:	f040 7000 	orr.w	r0, r0, #33554432	@ 0x2000000
 8004dd4:	60d8      	str	r0, [r3, #12]
 8004dd6:	e66a      	b.n	8004aae <HAL_ADCEx_InjectedConfigChannel+0x15a>
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfigInjected->InjectedChannel))
 8004dd8:	f3c4 6484 	ubfx	r4, r4, #26, #5
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 8004ddc:	42a6      	cmp	r6, r4
 8004dde:	d057      	beq.n	8004e90 <HAL_ADCEx_InjectedConfigChannel+0x53c>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8004de0:	6e5e      	ldr	r6, [r3, #100]	@ 0x64
 8004de2:	6e5e      	ldr	r6, [r3, #100]	@ 0x64
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 8004de4:	f3c6 6684 	ubfx	r6, r6, #26, #5
 8004de8:	42a6      	cmp	r6, r4
 8004dea:	d03b      	beq.n	8004e64 <HAL_ADCEx_InjectedConfigChannel+0x510>
 8004dec:	68ae      	ldr	r6, [r5, #8]
 8004dee:	68ae      	ldr	r6, [r5, #8]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8004df0:	f105 0c08 	add.w	ip, r5, #8
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 8004df4:	f3c6 6684 	ubfx	r6, r6, #26, #5
 8004df8:	42a6      	cmp	r6, r4
 8004dfa:	d05c      	beq.n	8004eb6 <HAL_ADCEx_InjectedConfigChannel+0x562>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8004dfc:	68ee      	ldr	r6, [r5, #12]
 8004dfe:	68ee      	ldr	r6, [r5, #12]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8004e00:	f105 070c 	add.w	r7, r5, #12
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 8004e04:	f3c6 6584 	ubfx	r5, r6, #26, #5
 8004e08:	e7c6      	b.n	8004d98 <HAL_ADCEx_InjectedConfigChannel+0x444>
                                    (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL(
 8004e0a:	3c1e      	subs	r4, #30
 8004e0c:	0524      	lsls	r4, r4, #20
 8004e0e:	f044 7400 	orr.w	r4, r4, #33554432	@ 0x2000000
 8004e12:	e708      	b.n	8004c26 <HAL_ADCEx_InjectedConfigChannel+0x2d2>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8004e14:	6dd5      	ldr	r5, [r2, #92]	@ 0x5c
 8004e16:	f045 0520 	orr.w	r5, r5, #32
 8004e1a:	65d5      	str	r5, [r2, #92]	@ 0x5c
        tmp_hal_status = HAL_ERROR;
 8004e1c:	e648      	b.n	8004ab0 <HAL_ADCEx_InjectedConfigChannel+0x15c>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004e1e:	fa94 f5a4 	rbit	r5, r4
  if (value == 0U)
 8004e22:	2d00      	cmp	r5, #0
 8004e24:	d071      	beq.n	8004f0a <HAL_ADCEx_InjectedConfigChannel+0x5b6>
  return __builtin_clz(value);
 8004e26:	fab5 f585 	clz	r5, r5
                                    (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL(
 8004e2a:	3501      	adds	r5, #1
 8004e2c:	06ad      	lsls	r5, r5, #26
 8004e2e:	f005 45f8 	and.w	r5, r5, #2080374784	@ 0x7c000000
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004e32:	fa94 f6a4 	rbit	r6, r4
  if (value == 0U)
 8004e36:	2e00      	cmp	r6, #0
 8004e38:	d065      	beq.n	8004f06 <HAL_ADCEx_InjectedConfigChannel+0x5b2>
  return __builtin_clz(value);
 8004e3a:	fab6 f686 	clz	r6, r6
 8004e3e:	3601      	adds	r6, #1
 8004e40:	f006 061f 	and.w	r6, r6, #31
 8004e44:	2701      	movs	r7, #1
 8004e46:	fa07 f606 	lsl.w	r6, r7, r6
 8004e4a:	4335      	orrs	r5, r6
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004e4c:	fa94 f4a4 	rbit	r4, r4
  if (value == 0U)
 8004e50:	2c00      	cmp	r4, #0
 8004e52:	d053      	beq.n	8004efc <HAL_ADCEx_InjectedConfigChannel+0x5a8>
  return __builtin_clz(value);
 8004e54:	fab4 f484 	clz	r4, r4
 8004e58:	3401      	adds	r4, #1
 8004e5a:	f004 041f 	and.w	r4, r4, #31
 8004e5e:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 8004e62:	e6df      	b.n	8004c24 <HAL_ADCEx_InjectedConfigChannel+0x2d0>
 8004e64:	f105 0808 	add.w	r8, r5, #8
  MODIFY_REG(*preg,
 8004e68:	6e5c      	ldr	r4, [r3, #100]	@ 0x64
 8004e6a:	f024 4400 	bic.w	r4, r4, #2147483648	@ 0x80000000
 8004e6e:	665c      	str	r4, [r3, #100]	@ 0x64
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfigInjected->InjectedChannel))
 8004e70:	f8d1 e000 	ldr.w	lr, [r1]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8004e74:	68ac      	ldr	r4, [r5, #8]
 8004e76:	68ae      	ldr	r6, [r5, #8]
 8004e78:	f3ce 0712 	ubfx	r7, lr, #0, #19
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8004e7c:	46c4      	mov	ip, r8
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 8004e7e:	f3c6 6684 	ubfx	r6, r6, #26, #5
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfigInjected->InjectedChannel))
 8004e82:	4674      	mov	r4, lr
 8004e84:	2f00      	cmp	r7, #0
 8004e86:	f47f af6f 	bne.w	8004d68 <HAL_ADCEx_InjectedConfigChannel+0x414>
 8004e8a:	f3ce 6484 	ubfx	r4, lr, #26, #5
 8004e8e:	e7b3      	b.n	8004df8 <HAL_ADCEx_InjectedConfigChannel+0x4a4>
  MODIFY_REG(*preg,
 8004e90:	6e1c      	ldr	r4, [r3, #96]	@ 0x60
 8004e92:	f024 4400 	bic.w	r4, r4, #2147483648	@ 0x80000000
 8004e96:	661c      	str	r4, [r3, #96]	@ 0x60
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfigInjected->InjectedChannel))
 8004e98:	f8d1 e000 	ldr.w	lr, [r1]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8004e9c:	6e5c      	ldr	r4, [r3, #100]	@ 0x64
 8004e9e:	6e5e      	ldr	r6, [r3, #100]	@ 0x64
 8004ea0:	f3ce 0712 	ubfx	r7, lr, #0, #19
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 8004ea4:	f3c6 6684 	ubfx	r6, r6, #26, #5
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfigInjected->InjectedChannel))
 8004ea8:	4674      	mov	r4, lr
 8004eaa:	2f00      	cmp	r7, #0
 8004eac:	f47f af4d 	bne.w	8004d4a <HAL_ADCEx_InjectedConfigChannel+0x3f6>
 8004eb0:	f3ce 6484 	ubfx	r4, lr, #26, #5
 8004eb4:	e798      	b.n	8004de8 <HAL_ADCEx_InjectedConfigChannel+0x494>
 8004eb6:	f105 090c 	add.w	r9, r5, #12
  MODIFY_REG(*preg,
 8004eba:	f8dc 4000 	ldr.w	r4, [ip]
 8004ebe:	f024 4400 	bic.w	r4, r4, #2147483648	@ 0x80000000
 8004ec2:	f8cc 4000 	str.w	r4, [ip]
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfigInjected->InjectedChannel))
 8004ec6:	f8d1 e000 	ldr.w	lr, [r1]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8004eca:	68ec      	ldr	r4, [r5, #12]
 8004ecc:	68ed      	ldr	r5, [r5, #12]
 8004ece:	f3ce 0612 	ubfx	r6, lr, #0, #19
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8004ed2:	464f      	mov	r7, r9
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 8004ed4:	f3c5 6584 	ubfx	r5, r5, #26, #5
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfigInjected->InjectedChannel))
 8004ed8:	4674      	mov	r4, lr
 8004eda:	2e00      	cmp	r6, #0
 8004edc:	f47f af55 	bne.w	8004d8a <HAL_ADCEx_InjectedConfigChannel+0x436>
 8004ee0:	f3ce 6484 	ubfx	r4, lr, #26, #5
 8004ee4:	e758      	b.n	8004d98 <HAL_ADCEx_InjectedConfigChannel+0x444>
  MODIFY_REG(*preg,
 8004ee6:	683c      	ldr	r4, [r7, #0]
 8004ee8:	f024 4400 	bic.w	r4, r4, #2147483648	@ 0x80000000
 8004eec:	603c      	str	r4, [r7, #0]
    LL_ADC_SetChannelSingleDiff(hadc->Instance, pConfigInjected->InjectedChannel, pConfigInjected->InjectedSingleDiff);
 8004eee:	680c      	ldr	r4, [r1, #0]
}
 8004ef0:	e577      	b.n	80049e2 <HAL_ADCEx_InjectedConfigChannel+0x8e>
 8004ef2:	2602      	movs	r6, #2
 8004ef4:	e701      	b.n	8004cfa <HAL_ADCEx_InjectedConfigChannel+0x3a6>
 8004ef6:	f04f 6580 	mov.w	r5, #67108864	@ 0x4000000
 8004efa:	e6f1      	b.n	8004ce0 <HAL_ADCEx_InjectedConfigChannel+0x38c>
 8004efc:	f44f 1440 	mov.w	r4, #3145728	@ 0x300000
 8004f00:	e691      	b.n	8004c26 <HAL_ADCEx_InjectedConfigChannel+0x2d2>
 8004f02:	4c03      	ldr	r4, [pc, #12]	@ (8004f10 <HAL_ADCEx_InjectedConfigChannel+0x5bc>)
 8004f04:	e68f      	b.n	8004c26 <HAL_ADCEx_InjectedConfigChannel+0x2d2>
 8004f06:	2602      	movs	r6, #2
 8004f08:	e79f      	b.n	8004e4a <HAL_ADCEx_InjectedConfigChannel+0x4f6>
 8004f0a:	f04f 6580 	mov.w	r5, #67108864	@ 0x4000000
 8004f0e:	e790      	b.n	8004e32 <HAL_ADCEx_InjectedConfigChannel+0x4de>
 8004f10:	fe500000 	.word	0xfe500000

08004f14 <HAL_ADCEx_MultiModeConfigChannel>:
  * @param hadc Master ADC handle
  * @param pMultimode Structure of ADC multimode configuration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_MultiModeConfigChannel(ADC_HandleTypeDef *hadc, const ADC_MultiModeTypeDef *pMultimode)
{
 8004f14:	b4f0      	push	{r4, r5, r6, r7}
    assert_param(IS_ADC_DMA_ACCESS_MULTIMODE(pMultimode->DMAAccessMode));
    assert_param(IS_ADC_SAMPLING_DELAY(pMultimode->TwoSamplingDelay));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 8004f16:	f890 2058 	ldrb.w	r2, [r0, #88]	@ 0x58
  if (pMultimode->Mode != ADC_MODE_INDEPENDENT)
 8004f1a:	680d      	ldr	r5, [r1, #0]
  __HAL_LOCK(hadc);
 8004f1c:	2a01      	cmp	r2, #1
{
 8004f1e:	b09c      	sub	sp, #112	@ 0x70
  __HAL_LOCK(hadc);
 8004f20:	d042      	beq.n	8004fa8 <HAL_ADCEx_MultiModeConfigChannel+0x94>

  /* Temporary handle minimum initialization */
  __HAL_ADC_RESET_HANDLE_STATE(&tmp_hadc_slave);
  ADC_CLEAR_ERRORCODE(&tmp_hadc_slave);

  ADC_MULTI_SLAVE(hadc, &tmp_hadc_slave);
 8004f22:	6804      	ldr	r4, [r0, #0]
 8004f24:	4603      	mov	r3, r0
  __HAL_ADC_RESET_HANDLE_STATE(&tmp_hadc_slave);
 8004f26:	2200      	movs	r2, #0
  __HAL_LOCK(hadc);
 8004f28:	2001      	movs	r0, #1
  ADC_MULTI_SLAVE(hadc, &tmp_hadc_slave);
 8004f2a:	f1b4 4fa0 	cmp.w	r4, #1342177280	@ 0x50000000
  __HAL_ADC_RESET_HANDLE_STATE(&tmp_hadc_slave);
 8004f2e:	9218      	str	r2, [sp, #96]	@ 0x60
  __HAL_LOCK(hadc);
 8004f30:	f883 0058 	strb.w	r0, [r3, #88]	@ 0x58
  ADC_CLEAR_ERRORCODE(&tmp_hadc_slave);
 8004f34:	9219      	str	r2, [sp, #100]	@ 0x64
  ADC_MULTI_SLAVE(hadc, &tmp_hadc_slave);
 8004f36:	d008      	beq.n	8004f4a <HAL_ADCEx_MultiModeConfigChannel+0x36>

  if (tmp_hadc_slave.Instance == NULL)
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8004f38:	6dd9      	ldr	r1, [r3, #92]	@ 0x5c

    /* Process unlocked */
    __HAL_UNLOCK(hadc);
 8004f3a:	f883 2058 	strb.w	r2, [r3, #88]	@ 0x58
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8004f3e:	f041 0120 	orr.w	r1, r1, #32
 8004f42:	65d9      	str	r1, [r3, #92]	@ 0x5c
  /* Process unlocked */
  __HAL_UNLOCK(hadc);

  /* Return function status */
  return tmp_hal_status;
}
 8004f44:	b01c      	add	sp, #112	@ 0x70
 8004f46:	bcf0      	pop	{r4, r5, r6, r7}
 8004f48:	4770      	bx	lr
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8004f4a:	4a23      	ldr	r2, [pc, #140]	@ (8004fd8 <HAL_ADCEx_MultiModeConfigChannel+0xc4>)
 8004f4c:	6890      	ldr	r0, [r2, #8]
 8004f4e:	0740      	lsls	r0, r0, #29
 8004f50:	d50b      	bpl.n	8004f6a <HAL_ADCEx_MultiModeConfigChannel+0x56>
 8004f52:	68a2      	ldr	r2, [r4, #8]
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8004f54:	6dda      	ldr	r2, [r3, #92]	@ 0x5c
 8004f56:	f042 0220 	orr.w	r2, r2, #32
    tmp_hal_status = HAL_ERROR;
 8004f5a:	2001      	movs	r0, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8004f5c:	65da      	str	r2, [r3, #92]	@ 0x5c
  __HAL_UNLOCK(hadc);
 8004f5e:	2200      	movs	r2, #0
 8004f60:	f883 2058 	strb.w	r2, [r3, #88]	@ 0x58
}
 8004f64:	b01c      	add	sp, #112	@ 0x70
 8004f66:	bcf0      	pop	{r4, r5, r6, r7}
 8004f68:	4770      	bx	lr
 8004f6a:	68a0      	ldr	r0, [r4, #8]
 8004f6c:	0746      	lsls	r6, r0, #29
 8004f6e:	d4f1      	bmi.n	8004f54 <HAL_ADCEx_MultiModeConfigChannel+0x40>
    if (pMultimode->Mode != ADC_MODE_INDEPENDENT)
 8004f70:	b1f5      	cbz	r5, 8004fb0 <HAL_ADCEx_MultiModeConfigChannel+0x9c>
      MODIFY_REG(tmpADC_Common->CCR, ADC_CCR_MDMA | ADC_CCR_DMACFG,
 8004f72:	4e1a      	ldr	r6, [pc, #104]	@ (8004fdc <HAL_ADCEx_MultiModeConfigChannel+0xc8>)
 8004f74:	684f      	ldr	r7, [r1, #4]
 8004f76:	68b0      	ldr	r0, [r6, #8]
 8004f78:	f893 c038 	ldrb.w	ip, [r3, #56]	@ 0x38
 8004f7c:	f420 4060 	bic.w	r0, r0, #57344	@ 0xe000
 8004f80:	4338      	orrs	r0, r7
 8004f82:	ea40 304c 	orr.w	r0, r0, ip, lsl #13
 8004f86:	60b0      	str	r0, [r6, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8004f88:	68a0      	ldr	r0, [r4, #8]
 8004f8a:	6892      	ldr	r2, [r2, #8]
 8004f8c:	07c0      	lsls	r0, r0, #31
 8004f8e:	d420      	bmi.n	8004fd2 <HAL_ADCEx_MultiModeConfigChannel+0xbe>
 8004f90:	07d7      	lsls	r7, r2, #31
 8004f92:	d41e      	bmi.n	8004fd2 <HAL_ADCEx_MultiModeConfigChannel+0xbe>
        MODIFY_REG(tmpADC_Common->CCR,
 8004f94:	68b0      	ldr	r0, [r6, #8]
 8004f96:	688a      	ldr	r2, [r1, #8]
 8004f98:	f420 6171 	bic.w	r1, r0, #3856	@ 0xf10
 8004f9c:	432a      	orrs	r2, r5
 8004f9e:	f021 010f 	bic.w	r1, r1, #15
 8004fa2:	430a      	orrs	r2, r1
 8004fa4:	60b2      	str	r2, [r6, #8]
 8004fa6:	e014      	b.n	8004fd2 <HAL_ADCEx_MultiModeConfigChannel+0xbe>
  __HAL_LOCK(hadc);
 8004fa8:	2002      	movs	r0, #2
}
 8004faa:	b01c      	add	sp, #112	@ 0x70
 8004fac:	bcf0      	pop	{r4, r5, r6, r7}
 8004fae:	4770      	bx	lr
      CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_MDMA | ADC_CCR_DMACFG);
 8004fb0:	480a      	ldr	r0, [pc, #40]	@ (8004fdc <HAL_ADCEx_MultiModeConfigChannel+0xc8>)
 8004fb2:	6881      	ldr	r1, [r0, #8]
 8004fb4:	f421 4160 	bic.w	r1, r1, #57344	@ 0xe000
 8004fb8:	6081      	str	r1, [r0, #8]
 8004fba:	68a1      	ldr	r1, [r4, #8]
 8004fbc:	6892      	ldr	r2, [r2, #8]
 8004fbe:	07cd      	lsls	r5, r1, #31
 8004fc0:	d407      	bmi.n	8004fd2 <HAL_ADCEx_MultiModeConfigChannel+0xbe>
 8004fc2:	07d4      	lsls	r4, r2, #31
 8004fc4:	d405      	bmi.n	8004fd2 <HAL_ADCEx_MultiModeConfigChannel+0xbe>
        CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DUAL | ADC_CCR_DELAY);
 8004fc6:	6882      	ldr	r2, [r0, #8]
 8004fc8:	f422 6271 	bic.w	r2, r2, #3856	@ 0xf10
 8004fcc:	f022 020f 	bic.w	r2, r2, #15
 8004fd0:	6082      	str	r2, [r0, #8]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8004fd2:	2000      	movs	r0, #0
 8004fd4:	e7c3      	b.n	8004f5e <HAL_ADCEx_MultiModeConfigChannel+0x4a>
 8004fd6:	bf00      	nop
 8004fd8:	50000100 	.word	0x50000100
 8004fdc:	50000300 	.word	0x50000300

08004fe0 <HAL_CORDIC_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CORDIC_Init(CORDIC_HandleTypeDef *hcordic)
{
  /* Check the CORDIC handle allocation */
  if (hcordic == NULL)
 8004fe0:	b1b0      	cbz	r0, 8005010 <HAL_CORDIC_Init+0x30>
{
 8004fe2:	b510      	push	{r4, lr}

    /* Initialize the low level hardware */
    hcordic->MspInitCallback(hcordic);
  }
#else
  if (hcordic->State == HAL_CORDIC_STATE_RESET)
 8004fe4:	f890 3021 	ldrb.w	r3, [r0, #33]	@ 0x21
 8004fe8:	4604      	mov	r4, r0
 8004fea:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 8004fee:	b153      	cbz	r3, 8005006 <HAL_CORDIC_Init+0x26>
    HAL_CORDIC_MspInit(hcordic);
  }
#endif /* (USE_HAL_CORDIC_REGISTER_CALLBACKS) */

  /* Set CORDIC error code to none */
  hcordic->ErrorCode = HAL_CORDIC_ERROR_NONE;
 8004ff0:	2000      	movs	r0, #0

  /* Reset DMADirection */
  hcordic->DMADirection = CORDIC_DMA_DIR_NONE;

  /* Change CORDIC peripheral state */
  hcordic->State = HAL_CORDIC_STATE_READY;
 8004ff2:	2301      	movs	r3, #1
  hcordic->ErrorCode = HAL_CORDIC_ERROR_NONE;
 8004ff4:	6260      	str	r0, [r4, #36]	@ 0x24
  hcordic->State = HAL_CORDIC_STATE_READY;
 8004ff6:	f884 3021 	strb.w	r3, [r4, #33]	@ 0x21
  hcordic->pInBuff = NULL;
 8004ffa:	e9c4 0001 	strd	r0, r0, [r4, #4]
  hcordic->NbCalcToOrder = 0U;
 8004ffe:	e9c4 0003 	strd	r0, r0, [r4, #12]
  hcordic->DMADirection = CORDIC_DMA_DIR_NONE;
 8005002:	6160      	str	r0, [r4, #20]

  /* Return function status */
  return HAL_OK;
}
 8005004:	bd10      	pop	{r4, pc}
    hcordic->Lock = HAL_UNLOCKED;
 8005006:	f880 2020 	strb.w	r2, [r0, #32]
    HAL_CORDIC_MspInit(hcordic);
 800500a:	f7fe fef7 	bl	8003dfc <HAL_CORDIC_MspInit>
 800500e:	e7ef      	b.n	8004ff0 <HAL_CORDIC_Init+0x10>
    return HAL_ERROR;
 8005010:	2001      	movs	r0, #1
}
 8005012:	4770      	bx	lr

08005014 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8005014:	4907      	ldr	r1, [pc, #28]	@ (8005034 <HAL_NVIC_SetPriorityGrouping+0x20>)
 8005016:	68ca      	ldr	r2, [r1, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8005018:	0203      	lsls	r3, r0, #8
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800501a:	f64f 00ff 	movw	r0, #63743	@ 0xf8ff
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800501e:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8005022:	4002      	ands	r2, r0
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8005024:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8005026:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 800502a:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
  SCB->AIRCR =  reg_value;
 800502e:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 8005030:	4770      	bx	lr
 8005032:	bf00      	nop
 8005034:	e000ed00 	.word	0xe000ed00

08005038 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8005038:	4b1b      	ldr	r3, [pc, #108]	@ (80050a8 <HAL_NVIC_SetPriority+0x70>)
 800503a:	68db      	ldr	r3, [r3, #12]
 800503c:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8005040:	b500      	push	{lr}
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8005042:	f1c3 0e07 	rsb	lr, r3, #7
 8005046:	f1be 0f04 	cmp.w	lr, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800504a:	f103 0c04 	add.w	ip, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800504e:	bf28      	it	cs
 8005050:	f04f 0e04 	movcs.w	lr, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8005054:	f1bc 0f06 	cmp.w	ip, #6
 8005058:	d91c      	bls.n	8005094 <HAL_NVIC_SetPriority+0x5c>
 800505a:	f1a3 0c03 	sub.w	ip, r3, #3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800505e:	f04f 33ff 	mov.w	r3, #4294967295
 8005062:	fa03 f30c 	lsl.w	r3, r3, ip
 8005066:	ea22 0203 	bic.w	r2, r2, r3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800506a:	f04f 33ff 	mov.w	r3, #4294967295
 800506e:	fa03 f30e 	lsl.w	r3, r3, lr
 8005072:	ea21 0303 	bic.w	r3, r1, r3
 8005076:	fa03 f30c 	lsl.w	r3, r3, ip
 800507a:	4313      	orrs	r3, r2
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800507c:	011b      	lsls	r3, r3, #4
  if ((int32_t)(IRQn) >= 0)
 800507e:	2800      	cmp	r0, #0
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8005080:	b2db      	uxtb	r3, r3
  if ((int32_t)(IRQn) >= 0)
 8005082:	db0a      	blt.n	800509a <HAL_NVIC_SetPriority+0x62>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8005084:	f100 4060 	add.w	r0, r0, #3758096384	@ 0xe0000000
 8005088:	f500 4061 	add.w	r0, r0, #57600	@ 0xe100
 800508c:	f880 3300 	strb.w	r3, [r0, #768]	@ 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8005090:	f85d fb04 	ldr.w	pc, [sp], #4
 8005094:	2200      	movs	r2, #0
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8005096:	4694      	mov	ip, r2
 8005098:	e7e7      	b.n	800506a <HAL_NVIC_SetPriority+0x32>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800509a:	4a04      	ldr	r2, [pc, #16]	@ (80050ac <HAL_NVIC_SetPriority+0x74>)
 800509c:	f000 000f 	and.w	r0, r0, #15
 80050a0:	4402      	add	r2, r0
 80050a2:	7613      	strb	r3, [r2, #24]
 80050a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80050a8:	e000ed00 	.word	0xe000ed00
 80050ac:	e000ecfc 	.word	0xe000ecfc

080050b0 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 80050b0:	2800      	cmp	r0, #0
 80050b2:	db07      	blt.n	80050c4 <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80050b4:	4a04      	ldr	r2, [pc, #16]	@ (80050c8 <HAL_NVIC_EnableIRQ+0x18>)
 80050b6:	0941      	lsrs	r1, r0, #5
 80050b8:	2301      	movs	r3, #1
 80050ba:	f000 001f 	and.w	r0, r0, #31
 80050be:	4083      	lsls	r3, r0
 80050c0:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 80050c4:	4770      	bx	lr
 80050c6:	bf00      	nop
 80050c8:	e000e100 	.word	0xe000e100

080050cc <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 80050cc:	3801      	subs	r0, #1
 80050ce:	f1b0 7f80 	cmp.w	r0, #16777216	@ 0x1000000
 80050d2:	d301      	bcc.n	80050d8 <HAL_SYSTICK_Config+0xc>
  {
    return (1UL);                                                   /* Reload value impossible */
 80050d4:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 80050d6:	4770      	bx	lr
{
 80050d8:	b410      	push	{r4}
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80050da:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80050de:	4c07      	ldr	r4, [pc, #28]	@ (80050fc <HAL_SYSTICK_Config+0x30>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80050e0:	6158      	str	r0, [r3, #20]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80050e2:	f04f 0cf0 	mov.w	ip, #240	@ 0xf0
 80050e6:	f884 c023 	strb.w	ip, [r4, #35]	@ 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80050ea:	2200      	movs	r2, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80050ec:	2107      	movs	r1, #7
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 80050ee:	4610      	mov	r0, r2
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80050f0:	619a      	str	r2, [r3, #24]
}
 80050f2:	f85d 4b04 	ldr.w	r4, [sp], #4
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80050f6:	6119      	str	r1, [r3, #16]
 80050f8:	4770      	bx	lr
 80050fa:	bf00      	nop
 80050fc:	e000ed00 	.word	0xe000ed00

08005100 <HAL_DMA_Init>:
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
  uint32_t tmp;

  /* Check the DMA handle allocation */
  if (hdma == NULL)
 8005100:	2800      	cmp	r0, #0
 8005102:	d076      	beq.n	80051f2 <HAL_DMA_Init+0xf2>
{
 8005104:	b4f0      	push	{r4, r5, r6, r7}
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));

  assert_param(IS_DMA_ALL_REQUEST(hdma->Init.Request));

  /* Compute the channel index */
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 8005106:	4a3c      	ldr	r2, [pc, #240]	@ (80051f8 <HAL_DMA_Init+0xf8>)
 8005108:	6804      	ldr	r4, [r0, #0]
 800510a:	4294      	cmp	r4, r2
 800510c:	4603      	mov	r3, r0
 800510e:	d95c      	bls.n	80051ca <HAL_DMA_Init+0xca>
    hdma->DmaBaseAddress = DMA1;
  }
  else
  {
    /* DMA2 */
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2;
 8005110:	493a      	ldr	r1, [pc, #232]	@ (80051fc <HAL_DMA_Init+0xfc>)
 8005112:	4a3b      	ldr	r2, [pc, #236]	@ (8005200 <HAL_DMA_Init+0x100>)
    hdma->DmaBaseAddress = DMA2;
 8005114:	483b      	ldr	r0, [pc, #236]	@ (8005204 <HAL_DMA_Init+0x104>)
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2;
 8005116:	4421      	add	r1, r4
 8005118:	fba2 2101 	umull	r2, r1, r2, r1
 800511c:	0909      	lsrs	r1, r1, #4
 800511e:	0089      	lsls	r1, r1, #2
  }

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 8005120:	2202      	movs	r2, #2
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  |
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   |
                      DMA_CCR_DIR   | DMA_CCR_MEM2MEM));

  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 8005122:	689d      	ldr	r5, [r3, #8]
  hdma->State = HAL_DMA_STATE_BUSY;
 8005124:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25
  tmp |=  hdma->Init.Direction        |
 8005128:	68da      	ldr	r2, [r3, #12]
#else
    DMAMUX1_ChannelBase = DMAMUX1_Channel7;
#endif /* STM32G4x1xx) */
  }
  dmamux_base_addr = (uint32_t)DMAMUX1_ChannelBase;
  channel_number = (((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U;
 800512a:	4e35      	ldr	r6, [pc, #212]	@ (8005200 <HAL_DMA_Init+0x100>)
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
 800512c:	4f36      	ldr	r7, [pc, #216]	@ (8005208 <HAL_DMA_Init+0x108>)
 800512e:	e9c3 0110 	strd	r0, r1, [r3, #64]	@ 0x40
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8005132:	6918      	ldr	r0, [r3, #16]
  tmp |=  hdma->Init.Direction        |
 8005134:	432a      	orrs	r2, r5
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8005136:	4302      	orrs	r2, r0
 8005138:	6958      	ldr	r0, [r3, #20]
 800513a:	4302      	orrs	r2, r0
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800513c:	6998      	ldr	r0, [r3, #24]
 800513e:	4302      	orrs	r2, r0
  tmp = hdma->Instance->CCR;
 8005140:	6820      	ldr	r0, [r4, #0]
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  |
 8005142:	f420 4cff 	bic.w	ip, r0, #32640	@ 0x7f80
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8005146:	69d8      	ldr	r0, [r3, #28]
 8005148:	4302      	orrs	r2, r0
  channel_number = (((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U;
 800514a:	b2e0      	uxtb	r0, r4
 800514c:	3808      	subs	r0, #8
 800514e:	fba6 6000 	umull	r6, r0, r6, r0
          hdma->Init.Mode                | hdma->Init.Priority;
 8005152:	6a1e      	ldr	r6, [r3, #32]
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  |
 8005154:	f02c 0c70 	bic.w	ip, ip, #112	@ 0x70
          hdma->Init.Mode                | hdma->Init.Priority;
 8005158:	4332      	orrs	r2, r6
  tmp |=  hdma->Init.Direction        |
 800515a:	ea42 020c 	orr.w	r2, r2, ip
  hdma->Instance->CCR = tmp;
 800515e:	6022      	str	r2, [r4, #0]
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
 8005160:	4e25      	ldr	r6, [pc, #148]	@ (80051f8 <HAL_DMA_Init+0xf8>)
 8005162:	4a2a      	ldr	r2, [pc, #168]	@ (800520c <HAL_DMA_Init+0x10c>)
  hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)(uint32_t)(dmamux_base_addr + ((hdma->ChannelIndex >> 2U) * ((uint32_t)DMAMUX1_Channel1 - (uint32_t)DMAMUX1_Channel0)));
  hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 8005164:	f3c0 1004 	ubfx	r0, r0, #4, #5
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
 8005168:	42b4      	cmp	r4, r6
 800516a:	bf98      	it	ls
 800516c:	463a      	movls	r2, r7
  hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 800516e:	f206 4679 	addw	r6, r6, #1145	@ 0x479
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 8005172:	2401      	movs	r4, #1
 8005174:	fa04 f000 	lsl.w	r0, r4, r0
  hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 8005178:	64de      	str	r6, [r3, #76]	@ 0x4c
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 800517a:	f5b5 4f80 	cmp.w	r5, #16384	@ 0x4000
  hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)(uint32_t)(dmamux_base_addr + ((hdma->ChannelIndex >> 2U) * ((uint32_t)DMAMUX1_Channel1 - (uint32_t)DMAMUX1_Channel0)));
 800517e:	eb01 0602 	add.w	r6, r1, r2
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 8005182:	6518      	str	r0, [r3, #80]	@ 0x50
  hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)(uint32_t)(dmamux_base_addr + ((hdma->ChannelIndex >> 2U) * ((uint32_t)DMAMUX1_Channel1 - (uint32_t)DMAMUX1_Channel0)));
 8005184:	649e      	str	r6, [r3, #72]	@ 0x48
 8005186:	ea4f 0191 	mov.w	r1, r1, lsr #2
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 800518a:	d027      	beq.n	80051dc <HAL_DMA_Init+0xdc>
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 800518c:	685e      	ldr	r6, [r3, #4]
 800518e:	b2f5      	uxtb	r5, r6
  if (((hdma->Init.Request >  0U) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 8005190:	3e01      	subs	r6, #1
 8005192:	2e03      	cmp	r6, #3
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 8005194:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8005198:	f8c7 0084 	str.w	r0, [r7, #132]	@ 0x84
  if (((hdma->Init.Request >  0U) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 800519c:	d824      	bhi.n	80051e8 <HAL_DMA_Init+0xe8>
static void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma)
{
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;

  /* DMA Channels are connected to DMAMUX1 request generator blocks*/
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 800519e:	4a1c      	ldr	r2, [pc, #112]	@ (8005210 <HAL_DMA_Init+0x110>)

  hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 80051a0:	481c      	ldr	r0, [pc, #112]	@ (8005214 <HAL_DMA_Init+0x114>)
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 80051a2:	442a      	add	r2, r5
 80051a4:	0092      	lsls	r2, r2, #2

  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x1FU);
 80051a6:	3d01      	subs	r5, #1
 80051a8:	40ac      	lsls	r4, r5
    hdma->DMAmuxRequestGen->RGCR = 0U;
 80051aa:	2100      	movs	r1, #0
  hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 80051ac:	e9c3 2015 	strd	r2, r0, [r3, #84]	@ 0x54
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x1FU);
 80051b0:	65dc      	str	r4, [r3, #92]	@ 0x5c
    hdma->DMAmuxRequestGen->RGCR = 0U;
 80051b2:	6011      	str	r1, [r2, #0]
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 80051b4:	4a18      	ldr	r2, [pc, #96]	@ (8005218 <HAL_DMA_Init+0x118>)
 80051b6:	6454      	str	r4, [r2, #68]	@ 0x44
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80051b8:	2000      	movs	r0, #0
  hdma->State  = HAL_DMA_STATE_READY;
 80051ba:	2201      	movs	r2, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80051bc:	63d8      	str	r0, [r3, #60]	@ 0x3c
  hdma->Lock = HAL_UNLOCKED;
 80051be:	f883 0024 	strb.w	r0, [r3, #36]	@ 0x24
  hdma->State  = HAL_DMA_STATE_READY;
 80051c2:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25
}
 80051c6:	bcf0      	pop	{r4, r5, r6, r7}
 80051c8:	4770      	bx	lr
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
 80051ca:	4914      	ldr	r1, [pc, #80]	@ (800521c <HAL_DMA_Init+0x11c>)
 80051cc:	4a0c      	ldr	r2, [pc, #48]	@ (8005200 <HAL_DMA_Init+0x100>)
    hdma->DmaBaseAddress = DMA1;
 80051ce:	4814      	ldr	r0, [pc, #80]	@ (8005220 <HAL_DMA_Init+0x120>)
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
 80051d0:	4421      	add	r1, r4
 80051d2:	fba2 2101 	umull	r2, r1, r2, r1
 80051d6:	0909      	lsrs	r1, r1, #4
 80051d8:	0089      	lsls	r1, r1, #2
    hdma->DmaBaseAddress = DMA1;
 80051da:	e7a1      	b.n	8005120 <HAL_DMA_Init+0x20>
    hdma->Init.Request = DMA_REQUEST_MEM2MEM;
 80051dc:	2400      	movs	r4, #0
 80051de:	605c      	str	r4, [r3, #4]
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 80051e0:	f842 4021 	str.w	r4, [r2, r1, lsl #2]
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 80051e4:	f8c7 0084 	str.w	r0, [r7, #132]	@ 0x84
    hdma->DMAmuxRequestGen = 0U;
 80051e8:	2200      	movs	r2, #0
 80051ea:	e9c3 2215 	strd	r2, r2, [r3, #84]	@ 0x54
    hdma->DMAmuxRequestGenStatusMask = 0U;
 80051ee:	65da      	str	r2, [r3, #92]	@ 0x5c
 80051f0:	e7e2      	b.n	80051b8 <HAL_DMA_Init+0xb8>
    return HAL_ERROR;
 80051f2:	2001      	movs	r0, #1
}
 80051f4:	4770      	bx	lr
 80051f6:	bf00      	nop
 80051f8:	40020407 	.word	0x40020407
 80051fc:	bffdfbf8 	.word	0xbffdfbf8
 8005200:	cccccccd 	.word	0xcccccccd
 8005204:	40020400 	.word	0x40020400
 8005208:	40020800 	.word	0x40020800
 800520c:	40020820 	.word	0x40020820
 8005210:	1000823f 	.word	0x1000823f
 8005214:	40020940 	.word	0x40020940
 8005218:	40020900 	.word	0x40020900
 800521c:	bffdfff8 	.word	0xbffdfff8
 8005220:	40020000 	.word	0x40020000

08005224 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8005224:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0U)
 8005228:	680c      	ldr	r4, [r1, #0]
{
 800522a:	b085      	sub	sp, #20
  while (((GPIO_Init->Pin) >> position) != 0U)
 800522c:	2c00      	cmp	r4, #0
 800522e:	f000 8089 	beq.w	8005344 <HAL_GPIO_Init+0x120>
  uint32_t position = 0x00U;
 8005232:	2300      	movs	r3, #0
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 8005234:	f04f 0b01 	mov.w	fp, #1
 8005238:	fa0b fe03 	lsl.w	lr, fp, r3

    if (iocurrent != 0x00u)
 800523c:	ea1e 0a04 	ands.w	sl, lr, r4
 8005240:	d07b      	beq.n	800533a <HAL_GPIO_Init+0x116>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) ||
 8005242:	684d      	ldr	r5, [r1, #4]
 8005244:	f005 0203 	and.w	r2, r5, #3
 8005248:	ea4f 0c43 	mov.w	ip, r3, lsl #1
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 800524c:	2603      	movs	r6, #3
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) ||
 800524e:	f102 38ff 	add.w	r8, r2, #4294967295
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8005252:	fa06 f70c 	lsl.w	r7, r6, ip
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) ||
 8005256:	f1b8 0f01 	cmp.w	r8, #1
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 800525a:	ea6f 0707 	mvn.w	r7, r7
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) ||
 800525e:	d974      	bls.n	800534a <HAL_GPIO_Init+0x126>
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
        GPIOx->OTYPER = temp;
      }

      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 8005260:	2a03      	cmp	r2, #3
 8005262:	f040 80b0 	bne.w	80053c6 <HAL_GPIO_Init+0x1a2>
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8005266:	fa02 f20c 	lsl.w	r2, r2, ip
      temp = GPIOx->MODER;
 800526a:	f8d0 c000 	ldr.w	ip, [r0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 800526e:	ea0c 0707 	and.w	r7, ip, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8005272:	433a      	orrs	r2, r7
      GPIOx->MODER = temp;

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 8005274:	f415 3f40 	tst.w	r5, #196608	@ 0x30000
      GPIOx->MODER = temp;
 8005278:	6002      	str	r2, [r0, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 800527a:	d05e      	beq.n	800533a <HAL_GPIO_Init+0x116>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800527c:	4f66      	ldr	r7, [pc, #408]	@ (8005418 <HAL_GPIO_Init+0x1f4>)
 800527e:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8005280:	f042 0201 	orr.w	r2, r2, #1
 8005284:	663a      	str	r2, [r7, #96]	@ 0x60
 8005286:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8005288:	f002 0201 	and.w	r2, r2, #1
 800528c:	9203      	str	r2, [sp, #12]
 800528e:	9a03      	ldr	r2, [sp, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
 8005290:	f023 0203 	bic.w	r2, r3, #3
 8005294:	f102 4280 	add.w	r2, r2, #1073741824	@ 0x40000000
 8005298:	f502 3280 	add.w	r2, r2, #65536	@ 0x10000
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 800529c:	f003 0c03 	and.w	ip, r3, #3
        temp = SYSCFG->EXTICR[position >> 2U];
 80052a0:	6897      	ldr	r7, [r2, #8]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 80052a2:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 80052a6:	260f      	movs	r6, #15
 80052a8:	fa06 fe0c 	lsl.w	lr, r6, ip
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 80052ac:	f1b0 4f90 	cmp.w	r0, #1207959552	@ 0x48000000
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 80052b0:	ea27 070e 	bic.w	r7, r7, lr
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 80052b4:	d01d      	beq.n	80052f2 <HAL_GPIO_Init+0xce>
 80052b6:	4e59      	ldr	r6, [pc, #356]	@ (800541c <HAL_GPIO_Init+0x1f8>)
 80052b8:	42b0      	cmp	r0, r6
 80052ba:	f000 8097 	beq.w	80053ec <HAL_GPIO_Init+0x1c8>
 80052be:	4e58      	ldr	r6, [pc, #352]	@ (8005420 <HAL_GPIO_Init+0x1fc>)
 80052c0:	42b0      	cmp	r0, r6
 80052c2:	f000 809a 	beq.w	80053fa <HAL_GPIO_Init+0x1d6>
 80052c6:	f8df e160 	ldr.w	lr, [pc, #352]	@ 8005428 <HAL_GPIO_Init+0x204>
 80052ca:	4570      	cmp	r0, lr
 80052cc:	f000 8087 	beq.w	80053de <HAL_GPIO_Init+0x1ba>
 80052d0:	f8df e158 	ldr.w	lr, [pc, #344]	@ 800542c <HAL_GPIO_Init+0x208>
 80052d4:	4570      	cmp	r0, lr
 80052d6:	f000 8097 	beq.w	8005408 <HAL_GPIO_Init+0x1e4>
 80052da:	f8df e154 	ldr.w	lr, [pc, #340]	@ 8005430 <HAL_GPIO_Init+0x20c>
 80052de:	4570      	cmp	r0, lr
 80052e0:	bf0c      	ite	eq
 80052e2:	f04f 0e05 	moveq.w	lr, #5
 80052e6:	f04f 0e06 	movne.w	lr, #6
 80052ea:	fa0e fc0c 	lsl.w	ip, lr, ip
 80052ee:	ea47 070c 	orr.w	r7, r7, ip
        SYSCFG->EXTICR[position >> 2U] = temp;
 80052f2:	6097      	str	r7, [r2, #8]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 80052f4:	4a4b      	ldr	r2, [pc, #300]	@ (8005424 <HAL_GPIO_Init+0x200>)
 80052f6:	6892      	ldr	r2, [r2, #8]
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 80052f8:	02ee      	lsls	r6, r5, #11
        temp &= ~(iocurrent);
 80052fa:	ea6f 070a 	mvn.w	r7, sl
        {
          temp |= iocurrent;
        }
        EXTI->RTSR1 = temp;
 80052fe:	4e49      	ldr	r6, [pc, #292]	@ (8005424 <HAL_GPIO_Init+0x200>)
        temp &= ~(iocurrent);
 8005300:	bf54      	ite	pl
 8005302:	403a      	andpl	r2, r7
          temp |= iocurrent;
 8005304:	ea4a 0202 	orrmi.w	r2, sl, r2
        EXTI->RTSR1 = temp;
 8005308:	60b2      	str	r2, [r6, #8]

        temp = EXTI->FTSR1;
 800530a:	68f2      	ldr	r2, [r6, #12]
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 800530c:	02ae      	lsls	r6, r5, #10
        {
          temp |= iocurrent;
        }
        EXTI->FTSR1 = temp;
 800530e:	4e45      	ldr	r6, [pc, #276]	@ (8005424 <HAL_GPIO_Init+0x200>)
        temp &= ~(iocurrent);
 8005310:	bf54      	ite	pl
 8005312:	403a      	andpl	r2, r7
          temp |= iocurrent;
 8005314:	ea4a 0202 	orrmi.w	r2, sl, r2
        EXTI->FTSR1 = temp;
 8005318:	60f2      	str	r2, [r6, #12]

        temp = EXTI->EMR1;
 800531a:	6872      	ldr	r2, [r6, #4]
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 800531c:	03ae      	lsls	r6, r5, #14
        {
          temp |= iocurrent;
        }
        EXTI->EMR1 = temp;
 800531e:	4e41      	ldr	r6, [pc, #260]	@ (8005424 <HAL_GPIO_Init+0x200>)
        temp &= ~(iocurrent);
 8005320:	bf54      	ite	pl
 8005322:	403a      	andpl	r2, r7
          temp |= iocurrent;
 8005324:	ea4a 0202 	orrmi.w	r2, sl, r2
        EXTI->EMR1 = temp;
 8005328:	6072      	str	r2, [r6, #4]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 800532a:	6832      	ldr	r2, [r6, #0]
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 800532c:	03ed      	lsls	r5, r5, #15
        {
          temp |= iocurrent;
        }
        EXTI->IMR1 = temp;
 800532e:	4d3d      	ldr	r5, [pc, #244]	@ (8005424 <HAL_GPIO_Init+0x200>)
        temp &= ~(iocurrent);
 8005330:	bf54      	ite	pl
 8005332:	403a      	andpl	r2, r7
          temp |= iocurrent;
 8005334:	ea4a 0202 	orrmi.w	r2, sl, r2
        EXTI->IMR1 = temp;
 8005338:	602a      	str	r2, [r5, #0]
      }
    }

    position++;
 800533a:	3301      	adds	r3, #1
  while (((GPIO_Init->Pin) >> position) != 0U)
 800533c:	fa34 f203 	lsrs.w	r2, r4, r3
 8005340:	f47f af7a 	bne.w	8005238 <HAL_GPIO_Init+0x14>
  }
}
 8005344:	b005      	add	sp, #20
 8005346:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp = GPIOx->OSPEEDR;
 800534a:	f8d0 9008 	ldr.w	r9, [r0, #8]
        temp |= (GPIO_Init->Speed << (position * 2U));
 800534e:	68ce      	ldr	r6, [r1, #12]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8005350:	ea09 0907 	and.w	r9, r9, r7
        temp |= (GPIO_Init->Speed << (position * 2U));
 8005354:	fa06 f80c 	lsl.w	r8, r6, ip
 8005358:	ea48 0809 	orr.w	r8, r8, r9
        GPIOx->OSPEEDR = temp;
 800535c:	f8c0 8008 	str.w	r8, [r0, #8]
        temp = GPIOx->OTYPER;
 8005360:	f8d0 8004 	ldr.w	r8, [r0, #4]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 8005364:	688e      	ldr	r6, [r1, #8]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8005366:	ea28 080e 	bic.w	r8, r8, lr
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 800536a:	f3c5 1e00 	ubfx	lr, r5, #4, #1
 800536e:	fa0e fe03 	lsl.w	lr, lr, r3
 8005372:	ea4e 0e08 	orr.w	lr, lr, r8
        GPIOx->OTYPER = temp;
 8005376:	f8c0 e004 	str.w	lr, [r0, #4]
        temp = GPIOx->PUPDR;
 800537a:	f8d0 800c 	ldr.w	r8, [r0, #12]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 800537e:	fa06 fe0c 	lsl.w	lr, r6, ip
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8005382:	ea08 0807 	and.w	r8, r8, r7
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 8005386:	ea4e 0e08 	orr.w	lr, lr, r8
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 800538a:	2a02      	cmp	r2, #2
        GPIOx->PUPDR = temp;
 800538c:	f8c0 e00c 	str.w	lr, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8005390:	f47f af69 	bne.w	8005266 <HAL_GPIO_Init+0x42>
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 8005394:	690e      	ldr	r6, [r1, #16]
        temp = GPIOx->AFR[position >> 3U];
 8005396:	ea4f 08d3 	mov.w	r8, r3, lsr #3
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 800539a:	f003 0e07 	and.w	lr, r3, #7
 800539e:	eb00 0888 	add.w	r8, r0, r8, lsl #2
 80053a2:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 80053a6:	fa06 f60e 	lsl.w	r6, r6, lr
        temp = GPIOx->AFR[position >> 3U];
 80053aa:	f8d8 9020 	ldr.w	r9, [r8, #32]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 80053ae:	9601      	str	r6, [sp, #4]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 80053b0:	260f      	movs	r6, #15
 80053b2:	fa06 fe0e 	lsl.w	lr, r6, lr
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 80053b6:	9e01      	ldr	r6, [sp, #4]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 80053b8:	ea29 090e 	bic.w	r9, r9, lr
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 80053bc:	ea46 0e09 	orr.w	lr, r6, r9
        GPIOx->AFR[position >> 3U] = temp;
 80053c0:	f8c8 e020 	str.w	lr, [r8, #32]
 80053c4:	e74f      	b.n	8005266 <HAL_GPIO_Init+0x42>
        temp = GPIOx->PUPDR;
 80053c6:	f8d0 800c 	ldr.w	r8, [r0, #12]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 80053ca:	688e      	ldr	r6, [r1, #8]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 80053cc:	ea08 0807 	and.w	r8, r8, r7
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 80053d0:	fa06 fe0c 	lsl.w	lr, r6, ip
 80053d4:	ea4e 0e08 	orr.w	lr, lr, r8
        GPIOx->PUPDR = temp;
 80053d8:	f8c0 e00c 	str.w	lr, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 80053dc:	e743      	b.n	8005266 <HAL_GPIO_Init+0x42>
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 80053de:	f04f 0e03 	mov.w	lr, #3
 80053e2:	fa0e fc0c 	lsl.w	ip, lr, ip
 80053e6:	ea47 070c 	orr.w	r7, r7, ip
 80053ea:	e782      	b.n	80052f2 <HAL_GPIO_Init+0xce>
 80053ec:	f04f 0e01 	mov.w	lr, #1
 80053f0:	fa0e fc0c 	lsl.w	ip, lr, ip
 80053f4:	ea47 070c 	orr.w	r7, r7, ip
 80053f8:	e77b      	b.n	80052f2 <HAL_GPIO_Init+0xce>
 80053fa:	f04f 0e02 	mov.w	lr, #2
 80053fe:	fa0e fc0c 	lsl.w	ip, lr, ip
 8005402:	ea47 070c 	orr.w	r7, r7, ip
 8005406:	e774      	b.n	80052f2 <HAL_GPIO_Init+0xce>
 8005408:	f04f 0e04 	mov.w	lr, #4
 800540c:	fa0e fc0c 	lsl.w	ip, lr, ip
 8005410:	ea47 070c 	orr.w	r7, r7, ip
 8005414:	e76d      	b.n	80052f2 <HAL_GPIO_Init+0xce>
 8005416:	bf00      	nop
 8005418:	40021000 	.word	0x40021000
 800541c:	48000400 	.word	0x48000400
 8005420:	48000800 	.word	0x48000800
 8005424:	40010400 	.word	0x40010400
 8005428:	48000c00 	.word	0x48000c00
 800542c:	48001000 	.word	0x48001000
 8005430:	48001400 	.word	0x48001400

08005434 <HAL_PWREx_ControlVoltageScaling>:
  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));

  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1_BOOST)
  {
    /* If current range is range 2 */
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8005434:	4a35      	ldr	r2, [pc, #212]	@ (800550c <HAL_PWREx_ControlVoltageScaling+0xd8>)
 8005436:	6813      	ldr	r3, [r2, #0]
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1_BOOST)
 8005438:	b960      	cbnz	r0, 8005454 <HAL_PWREx_ControlVoltageScaling+0x20>
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 800543a:	f403 63c0 	and.w	r3, r3, #1536	@ 0x600
 800543e:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
    {
      /* Make sure Range 1 Boost is enabled */
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8005442:	f8d2 3080 	ldr.w	r3, [r2, #128]	@ 0x80
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8005446:	d01b      	beq.n	8005480 <HAL_PWREx_ControlVoltageScaling+0x4c>
    }
    /* If current range is range 1 normal or boost mode */
    else
    {
      /* Enable Range 1 Boost (no issue if bit already reset) */
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8005448:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 800544c:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
    MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
    /* No need to wait for VOSF to be cleared for this transition */
    /* PWR_CR5_R1MODE bit setting has no effect in Range 2        */
  }

  return HAL_OK;
 8005450:	2000      	movs	r0, #0
}
 8005452:	4770      	bx	lr
  else if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
 8005454:	f5b0 7f00 	cmp.w	r0, #512	@ 0x200
 8005458:	d006      	beq.n	8005468 <HAL_PWREx_ControlVoltageScaling+0x34>
    MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
 800545a:	f423 63c0 	bic.w	r3, r3, #1536	@ 0x600
 800545e:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 8005462:	6013      	str	r3, [r2, #0]
  return HAL_OK;
 8005464:	2000      	movs	r0, #0
}
 8005466:	4770      	bx	lr
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8005468:	f403 63c0 	and.w	r3, r3, #1536	@ 0x600
 800546c:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8005470:	f8d2 3080 	ldr.w	r3, [r2, #128]	@ 0x80
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8005474:	d029      	beq.n	80054ca <HAL_PWREx_ControlVoltageScaling+0x96>
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8005476:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 800547a:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
 800547e:	e7f1      	b.n	8005464 <HAL_PWREx_ControlVoltageScaling+0x30>
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8005480:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8005484:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 8005488:	6813      	ldr	r3, [r2, #0]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 800548a:	4821      	ldr	r0, [pc, #132]	@ (8005510 <HAL_PWREx_ControlVoltageScaling+0xdc>)
 800548c:	4921      	ldr	r1, [pc, #132]	@ (8005514 <HAL_PWREx_ControlVoltageScaling+0xe0>)
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 800548e:	f423 63c0 	bic.w	r3, r3, #1536	@ 0x600
 8005492:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8005496:	6013      	str	r3, [r2, #0]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 8005498:	6803      	ldr	r3, [r0, #0]
 800549a:	2032      	movs	r0, #50	@ 0x32
 800549c:	fb00 f303 	mul.w	r3, r0, r3
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 80054a0:	6950      	ldr	r0, [r2, #20]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 80054a2:	fba1 1303 	umull	r1, r3, r1, r3
 80054a6:	0c9b      	lsrs	r3, r3, #18
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 80054a8:	0540      	lsls	r0, r0, #21
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 80054aa:	f103 0301 	add.w	r3, r3, #1
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 80054ae:	d506      	bpl.n	80054be <HAL_PWREx_ControlVoltageScaling+0x8a>
 80054b0:	e000      	b.n	80054b4 <HAL_PWREx_ControlVoltageScaling+0x80>
 80054b2:	b123      	cbz	r3, 80054be <HAL_PWREx_ControlVoltageScaling+0x8a>
 80054b4:	6951      	ldr	r1, [r2, #20]
 80054b6:	0549      	lsls	r1, r1, #21
        wait_loop_index--;
 80054b8:	f103 33ff 	add.w	r3, r3, #4294967295
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 80054bc:	d4f9      	bmi.n	80054b2 <HAL_PWREx_ControlVoltageScaling+0x7e>
      if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
 80054be:	4b13      	ldr	r3, [pc, #76]	@ (800550c <HAL_PWREx_ControlVoltageScaling+0xd8>)
 80054c0:	695b      	ldr	r3, [r3, #20]
 80054c2:	055b      	lsls	r3, r3, #21
 80054c4:	d5ce      	bpl.n	8005464 <HAL_PWREx_ControlVoltageScaling+0x30>
        return HAL_TIMEOUT;
 80054c6:	2003      	movs	r0, #3
 80054c8:	4770      	bx	lr
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
 80054ca:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 80054ce:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 80054d2:	6813      	ldr	r3, [r2, #0]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 80054d4:	480e      	ldr	r0, [pc, #56]	@ (8005510 <HAL_PWREx_ControlVoltageScaling+0xdc>)
 80054d6:	490f      	ldr	r1, [pc, #60]	@ (8005514 <HAL_PWREx_ControlVoltageScaling+0xe0>)
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 80054d8:	f423 63c0 	bic.w	r3, r3, #1536	@ 0x600
 80054dc:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 80054e0:	6013      	str	r3, [r2, #0]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 80054e2:	6803      	ldr	r3, [r0, #0]
 80054e4:	2032      	movs	r0, #50	@ 0x32
 80054e6:	fb00 f303 	mul.w	r3, r0, r3
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 80054ea:	6950      	ldr	r0, [r2, #20]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 80054ec:	fba1 1303 	umull	r1, r3, r1, r3
 80054f0:	0c9b      	lsrs	r3, r3, #18
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 80054f2:	0540      	lsls	r0, r0, #21
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 80054f4:	f103 0301 	add.w	r3, r3, #1
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 80054f8:	d5e1      	bpl.n	80054be <HAL_PWREx_ControlVoltageScaling+0x8a>
 80054fa:	e001      	b.n	8005500 <HAL_PWREx_ControlVoltageScaling+0xcc>
 80054fc:	2b00      	cmp	r3, #0
 80054fe:	d0de      	beq.n	80054be <HAL_PWREx_ControlVoltageScaling+0x8a>
 8005500:	6951      	ldr	r1, [r2, #20]
 8005502:	0549      	lsls	r1, r1, #21
        wait_loop_index--;
 8005504:	f103 33ff 	add.w	r3, r3, #4294967295
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8005508:	d5d9      	bpl.n	80054be <HAL_PWREx_ControlVoltageScaling+0x8a>
 800550a:	e7f7      	b.n	80054fc <HAL_PWREx_ControlVoltageScaling+0xc8>
 800550c:	40007000 	.word	0x40007000
 8005510:	20000558 	.word	0x20000558
 8005514:	431bde83 	.word	0x431bde83

08005518 <HAL_PWREx_DisableUCPDDeadBattery>:
  * @retval None
  */
void HAL_PWREx_DisableUCPDDeadBattery(void)
{
  /* Write 1 to disable the USB Type-C dead battery pull-down behavior */
  SET_BIT(PWR->CR3, PWR_CR3_UCPD_DBDIS);
 8005518:	4a02      	ldr	r2, [pc, #8]	@ (8005524 <HAL_PWREx_DisableUCPDDeadBattery+0xc>)
 800551a:	6893      	ldr	r3, [r2, #8]
 800551c:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8005520:	6093      	str	r3, [r2, #8]
}
 8005522:	4770      	bx	lr
 8005524:	40007000 	.word	0x40007000

08005528 <HAL_RCC_OscConfig>:
  uint32_t tickstart;
  uint32_t temp_sysclksrc;
  uint32_t temp_pllckcfg;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 8005528:	2800      	cmp	r0, #0
 800552a:	f000 81bd 	beq.w	80058a8 <HAL_RCC_OscConfig+0x380>
{
 800552e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8005532:	6803      	ldr	r3, [r0, #0]
 8005534:	07d9      	lsls	r1, r3, #31
{
 8005536:	b082      	sub	sp, #8
 8005538:	4604      	mov	r4, r0
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800553a:	d512      	bpl.n	8005562 <HAL_RCC_OscConfig+0x3a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800553c:	49a6      	ldr	r1, [pc, #664]	@ (80057d8 <HAL_RCC_OscConfig+0x2b0>)
 800553e:	688a      	ldr	r2, [r1, #8]
    temp_pllckcfg = __HAL_RCC_GET_PLL_OSCSOURCE();
 8005540:	68c9      	ldr	r1, [r1, #12]
    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8005542:	f002 020c 	and.w	r2, r2, #12

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if (((temp_sysclksrc == RCC_CFGR_SWS_PLL) && (temp_pllckcfg == RCC_PLLSOURCE_HSE)) || (temp_sysclksrc == RCC_CFGR_SWS_HSE))
 8005546:	2a0c      	cmp	r2, #12
 8005548:	f000 80d0 	beq.w	80056ec <HAL_RCC_OscConfig+0x1c4>
 800554c:	2a08      	cmp	r2, #8
 800554e:	f040 80d2 	bne.w	80056f6 <HAL_RCC_OscConfig+0x1ce>
    {
      if ((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8005552:	4aa1      	ldr	r2, [pc, #644]	@ (80057d8 <HAL_RCC_OscConfig+0x2b0>)
 8005554:	6812      	ldr	r2, [r2, #0]
 8005556:	0392      	lsls	r2, r2, #14
 8005558:	d503      	bpl.n	8005562 <HAL_RCC_OscConfig+0x3a>
 800555a:	6862      	ldr	r2, [r4, #4]
 800555c:	2a00      	cmp	r2, #0
 800555e:	f000 8137 	beq.w	80057d0 <HAL_RCC_OscConfig+0x2a8>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8005562:	079a      	lsls	r2, r3, #30
 8005564:	d522      	bpl.n	80055ac <HAL_RCC_OscConfig+0x84>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8005566:	4a9c      	ldr	r2, [pc, #624]	@ (80057d8 <HAL_RCC_OscConfig+0x2b0>)
 8005568:	6893      	ldr	r3, [r2, #8]
    temp_pllckcfg = __HAL_RCC_GET_PLL_OSCSOURCE();
 800556a:	68d2      	ldr	r2, [r2, #12]
    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800556c:	f003 030c 	and.w	r3, r3, #12
    if (((temp_sysclksrc == RCC_CFGR_SWS_PLL) && (temp_pllckcfg == RCC_PLLSOURCE_HSI)) || (temp_sysclksrc == RCC_CFGR_SWS_HSI))
 8005570:	2b0c      	cmp	r3, #12
 8005572:	f000 80f8 	beq.w	8005766 <HAL_RCC_OscConfig+0x23e>
 8005576:	2b04      	cmp	r3, #4
 8005578:	f040 80fa 	bne.w	8005770 <HAL_RCC_OscConfig+0x248>
    {
      /* When HSI is used as system clock it will not be disabled */
      if ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 800557c:	4b96      	ldr	r3, [pc, #600]	@ (80057d8 <HAL_RCC_OscConfig+0x2b0>)
 800557e:	681b      	ldr	r3, [r3, #0]
 8005580:	055b      	lsls	r3, r3, #21
 8005582:	d503      	bpl.n	800558c <HAL_RCC_OscConfig+0x64>
 8005584:	68e3      	ldr	r3, [r4, #12]
 8005586:	2b00      	cmp	r3, #0
 8005588:	f000 8122 	beq.w	80057d0 <HAL_RCC_OscConfig+0x2a8>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800558c:	4a92      	ldr	r2, [pc, #584]	@ (80057d8 <HAL_RCC_OscConfig+0x2b0>)
 800558e:	6920      	ldr	r0, [r4, #16]
 8005590:	6853      	ldr	r3, [r2, #4]

        /* Adapt Systick interrupt period */
        if (HAL_InitTick(uwTickPrio) != HAL_OK)
 8005592:	4992      	ldr	r1, [pc, #584]	@ (80057dc <HAL_RCC_OscConfig+0x2b4>)
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8005594:	f023 43fe 	bic.w	r3, r3, #2130706432	@ 0x7f000000
 8005598:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 800559c:	6053      	str	r3, [r2, #4]
        if (HAL_InitTick(uwTickPrio) != HAL_OK)
 800559e:	6808      	ldr	r0, [r1, #0]
 80055a0:	f7fe fd52 	bl	8004048 <HAL_InitTick>
 80055a4:	2800      	cmp	r0, #0
 80055a6:	f040 8113 	bne.w	80057d0 <HAL_RCC_OscConfig+0x2a8>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80055aa:	6823      	ldr	r3, [r4, #0]
 80055ac:	071a      	lsls	r2, r3, #28
 80055ae:	d519      	bpl.n	80055e4 <HAL_RCC_OscConfig+0xbc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 80055b0:	6963      	ldr	r3, [r4, #20]
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 80055b2:	4d89      	ldr	r5, [pc, #548]	@ (80057d8 <HAL_RCC_OscConfig+0x2b0>)
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 80055b4:	2b00      	cmp	r3, #0
 80055b6:	f000 80c2 	beq.w	800573e <HAL_RCC_OscConfig+0x216>
      __HAL_RCC_LSI_ENABLE();
 80055ba:	f8d5 3094 	ldr.w	r3, [r5, #148]	@ 0x94
 80055be:	f043 0301 	orr.w	r3, r3, #1
 80055c2:	f8c5 3094 	str.w	r3, [r5, #148]	@ 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80055c6:	f7fe fe73 	bl	80042b0 <HAL_GetTick>
 80055ca:	4606      	mov	r6, r0

      /* Wait till LSI is ready */
      while (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 80055cc:	e005      	b.n	80055da <HAL_RCC_OscConfig+0xb2>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 80055ce:	f7fe fe6f 	bl	80042b0 <HAL_GetTick>
 80055d2:	1b80      	subs	r0, r0, r6
 80055d4:	2802      	cmp	r0, #2
 80055d6:	f200 8117 	bhi.w	8005808 <HAL_RCC_OscConfig+0x2e0>
      while (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 80055da:	f8d5 3094 	ldr.w	r3, [r5, #148]	@ 0x94
 80055de:	079b      	lsls	r3, r3, #30
 80055e0:	d5f5      	bpl.n	80055ce <HAL_RCC_OscConfig+0xa6>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80055e2:	6823      	ldr	r3, [r4, #0]
 80055e4:	075d      	lsls	r5, r3, #29
 80055e6:	d541      	bpl.n	800566c <HAL_RCC_OscConfig+0x144>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain if necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED() != 0U)
 80055e8:	4b7b      	ldr	r3, [pc, #492]	@ (80057d8 <HAL_RCC_OscConfig+0x2b0>)
 80055ea:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 80055ec:	00d0      	lsls	r0, r2, #3
 80055ee:	f100 810f 	bmi.w	8005810 <HAL_RCC_OscConfig+0x2e8>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 80055f2:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 80055f4:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
 80055f8:	659a      	str	r2, [r3, #88]	@ 0x58
 80055fa:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 80055fc:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8005600:	9301      	str	r3, [sp, #4]
 8005602:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8005604:	2501      	movs	r5, #1
    }

    if (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8005606:	4e76      	ldr	r6, [pc, #472]	@ (80057e0 <HAL_RCC_OscConfig+0x2b8>)
 8005608:	6833      	ldr	r3, [r6, #0]
 800560a:	05d9      	lsls	r1, r3, #23
 800560c:	f140 812e 	bpl.w	800586c <HAL_RCC_OscConfig+0x344>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8005610:	68a3      	ldr	r3, [r4, #8]
 8005612:	2b01      	cmp	r3, #1
 8005614:	f000 80fe 	beq.w	8005814 <HAL_RCC_OscConfig+0x2ec>
 8005618:	2b05      	cmp	r3, #5
 800561a:	f000 8184 	beq.w	8005926 <HAL_RCC_OscConfig+0x3fe>
 800561e:	4e6e      	ldr	r6, [pc, #440]	@ (80057d8 <HAL_RCC_OscConfig+0x2b0>)
 8005620:	f8d6 2090 	ldr.w	r2, [r6, #144]	@ 0x90
 8005624:	f022 0201 	bic.w	r2, r2, #1
 8005628:	f8c6 2090 	str.w	r2, [r6, #144]	@ 0x90
 800562c:	f8d6 2090 	ldr.w	r2, [r6, #144]	@ 0x90
 8005630:	f022 0204 	bic.w	r2, r2, #4
 8005634:	f8c6 2090 	str.w	r2, [r6, #144]	@ 0x90

    /* Check the LSE State */
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8005638:	2b00      	cmp	r3, #0
 800563a:	f040 80f2 	bne.w	8005822 <HAL_RCC_OscConfig+0x2fa>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800563e:	f7fe fe37 	bl	80042b0 <HAL_GetTick>

      /* Wait till LSE is disabled */
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8005642:	f241 3888 	movw	r8, #5000	@ 0x1388
      tickstart = HAL_GetTick();
 8005646:	4607      	mov	r7, r0
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 8005648:	e005      	b.n	8005656 <HAL_RCC_OscConfig+0x12e>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800564a:	f7fe fe31 	bl	80042b0 <HAL_GetTick>
 800564e:	1bc0      	subs	r0, r0, r7
 8005650:	4540      	cmp	r0, r8
 8005652:	f200 80d9 	bhi.w	8005808 <HAL_RCC_OscConfig+0x2e0>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 8005656:	f8d6 3090 	ldr.w	r3, [r6, #144]	@ 0x90
 800565a:	0799      	lsls	r1, r3, #30
 800565c:	d4f5      	bmi.n	800564a <HAL_RCC_OscConfig+0x122>
        }
      }
    }

    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
 800565e:	b125      	cbz	r5, 800566a <HAL_RCC_OscConfig+0x142>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8005660:	4a5d      	ldr	r2, [pc, #372]	@ (80057d8 <HAL_RCC_OscConfig+0x2b0>)
 8005662:	6d93      	ldr	r3, [r2, #88]	@ 0x58
 8005664:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 8005668:	6593      	str	r3, [r2, #88]	@ 0x58
    }
  }

  /*------------------------------ HSI48 Configuration -----------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 800566a:	6823      	ldr	r3, [r4, #0]
 800566c:	069a      	lsls	r2, r3, #26
 800566e:	d518      	bpl.n	80056a2 <HAL_RCC_OscConfig+0x17a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

    /* Check the HSI48 State */
    if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 8005670:	69a3      	ldr	r3, [r4, #24]
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
 8005672:	4d59      	ldr	r5, [pc, #356]	@ (80057d8 <HAL_RCC_OscConfig+0x2b0>)
    if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 8005674:	2b00      	cmp	r3, #0
 8005676:	f000 80e5 	beq.w	8005844 <HAL_RCC_OscConfig+0x31c>
      __HAL_RCC_HSI48_ENABLE();
 800567a:	f8d5 3098 	ldr.w	r3, [r5, #152]	@ 0x98
 800567e:	f043 0301 	orr.w	r3, r3, #1
 8005682:	f8c5 3098 	str.w	r3, [r5, #152]	@ 0x98

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8005686:	f7fe fe13 	bl	80042b0 <HAL_GetTick>
 800568a:	4606      	mov	r6, r0

      /* Wait till HSI48 is ready */
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
 800568c:	e005      	b.n	800569a <HAL_RCC_OscConfig+0x172>
      {
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 800568e:	f7fe fe0f 	bl	80042b0 <HAL_GetTick>
 8005692:	1b80      	subs	r0, r0, r6
 8005694:	2802      	cmp	r0, #2
 8005696:	f200 80b7 	bhi.w	8005808 <HAL_RCC_OscConfig+0x2e0>
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
 800569a:	f8d5 3098 	ldr.w	r3, [r5, #152]	@ 0x98
 800569e:	079b      	lsls	r3, r3, #30
 80056a0:	d5f5      	bpl.n	800568e <HAL_RCC_OscConfig+0x166>

  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));

  if (RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 80056a2:	69e3      	ldr	r3, [r4, #28]
 80056a4:	b1f3      	cbz	r3, 80056e4 <HAL_RCC_OscConfig+0x1bc>
  {
    /* Check if the PLL is used as system clock or not */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 80056a6:	4d4c      	ldr	r5, [pc, #304]	@ (80057d8 <HAL_RCC_OscConfig+0x2b0>)
 80056a8:	68aa      	ldr	r2, [r5, #8]
 80056aa:	f002 020c 	and.w	r2, r2, #12
 80056ae:	2a0c      	cmp	r2, #12
 80056b0:	f000 8147 	beq.w	8005942 <HAL_RCC_OscConfig+0x41a>
    {
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 80056b4:	2b02      	cmp	r3, #2
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80056b6:	682b      	ldr	r3, [r5, #0]
 80056b8:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
 80056bc:	602b      	str	r3, [r5, #0]
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 80056be:	f000 80f5 	beq.w	80058ac <HAL_RCC_OscConfig+0x384>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80056c2:	f7fe fdf5 	bl	80042b0 <HAL_GetTick>
 80056c6:	4604      	mov	r4, r0

        /* Wait till PLL is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 80056c8:	e005      	b.n	80056d6 <HAL_RCC_OscConfig+0x1ae>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80056ca:	f7fe fdf1 	bl	80042b0 <HAL_GetTick>
 80056ce:	1b00      	subs	r0, r0, r4
 80056d0:	2802      	cmp	r0, #2
 80056d2:	f200 8099 	bhi.w	8005808 <HAL_RCC_OscConfig+0x2e0>
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 80056d6:	682b      	ldr	r3, [r5, #0]
 80056d8:	019b      	lsls	r3, r3, #6
 80056da:	d4f6      	bmi.n	80056ca <HAL_RCC_OscConfig+0x1a2>
            return HAL_TIMEOUT;
          }
        }

        /* Unselect PLL clock source and disable outputs to save power */
        RCC->PLLCFGR &= ~(RCC_PLLCFGR_PLLSRC | RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_ADCCLK);
 80056dc:	68ea      	ldr	r2, [r5, #12]
 80056de:	4b41      	ldr	r3, [pc, #260]	@ (80057e4 <HAL_RCC_OscConfig+0x2bc>)
 80056e0:	4013      	ands	r3, r2
 80056e2:	60eb      	str	r3, [r5, #12]
      }
    }
  }
  }

  return HAL_OK;
 80056e4:	2000      	movs	r0, #0
}
 80056e6:	b002      	add	sp, #8
 80056e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    temp_pllckcfg = __HAL_RCC_GET_PLL_OSCSOURCE();
 80056ec:	f001 0103 	and.w	r1, r1, #3
    if (((temp_sysclksrc == RCC_CFGR_SWS_PLL) && (temp_pllckcfg == RCC_PLLSOURCE_HSE)) || (temp_sysclksrc == RCC_CFGR_SWS_HSE))
 80056f0:	2903      	cmp	r1, #3
 80056f2:	f43f af2e 	beq.w	8005552 <HAL_RCC_OscConfig+0x2a>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80056f6:	6863      	ldr	r3, [r4, #4]
 80056f8:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 80056fc:	d055      	beq.n	80057aa <HAL_RCC_OscConfig+0x282>
 80056fe:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 8005702:	f000 80c4 	beq.w	800588e <HAL_RCC_OscConfig+0x366>
 8005706:	4d34      	ldr	r5, [pc, #208]	@ (80057d8 <HAL_RCC_OscConfig+0x2b0>)
 8005708:	682a      	ldr	r2, [r5, #0]
 800570a:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 800570e:	602a      	str	r2, [r5, #0]
 8005710:	682a      	ldr	r2, [r5, #0]
 8005712:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
 8005716:	602a      	str	r2, [r5, #0]
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8005718:	2b00      	cmp	r3, #0
 800571a:	d14b      	bne.n	80057b4 <HAL_RCC_OscConfig+0x28c>
        tickstart = HAL_GetTick();
 800571c:	f7fe fdc8 	bl	80042b0 <HAL_GetTick>
 8005720:	4606      	mov	r6, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 8005722:	e004      	b.n	800572e <HAL_RCC_OscConfig+0x206>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8005724:	f7fe fdc4 	bl	80042b0 <HAL_GetTick>
 8005728:	1b80      	subs	r0, r0, r6
 800572a:	2864      	cmp	r0, #100	@ 0x64
 800572c:	d86c      	bhi.n	8005808 <HAL_RCC_OscConfig+0x2e0>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 800572e:	682b      	ldr	r3, [r5, #0]
 8005730:	0399      	lsls	r1, r3, #14
 8005732:	d4f7      	bmi.n	8005724 <HAL_RCC_OscConfig+0x1fc>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8005734:	6823      	ldr	r3, [r4, #0]
 8005736:	079a      	lsls	r2, r3, #30
 8005738:	f57f af38 	bpl.w	80055ac <HAL_RCC_OscConfig+0x84>
 800573c:	e713      	b.n	8005566 <HAL_RCC_OscConfig+0x3e>
      __HAL_RCC_LSI_DISABLE();
 800573e:	f8d5 3094 	ldr.w	r3, [r5, #148]	@ 0x94
 8005742:	f023 0301 	bic.w	r3, r3, #1
 8005746:	f8c5 3094 	str.w	r3, [r5, #148]	@ 0x94
      tickstart = HAL_GetTick();
 800574a:	f7fe fdb1 	bl	80042b0 <HAL_GetTick>
 800574e:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 8005750:	e004      	b.n	800575c <HAL_RCC_OscConfig+0x234>
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8005752:	f7fe fdad 	bl	80042b0 <HAL_GetTick>
 8005756:	1b80      	subs	r0, r0, r6
 8005758:	2802      	cmp	r0, #2
 800575a:	d855      	bhi.n	8005808 <HAL_RCC_OscConfig+0x2e0>
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 800575c:	f8d5 3094 	ldr.w	r3, [r5, #148]	@ 0x94
 8005760:	079f      	lsls	r7, r3, #30
 8005762:	d4f6      	bmi.n	8005752 <HAL_RCC_OscConfig+0x22a>
 8005764:	e73d      	b.n	80055e2 <HAL_RCC_OscConfig+0xba>
    temp_pllckcfg = __HAL_RCC_GET_PLL_OSCSOURCE();
 8005766:	f002 0203 	and.w	r2, r2, #3
    if (((temp_sysclksrc == RCC_CFGR_SWS_PLL) && (temp_pllckcfg == RCC_PLLSOURCE_HSI)) || (temp_sysclksrc == RCC_CFGR_SWS_HSI))
 800576a:	2a02      	cmp	r2, #2
 800576c:	f43f af06 	beq.w	800557c <HAL_RCC_OscConfig+0x54>
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8005770:	68e3      	ldr	r3, [r4, #12]
        __HAL_RCC_HSI_ENABLE();
 8005772:	4d19      	ldr	r5, [pc, #100]	@ (80057d8 <HAL_RCC_OscConfig+0x2b0>)
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8005774:	2b00      	cmp	r3, #0
 8005776:	d037      	beq.n	80057e8 <HAL_RCC_OscConfig+0x2c0>
        __HAL_RCC_HSI_ENABLE();
 8005778:	682b      	ldr	r3, [r5, #0]
 800577a:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 800577e:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8005780:	f7fe fd96 	bl	80042b0 <HAL_GetTick>
 8005784:	4606      	mov	r6, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8005786:	e004      	b.n	8005792 <HAL_RCC_OscConfig+0x26a>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8005788:	f7fe fd92 	bl	80042b0 <HAL_GetTick>
 800578c:	1b80      	subs	r0, r0, r6
 800578e:	2802      	cmp	r0, #2
 8005790:	d83a      	bhi.n	8005808 <HAL_RCC_OscConfig+0x2e0>
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8005792:	682b      	ldr	r3, [r5, #0]
 8005794:	055f      	lsls	r7, r3, #21
 8005796:	d5f7      	bpl.n	8005788 <HAL_RCC_OscConfig+0x260>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8005798:	686b      	ldr	r3, [r5, #4]
 800579a:	6922      	ldr	r2, [r4, #16]
 800579c:	f023 43fe 	bic.w	r3, r3, #2130706432	@ 0x7f000000
 80057a0:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80057a4:	606b      	str	r3, [r5, #4]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80057a6:	6823      	ldr	r3, [r4, #0]
 80057a8:	e700      	b.n	80055ac <HAL_RCC_OscConfig+0x84>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80057aa:	4a0b      	ldr	r2, [pc, #44]	@ (80057d8 <HAL_RCC_OscConfig+0x2b0>)
 80057ac:	6813      	ldr	r3, [r2, #0]
 80057ae:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 80057b2:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 80057b4:	f7fe fd7c 	bl	80042b0 <HAL_GetTick>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 80057b8:	4e07      	ldr	r6, [pc, #28]	@ (80057d8 <HAL_RCC_OscConfig+0x2b0>)
        tickstart = HAL_GetTick();
 80057ba:	4605      	mov	r5, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 80057bc:	e004      	b.n	80057c8 <HAL_RCC_OscConfig+0x2a0>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80057be:	f7fe fd77 	bl	80042b0 <HAL_GetTick>
 80057c2:	1b40      	subs	r0, r0, r5
 80057c4:	2864      	cmp	r0, #100	@ 0x64
 80057c6:	d81f      	bhi.n	8005808 <HAL_RCC_OscConfig+0x2e0>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 80057c8:	6833      	ldr	r3, [r6, #0]
 80057ca:	039f      	lsls	r7, r3, #14
 80057cc:	d5f7      	bpl.n	80057be <HAL_RCC_OscConfig+0x296>
 80057ce:	e7b1      	b.n	8005734 <HAL_RCC_OscConfig+0x20c>
    return HAL_ERROR;
 80057d0:	2001      	movs	r0, #1
}
 80057d2:	b002      	add	sp, #8
 80057d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80057d8:	40021000 	.word	0x40021000
 80057dc:	20000560 	.word	0x20000560
 80057e0:	40007000 	.word	0x40007000
 80057e4:	feeefffc 	.word	0xfeeefffc
        __HAL_RCC_HSI_DISABLE();
 80057e8:	682b      	ldr	r3, [r5, #0]
 80057ea:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 80057ee:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 80057f0:	f7fe fd5e 	bl	80042b0 <HAL_GetTick>
 80057f4:	4606      	mov	r6, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 80057f6:	682b      	ldr	r3, [r5, #0]
 80057f8:	0559      	lsls	r1, r3, #21
 80057fa:	f57f aed6 	bpl.w	80055aa <HAL_RCC_OscConfig+0x82>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 80057fe:	f7fe fd57 	bl	80042b0 <HAL_GetTick>
 8005802:	1b80      	subs	r0, r0, r6
 8005804:	2802      	cmp	r0, #2
 8005806:	d9f6      	bls.n	80057f6 <HAL_RCC_OscConfig+0x2ce>
            return HAL_TIMEOUT;
 8005808:	2003      	movs	r0, #3
}
 800580a:	b002      	add	sp, #8
 800580c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    FlagStatus       pwrclkchanged = RESET;
 8005810:	2500      	movs	r5, #0
 8005812:	e6f8      	b.n	8005606 <HAL_RCC_OscConfig+0xde>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8005814:	4a65      	ldr	r2, [pc, #404]	@ (80059ac <HAL_RCC_OscConfig+0x484>)
 8005816:	f8d2 3090 	ldr.w	r3, [r2, #144]	@ 0x90
 800581a:	f043 0301 	orr.w	r3, r3, #1
 800581e:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
      tickstart = HAL_GetTick();
 8005822:	f7fe fd45 	bl	80042b0 <HAL_GetTick>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8005826:	4f61      	ldr	r7, [pc, #388]	@ (80059ac <HAL_RCC_OscConfig+0x484>)
      tickstart = HAL_GetTick();
 8005828:	4606      	mov	r6, r0
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800582a:	f241 3888 	movw	r8, #5000	@ 0x1388
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 800582e:	e004      	b.n	800583a <HAL_RCC_OscConfig+0x312>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8005830:	f7fe fd3e 	bl	80042b0 <HAL_GetTick>
 8005834:	1b80      	subs	r0, r0, r6
 8005836:	4540      	cmp	r0, r8
 8005838:	d8e6      	bhi.n	8005808 <HAL_RCC_OscConfig+0x2e0>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 800583a:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 800583e:	079b      	lsls	r3, r3, #30
 8005840:	d5f6      	bpl.n	8005830 <HAL_RCC_OscConfig+0x308>
 8005842:	e70c      	b.n	800565e <HAL_RCC_OscConfig+0x136>
      __HAL_RCC_HSI48_DISABLE();
 8005844:	f8d5 3098 	ldr.w	r3, [r5, #152]	@ 0x98
 8005848:	f023 0301 	bic.w	r3, r3, #1
 800584c:	f8c5 3098 	str.w	r3, [r5, #152]	@ 0x98
      tickstart = HAL_GetTick();
 8005850:	f7fe fd2e 	bl	80042b0 <HAL_GetTick>
 8005854:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
 8005856:	e004      	b.n	8005862 <HAL_RCC_OscConfig+0x33a>
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8005858:	f7fe fd2a 	bl	80042b0 <HAL_GetTick>
 800585c:	1b80      	subs	r0, r0, r6
 800585e:	2802      	cmp	r0, #2
 8005860:	d8d2      	bhi.n	8005808 <HAL_RCC_OscConfig+0x2e0>
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
 8005862:	f8d5 3098 	ldr.w	r3, [r5, #152]	@ 0x98
 8005866:	079f      	lsls	r7, r3, #30
 8005868:	d4f6      	bmi.n	8005858 <HAL_RCC_OscConfig+0x330>
 800586a:	e71a      	b.n	80056a2 <HAL_RCC_OscConfig+0x17a>
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
 800586c:	6833      	ldr	r3, [r6, #0]
 800586e:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8005872:	6033      	str	r3, [r6, #0]
      tickstart = HAL_GetTick();
 8005874:	f7fe fd1c 	bl	80042b0 <HAL_GetTick>
 8005878:	4607      	mov	r7, r0
      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 800587a:	6833      	ldr	r3, [r6, #0]
 800587c:	05da      	lsls	r2, r3, #23
 800587e:	f53f aec7 	bmi.w	8005610 <HAL_RCC_OscConfig+0xe8>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8005882:	f7fe fd15 	bl	80042b0 <HAL_GetTick>
 8005886:	1bc0      	subs	r0, r0, r7
 8005888:	2802      	cmp	r0, #2
 800588a:	d9f6      	bls.n	800587a <HAL_RCC_OscConfig+0x352>
 800588c:	e7bc      	b.n	8005808 <HAL_RCC_OscConfig+0x2e0>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800588e:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 8005892:	f5a3 333c 	sub.w	r3, r3, #192512	@ 0x2f000
 8005896:	681a      	ldr	r2, [r3, #0]
 8005898:	f442 2280 	orr.w	r2, r2, #262144	@ 0x40000
 800589c:	601a      	str	r2, [r3, #0]
 800589e:	681a      	ldr	r2, [r3, #0]
 80058a0:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 80058a4:	601a      	str	r2, [r3, #0]
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 80058a6:	e785      	b.n	80057b4 <HAL_RCC_OscConfig+0x28c>
    return HAL_ERROR;
 80058a8:	2001      	movs	r0, #1
}
 80058aa:	4770      	bx	lr
        tickstart = HAL_GetTick();
 80058ac:	f7fe fd00 	bl	80042b0 <HAL_GetTick>
 80058b0:	4606      	mov	r6, r0
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 80058b2:	e004      	b.n	80058be <HAL_RCC_OscConfig+0x396>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80058b4:	f7fe fcfc 	bl	80042b0 <HAL_GetTick>
 80058b8:	1b80      	subs	r0, r0, r6
 80058ba:	2802      	cmp	r0, #2
 80058bc:	d8a4      	bhi.n	8005808 <HAL_RCC_OscConfig+0x2e0>
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 80058be:	682b      	ldr	r3, [r5, #0]
 80058c0:	0199      	lsls	r1, r3, #6
 80058c2:	d4f7      	bmi.n	80058b4 <HAL_RCC_OscConfig+0x38c>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 80058c4:	68e9      	ldr	r1, [r5, #12]
 80058c6:	4b3a      	ldr	r3, [pc, #232]	@ (80059b0 <HAL_RCC_OscConfig+0x488>)
 80058c8:	6a22      	ldr	r2, [r4, #32]
 80058ca:	6a60      	ldr	r0, [r4, #36]	@ 0x24
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 80058cc:	4e37      	ldr	r6, [pc, #220]	@ (80059ac <HAL_RCC_OscConfig+0x484>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 80058ce:	400b      	ands	r3, r1
 80058d0:	4313      	orrs	r3, r2
 80058d2:	e9d4 120a 	ldrd	r1, r2, [r4, #40]	@ 0x28
 80058d6:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 80058da:	ea43 63c2 	orr.w	r3, r3, r2, lsl #27
 80058de:	e9d4 120c 	ldrd	r1, r2, [r4, #48]	@ 0x30
 80058e2:	3801      	subs	r0, #1
 80058e4:	0849      	lsrs	r1, r1, #1
 80058e6:	ea43 1300 	orr.w	r3, r3, r0, lsl #4
 80058ea:	3901      	subs	r1, #1
 80058ec:	0852      	lsrs	r2, r2, #1
 80058ee:	ea43 5341 	orr.w	r3, r3, r1, lsl #21
 80058f2:	3a01      	subs	r2, #1
 80058f4:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 80058f8:	60eb      	str	r3, [r5, #12]
        __HAL_RCC_PLL_ENABLE();
 80058fa:	682b      	ldr	r3, [r5, #0]
 80058fc:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8005900:	602b      	str	r3, [r5, #0]
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8005902:	68eb      	ldr	r3, [r5, #12]
 8005904:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8005908:	60eb      	str	r3, [r5, #12]
        tickstart = HAL_GetTick();
 800590a:	f7fe fcd1 	bl	80042b0 <HAL_GetTick>
 800590e:	4604      	mov	r4, r0
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8005910:	e005      	b.n	800591e <HAL_RCC_OscConfig+0x3f6>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8005912:	f7fe fccd 	bl	80042b0 <HAL_GetTick>
 8005916:	1b00      	subs	r0, r0, r4
 8005918:	2802      	cmp	r0, #2
 800591a:	f63f af75 	bhi.w	8005808 <HAL_RCC_OscConfig+0x2e0>
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 800591e:	6833      	ldr	r3, [r6, #0]
 8005920:	019a      	lsls	r2, r3, #6
 8005922:	d5f6      	bpl.n	8005912 <HAL_RCC_OscConfig+0x3ea>
 8005924:	e6de      	b.n	80056e4 <HAL_RCC_OscConfig+0x1bc>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8005926:	4b21      	ldr	r3, [pc, #132]	@ (80059ac <HAL_RCC_OscConfig+0x484>)
 8005928:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
 800592c:	f042 0204 	orr.w	r2, r2, #4
 8005930:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
 8005934:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
 8005938:	f042 0201 	orr.w	r2, r2, #1
 800593c:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8005940:	e76f      	b.n	8005822 <HAL_RCC_OscConfig+0x2fa>
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 8005942:	2b01      	cmp	r3, #1
 8005944:	f43f af44 	beq.w	80057d0 <HAL_RCC_OscConfig+0x2a8>
      temp_pllckcfg = RCC->PLLCFGR;
 8005948:	68eb      	ldr	r3, [r5, #12]
      if((READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800594a:	6a22      	ldr	r2, [r4, #32]
 800594c:	f003 0103 	and.w	r1, r3, #3
 8005950:	4291      	cmp	r1, r2
 8005952:	f47f af3d 	bne.w	80057d0 <HAL_RCC_OscConfig+0x2a8>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLM) != (((RCC_OscInitStruct->PLL.PLLM) - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 8005956:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 8005958:	f003 02f0 	and.w	r2, r3, #240	@ 0xf0
 800595c:	3901      	subs	r1, #1
      if((READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800595e:	ebb2 1f01 	cmp.w	r2, r1, lsl #4
 8005962:	f47f af35 	bne.w	80057d0 <HAL_RCC_OscConfig+0x2a8>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLN) != ((RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos)) ||
 8005966:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 8005968:	f403 42fe 	and.w	r2, r3, #32512	@ 0x7f00
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLM) != (((RCC_OscInitStruct->PLL.PLLM) - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 800596c:	ebb2 2f01 	cmp.w	r2, r1, lsl #8
 8005970:	f47f af2e 	bne.w	80057d0 <HAL_RCC_OscConfig+0x2a8>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLPDIV) != ((RCC_OscInitStruct->PLL.PLLP) << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 8005974:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 8005976:	f003 4278 	and.w	r2, r3, #4160749568	@ 0xf8000000
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLN) != ((RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos)) ||
 800597a:	ebb2 6fc1 	cmp.w	r2, r1, lsl #27
 800597e:	f47f af27 	bne.w	80057d0 <HAL_RCC_OscConfig+0x2a8>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLQ) != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 8005982:	6b22      	ldr	r2, [r4, #48]	@ 0x30
 8005984:	0852      	lsrs	r2, r2, #1
 8005986:	f403 01c0 	and.w	r1, r3, #6291456	@ 0x600000
 800598a:	3a01      	subs	r2, #1
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLPDIV) != ((RCC_OscInitStruct->PLL.PLLP) << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 800598c:	ebb1 5f42 	cmp.w	r1, r2, lsl #21
 8005990:	f47f af1e 	bne.w	80057d0 <HAL_RCC_OscConfig+0x2a8>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLR) != ((((RCC_OscInitStruct->PLL.PLLR) >> 1U) - 1U) << RCC_PLLCFGR_PLLR_Pos)))
 8005994:	6b62      	ldr	r2, [r4, #52]	@ 0x34
 8005996:	0852      	lsrs	r2, r2, #1
 8005998:	f003 63c0 	and.w	r3, r3, #100663296	@ 0x6000000
 800599c:	3a01      	subs	r2, #1
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLQ) != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 800599e:	ebb3 6f42 	cmp.w	r3, r2, lsl #25
 80059a2:	bf14      	ite	ne
 80059a4:	2001      	movne	r0, #1
 80059a6:	2000      	moveq	r0, #0
 80059a8:	e69d      	b.n	80056e6 <HAL_RCC_OscConfig+0x1be>
 80059aa:	bf00      	nop
 80059ac:	40021000 	.word	0x40021000
 80059b0:	019f800c 	.word	0x019f800c

080059b4 <HAL_RCC_GetSysClockFreq>:
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t pllvco, pllsource, pllr, pllm;
  uint32_t sysclockfreq;

  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)
 80059b4:	4b18      	ldr	r3, [pc, #96]	@ (8005a18 <HAL_RCC_GetSysClockFreq+0x64>)
 80059b6:	689a      	ldr	r2, [r3, #8]
 80059b8:	f002 020c 	and.w	r2, r2, #12
 80059bc:	2a04      	cmp	r2, #4
 80059be:	d026      	beq.n	8005a0e <HAL_RCC_GetSysClockFreq+0x5a>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
  }
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)
 80059c0:	689a      	ldr	r2, [r3, #8]
 80059c2:	f002 020c 	and.w	r2, r2, #12
 80059c6:	2a08      	cmp	r2, #8
 80059c8:	d023      	beq.n	8005a12 <HAL_RCC_GetSysClockFreq+0x5e>
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
  }
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
 80059ca:	689a      	ldr	r2, [r3, #8]
 80059cc:	f002 020c 	and.w	r2, r2, #12
 80059d0:	2a0c      	cmp	r2, #12
 80059d2:	d001      	beq.n	80059d8 <HAL_RCC_GetSysClockFreq+0x24>
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
    sysclockfreq = pllvco/pllr;
  }
  else
  {
    sysclockfreq = 0U;
 80059d4:	2000      	movs	r0, #0
  }

  return sysclockfreq;
}
 80059d6:	4770      	bx	lr
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 80059d8:	68d9      	ldr	r1, [r3, #12]
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 80059da:	68da      	ldr	r2, [r3, #12]
      pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 80059dc:	68d8      	ldr	r0, [r3, #12]
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 80059de:	f001 0103 	and.w	r1, r1, #3
    switch (pllsource)
 80059e2:	2903      	cmp	r1, #3
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 80059e4:	f3c2 1203 	ubfx	r2, r2, #4, #4
      pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 80059e8:	f3c0 2006 	ubfx	r0, r0, #8, #7
      pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 80059ec:	bf0c      	ite	eq
 80059ee:	4b0b      	ldreq	r3, [pc, #44]	@ (8005a1c <HAL_RCC_GetSysClockFreq+0x68>)
      pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 80059f0:	4b0b      	ldrne	r3, [pc, #44]	@ (8005a20 <HAL_RCC_GetSysClockFreq+0x6c>)
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 80059f2:	3201      	adds	r2, #1
      pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 80059f4:	fbb3 f3f2 	udiv	r3, r3, r2
 80059f8:	fb03 f000 	mul.w	r0, r3, r0
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 80059fc:	4b06      	ldr	r3, [pc, #24]	@ (8005a18 <HAL_RCC_GetSysClockFreq+0x64>)
 80059fe:	68db      	ldr	r3, [r3, #12]
 8005a00:	f3c3 6341 	ubfx	r3, r3, #25, #2
 8005a04:	3301      	adds	r3, #1
 8005a06:	005b      	lsls	r3, r3, #1
    sysclockfreq = pllvco/pllr;
 8005a08:	fbb0 f0f3 	udiv	r0, r0, r3
  return sysclockfreq;
 8005a0c:	4770      	bx	lr
    sysclockfreq = HSI_VALUE;
 8005a0e:	4804      	ldr	r0, [pc, #16]	@ (8005a20 <HAL_RCC_GetSysClockFreq+0x6c>)
 8005a10:	4770      	bx	lr
    sysclockfreq = HSE_VALUE;
 8005a12:	4802      	ldr	r0, [pc, #8]	@ (8005a1c <HAL_RCC_GetSysClockFreq+0x68>)
 8005a14:	4770      	bx	lr
 8005a16:	bf00      	nop
 8005a18:	40021000 	.word	0x40021000
 8005a1c:	016e3600 	.word	0x016e3600
 8005a20:	00f42400 	.word	0x00f42400

08005a24 <HAL_RCC_ClockConfig>:
  if (RCC_ClkInitStruct == NULL)
 8005a24:	2800      	cmp	r0, #0
 8005a26:	f000 80ee 	beq.w	8005c06 <HAL_RCC_ClockConfig+0x1e2>
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8005a2a:	4a78      	ldr	r2, [pc, #480]	@ (8005c0c <HAL_RCC_ClockConfig+0x1e8>)
{
 8005a2c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8005a30:	6813      	ldr	r3, [r2, #0]
 8005a32:	f003 030f 	and.w	r3, r3, #15
 8005a36:	428b      	cmp	r3, r1
 8005a38:	460d      	mov	r5, r1
 8005a3a:	4604      	mov	r4, r0
 8005a3c:	d20c      	bcs.n	8005a58 <HAL_RCC_ClockConfig+0x34>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8005a3e:	6813      	ldr	r3, [r2, #0]
 8005a40:	f023 030f 	bic.w	r3, r3, #15
 8005a44:	430b      	orrs	r3, r1
 8005a46:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8005a48:	6813      	ldr	r3, [r2, #0]
 8005a4a:	f003 030f 	and.w	r3, r3, #15
 8005a4e:	428b      	cmp	r3, r1
 8005a50:	d002      	beq.n	8005a58 <HAL_RCC_ClockConfig+0x34>
    return HAL_ERROR;
 8005a52:	2001      	movs	r0, #1
}
 8005a54:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8005a58:	6823      	ldr	r3, [r4, #0]
 8005a5a:	07df      	lsls	r7, r3, #31
 8005a5c:	d569      	bpl.n	8005b32 <HAL_RCC_ClockConfig+0x10e>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8005a5e:	6867      	ldr	r7, [r4, #4]
 8005a60:	2f03      	cmp	r7, #3
 8005a62:	f000 80a0 	beq.w	8005ba6 <HAL_RCC_ClockConfig+0x182>
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8005a66:	4b6a      	ldr	r3, [pc, #424]	@ (8005c10 <HAL_RCC_ClockConfig+0x1ec>)
      if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8005a68:	2f02      	cmp	r7, #2
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8005a6a:	681b      	ldr	r3, [r3, #0]
      if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8005a6c:	f000 8097 	beq.w	8005b9e <HAL_RCC_ClockConfig+0x17a>
        if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8005a70:	055b      	lsls	r3, r3, #21
 8005a72:	d5ee      	bpl.n	8005a52 <HAL_RCC_ClockConfig+0x2e>
      pllfreq = HAL_RCC_GetSysClockFreq();
 8005a74:	f7ff ff9e 	bl	80059b4 <HAL_RCC_GetSysClockFreq>
      if(pllfreq > 80000000U)
 8005a78:	4b66      	ldr	r3, [pc, #408]	@ (8005c14 <HAL_RCC_ClockConfig+0x1f0>)
 8005a7a:	4298      	cmp	r0, r3
 8005a7c:	f240 80c0 	bls.w	8005c00 <HAL_RCC_ClockConfig+0x1dc>
          MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
 8005a80:	4a63      	ldr	r2, [pc, #396]	@ (8005c10 <HAL_RCC_ClockConfig+0x1ec>)
 8005a82:	6893      	ldr	r3, [r2, #8]
 8005a84:	f023 03f0 	bic.w	r3, r3, #240	@ 0xf0
 8005a88:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8005a8c:	6093      	str	r3, [r2, #8]
        hpre = RCC_SYSCLK_DIV2;
 8005a8e:	f04f 0980 	mov.w	r9, #128	@ 0x80
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8005a92:	4e5f      	ldr	r6, [pc, #380]	@ (8005c10 <HAL_RCC_ClockConfig+0x1ec>)
 8005a94:	68b3      	ldr	r3, [r6, #8]
 8005a96:	f023 0303 	bic.w	r3, r3, #3
 8005a9a:	433b      	orrs	r3, r7
 8005a9c:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 8005a9e:	f7fe fc07 	bl	80042b0 <HAL_GetTick>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8005aa2:	f241 3888 	movw	r8, #5000	@ 0x1388
    tickstart = HAL_GetTick();
 8005aa6:	4607      	mov	r7, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8005aa8:	e004      	b.n	8005ab4 <HAL_RCC_ClockConfig+0x90>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8005aaa:	f7fe fc01 	bl	80042b0 <HAL_GetTick>
 8005aae:	1bc0      	subs	r0, r0, r7
 8005ab0:	4540      	cmp	r0, r8
 8005ab2:	d871      	bhi.n	8005b98 <HAL_RCC_ClockConfig+0x174>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8005ab4:	68b3      	ldr	r3, [r6, #8]
 8005ab6:	6862      	ldr	r2, [r4, #4]
 8005ab8:	f003 030c 	and.w	r3, r3, #12
 8005abc:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8005ac0:	d1f3      	bne.n	8005aaa <HAL_RCC_ClockConfig+0x86>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8005ac2:	6823      	ldr	r3, [r4, #0]
 8005ac4:	079f      	lsls	r7, r3, #30
 8005ac6:	d436      	bmi.n	8005b36 <HAL_RCC_ClockConfig+0x112>
    if(hpre == RCC_SYSCLK_DIV2)
 8005ac8:	f1b9 0f00 	cmp.w	r9, #0
 8005acc:	d003      	beq.n	8005ad6 <HAL_RCC_ClockConfig+0xb2>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV1);
 8005ace:	68b3      	ldr	r3, [r6, #8]
 8005ad0:	f023 03f0 	bic.w	r3, r3, #240	@ 0xf0
 8005ad4:	60b3      	str	r3, [r6, #8]
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8005ad6:	4e4d      	ldr	r6, [pc, #308]	@ (8005c0c <HAL_RCC_ClockConfig+0x1e8>)
 8005ad8:	6833      	ldr	r3, [r6, #0]
 8005ada:	f003 030f 	and.w	r3, r3, #15
 8005ade:	42ab      	cmp	r3, r5
 8005ae0:	d846      	bhi.n	8005b70 <HAL_RCC_ClockConfig+0x14c>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8005ae2:	6823      	ldr	r3, [r4, #0]
 8005ae4:	075a      	lsls	r2, r3, #29
 8005ae6:	d506      	bpl.n	8005af6 <HAL_RCC_ClockConfig+0xd2>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8005ae8:	4949      	ldr	r1, [pc, #292]	@ (8005c10 <HAL_RCC_ClockConfig+0x1ec>)
 8005aea:	68e0      	ldr	r0, [r4, #12]
 8005aec:	688a      	ldr	r2, [r1, #8]
 8005aee:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 8005af2:	4302      	orrs	r2, r0
 8005af4:	608a      	str	r2, [r1, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8005af6:	071b      	lsls	r3, r3, #28
 8005af8:	d507      	bpl.n	8005b0a <HAL_RCC_ClockConfig+0xe6>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8005afa:	4a45      	ldr	r2, [pc, #276]	@ (8005c10 <HAL_RCC_ClockConfig+0x1ec>)
 8005afc:	6921      	ldr	r1, [r4, #16]
 8005afe:	6893      	ldr	r3, [r2, #8]
 8005b00:	f423 5360 	bic.w	r3, r3, #14336	@ 0x3800
 8005b04:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8005b08:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 8005b0a:	f7ff ff53 	bl	80059b4 <HAL_RCC_GetSysClockFreq>
 8005b0e:	4a40      	ldr	r2, [pc, #256]	@ (8005c10 <HAL_RCC_ClockConfig+0x1ec>)
 8005b10:	4c41      	ldr	r4, [pc, #260]	@ (8005c18 <HAL_RCC_ClockConfig+0x1f4>)
 8005b12:	6892      	ldr	r2, [r2, #8]
 8005b14:	4941      	ldr	r1, [pc, #260]	@ (8005c1c <HAL_RCC_ClockConfig+0x1f8>)
 8005b16:	f3c2 1203 	ubfx	r2, r2, #4, #4
 8005b1a:	4603      	mov	r3, r0
 8005b1c:	5ca2      	ldrb	r2, [r4, r2]
  return HAL_InitTick(uwTickPrio);
 8005b1e:	4840      	ldr	r0, [pc, #256]	@ (8005c20 <HAL_RCC_ClockConfig+0x1fc>)
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 8005b20:	f002 021f 	and.w	r2, r2, #31
 8005b24:	40d3      	lsrs	r3, r2
 8005b26:	600b      	str	r3, [r1, #0]
  return HAL_InitTick(uwTickPrio);
 8005b28:	6800      	ldr	r0, [r0, #0]
}
 8005b2a:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  return HAL_InitTick(uwTickPrio);
 8005b2e:	f7fe ba8b 	b.w	8004048 <HAL_InitTick>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8005b32:	079e      	lsls	r6, r3, #30
 8005b34:	d5cf      	bpl.n	8005ad6 <HAL_RCC_ClockConfig+0xb2>
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8005b36:	0758      	lsls	r0, r3, #29
 8005b38:	d504      	bpl.n	8005b44 <HAL_RCC_ClockConfig+0x120>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 8005b3a:	4935      	ldr	r1, [pc, #212]	@ (8005c10 <HAL_RCC_ClockConfig+0x1ec>)
 8005b3c:	688a      	ldr	r2, [r1, #8]
 8005b3e:	f442 62e0 	orr.w	r2, r2, #1792	@ 0x700
 8005b42:	608a      	str	r2, [r1, #8]
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8005b44:	0719      	lsls	r1, r3, #28
 8005b46:	d506      	bpl.n	8005b56 <HAL_RCC_ClockConfig+0x132>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, RCC_HCLK_DIV16);
 8005b48:	4a31      	ldr	r2, [pc, #196]	@ (8005c10 <HAL_RCC_ClockConfig+0x1ec>)
 8005b4a:	6893      	ldr	r3, [r2, #8]
 8005b4c:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
 8005b50:	f443 63e0 	orr.w	r3, r3, #1792	@ 0x700
 8005b54:	6093      	str	r3, [r2, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8005b56:	4a2e      	ldr	r2, [pc, #184]	@ (8005c10 <HAL_RCC_ClockConfig+0x1ec>)
 8005b58:	68a1      	ldr	r1, [r4, #8]
 8005b5a:	6893      	ldr	r3, [r2, #8]
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8005b5c:	4e2b      	ldr	r6, [pc, #172]	@ (8005c0c <HAL_RCC_ClockConfig+0x1e8>)
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8005b5e:	f023 03f0 	bic.w	r3, r3, #240	@ 0xf0
 8005b62:	430b      	orrs	r3, r1
 8005b64:	6093      	str	r3, [r2, #8]
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8005b66:	6833      	ldr	r3, [r6, #0]
 8005b68:	f003 030f 	and.w	r3, r3, #15
 8005b6c:	42ab      	cmp	r3, r5
 8005b6e:	d9b8      	bls.n	8005ae2 <HAL_RCC_ClockConfig+0xbe>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8005b70:	6833      	ldr	r3, [r6, #0]
 8005b72:	f023 030f 	bic.w	r3, r3, #15
 8005b76:	432b      	orrs	r3, r5
 8005b78:	6033      	str	r3, [r6, #0]
    tickstart = HAL_GetTick();
 8005b7a:	f7fe fb99 	bl	80042b0 <HAL_GetTick>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8005b7e:	f241 3888 	movw	r8, #5000	@ 0x1388
    tickstart = HAL_GetTick();
 8005b82:	4607      	mov	r7, r0
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 8005b84:	6833      	ldr	r3, [r6, #0]
 8005b86:	f003 030f 	and.w	r3, r3, #15
 8005b8a:	42ab      	cmp	r3, r5
 8005b8c:	d0a9      	beq.n	8005ae2 <HAL_RCC_ClockConfig+0xbe>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8005b8e:	f7fe fb8f 	bl	80042b0 <HAL_GetTick>
 8005b92:	1bc0      	subs	r0, r0, r7
 8005b94:	4540      	cmp	r0, r8
 8005b96:	d9f5      	bls.n	8005b84 <HAL_RCC_ClockConfig+0x160>
        return HAL_TIMEOUT;
 8005b98:	2003      	movs	r0, #3
}
 8005b9a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8005b9e:	039a      	lsls	r2, r3, #14
 8005ba0:	f53f af68 	bmi.w	8005a74 <HAL_RCC_ClockConfig+0x50>
 8005ba4:	e755      	b.n	8005a52 <HAL_RCC_ClockConfig+0x2e>
      if (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8005ba6:	4a1a      	ldr	r2, [pc, #104]	@ (8005c10 <HAL_RCC_ClockConfig+0x1ec>)
 8005ba8:	6811      	ldr	r1, [r2, #0]
 8005baa:	0188      	lsls	r0, r1, #6
 8005bac:	f57f af51 	bpl.w	8005a52 <HAL_RCC_ClockConfig+0x2e>
  uint32_t sysclockfreq;

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE/ PLLM) * PLLN
     SYSCLK = PLL_VCO / PLLR
   */
  pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8005bb0:	68d0      	ldr	r0, [r2, #12]
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8005bb2:	68d1      	ldr	r1, [r2, #12]
    pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
    break;

  case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
  default:
    pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8005bb4:	68d2      	ldr	r2, [r2, #12]
      if(pllfreq > 80000000U)
 8005bb6:	4e17      	ldr	r6, [pc, #92]	@ (8005c14 <HAL_RCC_ClockConfig+0x1f0>)
  pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8005bb8:	f000 0003 	and.w	r0, r0, #3
  switch (pllsource)
 8005bbc:	2803      	cmp	r0, #3
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8005bbe:	f3c1 1103 	ubfx	r1, r1, #4, #4
    pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8005bc2:	bf0c      	ite	eq
 8005bc4:	4817      	ldreq	r0, [pc, #92]	@ (8005c24 <HAL_RCC_ClockConfig+0x200>)
    pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8005bc6:	4818      	ldrne	r0, [pc, #96]	@ (8005c28 <HAL_RCC_ClockConfig+0x204>)
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8005bc8:	3101      	adds	r1, #1
    pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8005bca:	fbb0 f1f1 	udiv	r1, r0, r1
    break;
  }

  pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8005bce:	4810      	ldr	r0, [pc, #64]	@ (8005c10 <HAL_RCC_ClockConfig+0x1ec>)
    pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8005bd0:	f3c2 2206 	ubfx	r2, r2, #8, #7
 8005bd4:	fb01 f202 	mul.w	r2, r1, r2
  pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8005bd8:	68c1      	ldr	r1, [r0, #12]
 8005bda:	f3c1 6141 	ubfx	r1, r1, #25, #2
 8005bde:	3101      	adds	r1, #1
 8005be0:	0049      	lsls	r1, r1, #1
  sysclockfreq = pllvco/pllr;
 8005be2:	fbb2 f2f1 	udiv	r2, r2, r1
      if(pllfreq > 80000000U)
 8005be6:	42b2      	cmp	r2, r6
 8005be8:	d90a      	bls.n	8005c00 <HAL_RCC_ClockConfig+0x1dc>
        if (((READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) == RCC_SYSCLK_DIV1)) ||
 8005bea:	6882      	ldr	r2, [r0, #8]
 8005bec:	f012 0ff0 	tst.w	r2, #240	@ 0xf0
 8005bf0:	f43f af46 	beq.w	8005a80 <HAL_RCC_ClockConfig+0x5c>
 8005bf4:	0799      	lsls	r1, r3, #30
 8005bf6:	d503      	bpl.n	8005c00 <HAL_RCC_ClockConfig+0x1dc>
            (((((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK) &&
 8005bf8:	68a3      	ldr	r3, [r4, #8]
 8005bfa:	2b00      	cmp	r3, #0
 8005bfc:	f43f af40 	beq.w	8005a80 <HAL_RCC_ClockConfig+0x5c>
  uint32_t hpre = RCC_SYSCLK_DIV1;
 8005c00:	f04f 0900 	mov.w	r9, #0
 8005c04:	e745      	b.n	8005a92 <HAL_RCC_ClockConfig+0x6e>
    return HAL_ERROR;
 8005c06:	2001      	movs	r0, #1
}
 8005c08:	4770      	bx	lr
 8005c0a:	bf00      	nop
 8005c0c:	40022000 	.word	0x40022000
 8005c10:	40021000 	.word	0x40021000
 8005c14:	04c4b400 	.word	0x04c4b400
 8005c18:	0800a3f0 	.word	0x0800a3f0
 8005c1c:	20000558 	.word	0x20000558
 8005c20:	20000560 	.word	0x20000560
 8005c24:	016e3600 	.word	0x016e3600
 8005c28:	00f42400 	.word	0x00f42400

08005c2c <HAL_RCC_GetHCLKFreq>:
  return SystemCoreClock;
 8005c2c:	4b01      	ldr	r3, [pc, #4]	@ (8005c34 <HAL_RCC_GetHCLKFreq+0x8>)
}
 8005c2e:	6818      	ldr	r0, [r3, #0]
 8005c30:	4770      	bx	lr
 8005c32:	bf00      	nop
 8005c34:	20000558 	.word	0x20000558

08005c38 <HAL_RCC_GetPCLK1Freq>:
  return (HAL_RCC_GetHCLKFreq() >> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos] & 0x1FU));
 8005c38:	4b05      	ldr	r3, [pc, #20]	@ (8005c50 <HAL_RCC_GetPCLK1Freq+0x18>)
 8005c3a:	4a06      	ldr	r2, [pc, #24]	@ (8005c54 <HAL_RCC_GetPCLK1Freq+0x1c>)
 8005c3c:	689b      	ldr	r3, [r3, #8]
  return SystemCoreClock;
 8005c3e:	4906      	ldr	r1, [pc, #24]	@ (8005c58 <HAL_RCC_GetPCLK1Freq+0x20>)
  return (HAL_RCC_GetHCLKFreq() >> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos] & 0x1FU));
 8005c40:	f3c3 2302 	ubfx	r3, r3, #8, #3
 8005c44:	6808      	ldr	r0, [r1, #0]
 8005c46:	5cd3      	ldrb	r3, [r2, r3]
 8005c48:	f003 031f 	and.w	r3, r3, #31
}
 8005c4c:	40d8      	lsrs	r0, r3
 8005c4e:	4770      	bx	lr
 8005c50:	40021000 	.word	0x40021000
 8005c54:	0800a3e8 	.word	0x0800a3e8
 8005c58:	20000558 	.word	0x20000558

08005c5c <HAL_RCC_GetPCLK2Freq>:
  return (HAL_RCC_GetHCLKFreq()>> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos] & 0x1FU));
 8005c5c:	4b05      	ldr	r3, [pc, #20]	@ (8005c74 <HAL_RCC_GetPCLK2Freq+0x18>)
 8005c5e:	4a06      	ldr	r2, [pc, #24]	@ (8005c78 <HAL_RCC_GetPCLK2Freq+0x1c>)
 8005c60:	689b      	ldr	r3, [r3, #8]
  return SystemCoreClock;
 8005c62:	4906      	ldr	r1, [pc, #24]	@ (8005c7c <HAL_RCC_GetPCLK2Freq+0x20>)
  return (HAL_RCC_GetHCLKFreq()>> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos] & 0x1FU));
 8005c64:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 8005c68:	6808      	ldr	r0, [r1, #0]
 8005c6a:	5cd3      	ldrb	r3, [r2, r3]
 8005c6c:	f003 031f 	and.w	r3, r3, #31
}
 8005c70:	40d8      	lsrs	r0, r3
 8005c72:	4770      	bx	lr
 8005c74:	40021000 	.word	0x40021000
 8005c78:	0800a3e8 	.word	0x0800a3e8
 8005c7c:	20000558 	.word	0x20000558

08005c80 <HAL_RCC_GetClockConfig>:
  RCC_ClkInitStruct->SYSCLKSource = READ_BIT(RCC->CFGR, RCC_CFGR_SW);
 8005c80:	4b0e      	ldr	r3, [pc, #56]	@ (8005cbc <HAL_RCC_GetClockConfig+0x3c>)
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 8005c82:	220f      	movs	r2, #15
 8005c84:	6002      	str	r2, [r0, #0]
  RCC_ClkInitStruct->SYSCLKSource = READ_BIT(RCC->CFGR, RCC_CFGR_SW);
 8005c86:	689a      	ldr	r2, [r3, #8]
 8005c88:	f002 0203 	and.w	r2, r2, #3
 8005c8c:	6042      	str	r2, [r0, #4]
  RCC_ClkInitStruct->AHBCLKDivider = READ_BIT(RCC->CFGR, RCC_CFGR_HPRE);
 8005c8e:	689a      	ldr	r2, [r3, #8]
 8005c90:	f002 02f0 	and.w	r2, r2, #240	@ 0xf0
 8005c94:	6082      	str	r2, [r0, #8]
  RCC_ClkInitStruct->APB1CLKDivider = READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1);
 8005c96:	689a      	ldr	r2, [r3, #8]
 8005c98:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
 8005c9c:	60c2      	str	r2, [r0, #12]
  RCC_ClkInitStruct->APB2CLKDivider = (READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> 3U);
 8005c9e:	689b      	ldr	r3, [r3, #8]
 8005ca0:	08db      	lsrs	r3, r3, #3
{
 8005ca2:	b410      	push	{r4}
  RCC_ClkInitStruct->APB2CLKDivider = (READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> 3U);
 8005ca4:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
  *pFLatency = __HAL_FLASH_GET_LATENCY();
 8005ca8:	4c05      	ldr	r4, [pc, #20]	@ (8005cc0 <HAL_RCC_GetClockConfig+0x40>)
  RCC_ClkInitStruct->APB2CLKDivider = (READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> 3U);
 8005caa:	6103      	str	r3, [r0, #16]
  *pFLatency = __HAL_FLASH_GET_LATENCY();
 8005cac:	6823      	ldr	r3, [r4, #0]
}
 8005cae:	f85d 4b04 	ldr.w	r4, [sp], #4
  *pFLatency = __HAL_FLASH_GET_LATENCY();
 8005cb2:	f003 030f 	and.w	r3, r3, #15
 8005cb6:	600b      	str	r3, [r1, #0]
}
 8005cb8:	4770      	bx	lr
 8005cba:	bf00      	nop
 8005cbc:	40021000 	.word	0x40021000
 8005cc0:	40022000 	.word	0x40022000

08005cc4 <HAL_RCC_EnableCSS>:
  SET_BIT(RCC->CR, RCC_CR_CSSON) ;
 8005cc4:	4a02      	ldr	r2, [pc, #8]	@ (8005cd0 <HAL_RCC_EnableCSS+0xc>)
 8005cc6:	6813      	ldr	r3, [r2, #0]
 8005cc8:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 8005ccc:	6013      	str	r3, [r2, #0]
}
 8005cce:	4770      	bx	lr
 8005cd0:	40021000 	.word	0x40021000

08005cd4 <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8005cd4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- RTC clock source configuration ----------------------*/
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8005cd8:	6803      	ldr	r3, [r0, #0]
{
 8005cda:	4604      	mov	r4, r0
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8005cdc:	f413 2000 	ands.w	r0, r3, #524288	@ 0x80000
{
 8005ce0:	b082      	sub	sp, #8
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8005ce2:	d052      	beq.n	8005d8a <HAL_RCCEx_PeriphCLKConfig+0xb6>
    
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8005ce4:	4ba1      	ldr	r3, [pc, #644]	@ (8005f6c <HAL_RCCEx_PeriphCLKConfig+0x298>)
 8005ce6:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 8005ce8:	00d5      	lsls	r5, r2, #3
 8005cea:	f140 8108 	bpl.w	8005efe <HAL_RCCEx_PeriphCLKConfig+0x22a>
    FlagStatus       pwrclkchanged = RESET;
 8005cee:	2700      	movs	r7, #0
      __HAL_RCC_PWR_CLK_ENABLE();
      pwrclkchanged = SET;
    }
      
    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8005cf0:	4d9f      	ldr	r5, [pc, #636]	@ (8005f70 <HAL_RCCEx_PeriphCLKConfig+0x29c>)
 8005cf2:	682b      	ldr	r3, [r5, #0]
 8005cf4:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8005cf8:	602b      	str	r3, [r5, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 8005cfa:	f7fe fad9 	bl	80042b0 <HAL_GetTick>
 8005cfe:	4606      	mov	r6, r0

    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 8005d00:	e005      	b.n	8005d0e <HAL_RCCEx_PeriphCLKConfig+0x3a>
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8005d02:	f7fe fad5 	bl	80042b0 <HAL_GetTick>
 8005d06:	1b83      	subs	r3, r0, r6
 8005d08:	2b02      	cmp	r3, #2
 8005d0a:	f200 8103 	bhi.w	8005f14 <HAL_RCCEx_PeriphCLKConfig+0x240>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 8005d0e:	682b      	ldr	r3, [r5, #0]
 8005d10:	05d8      	lsls	r0, r3, #23
 8005d12:	d5f6      	bpl.n	8005d02 <HAL_RCCEx_PeriphCLKConfig+0x2e>
    }

    if(ret == HAL_OK)
    { 
      /* Reset the Backup domain only if the RTC Clock source selection is modified from default */
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 8005d14:	4d95      	ldr	r5, [pc, #596]	@ (8005f6c <HAL_RCCEx_PeriphCLKConfig+0x298>)
      
      if((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
 8005d16:	6c22      	ldr	r2, [r4, #64]	@ 0x40
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 8005d18:	f8d5 3090 	ldr.w	r3, [r5, #144]	@ 0x90
      if((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
 8005d1c:	f413 7340 	ands.w	r3, r3, #768	@ 0x300
 8005d20:	d026      	beq.n	8005d70 <HAL_RCCEx_PeriphCLKConfig+0x9c>
 8005d22:	4293      	cmp	r3, r2
 8005d24:	d024      	beq.n	8005d70 <HAL_RCCEx_PeriphCLKConfig+0x9c>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8005d26:	f8d5 1090 	ldr.w	r1, [r5, #144]	@ 0x90
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
 8005d2a:	f8d5 3090 	ldr.w	r3, [r5, #144]	@ 0x90
 8005d2e:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8005d32:	f8c5 3090 	str.w	r3, [r5, #144]	@ 0x90
        __HAL_RCC_BACKUPRESET_RELEASE();
 8005d36:	f8d5 3090 	ldr.w	r3, [r5, #144]	@ 0x90
 8005d3a:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8005d3e:	f8c5 3090 	str.w	r3, [r5, #144]	@ 0x90
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8005d42:	f421 7340 	bic.w	r3, r1, #768	@ 0x300
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpregister;
      }

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 8005d46:	07c9      	lsls	r1, r1, #31
        RCC->BDCR = tmpregister;
 8005d48:	f8c5 3090 	str.w	r3, [r5, #144]	@ 0x90
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 8005d4c:	d510      	bpl.n	8005d70 <HAL_RCCEx_PeriphCLKConfig+0x9c>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8005d4e:	f7fe faaf 	bl	80042b0 <HAL_GetTick>

        /* Wait till LSE is ready */
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
        {
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8005d52:	f241 3888 	movw	r8, #5000	@ 0x1388
        tickstart = HAL_GetTick();
 8005d56:	4606      	mov	r6, r0
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8005d58:	e005      	b.n	8005d66 <HAL_RCCEx_PeriphCLKConfig+0x92>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8005d5a:	f7fe faa9 	bl	80042b0 <HAL_GetTick>
 8005d5e:	1b80      	subs	r0, r0, r6
 8005d60:	4540      	cmp	r0, r8
 8005d62:	f200 80d7 	bhi.w	8005f14 <HAL_RCCEx_PeriphCLKConfig+0x240>
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8005d66:	f8d5 3090 	ldr.w	r3, [r5, #144]	@ 0x90
 8005d6a:	079b      	lsls	r3, r3, #30
 8005d6c:	d5f5      	bpl.n	8005d5a <HAL_RCCEx_PeriphCLKConfig+0x86>
      }
      
      if(ret == HAL_OK)
      {
        /* Apply new RTC clock source selection */
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8005d6e:	6c22      	ldr	r2, [r4, #64]	@ 0x40
 8005d70:	497e      	ldr	r1, [pc, #504]	@ (8005f6c <HAL_RCCEx_PeriphCLKConfig+0x298>)
 8005d72:	f8d1 3090 	ldr.w	r3, [r1, #144]	@ 0x90
 8005d76:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8005d7a:	4313      	orrs	r3, r2
 8005d7c:	f8c1 3090 	str.w	r3, [r1, #144]	@ 0x90
      __HAL_RCC_PWR_CLK_DISABLE();
    }
  }

  /*-------------------------- USART1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8005d80:	6823      	ldr	r3, [r4, #0]
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
 8005d82:	2000      	movs	r0, #0
    if(pwrclkchanged == SET)
 8005d84:	2f00      	cmp	r7, #0
 8005d86:	f040 80ca 	bne.w	8005f1e <HAL_RCCEx_PeriphCLKConfig+0x24a>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8005d8a:	07de      	lsls	r6, r3, #31
 8005d8c:	d508      	bpl.n	8005da0 <HAL_RCCEx_PeriphCLKConfig+0xcc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8005d8e:	4977      	ldr	r1, [pc, #476]	@ (8005f6c <HAL_RCCEx_PeriphCLKConfig+0x298>)
 8005d90:	6865      	ldr	r5, [r4, #4]
 8005d92:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8005d96:	f022 0203 	bic.w	r2, r2, #3
 8005d9a:	432a      	orrs	r2, r5
 8005d9c:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
  }

  /*-------------------------- USART2 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8005da0:	079d      	lsls	r5, r3, #30
 8005da2:	d508      	bpl.n	8005db6 <HAL_RCCEx_PeriphCLKConfig+0xe2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8005da4:	4971      	ldr	r1, [pc, #452]	@ (8005f6c <HAL_RCCEx_PeriphCLKConfig+0x298>)
 8005da6:	68a5      	ldr	r5, [r4, #8]
 8005da8:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8005dac:	f022 020c 	bic.w	r2, r2, #12
 8005db0:	432a      	orrs	r2, r5
 8005db2:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
  }

#if defined(USART3)

  /*-------------------------- USART3 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 8005db6:	0759      	lsls	r1, r3, #29
 8005db8:	d508      	bpl.n	8005dcc <HAL_RCCEx_PeriphCLKConfig+0xf8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 8005dba:	496c      	ldr	r1, [pc, #432]	@ (8005f6c <HAL_RCCEx_PeriphCLKConfig+0x298>)
 8005dbc:	68e5      	ldr	r5, [r4, #12]
 8005dbe:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8005dc2:	f022 0230 	bic.w	r2, r2, #48	@ 0x30
 8005dc6:	432a      	orrs	r2, r5
 8005dc8:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88

#endif /* USART3 */

#if defined(UART4)
  /*-------------------------- UART4 clock source configuration --------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 8005dcc:	071a      	lsls	r2, r3, #28
 8005dce:	d508      	bpl.n	8005de2 <HAL_RCCEx_PeriphCLKConfig+0x10e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 8005dd0:	4966      	ldr	r1, [pc, #408]	@ (8005f6c <HAL_RCCEx_PeriphCLKConfig+0x298>)
 8005dd2:	6925      	ldr	r5, [r4, #16]
 8005dd4:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8005dd8:	f022 02c0 	bic.w	r2, r2, #192	@ 0xc0
 8005ddc:	432a      	orrs	r2, r5
 8005dde:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
  }

#endif /* UART5 */

  /*-------------------------- LPUART1 clock source configuration ------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8005de2:	069f      	lsls	r7, r3, #26
 8005de4:	d508      	bpl.n	8005df8 <HAL_RCCEx_PeriphCLKConfig+0x124>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 8005de6:	4961      	ldr	r1, [pc, #388]	@ (8005f6c <HAL_RCCEx_PeriphCLKConfig+0x298>)
 8005de8:	6965      	ldr	r5, [r4, #20]
 8005dea:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8005dee:	f422 6240 	bic.w	r2, r2, #3072	@ 0xc00
 8005df2:	432a      	orrs	r2, r5
 8005df4:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
  }

  /*-------------------------- I2C1 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8005df8:	065e      	lsls	r6, r3, #25
 8005dfa:	d508      	bpl.n	8005e0e <HAL_RCCEx_PeriphCLKConfig+0x13a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8005dfc:	495b      	ldr	r1, [pc, #364]	@ (8005f6c <HAL_RCCEx_PeriphCLKConfig+0x298>)
 8005dfe:	69a5      	ldr	r5, [r4, #24]
 8005e00:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8005e04:	f422 5240 	bic.w	r2, r2, #12288	@ 0x3000
 8005e08:	432a      	orrs	r2, r5
 8005e0a:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
  }

  /*-------------------------- I2C2 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8005e0e:	061d      	lsls	r5, r3, #24
 8005e10:	d508      	bpl.n	8005e24 <HAL_RCCEx_PeriphCLKConfig+0x150>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 8005e12:	4956      	ldr	r1, [pc, #344]	@ (8005f6c <HAL_RCCEx_PeriphCLKConfig+0x298>)
 8005e14:	69e5      	ldr	r5, [r4, #28]
 8005e16:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8005e1a:	f422 4240 	bic.w	r2, r2, #49152	@ 0xc000
 8005e1e:	432a      	orrs	r2, r5
 8005e20:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
  }
#if defined(I2C3)

  /*-------------------------- I2C3 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8005e24:	05d9      	lsls	r1, r3, #23
 8005e26:	d508      	bpl.n	8005e3a <HAL_RCCEx_PeriphCLKConfig+0x166>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8005e28:	4950      	ldr	r1, [pc, #320]	@ (8005f6c <HAL_RCCEx_PeriphCLKConfig+0x298>)
 8005e2a:	6a25      	ldr	r5, [r4, #32]
 8005e2c:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8005e30:	f422 3240 	bic.w	r2, r2, #196608	@ 0x30000
 8005e34:	432a      	orrs	r2, r5
 8005e36:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
  }

#endif /* I2C4 */

  /*-------------------------- LPTIM1 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 8005e3a:	059a      	lsls	r2, r3, #22
 8005e3c:	d508      	bpl.n	8005e50 <HAL_RCCEx_PeriphCLKConfig+0x17c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LPTIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8005e3e:	494b      	ldr	r1, [pc, #300]	@ (8005f6c <HAL_RCCEx_PeriphCLKConfig+0x298>)
 8005e40:	6a65      	ldr	r5, [r4, #36]	@ 0x24
 8005e42:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8005e46:	f422 2240 	bic.w	r2, r2, #786432	@ 0xc0000
 8005e4a:	432a      	orrs	r2, r5
 8005e4c:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
  }

#if defined(SAI1) 
  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
 8005e50:	055f      	lsls	r7, r3, #21
 8005e52:	d50b      	bpl.n	8005e6c <HAL_RCCEx_PeriphCLKConfig+0x198>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    /* Configure the SAI1 interface clock source */
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8005e54:	4945      	ldr	r1, [pc, #276]	@ (8005f6c <HAL_RCCEx_PeriphCLKConfig+0x298>)
 8005e56:	6aa5      	ldr	r5, [r4, #40]	@ 0x28
 8005e58:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8005e5c:	f422 1240 	bic.w	r2, r2, #3145728	@ 0x300000
 8005e60:	432a      	orrs	r2, r5
    
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLL)
 8005e62:	f5b5 1f80 	cmp.w	r5, #1048576	@ 0x100000
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8005e66:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLL)
 8005e6a:	d05e      	beq.n	8005f2a <HAL_RCCEx_PeriphCLKConfig+0x256>

#endif /* SAI1 */

#if defined(SPI_I2S_SUPPORT)
  /*-------------------------- I2S clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S)
 8005e6c:	051e      	lsls	r6, r3, #20
 8005e6e:	d50b      	bpl.n	8005e88 <HAL_RCCEx_PeriphCLKConfig+0x1b4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));

    /* Configure the I2S interface clock source */
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 8005e70:	493e      	ldr	r1, [pc, #248]	@ (8005f6c <HAL_RCCEx_PeriphCLKConfig+0x298>)
 8005e72:	6ae5      	ldr	r5, [r4, #44]	@ 0x2c
 8005e74:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8005e78:	f422 0240 	bic.w	r2, r2, #12582912	@ 0xc00000
 8005e7c:	432a      	orrs	r2, r5
    
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLL)
 8005e7e:	f5b5 0f80 	cmp.w	r5, #4194304	@ 0x400000
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 8005e82:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLL)
 8005e86:	d055      	beq.n	8005f34 <HAL_RCCEx_PeriphCLKConfig+0x260>

#endif /* SPI_I2S_SUPPORT */

#if defined(FDCAN1)
  /*-------------------------- FDCAN clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
 8005e88:	04dd      	lsls	r5, r3, #19
 8005e8a:	d50b      	bpl.n	8005ea4 <HAL_RCCEx_PeriphCLKConfig+0x1d0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FDCANCLKSOURCE(PeriphClkInit->FdcanClockSelection));

    /* Configure the FDCAN interface clock source */
    __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
 8005e8c:	4937      	ldr	r1, [pc, #220]	@ (8005f6c <HAL_RCCEx_PeriphCLKConfig+0x298>)
 8005e8e:	6b25      	ldr	r5, [r4, #48]	@ 0x30
 8005e90:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8005e94:	f022 7240 	bic.w	r2, r2, #50331648	@ 0x3000000
 8005e98:	432a      	orrs	r2, r5
    
    if(PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_PLL)
 8005e9a:	f1b5 7f80 	cmp.w	r5, #16777216	@ 0x1000000
    __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
 8005e9e:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
    if(PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_PLL)
 8005ea2:	d04c      	beq.n	8005f3e <HAL_RCCEx_PeriphCLKConfig+0x26a>
#endif /* FDCAN1 */

#if defined(USB)

  /*-------------------------- USB clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 8005ea4:	0499      	lsls	r1, r3, #18
 8005ea6:	d50b      	bpl.n	8005ec0 <HAL_RCCEx_PeriphCLKConfig+0x1ec>
  {
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8005ea8:	4930      	ldr	r1, [pc, #192]	@ (8005f6c <HAL_RCCEx_PeriphCLKConfig+0x298>)
 8005eaa:	6b65      	ldr	r5, [r4, #52]	@ 0x34
 8005eac:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8005eb0:	f022 6240 	bic.w	r2, r2, #201326592	@ 0xc000000
 8005eb4:	432a      	orrs	r2, r5

    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 8005eb6:	f1b5 6f00 	cmp.w	r5, #134217728	@ 0x8000000
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8005eba:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 8005ebe:	d043      	beq.n	8005f48 <HAL_RCCEx_PeriphCLKConfig+0x274>
  }

#endif /* USB */

  /*-------------------------- RNG clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 8005ec0:	045a      	lsls	r2, r3, #17
 8005ec2:	d50b      	bpl.n	8005edc <HAL_RCCEx_PeriphCLKConfig+0x208>
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8005ec4:	4929      	ldr	r1, [pc, #164]	@ (8005f6c <HAL_RCCEx_PeriphCLKConfig+0x298>)
 8005ec6:	6ba5      	ldr	r5, [r4, #56]	@ 0x38
 8005ec8:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8005ecc:	f022 6240 	bic.w	r2, r2, #201326592	@ 0xc000000
 8005ed0:	432a      	orrs	r2, r5

    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 8005ed2:	f1b5 6f00 	cmp.w	r5, #134217728	@ 0x8000000
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8005ed6:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 8005eda:	d03a      	beq.n	8005f52 <HAL_RCCEx_PeriphCLKConfig+0x27e>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
    }
  }

  /*-------------------------- ADC12 clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC12) == RCC_PERIPHCLK_ADC12)
 8005edc:	041b      	lsls	r3, r3, #16
 8005ede:	d50b      	bpl.n	8005ef8 <HAL_RCCEx_PeriphCLKConfig+0x224>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADC12CLKSOURCE(PeriphClkInit->Adc12ClockSelection));

    /* Configure the ADC12 interface clock source */
    __HAL_RCC_ADC12_CONFIG(PeriphClkInit->Adc12ClockSelection);
 8005ee0:	4a22      	ldr	r2, [pc, #136]	@ (8005f6c <HAL_RCCEx_PeriphCLKConfig+0x298>)
 8005ee2:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
 8005ee4:	f8d2 3088 	ldr.w	r3, [r2, #136]	@ 0x88
 8005ee8:	f023 5340 	bic.w	r3, r3, #805306368	@ 0x30000000
 8005eec:	430b      	orrs	r3, r1
    
    if(PeriphClkInit->Adc12ClockSelection == RCC_ADC12CLKSOURCE_PLL)
 8005eee:	f1b1 5f80 	cmp.w	r1, #268435456	@ 0x10000000
    __HAL_RCC_ADC12_CONFIG(PeriphClkInit->Adc12ClockSelection);
 8005ef2:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
    if(PeriphClkInit->Adc12ClockSelection == RCC_ADC12CLKSOURCE_PLL)
 8005ef6:	d031      	beq.n	8005f5c <HAL_RCCEx_PeriphCLKConfig+0x288>
  }

#endif /* QUADSPI */

  return status;
}
 8005ef8:	b002      	add	sp, #8
 8005efa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_PWR_CLK_ENABLE();
 8005efe:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 8005f00:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
 8005f04:	659a      	str	r2, [r3, #88]	@ 0x58
 8005f06:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8005f08:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8005f0c:	9301      	str	r3, [sp, #4]
 8005f0e:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8005f10:	2701      	movs	r7, #1
 8005f12:	e6ed      	b.n	8005cf0 <HAL_RCCEx_PeriphCLKConfig+0x1c>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8005f14:	6823      	ldr	r3, [r4, #0]
        status = ret;
 8005f16:	2003      	movs	r0, #3
    if(pwrclkchanged == SET)
 8005f18:	2f00      	cmp	r7, #0
 8005f1a:	f43f af36 	beq.w	8005d8a <HAL_RCCEx_PeriphCLKConfig+0xb6>
      __HAL_RCC_PWR_CLK_DISABLE();
 8005f1e:	4913      	ldr	r1, [pc, #76]	@ (8005f6c <HAL_RCCEx_PeriphCLKConfig+0x298>)
 8005f20:	6d8a      	ldr	r2, [r1, #88]	@ 0x58
 8005f22:	f022 5280 	bic.w	r2, r2, #268435456	@ 0x10000000
 8005f26:	658a      	str	r2, [r1, #88]	@ 0x58
 8005f28:	e72f      	b.n	8005d8a <HAL_RCCEx_PeriphCLKConfig+0xb6>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8005f2a:	68ca      	ldr	r2, [r1, #12]
 8005f2c:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
 8005f30:	60ca      	str	r2, [r1, #12]
 8005f32:	e79b      	b.n	8005e6c <HAL_RCCEx_PeriphCLKConfig+0x198>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8005f34:	68ca      	ldr	r2, [r1, #12]
 8005f36:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
 8005f3a:	60ca      	str	r2, [r1, #12]
 8005f3c:	e7a4      	b.n	8005e88 <HAL_RCCEx_PeriphCLKConfig+0x1b4>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8005f3e:	68ca      	ldr	r2, [r1, #12]
 8005f40:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
 8005f44:	60ca      	str	r2, [r1, #12]
 8005f46:	e7ad      	b.n	8005ea4 <HAL_RCCEx_PeriphCLKConfig+0x1d0>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8005f48:	68ca      	ldr	r2, [r1, #12]
 8005f4a:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
 8005f4e:	60ca      	str	r2, [r1, #12]
 8005f50:	e7b6      	b.n	8005ec0 <HAL_RCCEx_PeriphCLKConfig+0x1ec>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8005f52:	68ca      	ldr	r2, [r1, #12]
 8005f54:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
 8005f58:	60ca      	str	r2, [r1, #12]
 8005f5a:	e7bf      	b.n	8005edc <HAL_RCCEx_PeriphCLKConfig+0x208>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
 8005f5c:	68d3      	ldr	r3, [r2, #12]
 8005f5e:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8005f62:	60d3      	str	r3, [r2, #12]
}
 8005f64:	b002      	add	sp, #8
 8005f66:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005f6a:	bf00      	nop
 8005f6c:	40021000 	.word	0x40021000
 8005f70:	40007000 	.word	0x40007000

08005f74 <TIM_OC1_SetConfig>:
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8005f74:	6a03      	ldr	r3, [r0, #32]

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8005f76:	6a02      	ldr	r2, [r0, #32]
 8005f78:	f022 0201 	bic.w	r2, r2, #1
 8005f7c:	6202      	str	r2, [r0, #32]
{
 8005f7e:	b470      	push	{r4, r5, r6}

  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8005f80:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8005f82:	6982      	ldr	r2, [r0, #24]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8005f84:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 8005f86:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 8005f8a:	f022 0273 	bic.w	r2, r2, #115	@ 0x73
  tmpccmrx |= OC_Config->OCMode;
 8005f8e:	432a      	orrs	r2, r5

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 8005f90:	688d      	ldr	r5, [r1, #8]
  tmpccer &= ~TIM_CCER_CC1P;
 8005f92:	f023 0302 	bic.w	r3, r3, #2
  tmpccer |= OC_Config->OCPolarity;
 8005f96:	432b      	orrs	r3, r5

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 8005f98:	4d13      	ldr	r5, [pc, #76]	@ (8005fe8 <TIM_OC1_SetConfig+0x74>)
 8005f9a:	42a8      	cmp	r0, r5
 8005f9c:	d00f      	beq.n	8005fbe <TIM_OC1_SetConfig+0x4a>
 8005f9e:	f505 6500 	add.w	r5, r5, #2048	@ 0x800
 8005fa2:	42a8      	cmp	r0, r5
 8005fa4:	d00b      	beq.n	8005fbe <TIM_OC1_SetConfig+0x4a>
 8005fa6:	f505 6540 	add.w	r5, r5, #3072	@ 0xc00
 8005faa:	42a8      	cmp	r0, r5
 8005fac:	d007      	beq.n	8005fbe <TIM_OC1_SetConfig+0x4a>
 8005fae:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 8005fb2:	42a8      	cmp	r0, r5
 8005fb4:	d003      	beq.n	8005fbe <TIM_OC1_SetConfig+0x4a>
 8005fb6:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 8005fba:	42a8      	cmp	r0, r5
 8005fbc:	d10d      	bne.n	8005fda <TIM_OC1_SetConfig+0x66>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 8005fbe:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC1NP;
 8005fc0:	f023 0308 	bic.w	r3, r3, #8
    tmpccer |= OC_Config->OCNPolarity;
 8005fc4:	432b      	orrs	r3, r5
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 8005fc6:	e9d1 6505 	ldrd	r6, r5, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS1N;
 8005fca:	f424 7440 	bic.w	r4, r4, #768	@ 0x300
    tmpcr2 |= OC_Config->OCNIdleState;
 8005fce:	ea46 0c05 	orr.w	ip, r6, r5
    tmpccer &= ~TIM_CCER_CC1NE;
 8005fd2:	f023 0304 	bic.w	r3, r3, #4
    tmpcr2 |= OC_Config->OCNIdleState;
 8005fd6:	ea4c 0404 	orr.w	r4, ip, r4

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 8005fda:	6849      	ldr	r1, [r1, #4]
  TIMx->CR2 = tmpcr2;
 8005fdc:	6044      	str	r4, [r0, #4]
  TIMx->CCMR1 = tmpccmrx;
 8005fde:	6182      	str	r2, [r0, #24]

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
}
 8005fe0:	bc70      	pop	{r4, r5, r6}
  TIMx->CCR1 = OC_Config->Pulse;
 8005fe2:	6341      	str	r1, [r0, #52]	@ 0x34
  TIMx->CCER = tmpccer;
 8005fe4:	6203      	str	r3, [r0, #32]
}
 8005fe6:	4770      	bx	lr
 8005fe8:	40012c00 	.word	0x40012c00

08005fec <TIM_OC3_SetConfig>:
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8005fec:	6a03      	ldr	r3, [r0, #32]

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8005fee:	6a02      	ldr	r2, [r0, #32]
 8005ff0:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
 8005ff4:	6202      	str	r2, [r0, #32]
{
 8005ff6:	b470      	push	{r4, r5, r6}

  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8005ff8:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8005ffa:	69c2      	ldr	r2, [r0, #28]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
  tmpccmrx &= ~TIM_CCMR2_CC3S;
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8005ffc:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8005ffe:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 8006002:	f022 0273 	bic.w	r2, r2, #115	@ 0x73
  tmpccmrx |= OC_Config->OCMode;
 8006006:	432a      	orrs	r2, r5

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
 8006008:	688d      	ldr	r5, [r1, #8]
  tmpccer &= ~TIM_CCER_CC3P;
 800600a:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
  tmpccer |= (OC_Config->OCPolarity << 8U);
 800600e:	ea43 2305 	orr.w	r3, r3, r5, lsl #8

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 8006012:	4d14      	ldr	r5, [pc, #80]	@ (8006064 <TIM_OC3_SetConfig+0x78>)
 8006014:	42a8      	cmp	r0, r5
 8006016:	d00f      	beq.n	8006038 <TIM_OC3_SetConfig+0x4c>
 8006018:	f505 6500 	add.w	r5, r5, #2048	@ 0x800
 800601c:	42a8      	cmp	r0, r5
 800601e:	d00b      	beq.n	8006038 <TIM_OC3_SetConfig+0x4c>
    tmpccer |= (OC_Config->OCNPolarity << 8U);
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8006020:	4d11      	ldr	r5, [pc, #68]	@ (8006068 <TIM_OC3_SetConfig+0x7c>)
 8006022:	42a8      	cmp	r0, r5
 8006024:	d00f      	beq.n	8006046 <TIM_OC3_SetConfig+0x5a>
 8006026:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 800602a:	42a8      	cmp	r0, r5
 800602c:	d00b      	beq.n	8006046 <TIM_OC3_SetConfig+0x5a>
 800602e:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 8006032:	42a8      	cmp	r0, r5
 8006034:	d10f      	bne.n	8006056 <TIM_OC3_SetConfig+0x6a>
 8006036:	e006      	b.n	8006046 <TIM_OC3_SetConfig+0x5a>
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 8006038:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC3NP;
 800603a:	f423 6300 	bic.w	r3, r3, #2048	@ 0x800
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 800603e:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    tmpccer &= ~TIM_CCER_CC3NE;
 8006042:	f423 6380 	bic.w	r3, r3, #1024	@ 0x400
    tmpcr2 &= ~TIM_CR2_OIS3;
    tmpcr2 &= ~TIM_CR2_OIS3N;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8006046:	e9d1 6505 	ldrd	r6, r5, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS3N;
 800604a:	f424 5440 	bic.w	r4, r4, #12288	@ 0x3000
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 800604e:	ea46 0c05 	orr.w	ip, r6, r5
 8006052:	ea44 140c 	orr.w	r4, r4, ip, lsl #4

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 8006056:	6849      	ldr	r1, [r1, #4]
  TIMx->CR2 = tmpcr2;
 8006058:	6044      	str	r4, [r0, #4]
  TIMx->CCMR2 = tmpccmrx;
 800605a:	61c2      	str	r2, [r0, #28]

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
}
 800605c:	bc70      	pop	{r4, r5, r6}
  TIMx->CCR3 = OC_Config->Pulse;
 800605e:	63c1      	str	r1, [r0, #60]	@ 0x3c
  TIMx->CCER = tmpccer;
 8006060:	6203      	str	r3, [r0, #32]
}
 8006062:	4770      	bx	lr
 8006064:	40012c00 	.word	0x40012c00
 8006068:	40014000 	.word	0x40014000

0800606c <TIM_OC4_SetConfig>:
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800606c:	6a03      	ldr	r3, [r0, #32]

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 800606e:	6a02      	ldr	r2, [r0, #32]
 8006070:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
 8006074:	6202      	str	r2, [r0, #32]
{
 8006076:	b470      	push	{r4, r5, r6}

  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8006078:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 800607a:	69c2      	ldr	r2, [r0, #28]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
  tmpccmrx &= ~TIM_CCMR2_CC4S;

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 800607c:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 800607e:	f022 7280 	bic.w	r2, r2, #16777216	@ 0x1000000
 8006082:	f422 42e6 	bic.w	r2, r2, #29440	@ 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8006086:	ea42 2205 	orr.w	r2, r2, r5, lsl #8

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 800608a:	688d      	ldr	r5, [r1, #8]
  tmpccer &= ~TIM_CCER_CC4P;
 800608c:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
  tmpccer |= (OC_Config->OCPolarity << 12U);
 8006090:	ea43 3305 	orr.w	r3, r3, r5, lsl #12

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_4))
 8006094:	4d14      	ldr	r5, [pc, #80]	@ (80060e8 <TIM_OC4_SetConfig+0x7c>)
 8006096:	42a8      	cmp	r0, r5
 8006098:	d00f      	beq.n	80060ba <TIM_OC4_SetConfig+0x4e>
 800609a:	f505 6500 	add.w	r5, r5, #2048	@ 0x800
 800609e:	42a8      	cmp	r0, r5
 80060a0:	d00b      	beq.n	80060ba <TIM_OC4_SetConfig+0x4e>
    tmpccer |= (OC_Config->OCNPolarity << 12U);
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC4NE;
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 80060a2:	4d12      	ldr	r5, [pc, #72]	@ (80060ec <TIM_OC4_SetConfig+0x80>)
 80060a4:	42a8      	cmp	r0, r5
 80060a6:	d00f      	beq.n	80060c8 <TIM_OC4_SetConfig+0x5c>
 80060a8:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 80060ac:	42a8      	cmp	r0, r5
 80060ae:	d00b      	beq.n	80060c8 <TIM_OC4_SetConfig+0x5c>
 80060b0:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 80060b4:	42a8      	cmp	r0, r5
 80060b6:	d10f      	bne.n	80060d8 <TIM_OC4_SetConfig+0x6c>
 80060b8:	e006      	b.n	80060c8 <TIM_OC4_SetConfig+0x5c>
    tmpccer |= (OC_Config->OCNPolarity << 12U);
 80060ba:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC4NP;
 80060bc:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
    tmpccer |= (OC_Config->OCNPolarity << 12U);
 80060c0:	ea43 3305 	orr.w	r3, r3, r5, lsl #12
    tmpccer &= ~TIM_CCER_CC4NE;
 80060c4:	f423 4380 	bic.w	r3, r3, #16384	@ 0x4000
    tmpcr2 &= ~TIM_CR2_OIS4N;

    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 6U);
 80060c8:	e9d1 6505 	ldrd	r6, r5, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS4N;
 80060cc:	f424 4440 	bic.w	r4, r4, #49152	@ 0xc000
    tmpcr2 |= (OC_Config->OCNIdleState << 6U);
 80060d0:	ea46 0c05 	orr.w	ip, r6, r5
 80060d4:	ea44 148c 	orr.w	r4, r4, ip, lsl #6

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 80060d8:	6849      	ldr	r1, [r1, #4]
  TIMx->CR2 = tmpcr2;
 80060da:	6044      	str	r4, [r0, #4]
  TIMx->CCMR2 = tmpccmrx;
 80060dc:	61c2      	str	r2, [r0, #28]

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
}
 80060de:	bc70      	pop	{r4, r5, r6}
  TIMx->CCR4 = OC_Config->Pulse;
 80060e0:	6401      	str	r1, [r0, #64]	@ 0x40
  TIMx->CCER = tmpccer;
 80060e2:	6203      	str	r3, [r0, #32]
}
 80060e4:	4770      	bx	lr
 80060e6:	bf00      	nop
 80060e8:	40012c00 	.word	0x40012c00
 80060ec:	40014000 	.word	0x40014000

080060f0 <HAL_TIM_Base_MspInit>:
}
 80060f0:	4770      	bx	lr
 80060f2:	bf00      	nop

080060f4 <HAL_TIM_Base_Init>:
  if (htim == NULL)
 80060f4:	2800      	cmp	r0, #0
 80060f6:	d075      	beq.n	80061e4 <HAL_TIM_Base_Init+0xf0>
{
 80060f8:	b570      	push	{r4, r5, r6, lr}
  if (htim->State == HAL_TIM_STATE_RESET)
 80060fa:	f890 303d 	ldrb.w	r3, [r0, #61]	@ 0x3d
 80060fe:	4604      	mov	r4, r0
 8006100:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 8006104:	2b00      	cmp	r3, #0
 8006106:	d068      	beq.n	80061da <HAL_TIM_Base_Init+0xe6>
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8006108:	6823      	ldr	r3, [r4, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800610a:	4e37      	ldr	r6, [pc, #220]	@ (80061e8 <HAL_TIM_Base_Init+0xf4>)
  TIMx->PSC = Structure->Prescaler;
 800610c:	6861      	ldr	r1, [r4, #4]
  TIMx->ARR = (uint32_t)Structure->Period ;
 800610e:	68e0      	ldr	r0, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8006110:	69a5      	ldr	r5, [r4, #24]
  htim->State = HAL_TIM_STATE_BUSY;
 8006112:	2202      	movs	r2, #2
 8006114:	f884 203d 	strb.w	r2, [r4, #61]	@ 0x3d
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8006118:	42b3      	cmp	r3, r6
  tmpcr1 = TIMx->CR1;
 800611a:	681a      	ldr	r2, [r3, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800611c:	d04c      	beq.n	80061b8 <HAL_TIM_Base_Init+0xc4>
 800611e:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8006122:	d017      	beq.n	8006154 <HAL_TIM_Base_Init+0x60>
 8006124:	f5a6 3694 	sub.w	r6, r6, #75776	@ 0x12800
 8006128:	42b3      	cmp	r3, r6
 800612a:	d013      	beq.n	8006154 <HAL_TIM_Base_Init+0x60>
 800612c:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
 8006130:	42b3      	cmp	r3, r6
 8006132:	d00f      	beq.n	8006154 <HAL_TIM_Base_Init+0x60>
 8006134:	f506 3696 	add.w	r6, r6, #76800	@ 0x12c00
 8006138:	42b3      	cmp	r3, r6
 800613a:	d03d      	beq.n	80061b8 <HAL_TIM_Base_Init+0xc4>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800613c:	4e2b      	ldr	r6, [pc, #172]	@ (80061ec <HAL_TIM_Base_Init+0xf8>)
 800613e:	42b3      	cmp	r3, r6
 8006140:	d03e      	beq.n	80061c0 <HAL_TIM_Base_Init+0xcc>
 8006142:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
 8006146:	42b3      	cmp	r3, r6
 8006148:	d03a      	beq.n	80061c0 <HAL_TIM_Base_Init+0xcc>
 800614a:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
 800614e:	42b3      	cmp	r3, r6
 8006150:	d108      	bne.n	8006164 <HAL_TIM_Base_Init+0x70>
 8006152:	e035      	b.n	80061c0 <HAL_TIM_Base_Init+0xcc>
    tmpcr1 |= Structure->CounterMode;
 8006154:	68a6      	ldr	r6, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8006156:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
    tmpcr1 |= Structure->CounterMode;
 800615a:	4332      	orrs	r2, r6
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800615c:	6926      	ldr	r6, [r4, #16]
    tmpcr1 &= ~TIM_CR1_CKD;
 800615e:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8006162:	4332      	orrs	r2, r6
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8006164:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 8006168:	432a      	orrs	r2, r5
  TIMx->CR1 = tmpcr1;
 800616a:	601a      	str	r2, [r3, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 800616c:	62d8      	str	r0, [r3, #44]	@ 0x2c
  TIMx->PSC = Structure->Prescaler;
 800616e:	6299      	str	r1, [r3, #40]	@ 0x28
  TIMx->EGR = TIM_EGR_UG;
 8006170:	2201      	movs	r2, #1
 8006172:	615a      	str	r2, [r3, #20]
  if (HAL_IS_BIT_SET(TIMx->SR, TIM_FLAG_UPDATE))
 8006174:	691a      	ldr	r2, [r3, #16]
 8006176:	07d2      	lsls	r2, r2, #31
 8006178:	d503      	bpl.n	8006182 <HAL_TIM_Base_Init+0x8e>
    CLEAR_BIT(TIMx->SR, TIM_FLAG_UPDATE);
 800617a:	691a      	ldr	r2, [r3, #16]
 800617c:	f022 0201 	bic.w	r2, r2, #1
 8006180:	611a      	str	r2, [r3, #16]
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8006182:	2301      	movs	r3, #1
 8006184:	f884 3048 	strb.w	r3, [r4, #72]	@ 0x48
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8006188:	f884 303e 	strb.w	r3, [r4, #62]	@ 0x3e
 800618c:	f884 303f 	strb.w	r3, [r4, #63]	@ 0x3f
 8006190:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
 8006194:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
 8006198:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 800619c:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 80061a0:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
 80061a4:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
 80061a8:	f884 3046 	strb.w	r3, [r4, #70]	@ 0x46
 80061ac:	f884 3047 	strb.w	r3, [r4, #71]	@ 0x47
  htim->State = HAL_TIM_STATE_READY;
 80061b0:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  return HAL_OK;
 80061b4:	2000      	movs	r0, #0
}
 80061b6:	bd70      	pop	{r4, r5, r6, pc}
    tmpcr1 |= Structure->CounterMode;
 80061b8:	68a6      	ldr	r6, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80061ba:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
    tmpcr1 |= Structure->CounterMode;
 80061be:	4332      	orrs	r2, r6
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80061c0:	6926      	ldr	r6, [r4, #16]
    tmpcr1 &= ~TIM_CR1_CKD;
 80061c2:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80061c6:	4332      	orrs	r2, r6
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80061c8:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 80061cc:	432a      	orrs	r2, r5
  TIMx->CR1 = tmpcr1;
 80061ce:	601a      	str	r2, [r3, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 80061d0:	62d8      	str	r0, [r3, #44]	@ 0x2c
  TIMx->PSC = Structure->Prescaler;
 80061d2:	6299      	str	r1, [r3, #40]	@ 0x28
    TIMx->RCR = Structure->RepetitionCounter;
 80061d4:	6962      	ldr	r2, [r4, #20]
 80061d6:	631a      	str	r2, [r3, #48]	@ 0x30
 80061d8:	e7ca      	b.n	8006170 <HAL_TIM_Base_Init+0x7c>
    htim->Lock = HAL_UNLOCKED;
 80061da:	f880 203c 	strb.w	r2, [r0, #60]	@ 0x3c
    HAL_TIM_Base_MspInit(htim);
 80061de:	f7ff ff87 	bl	80060f0 <HAL_TIM_Base_MspInit>
 80061e2:	e791      	b.n	8006108 <HAL_TIM_Base_Init+0x14>
    return HAL_ERROR;
 80061e4:	2001      	movs	r0, #1
}
 80061e6:	4770      	bx	lr
 80061e8:	40012c00 	.word	0x40012c00
 80061ec:	40014000 	.word	0x40014000

080061f0 <HAL_TIM_Base_Start_IT>:
  if (htim->State != HAL_TIM_STATE_READY)
 80061f0:	f890 303d 	ldrb.w	r3, [r0, #61]	@ 0x3d
 80061f4:	2b01      	cmp	r3, #1
 80061f6:	d122      	bne.n	800623e <HAL_TIM_Base_Start_IT+0x4e>
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 80061f8:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 80061fa:	4916      	ldr	r1, [pc, #88]	@ (8006254 <HAL_TIM_Base_Start_IT+0x64>)
  htim->State = HAL_TIM_STATE_BUSY;
 80061fc:	2202      	movs	r2, #2
 80061fe:	f880 203d 	strb.w	r2, [r0, #61]	@ 0x3d
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8006202:	68da      	ldr	r2, [r3, #12]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8006204:	428b      	cmp	r3, r1
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8006206:	f042 0201 	orr.w	r2, r2, #1
 800620a:	60da      	str	r2, [r3, #12]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800620c:	d019      	beq.n	8006242 <HAL_TIM_Base_Start_IT+0x52>
 800620e:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8006212:	d016      	beq.n	8006242 <HAL_TIM_Base_Start_IT+0x52>
 8006214:	4a10      	ldr	r2, [pc, #64]	@ (8006258 <HAL_TIM_Base_Start_IT+0x68>)
 8006216:	4293      	cmp	r3, r2
 8006218:	d013      	beq.n	8006242 <HAL_TIM_Base_Start_IT+0x52>
 800621a:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 800621e:	4293      	cmp	r3, r2
 8006220:	d00f      	beq.n	8006242 <HAL_TIM_Base_Start_IT+0x52>
 8006222:	f502 3296 	add.w	r2, r2, #76800	@ 0x12c00
 8006226:	4293      	cmp	r3, r2
 8006228:	d00b      	beq.n	8006242 <HAL_TIM_Base_Start_IT+0x52>
 800622a:	f502 6240 	add.w	r2, r2, #3072	@ 0xc00
 800622e:	4293      	cmp	r3, r2
 8006230:	d007      	beq.n	8006242 <HAL_TIM_Base_Start_IT+0x52>
      __HAL_TIM_ENABLE(htim);
 8006232:	681a      	ldr	r2, [r3, #0]
 8006234:	f042 0201 	orr.w	r2, r2, #1
 8006238:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 800623a:	2000      	movs	r0, #0
 800623c:	4770      	bx	lr
    return HAL_ERROR;
 800623e:	2001      	movs	r0, #1
}
 8006240:	4770      	bx	lr
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8006242:	6899      	ldr	r1, [r3, #8]
 8006244:	4a05      	ldr	r2, [pc, #20]	@ (800625c <HAL_TIM_Base_Start_IT+0x6c>)
 8006246:	400a      	ands	r2, r1
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8006248:	2a06      	cmp	r2, #6
 800624a:	d0f6      	beq.n	800623a <HAL_TIM_Base_Start_IT+0x4a>
 800624c:	f5b2 3f80 	cmp.w	r2, #65536	@ 0x10000
 8006250:	d1ef      	bne.n	8006232 <HAL_TIM_Base_Start_IT+0x42>
 8006252:	e7f2      	b.n	800623a <HAL_TIM_Base_Start_IT+0x4a>
 8006254:	40012c00 	.word	0x40012c00
 8006258:	40000400 	.word	0x40000400
 800625c:	00010007 	.word	0x00010007

08006260 <HAL_TIM_PWM_Init>:
  if (htim == NULL)
 8006260:	2800      	cmp	r0, #0
 8006262:	d075      	beq.n	8006350 <HAL_TIM_PWM_Init+0xf0>
{
 8006264:	b570      	push	{r4, r5, r6, lr}
  if (htim->State == HAL_TIM_STATE_RESET)
 8006266:	f890 303d 	ldrb.w	r3, [r0, #61]	@ 0x3d
 800626a:	4604      	mov	r4, r0
 800626c:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 8006270:	2b00      	cmp	r3, #0
 8006272:	d068      	beq.n	8006346 <HAL_TIM_PWM_Init+0xe6>
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8006274:	6823      	ldr	r3, [r4, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8006276:	4e37      	ldr	r6, [pc, #220]	@ (8006354 <HAL_TIM_PWM_Init+0xf4>)
  TIMx->PSC = Structure->Prescaler;
 8006278:	6861      	ldr	r1, [r4, #4]
  TIMx->ARR = (uint32_t)Structure->Period ;
 800627a:	68e0      	ldr	r0, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800627c:	69a5      	ldr	r5, [r4, #24]
  htim->State = HAL_TIM_STATE_BUSY;
 800627e:	2202      	movs	r2, #2
 8006280:	f884 203d 	strb.w	r2, [r4, #61]	@ 0x3d
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8006284:	42b3      	cmp	r3, r6
  tmpcr1 = TIMx->CR1;
 8006286:	681a      	ldr	r2, [r3, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8006288:	d04c      	beq.n	8006324 <HAL_TIM_PWM_Init+0xc4>
 800628a:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 800628e:	d017      	beq.n	80062c0 <HAL_TIM_PWM_Init+0x60>
 8006290:	f5a6 3694 	sub.w	r6, r6, #75776	@ 0x12800
 8006294:	42b3      	cmp	r3, r6
 8006296:	d013      	beq.n	80062c0 <HAL_TIM_PWM_Init+0x60>
 8006298:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
 800629c:	42b3      	cmp	r3, r6
 800629e:	d00f      	beq.n	80062c0 <HAL_TIM_PWM_Init+0x60>
 80062a0:	f506 3696 	add.w	r6, r6, #76800	@ 0x12c00
 80062a4:	42b3      	cmp	r3, r6
 80062a6:	d03d      	beq.n	8006324 <HAL_TIM_PWM_Init+0xc4>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 80062a8:	4e2b      	ldr	r6, [pc, #172]	@ (8006358 <HAL_TIM_PWM_Init+0xf8>)
 80062aa:	42b3      	cmp	r3, r6
 80062ac:	d03e      	beq.n	800632c <HAL_TIM_PWM_Init+0xcc>
 80062ae:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
 80062b2:	42b3      	cmp	r3, r6
 80062b4:	d03a      	beq.n	800632c <HAL_TIM_PWM_Init+0xcc>
 80062b6:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
 80062ba:	42b3      	cmp	r3, r6
 80062bc:	d108      	bne.n	80062d0 <HAL_TIM_PWM_Init+0x70>
 80062be:	e035      	b.n	800632c <HAL_TIM_PWM_Init+0xcc>
    tmpcr1 |= Structure->CounterMode;
 80062c0:	68a6      	ldr	r6, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80062c2:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
    tmpcr1 |= Structure->CounterMode;
 80062c6:	4332      	orrs	r2, r6
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80062c8:	6926      	ldr	r6, [r4, #16]
    tmpcr1 &= ~TIM_CR1_CKD;
 80062ca:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80062ce:	4332      	orrs	r2, r6
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80062d0:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 80062d4:	432a      	orrs	r2, r5
  TIMx->CR1 = tmpcr1;
 80062d6:	601a      	str	r2, [r3, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 80062d8:	62d8      	str	r0, [r3, #44]	@ 0x2c
  TIMx->PSC = Structure->Prescaler;
 80062da:	6299      	str	r1, [r3, #40]	@ 0x28
  TIMx->EGR = TIM_EGR_UG;
 80062dc:	2201      	movs	r2, #1
 80062de:	615a      	str	r2, [r3, #20]
  if (HAL_IS_BIT_SET(TIMx->SR, TIM_FLAG_UPDATE))
 80062e0:	691a      	ldr	r2, [r3, #16]
 80062e2:	07d2      	lsls	r2, r2, #31
 80062e4:	d503      	bpl.n	80062ee <HAL_TIM_PWM_Init+0x8e>
    CLEAR_BIT(TIMx->SR, TIM_FLAG_UPDATE);
 80062e6:	691a      	ldr	r2, [r3, #16]
 80062e8:	f022 0201 	bic.w	r2, r2, #1
 80062ec:	611a      	str	r2, [r3, #16]
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 80062ee:	2301      	movs	r3, #1
 80062f0:	f884 3048 	strb.w	r3, [r4, #72]	@ 0x48
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 80062f4:	f884 303e 	strb.w	r3, [r4, #62]	@ 0x3e
 80062f8:	f884 303f 	strb.w	r3, [r4, #63]	@ 0x3f
 80062fc:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
 8006300:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
 8006304:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 8006308:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800630c:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
 8006310:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
 8006314:	f884 3046 	strb.w	r3, [r4, #70]	@ 0x46
 8006318:	f884 3047 	strb.w	r3, [r4, #71]	@ 0x47
  htim->State = HAL_TIM_STATE_READY;
 800631c:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  return HAL_OK;
 8006320:	2000      	movs	r0, #0
}
 8006322:	bd70      	pop	{r4, r5, r6, pc}
    tmpcr1 |= Structure->CounterMode;
 8006324:	68a6      	ldr	r6, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8006326:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
    tmpcr1 |= Structure->CounterMode;
 800632a:	4332      	orrs	r2, r6
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800632c:	6926      	ldr	r6, [r4, #16]
    tmpcr1 &= ~TIM_CR1_CKD;
 800632e:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8006332:	4332      	orrs	r2, r6
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8006334:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 8006338:	432a      	orrs	r2, r5
  TIMx->CR1 = tmpcr1;
 800633a:	601a      	str	r2, [r3, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 800633c:	62d8      	str	r0, [r3, #44]	@ 0x2c
  TIMx->PSC = Structure->Prescaler;
 800633e:	6299      	str	r1, [r3, #40]	@ 0x28
    TIMx->RCR = Structure->RepetitionCounter;
 8006340:	6962      	ldr	r2, [r4, #20]
 8006342:	631a      	str	r2, [r3, #48]	@ 0x30
 8006344:	e7ca      	b.n	80062dc <HAL_TIM_PWM_Init+0x7c>
    htim->Lock = HAL_UNLOCKED;
 8006346:	f880 203c 	strb.w	r2, [r0, #60]	@ 0x3c
    HAL_TIM_PWM_MspInit(htim);
 800634a:	f7fd fd71 	bl	8003e30 <HAL_TIM_PWM_MspInit>
 800634e:	e791      	b.n	8006274 <HAL_TIM_PWM_Init+0x14>
    return HAL_ERROR;
 8006350:	2001      	movs	r0, #1
}
 8006352:	4770      	bx	lr
 8006354:	40012c00 	.word	0x40012c00
 8006358:	40014000 	.word	0x40014000

0800635c <HAL_TIM_OC_DelayElapsedCallback>:
__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
 800635c:	4770      	bx	lr
 800635e:	bf00      	nop

08006360 <HAL_TIM_IC_CaptureCallback>:
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
 8006360:	4770      	bx	lr
 8006362:	bf00      	nop

08006364 <HAL_TIM_PWM_PulseFinishedCallback>:
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
 8006364:	4770      	bx	lr
 8006366:	bf00      	nop

08006368 <HAL_TIM_TriggerCallback>:
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
 8006368:	4770      	bx	lr
 800636a:	bf00      	nop

0800636c <HAL_TIM_IRQHandler>:
{
 800636c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t itsource = htim->Instance->DIER;
 800636e:	6803      	ldr	r3, [r0, #0]
 8006370:	68de      	ldr	r6, [r3, #12]
  uint32_t itflag   = htim->Instance->SR;
 8006372:	691c      	ldr	r4, [r3, #16]
  if ((itflag & (TIM_FLAG_CC1)) == (TIM_FLAG_CC1))
 8006374:	07a1      	lsls	r1, r4, #30
{
 8006376:	4605      	mov	r5, r0
  if ((itflag & (TIM_FLAG_CC1)) == (TIM_FLAG_CC1))
 8006378:	d501      	bpl.n	800637e <HAL_TIM_IRQHandler+0x12>
    if ((itsource & (TIM_IT_CC1)) == (TIM_IT_CC1))
 800637a:	07b2      	lsls	r2, r6, #30
 800637c:	d46e      	bmi.n	800645c <HAL_TIM_IRQHandler+0xf0>
  if ((itflag & (TIM_FLAG_CC2)) == (TIM_FLAG_CC2))
 800637e:	0760      	lsls	r0, r4, #29
 8006380:	d501      	bpl.n	8006386 <HAL_TIM_IRQHandler+0x1a>
    if ((itsource & (TIM_IT_CC2)) == (TIM_IT_CC2))
 8006382:	0771      	lsls	r1, r6, #29
 8006384:	d457      	bmi.n	8006436 <HAL_TIM_IRQHandler+0xca>
  if ((itflag & (TIM_FLAG_CC3)) == (TIM_FLAG_CC3))
 8006386:	0722      	lsls	r2, r4, #28
 8006388:	d501      	bpl.n	800638e <HAL_TIM_IRQHandler+0x22>
    if ((itsource & (TIM_IT_CC3)) == (TIM_IT_CC3))
 800638a:	0733      	lsls	r3, r6, #28
 800638c:	d440      	bmi.n	8006410 <HAL_TIM_IRQHandler+0xa4>
  if ((itflag & (TIM_FLAG_CC4)) == (TIM_FLAG_CC4))
 800638e:	06e1      	lsls	r1, r4, #27
 8006390:	d501      	bpl.n	8006396 <HAL_TIM_IRQHandler+0x2a>
    if ((itsource & (TIM_IT_CC4)) == (TIM_IT_CC4))
 8006392:	06f2      	lsls	r2, r6, #27
 8006394:	d428      	bmi.n	80063e8 <HAL_TIM_IRQHandler+0x7c>
  if ((itflag & (TIM_FLAG_UPDATE)) == (TIM_FLAG_UPDATE))
 8006396:	07e3      	lsls	r3, r4, #31
 8006398:	d501      	bpl.n	800639e <HAL_TIM_IRQHandler+0x32>
    if ((itsource & (TIM_IT_UPDATE)) == (TIM_IT_UPDATE))
 800639a:	07f7      	lsls	r7, r6, #31
 800639c:	d47c      	bmi.n	8006498 <HAL_TIM_IRQHandler+0x12c>
  if (((itflag & (TIM_FLAG_BREAK)) == (TIM_FLAG_BREAK)) || \
 800639e:	f414 5f02 	tst.w	r4, #8320	@ 0x2080
  if ((itflag & (TIM_FLAG_BREAK2)) == (TIM_FLAG_BREAK2))
 80063a2:	f404 7780 	and.w	r7, r4, #256	@ 0x100
  if (((itflag & (TIM_FLAG_BREAK)) == (TIM_FLAG_BREAK)) || \
 80063a6:	d069      	beq.n	800647c <HAL_TIM_IRQHandler+0x110>
    if ((itsource & (TIM_IT_BREAK)) == (TIM_IT_BREAK))
 80063a8:	0630      	lsls	r0, r6, #24
 80063aa:	d47d      	bmi.n	80064a8 <HAL_TIM_IRQHandler+0x13c>
  if ((itflag & (TIM_FLAG_TRIGGER)) == (TIM_FLAG_TRIGGER))
 80063ac:	0662      	lsls	r2, r4, #25
 80063ae:	d502      	bpl.n	80063b6 <HAL_TIM_IRQHandler+0x4a>
    if ((itsource & (TIM_IT_TRIGGER)) == (TIM_IT_TRIGGER))
 80063b0:	0673      	lsls	r3, r6, #25
 80063b2:	f100 808b 	bmi.w	80064cc <HAL_TIM_IRQHandler+0x160>
  if ((itflag & (TIM_FLAG_COM)) == (TIM_FLAG_COM))
 80063b6:	06a7      	lsls	r7, r4, #26
 80063b8:	d502      	bpl.n	80063c0 <HAL_TIM_IRQHandler+0x54>
    if ((itsource & (TIM_IT_COM)) == (TIM_IT_COM))
 80063ba:	06b0      	lsls	r0, r6, #26
 80063bc:	f100 808e 	bmi.w	80064dc <HAL_TIM_IRQHandler+0x170>
  if ((itflag & (TIM_FLAG_IDX)) == (TIM_FLAG_IDX))
 80063c0:	02e1      	lsls	r1, r4, #11
 80063c2:	d502      	bpl.n	80063ca <HAL_TIM_IRQHandler+0x5e>
    if ((itsource & (TIM_IT_IDX)) == (TIM_IT_IDX))
 80063c4:	02f2      	lsls	r2, r6, #11
 80063c6:	f100 8091 	bmi.w	80064ec <HAL_TIM_IRQHandler+0x180>
  if ((itflag & (TIM_FLAG_DIR)) == (TIM_FLAG_DIR))
 80063ca:	02a3      	lsls	r3, r4, #10
 80063cc:	d502      	bpl.n	80063d4 <HAL_TIM_IRQHandler+0x68>
    if ((itsource & (TIM_IT_DIR)) == (TIM_IT_DIR))
 80063ce:	02b7      	lsls	r7, r6, #10
 80063d0:	f100 8094 	bmi.w	80064fc <HAL_TIM_IRQHandler+0x190>
  if ((itflag & (TIM_FLAG_IERR)) == (TIM_FLAG_IERR))
 80063d4:	0260      	lsls	r0, r4, #9
 80063d6:	d502      	bpl.n	80063de <HAL_TIM_IRQHandler+0x72>
    if ((itsource & (TIM_IT_IERR)) == (TIM_IT_IERR))
 80063d8:	0271      	lsls	r1, r6, #9
 80063da:	f100 8097 	bmi.w	800650c <HAL_TIM_IRQHandler+0x1a0>
  if ((itflag & (TIM_FLAG_TERR)) == (TIM_FLAG_TERR))
 80063de:	0222      	lsls	r2, r4, #8
 80063e0:	d501      	bpl.n	80063e6 <HAL_TIM_IRQHandler+0x7a>
    if ((itsource & (TIM_IT_TERR)) == (TIM_IT_TERR))
 80063e2:	0233      	lsls	r3, r6, #8
 80063e4:	d44f      	bmi.n	8006486 <HAL_TIM_IRQHandler+0x11a>
}
 80063e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC4);
 80063e8:	682b      	ldr	r3, [r5, #0]
 80063ea:	f06f 0210 	mvn.w	r2, #16
 80063ee:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 80063f0:	2208      	movs	r2, #8
 80063f2:	772a      	strb	r2, [r5, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 80063f4:	69db      	ldr	r3, [r3, #28]
 80063f6:	f413 7f40 	tst.w	r3, #768	@ 0x300
        HAL_TIM_IC_CaptureCallback(htim);
 80063fa:	4628      	mov	r0, r5
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 80063fc:	f040 8097 	bne.w	800652e <HAL_TIM_IRQHandler+0x1c2>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8006400:	f7ff ffac 	bl	800635c <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8006404:	4628      	mov	r0, r5
 8006406:	f7ff ffad 	bl	8006364 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800640a:	2300      	movs	r3, #0
 800640c:	772b      	strb	r3, [r5, #28]
 800640e:	e7c2      	b.n	8006396 <HAL_TIM_IRQHandler+0x2a>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC3);
 8006410:	682b      	ldr	r3, [r5, #0]
 8006412:	f06f 0208 	mvn.w	r2, #8
 8006416:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8006418:	2204      	movs	r2, #4
 800641a:	772a      	strb	r2, [r5, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 800641c:	69db      	ldr	r3, [r3, #28]
 800641e:	079f      	lsls	r7, r3, #30
        HAL_TIM_IC_CaptureCallback(htim);
 8006420:	4628      	mov	r0, r5
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8006422:	f040 8081 	bne.w	8006528 <HAL_TIM_IRQHandler+0x1bc>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8006426:	f7ff ff99 	bl	800635c <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800642a:	4628      	mov	r0, r5
 800642c:	f7ff ff9a 	bl	8006364 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8006430:	2300      	movs	r3, #0
 8006432:	772b      	strb	r3, [r5, #28]
 8006434:	e7ab      	b.n	800638e <HAL_TIM_IRQHandler+0x22>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC2);
 8006436:	682b      	ldr	r3, [r5, #0]
 8006438:	f06f 0204 	mvn.w	r2, #4
 800643c:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 800643e:	2202      	movs	r2, #2
 8006440:	772a      	strb	r2, [r5, #28]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8006442:	699b      	ldr	r3, [r3, #24]
 8006444:	f413 7f40 	tst.w	r3, #768	@ 0x300
        HAL_TIM_IC_CaptureCallback(htim);
 8006448:	4628      	mov	r0, r5
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 800644a:	d16a      	bne.n	8006522 <HAL_TIM_IRQHandler+0x1b6>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800644c:	f7ff ff86 	bl	800635c <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8006450:	4628      	mov	r0, r5
 8006452:	f7ff ff87 	bl	8006364 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8006456:	2300      	movs	r3, #0
 8006458:	772b      	strb	r3, [r5, #28]
 800645a:	e794      	b.n	8006386 <HAL_TIM_IRQHandler+0x1a>
        __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC1);
 800645c:	f06f 0202 	mvn.w	r2, #2
 8006460:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8006462:	2201      	movs	r2, #1
 8006464:	7702      	strb	r2, [r0, #28]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8006466:	699b      	ldr	r3, [r3, #24]
 8006468:	079f      	lsls	r7, r3, #30
 800646a:	d157      	bne.n	800651c <HAL_TIM_IRQHandler+0x1b0>
          HAL_TIM_OC_DelayElapsedCallback(htim);
 800646c:	f7ff ff76 	bl	800635c <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8006470:	4628      	mov	r0, r5
 8006472:	f7ff ff77 	bl	8006364 <HAL_TIM_PWM_PulseFinishedCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8006476:	2300      	movs	r3, #0
 8006478:	772b      	strb	r3, [r5, #28]
 800647a:	e780      	b.n	800637e <HAL_TIM_IRQHandler+0x12>
  if ((itflag & (TIM_FLAG_BREAK2)) == (TIM_FLAG_BREAK2))
 800647c:	2f00      	cmp	r7, #0
 800647e:	d095      	beq.n	80063ac <HAL_TIM_IRQHandler+0x40>
    if ((itsource & (TIM_IT_BREAK)) == (TIM_IT_BREAK))
 8006480:	0631      	lsls	r1, r6, #24
 8006482:	d41b      	bmi.n	80064bc <HAL_TIM_IRQHandler+0x150>
 8006484:	e792      	b.n	80063ac <HAL_TIM_IRQHandler+0x40>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_TERR);
 8006486:	682b      	ldr	r3, [r5, #0]
 8006488:	f46f 0200 	mvn.w	r2, #8388608	@ 0x800000
 800648c:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_TransitionErrorCallback(htim);
 800648e:	4628      	mov	r0, r5
}
 8006490:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      HAL_TIMEx_TransitionErrorCallback(htim);
 8006494:	f000 ba7a 	b.w	800698c <HAL_TIMEx_TransitionErrorCallback>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_UPDATE);
 8006498:	682b      	ldr	r3, [r5, #0]
 800649a:	f06f 0201 	mvn.w	r2, #1
 800649e:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 80064a0:	4628      	mov	r0, r5
 80064a2:	f7fa fda3 	bl	8000fec <HAL_TIM_PeriodElapsedCallback>
 80064a6:	e77a      	b.n	800639e <HAL_TIM_IRQHandler+0x32>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK | TIM_FLAG_SYSTEM_BREAK);
 80064a8:	682b      	ldr	r3, [r5, #0]
 80064aa:	f46f 5202 	mvn.w	r2, #8320	@ 0x2080
 80064ae:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 80064b0:	4628      	mov	r0, r5
 80064b2:	f000 fa61 	bl	8006978 <HAL_TIMEx_BreakCallback>
  if ((itflag & (TIM_FLAG_BREAK2)) == (TIM_FLAG_BREAK2))
 80064b6:	2f00      	cmp	r7, #0
 80064b8:	f43f af78 	beq.w	80063ac <HAL_TIM_IRQHandler+0x40>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 80064bc:	682b      	ldr	r3, [r5, #0]
 80064be:	f46f 7280 	mvn.w	r2, #256	@ 0x100
 80064c2:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_Break2Callback(htim);
 80064c4:	4628      	mov	r0, r5
 80064c6:	f000 fa59 	bl	800697c <HAL_TIMEx_Break2Callback>
 80064ca:	e76f      	b.n	80063ac <HAL_TIM_IRQHandler+0x40>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_TRIGGER);
 80064cc:	682b      	ldr	r3, [r5, #0]
 80064ce:	f06f 0240 	mvn.w	r2, #64	@ 0x40
 80064d2:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 80064d4:	4628      	mov	r0, r5
 80064d6:	f7ff ff47 	bl	8006368 <HAL_TIM_TriggerCallback>
 80064da:	e76c      	b.n	80063b6 <HAL_TIM_IRQHandler+0x4a>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_COM);
 80064dc:	682b      	ldr	r3, [r5, #0]
 80064de:	f06f 0220 	mvn.w	r2, #32
 80064e2:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_CommutCallback(htim);
 80064e4:	4628      	mov	r0, r5
 80064e6:	f000 fa45 	bl	8006974 <HAL_TIMEx_CommutCallback>
 80064ea:	e769      	b.n	80063c0 <HAL_TIM_IRQHandler+0x54>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_IDX);
 80064ec:	682b      	ldr	r3, [r5, #0]
 80064ee:	f46f 1280 	mvn.w	r2, #1048576	@ 0x100000
 80064f2:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_EncoderIndexCallback(htim);
 80064f4:	4628      	mov	r0, r5
 80064f6:	f000 fa43 	bl	8006980 <HAL_TIMEx_EncoderIndexCallback>
 80064fa:	e766      	b.n	80063ca <HAL_TIM_IRQHandler+0x5e>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_DIR);
 80064fc:	682b      	ldr	r3, [r5, #0]
 80064fe:	f46f 1200 	mvn.w	r2, #2097152	@ 0x200000
 8006502:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_DirectionChangeCallback(htim);
 8006504:	4628      	mov	r0, r5
 8006506:	f000 fa3d 	bl	8006984 <HAL_TIMEx_DirectionChangeCallback>
 800650a:	e763      	b.n	80063d4 <HAL_TIM_IRQHandler+0x68>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_IERR);
 800650c:	682b      	ldr	r3, [r5, #0]
 800650e:	f46f 0280 	mvn.w	r2, #4194304	@ 0x400000
 8006512:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_IndexErrorCallback(htim);
 8006514:	4628      	mov	r0, r5
 8006516:	f000 fa37 	bl	8006988 <HAL_TIMEx_IndexErrorCallback>
 800651a:	e760      	b.n	80063de <HAL_TIM_IRQHandler+0x72>
          HAL_TIM_IC_CaptureCallback(htim);
 800651c:	f7ff ff20 	bl	8006360 <HAL_TIM_IC_CaptureCallback>
 8006520:	e7a9      	b.n	8006476 <HAL_TIM_IRQHandler+0x10a>
        HAL_TIM_IC_CaptureCallback(htim);
 8006522:	f7ff ff1d 	bl	8006360 <HAL_TIM_IC_CaptureCallback>
 8006526:	e796      	b.n	8006456 <HAL_TIM_IRQHandler+0xea>
        HAL_TIM_IC_CaptureCallback(htim);
 8006528:	f7ff ff1a 	bl	8006360 <HAL_TIM_IC_CaptureCallback>
 800652c:	e780      	b.n	8006430 <HAL_TIM_IRQHandler+0xc4>
        HAL_TIM_IC_CaptureCallback(htim);
 800652e:	f7ff ff17 	bl	8006360 <HAL_TIM_IC_CaptureCallback>
 8006532:	e76a      	b.n	800640a <HAL_TIM_IRQHandler+0x9e>

08006534 <TIM_OC2_SetConfig>:
  tmpccer = TIMx->CCER;
 8006534:	6a03      	ldr	r3, [r0, #32]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8006536:	6a02      	ldr	r2, [r0, #32]
 8006538:	f022 0210 	bic.w	r2, r2, #16
 800653c:	6202      	str	r2, [r0, #32]
{
 800653e:	b470      	push	{r4, r5, r6}
  tmpcr2 =  TIMx->CR2;
 8006540:	6844      	ldr	r4, [r0, #4]
  tmpccmrx = TIMx->CCMR1;
 8006542:	6982      	ldr	r2, [r0, #24]
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8006544:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 8006546:	f022 7280 	bic.w	r2, r2, #16777216	@ 0x1000000
 800654a:	f422 42e6 	bic.w	r2, r2, #29440	@ 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8U);
 800654e:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8006552:	688d      	ldr	r5, [r1, #8]
  tmpccer &= ~TIM_CCER_CC2P;
 8006554:	f023 0320 	bic.w	r3, r3, #32
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8006558:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 800655c:	4d14      	ldr	r5, [pc, #80]	@ (80065b0 <TIM_OC2_SetConfig+0x7c>)
 800655e:	42a8      	cmp	r0, r5
 8006560:	d00f      	beq.n	8006582 <TIM_OC2_SetConfig+0x4e>
 8006562:	f505 6500 	add.w	r5, r5, #2048	@ 0x800
 8006566:	42a8      	cmp	r0, r5
 8006568:	d00b      	beq.n	8006582 <TIM_OC2_SetConfig+0x4e>
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800656a:	4d12      	ldr	r5, [pc, #72]	@ (80065b4 <TIM_OC2_SetConfig+0x80>)
 800656c:	42a8      	cmp	r0, r5
 800656e:	d00f      	beq.n	8006590 <TIM_OC2_SetConfig+0x5c>
 8006570:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 8006574:	42a8      	cmp	r0, r5
 8006576:	d00b      	beq.n	8006590 <TIM_OC2_SetConfig+0x5c>
 8006578:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 800657c:	42a8      	cmp	r0, r5
 800657e:	d10f      	bne.n	80065a0 <TIM_OC2_SetConfig+0x6c>
 8006580:	e006      	b.n	8006590 <TIM_OC2_SetConfig+0x5c>
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8006582:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC2NP;
 8006584:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8006588:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
    tmpccer &= ~TIM_CCER_CC2NE;
 800658c:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8006590:	e9d1 6505 	ldrd	r6, r5, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8006594:	f424 6440 	bic.w	r4, r4, #3072	@ 0xc00
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8006598:	ea46 0c05 	orr.w	ip, r6, r5
 800659c:	ea44 048c 	orr.w	r4, r4, ip, lsl #2
  TIMx->CCR2 = OC_Config->Pulse;
 80065a0:	6849      	ldr	r1, [r1, #4]
  TIMx->CR2 = tmpcr2;
 80065a2:	6044      	str	r4, [r0, #4]
  TIMx->CCMR1 = tmpccmrx;
 80065a4:	6182      	str	r2, [r0, #24]
}
 80065a6:	bc70      	pop	{r4, r5, r6}
  TIMx->CCR2 = OC_Config->Pulse;
 80065a8:	6381      	str	r1, [r0, #56]	@ 0x38
  TIMx->CCER = tmpccer;
 80065aa:	6203      	str	r3, [r0, #32]
}
 80065ac:	4770      	bx	lr
 80065ae:	bf00      	nop
 80065b0:	40012c00 	.word	0x40012c00
 80065b4:	40014000 	.word	0x40014000

080065b8 <HAL_TIM_PWM_ConfigChannel>:
  __HAL_LOCK(htim);
 80065b8:	f890 303c 	ldrb.w	r3, [r0, #60]	@ 0x3c
 80065bc:	2b01      	cmp	r3, #1
 80065be:	f000 80dc 	beq.w	800677a <HAL_TIM_PWM_ConfigChannel+0x1c2>
 80065c2:	2301      	movs	r3, #1
{
 80065c4:	b570      	push	{r4, r5, r6, lr}
 80065c6:	4604      	mov	r4, r0
 80065c8:	460d      	mov	r5, r1
  __HAL_LOCK(htim);
 80065ca:	f880 303c 	strb.w	r3, [r0, #60]	@ 0x3c
  switch (Channel)
 80065ce:	2a14      	cmp	r2, #20
 80065d0:	d80c      	bhi.n	80065ec <HAL_TIM_PWM_ConfigChannel+0x34>
 80065d2:	e8df f002 	tbb	[pc, r2]
 80065d6:	0b4f      	.short	0x0b4f
 80065d8:	0b630b0b 	.word	0x0b630b0b
 80065dc:	0b740b0b 	.word	0x0b740b0b
 80065e0:	0b840b0b 	.word	0x0b840b0b
 80065e4:	0b950b0b 	.word	0x0b950b0b
 80065e8:	0b0b      	.short	0x0b0b
 80065ea:	10          	.byte	0x10
 80065eb:	00          	.byte	0x00
  __HAL_UNLOCK(htim);
 80065ec:	2300      	movs	r3, #0
 80065ee:	f884 303c 	strb.w	r3, [r4, #60]	@ 0x3c
  switch (Channel)
 80065f2:	2001      	movs	r0, #1
}
 80065f4:	bd70      	pop	{r4, r5, r6, pc}
      TIM_OC6_SetConfig(htim->Instance, sConfig);
 80065f6:	6803      	ldr	r3, [r0, #0]
  tmpccmrx = TIMx->CCMR3;

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80065f8:	682e      	ldr	r6, [r5, #0]
  tmpccer = TIMx->CCER;
 80065fa:	6a1a      	ldr	r2, [r3, #32]
  TIMx->CCER &= ~TIM_CCER_CC6E;
 80065fc:	6a19      	ldr	r1, [r3, #32]
 80065fe:	f421 1180 	bic.w	r1, r1, #1048576	@ 0x100000
 8006602:	6219      	str	r1, [r3, #32]
  tmpcr2 =  TIMx->CR2;
 8006604:	6858      	ldr	r0, [r3, #4]
  tmpccmrx = TIMx->CCMR3;
 8006606:	6d19      	ldr	r1, [r3, #80]	@ 0x50
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
 8006608:	f021 7180 	bic.w	r1, r1, #16777216	@ 0x1000000
 800660c:	f421 41e0 	bic.w	r1, r1, #28672	@ 0x7000
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8006610:	ea41 2106 	orr.w	r1, r1, r6, lsl #8

  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 20U);
 8006614:	68ae      	ldr	r6, [r5, #8]
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 8006616:	f422 1200 	bic.w	r2, r2, #2097152	@ 0x200000
  tmpccer |= (OC_Config->OCPolarity << 20U);
 800661a:	ea42 5206 	orr.w	r2, r2, r6, lsl #20

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800661e:	4e58      	ldr	r6, [pc, #352]	@ (8006780 <HAL_TIM_PWM_ConfigChannel+0x1c8>)
 8006620:	42b3      	cmp	r3, r6
 8006622:	d00f      	beq.n	8006644 <HAL_TIM_PWM_ConfigChannel+0x8c>
 8006624:	f506 6600 	add.w	r6, r6, #2048	@ 0x800
 8006628:	42b3      	cmp	r3, r6
 800662a:	d00b      	beq.n	8006644 <HAL_TIM_PWM_ConfigChannel+0x8c>
 800662c:	f506 6640 	add.w	r6, r6, #3072	@ 0xc00
 8006630:	42b3      	cmp	r3, r6
 8006632:	d007      	beq.n	8006644 <HAL_TIM_PWM_ConfigChannel+0x8c>
 8006634:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
 8006638:	42b3      	cmp	r3, r6
 800663a:	d003      	beq.n	8006644 <HAL_TIM_PWM_ConfigChannel+0x8c>
 800663c:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
 8006640:	42b3      	cmp	r3, r6
 8006642:	d104      	bne.n	800664e <HAL_TIM_PWM_ConfigChannel+0x96>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS6;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
 8006644:	696e      	ldr	r6, [r5, #20]
    tmpcr2 &= ~TIM_CR2_OIS6;
 8006646:	f420 2080 	bic.w	r0, r0, #262144	@ 0x40000
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
 800664a:	ea40 2086 	orr.w	r0, r0, r6, lsl #10
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800664e:	6058      	str	r0, [r3, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 8006650:	6519      	str	r1, [r3, #80]	@ 0x50

  /* Set the Capture Compare Register value */
  TIMx->CCR6 = OC_Config->Pulse;
 8006652:	6869      	ldr	r1, [r5, #4]
 8006654:	64d9      	str	r1, [r3, #76]	@ 0x4c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8006656:	621a      	str	r2, [r3, #32]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 8006658:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
 800665a:	6929      	ldr	r1, [r5, #16]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 800665c:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 8006660:	651a      	str	r2, [r3, #80]	@ 0x50
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
 8006662:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 8006664:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 8006668:	651a      	str	r2, [r3, #80]	@ 0x50
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
 800666a:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 800666c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8006670:	651a      	str	r2, [r3, #80]	@ 0x50
      break;
 8006672:	e00e      	b.n	8006692 <HAL_TIM_PWM_ConfigChannel+0xda>
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 8006674:	6800      	ldr	r0, [r0, #0]
 8006676:	f7ff fc7d 	bl	8005f74 <TIM_OC1_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 800667a:	6983      	ldr	r3, [r0, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 800667c:	692a      	ldr	r2, [r5, #16]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 800667e:	f043 0308 	orr.w	r3, r3, #8
 8006682:	6183      	str	r3, [r0, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 8006684:	6983      	ldr	r3, [r0, #24]
 8006686:	f023 0304 	bic.w	r3, r3, #4
 800668a:	6183      	str	r3, [r0, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 800668c:	6983      	ldr	r3, [r0, #24]
 800668e:	4313      	orrs	r3, r2
 8006690:	6183      	str	r3, [r0, #24]
  __HAL_UNLOCK(htim);
 8006692:	2300      	movs	r3, #0
 8006694:	f884 303c 	strb.w	r3, [r4, #60]	@ 0x3c
  HAL_StatusTypeDef status = HAL_OK;
 8006698:	2000      	movs	r0, #0
}
 800669a:	bd70      	pop	{r4, r5, r6, pc}
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 800669c:	6800      	ldr	r0, [r0, #0]
 800669e:	f7ff ff49 	bl	8006534 <TIM_OC2_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 80066a2:	6983      	ldr	r3, [r0, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 80066a4:	692a      	ldr	r2, [r5, #16]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 80066a6:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
 80066aa:	6183      	str	r3, [r0, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 80066ac:	6983      	ldr	r3, [r0, #24]
 80066ae:	f423 6380 	bic.w	r3, r3, #1024	@ 0x400
 80066b2:	6183      	str	r3, [r0, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 80066b4:	6983      	ldr	r3, [r0, #24]
 80066b6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80066ba:	6183      	str	r3, [r0, #24]
      break;
 80066bc:	e7e9      	b.n	8006692 <HAL_TIM_PWM_ConfigChannel+0xda>
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 80066be:	6800      	ldr	r0, [r0, #0]
 80066c0:	f7ff fc94 	bl	8005fec <TIM_OC3_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 80066c4:	69c3      	ldr	r3, [r0, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 80066c6:	692a      	ldr	r2, [r5, #16]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 80066c8:	f043 0308 	orr.w	r3, r3, #8
 80066cc:	61c3      	str	r3, [r0, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 80066ce:	69c3      	ldr	r3, [r0, #28]
 80066d0:	f023 0304 	bic.w	r3, r3, #4
 80066d4:	61c3      	str	r3, [r0, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 80066d6:	69c3      	ldr	r3, [r0, #28]
 80066d8:	4313      	orrs	r3, r2
 80066da:	61c3      	str	r3, [r0, #28]
      break;
 80066dc:	e7d9      	b.n	8006692 <HAL_TIM_PWM_ConfigChannel+0xda>
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 80066de:	6800      	ldr	r0, [r0, #0]
 80066e0:	f7ff fcc4 	bl	800606c <TIM_OC4_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 80066e4:	69c3      	ldr	r3, [r0, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 80066e6:	692a      	ldr	r2, [r5, #16]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 80066e8:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
 80066ec:	61c3      	str	r3, [r0, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 80066ee:	69c3      	ldr	r3, [r0, #28]
 80066f0:	f423 6380 	bic.w	r3, r3, #1024	@ 0x400
 80066f4:	61c3      	str	r3, [r0, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 80066f6:	69c3      	ldr	r3, [r0, #28]
 80066f8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80066fc:	61c3      	str	r3, [r0, #28]
      break;
 80066fe:	e7c8      	b.n	8006692 <HAL_TIM_PWM_ConfigChannel+0xda>
      TIM_OC5_SetConfig(htim->Instance, sConfig);
 8006700:	6803      	ldr	r3, [r0, #0]
  tmpccmrx |= OC_Config->OCMode;
 8006702:	682e      	ldr	r6, [r5, #0]
  tmpccer = TIMx->CCER;
 8006704:	6a1a      	ldr	r2, [r3, #32]
  TIMx->CCER &= ~TIM_CCER_CC5E;
 8006706:	6a19      	ldr	r1, [r3, #32]
 8006708:	f421 3180 	bic.w	r1, r1, #65536	@ 0x10000
 800670c:	6219      	str	r1, [r3, #32]
  tmpcr2 =  TIMx->CR2;
 800670e:	6858      	ldr	r0, [r3, #4]
  tmpccmrx = TIMx->CCMR3;
 8006710:	6d19      	ldr	r1, [r3, #80]	@ 0x50
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 8006712:	f421 3180 	bic.w	r1, r1, #65536	@ 0x10000
 8006716:	f021 0170 	bic.w	r1, r1, #112	@ 0x70
  tmpccmrx |= OC_Config->OCMode;
 800671a:	4331      	orrs	r1, r6
  tmpccer |= (OC_Config->OCPolarity << 16U);
 800671c:	68ae      	ldr	r6, [r5, #8]
  tmpccer &= ~TIM_CCER_CC5P;
 800671e:	f422 3200 	bic.w	r2, r2, #131072	@ 0x20000
  tmpccer |= (OC_Config->OCPolarity << 16U);
 8006722:	ea42 4206 	orr.w	r2, r2, r6, lsl #16
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8006726:	4e16      	ldr	r6, [pc, #88]	@ (8006780 <HAL_TIM_PWM_ConfigChannel+0x1c8>)
 8006728:	42b3      	cmp	r3, r6
 800672a:	d00f      	beq.n	800674c <HAL_TIM_PWM_ConfigChannel+0x194>
 800672c:	f506 6600 	add.w	r6, r6, #2048	@ 0x800
 8006730:	42b3      	cmp	r3, r6
 8006732:	d00b      	beq.n	800674c <HAL_TIM_PWM_ConfigChannel+0x194>
 8006734:	f506 6640 	add.w	r6, r6, #3072	@ 0xc00
 8006738:	42b3      	cmp	r3, r6
 800673a:	d007      	beq.n	800674c <HAL_TIM_PWM_ConfigChannel+0x194>
 800673c:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
 8006740:	42b3      	cmp	r3, r6
 8006742:	d003      	beq.n	800674c <HAL_TIM_PWM_ConfigChannel+0x194>
 8006744:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
 8006748:	42b3      	cmp	r3, r6
 800674a:	d104      	bne.n	8006756 <HAL_TIM_PWM_ConfigChannel+0x19e>
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
 800674c:	696e      	ldr	r6, [r5, #20]
    tmpcr2 &= ~TIM_CR2_OIS5;
 800674e:	f420 3080 	bic.w	r0, r0, #65536	@ 0x10000
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
 8006752:	ea40 2006 	orr.w	r0, r0, r6, lsl #8
  TIMx->CR2 = tmpcr2;
 8006756:	6058      	str	r0, [r3, #4]
  TIMx->CCMR3 = tmpccmrx;
 8006758:	6519      	str	r1, [r3, #80]	@ 0x50
  TIMx->CCR5 = OC_Config->Pulse;
 800675a:	6869      	ldr	r1, [r5, #4]
 800675c:	6499      	str	r1, [r3, #72]	@ 0x48
  TIMx->CCER = tmpccer;
 800675e:	621a      	str	r2, [r3, #32]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 8006760:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
 8006762:	6929      	ldr	r1, [r5, #16]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 8006764:	f042 0208 	orr.w	r2, r2, #8
 8006768:	651a      	str	r2, [r3, #80]	@ 0x50
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
 800676a:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 800676c:	f022 0204 	bic.w	r2, r2, #4
 8006770:	651a      	str	r2, [r3, #80]	@ 0x50
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
 8006772:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 8006774:	430a      	orrs	r2, r1
 8006776:	651a      	str	r2, [r3, #80]	@ 0x50
      break;
 8006778:	e78b      	b.n	8006692 <HAL_TIM_PWM_ConfigChannel+0xda>
  __HAL_LOCK(htim);
 800677a:	2002      	movs	r0, #2
}
 800677c:	4770      	bx	lr
 800677e:	bf00      	nop
 8006780:	40012c00 	.word	0x40012c00

08006784 <HAL_TIMEx_MasterConfigSynchronization>:
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 8006784:	f890 303c 	ldrb.w	r3, [r0, #60]	@ 0x3c
 8006788:	2b01      	cmp	r3, #1
 800678a:	d046      	beq.n	800681a <HAL_TIMEx_MasterConfigSynchronization+0x96>
{
 800678c:	b470      	push	{r4, r5, r6}
 800678e:	4602      	mov	r2, r0

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8006790:	4e23      	ldr	r6, [pc, #140]	@ (8006820 <HAL_TIMEx_MasterConfigSynchronization+0x9c>)
  tmpcr2 = htim->Instance->CR2;
 8006792:	6800      	ldr	r0, [r0, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 8006794:	2302      	movs	r3, #2
 8006796:	f882 303d 	strb.w	r3, [r2, #61]	@ 0x3d
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 800679a:	42b0      	cmp	r0, r6
  tmpcr2 = htim->Instance->CR2;
 800679c:	6843      	ldr	r3, [r0, #4]
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 800679e:	680d      	ldr	r5, [r1, #0]
  tmpsmcr = htim->Instance->SMCR;
 80067a0:	6884      	ldr	r4, [r0, #8]
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 80067a2:	d024      	beq.n	80067ee <HAL_TIMEx_MasterConfigSynchronization+0x6a>
 80067a4:	f506 6600 	add.w	r6, r6, #2048	@ 0x800
 80067a8:	42b0      	cmp	r0, r6
 80067aa:	d02b      	beq.n	8006804 <HAL_TIMEx_MasterConfigSynchronization+0x80>
  tmpcr2 &= ~TIM_CR2_MMS;
 80067ac:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
 80067b0:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 80067b4:	432b      	orrs	r3, r5

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 80067b6:	f1b0 4f80 	cmp.w	r0, #1073741824	@ 0x40000000
  htim->Instance->CR2 = tmpcr2;
 80067ba:	6043      	str	r3, [r0, #4]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 80067bc:	d00a      	beq.n	80067d4 <HAL_TIMEx_MasterConfigSynchronization+0x50>
 80067be:	4b19      	ldr	r3, [pc, #100]	@ (8006824 <HAL_TIMEx_MasterConfigSynchronization+0xa0>)
 80067c0:	4298      	cmp	r0, r3
 80067c2:	d007      	beq.n	80067d4 <HAL_TIMEx_MasterConfigSynchronization+0x50>
 80067c4:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80067c8:	4298      	cmp	r0, r3
 80067ca:	d003      	beq.n	80067d4 <HAL_TIMEx_MasterConfigSynchronization+0x50>
 80067cc:	f503 339c 	add.w	r3, r3, #79872	@ 0x13800
 80067d0:	4298      	cmp	r0, r3
 80067d2:	d104      	bne.n	80067de <HAL_TIMEx_MasterConfigSynchronization+0x5a>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 80067d4:	688b      	ldr	r3, [r1, #8]
    tmpsmcr &= ~TIM_SMCR_MSM;
 80067d6:	f024 0480 	bic.w	r4, r4, #128	@ 0x80
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 80067da:	431c      	orrs	r4, r3

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 80067dc:	6084      	str	r4, [r0, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;

  __HAL_UNLOCK(htim);
 80067de:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
 80067e0:	2301      	movs	r3, #1
 80067e2:	f882 303d 	strb.w	r3, [r2, #61]	@ 0x3d
  __HAL_UNLOCK(htim);
 80067e6:	f882 003c 	strb.w	r0, [r2, #60]	@ 0x3c

  return HAL_OK;
}
 80067ea:	bc70      	pop	{r4, r5, r6}
 80067ec:	4770      	bx	lr
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 80067ee:	684e      	ldr	r6, [r1, #4]
    tmpcr2 &= ~TIM_CR2_MMS2;
 80067f0:	f423 0370 	bic.w	r3, r3, #15728640	@ 0xf00000
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 80067f4:	4333      	orrs	r3, r6
  tmpcr2 &= ~TIM_CR2_MMS;
 80067f6:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
 80067fa:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 80067fe:	432b      	orrs	r3, r5
  htim->Instance->CR2 = tmpcr2;
 8006800:	6043      	str	r3, [r0, #4]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8006802:	e7e7      	b.n	80067d4 <HAL_TIMEx_MasterConfigSynchronization+0x50>
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 8006804:	684e      	ldr	r6, [r1, #4]
    tmpcr2 &= ~TIM_CR2_MMS2;
 8006806:	f423 0370 	bic.w	r3, r3, #15728640	@ 0xf00000
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 800680a:	4333      	orrs	r3, r6
  tmpcr2 &= ~TIM_CR2_MMS;
 800680c:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
 8006810:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8006814:	431d      	orrs	r5, r3
  htim->Instance->CR2 = tmpcr2;
 8006816:	6045      	str	r5, [r0, #4]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8006818:	e7dc      	b.n	80067d4 <HAL_TIMEx_MasterConfigSynchronization+0x50>
  __HAL_LOCK(htim);
 800681a:	2002      	movs	r0, #2
}
 800681c:	4770      	bx	lr
 800681e:	bf00      	nop
 8006820:	40012c00 	.word	0x40012c00
 8006824:	40000400 	.word	0x40000400

08006828 <HAL_TIMEx_ConfigBreakDeadTime>:
  assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->BreakFilter));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));
  assert_param(IS_TIM_BREAK_AFMODE(sBreakDeadTimeConfig->BreakAFMode));

  /* Check input state */
  __HAL_LOCK(htim);
 8006828:	f890 303c 	ldrb.w	r3, [r0, #60]	@ 0x3c
 800682c:	2b01      	cmp	r3, #1
 800682e:	d045      	beq.n	80068bc <HAL_TIMEx_ConfigBreakDeadTime+0x94>
{
 8006830:	b410      	push	{r4}
  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */

  /* Set the BDTR bits */
  MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
 8006832:	e9d1 4302 	ldrd	r4, r3, [r1, #8]
 8006836:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 800683a:	4602      	mov	r2, r0
 800683c:	4323      	orrs	r3, r4
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
 800683e:	6848      	ldr	r0, [r1, #4]
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
 8006840:	680c      	ldr	r4, [r1, #0]
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
 8006842:	f423 6380 	bic.w	r3, r3, #1024	@ 0x400
 8006846:	4303      	orrs	r3, r0
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
 8006848:	f423 6300 	bic.w	r3, r3, #2048	@ 0x800
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
 800684c:	6908      	ldr	r0, [r1, #16]
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
 800684e:	4323      	orrs	r3, r4
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
 8006850:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 8006854:	694c      	ldr	r4, [r1, #20]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
 8006856:	4303      	orrs	r3, r0
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 8006858:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 800685c:	6b08      	ldr	r0, [r1, #48]	@ 0x30
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 800685e:	4323      	orrs	r3, r4
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 8006860:	f423 4380 	bic.w	r3, r3, #16384	@ 0x4000
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << TIM_BDTR_BKF_Pos));
 8006864:	698c      	ldr	r4, [r1, #24]
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 8006866:	4303      	orrs	r3, r0
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << TIM_BDTR_BKF_Pos));
 8006868:	f423 2370 	bic.w	r3, r3, #983040	@ 0xf0000
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKBID, sBreakDeadTimeConfig->BreakAFMode);
 800686c:	69c8      	ldr	r0, [r1, #28]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << TIM_BDTR_BKF_Pos));
 800686e:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKBID, sBreakDeadTimeConfig->BreakAFMode);
 8006872:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000

  if (IS_TIM_BKIN2_INSTANCE(htim->Instance))
 8006876:	4c12      	ldr	r4, [pc, #72]	@ (80068c0 <HAL_TIMEx_ConfigBreakDeadTime+0x98>)
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKBID, sBreakDeadTimeConfig->BreakAFMode);
 8006878:	4303      	orrs	r3, r0
  if (IS_TIM_BKIN2_INSTANCE(htim->Instance))
 800687a:	6810      	ldr	r0, [r2, #0]
 800687c:	42a0      	cmp	r0, r4
 800687e:	d00b      	beq.n	8006898 <HAL_TIMEx_ConfigBreakDeadTime+0x70>
 8006880:	f504 6400 	add.w	r4, r4, #2048	@ 0x800
 8006884:	42a0      	cmp	r0, r4
 8006886:	d007      	beq.n	8006898 <HAL_TIMEx_ConfigBreakDeadTime+0x70>
  }

  /* Set TIMx_BDTR */
  htim->Instance->BDTR = tmpbdtr;

  __HAL_UNLOCK(htim);
 8006888:	2100      	movs	r1, #0
  htim->Instance->BDTR = tmpbdtr;
 800688a:	6443      	str	r3, [r0, #68]	@ 0x44
  __HAL_UNLOCK(htim);
 800688c:	f882 103c 	strb.w	r1, [r2, #60]	@ 0x3c

  return HAL_OK;
 8006890:	4608      	mov	r0, r1
}
 8006892:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006896:	4770      	bx	lr
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2F, (sBreakDeadTimeConfig->Break2Filter << TIM_BDTR_BK2F_Pos));
 8006898:	6a8c      	ldr	r4, [r1, #40]	@ 0x28
 800689a:	f423 0370 	bic.w	r3, r3, #15728640	@ 0xf00000
 800689e:	ea43 5304 	orr.w	r3, r3, r4, lsl #20
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, sBreakDeadTimeConfig->Break2State);
 80068a2:	6a0c      	ldr	r4, [r1, #32]
 80068a4:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
 80068a8:	4323      	orrs	r3, r4
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig->Break2Polarity);
 80068aa:	6a4c      	ldr	r4, [r1, #36]	@ 0x24
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2BID, sBreakDeadTimeConfig->Break2AFMode);
 80068ac:	6ac9      	ldr	r1, [r1, #44]	@ 0x2c
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig->Break2Polarity);
 80068ae:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
 80068b2:	4323      	orrs	r3, r4
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2BID, sBreakDeadTimeConfig->Break2AFMode);
 80068b4:	f023 5300 	bic.w	r3, r3, #536870912	@ 0x20000000
 80068b8:	430b      	orrs	r3, r1
 80068ba:	e7e5      	b.n	8006888 <HAL_TIMEx_ConfigBreakDeadTime+0x60>
  __HAL_LOCK(htim);
 80068bc:	2002      	movs	r0, #2
}
 80068be:	4770      	bx	lr
 80068c0:	40012c00 	.word	0x40012c00

080068c4 <HAL_TIMEx_ConfigBreakInput>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_ConfigBreakInput(TIM_HandleTypeDef *htim,
                                             uint32_t BreakInput,
                                             const TIMEx_BreakInputConfigTypeDef *sBreakInputConfig)
{
 80068c4:	4603      	mov	r3, r0
  assert_param(IS_TIM_BREAKINPUTSOURCE(sBreakInputConfig->Source));
  assert_param(IS_TIM_BREAKINPUTSOURCE_STATE(sBreakInputConfig->Enable));
  assert_param(IS_TIM_BREAKINPUTSOURCE_POLARITY(sBreakInputConfig->Polarity));

  /* Check input state */
  __HAL_LOCK(htim);
 80068c6:	f890 003c 	ldrb.w	r0, [r0, #60]	@ 0x3c
 80068ca:	2801      	cmp	r0, #1
 80068cc:	d047      	beq.n	800695e <HAL_TIMEx_ConfigBreakInput+0x9a>

  switch (sBreakInputConfig->Source)
 80068ce:	6810      	ldr	r0, [r2, #0]
 80068d0:	3801      	subs	r0, #1
 80068d2:	280f      	cmp	r0, #15
{
 80068d4:	b4f0      	push	{r4, r5, r6, r7}
 80068d6:	d825      	bhi.n	8006924 <HAL_TIMEx_ConfigBreakInput+0x60>
 80068d8:	4c22      	ldr	r4, [pc, #136]	@ (8006964 <HAL_TIMEx_ConfigBreakInput+0xa0>)
 80068da:	4e23      	ldr	r6, [pc, #140]	@ (8006968 <HAL_TIMEx_ConfigBreakInput+0xa4>)
 80068dc:	f854 5020 	ldr.w	r5, [r4, r0, lsl #2]
 80068e0:	f856 c020 	ldr.w	ip, [r6, r0, lsl #2]
 80068e4:	4c21      	ldr	r4, [pc, #132]	@ (800696c <HAL_TIMEx_ConfigBreakInput+0xa8>)
 80068e6:	4e22      	ldr	r6, [pc, #136]	@ (8006970 <HAL_TIMEx_ConfigBreakInput+0xac>)
 80068e8:	f854 4020 	ldr.w	r4, [r4, r0, lsl #2]
 80068ec:	f856 7020 	ldr.w	r7, [r6, r0, lsl #2]
      bkin_polarity_bitpos = 0U;
      break;
    }
  }

  switch (BreakInput)
 80068f0:	2901      	cmp	r1, #1
 80068f2:	d01d      	beq.n	8006930 <HAL_TIMEx_ConfigBreakInput+0x6c>
 80068f4:	2902      	cmp	r1, #2
 80068f6:	d12c      	bne.n	8006952 <HAL_TIMEx_ConfigBreakInput+0x8e>
      tmporx &= ~bkin_enable_mask;
      tmporx |= (sBreakInputConfig->Enable << bkin_enable_bitpos) & bkin_enable_mask;

      /* Set the break input polarity */
      tmporx &= ~bkin_polarity_mask;
      tmporx |= (sBreakInputConfig->Polarity << bkin_polarity_bitpos) & bkin_polarity_mask;
 80068f8:	6890      	ldr	r0, [r2, #8]
      tmporx = htim->Instance->AF2;
 80068fa:	681e      	ldr	r6, [r3, #0]
      tmporx |= (sBreakInputConfig->Enable << bkin_enable_bitpos) & bkin_enable_mask;
 80068fc:	6851      	ldr	r1, [r2, #4]
      tmporx |= (sBreakInputConfig->Polarity << bkin_polarity_bitpos) & bkin_polarity_mask;
 80068fe:	40b8      	lsls	r0, r7
      tmporx = htim->Instance->AF2;
 8006900:	6e77      	ldr	r7, [r6, #100]	@ 0x64
      tmporx |= (sBreakInputConfig->Enable << bkin_enable_bitpos) & bkin_enable_mask;
 8006902:	fa01 f10c 	lsl.w	r1, r1, ip
 8006906:	ea81 0207 	eor.w	r2, r1, r7
 800690a:	402a      	ands	r2, r5
 800690c:	407a      	eors	r2, r7
      tmporx |= (sBreakInputConfig->Polarity << bkin_polarity_bitpos) & bkin_polarity_mask;
 800690e:	ea80 0102 	eor.w	r1, r0, r2
 8006912:	4021      	ands	r1, r4
 8006914:	404a      	eors	r2, r1

      /* Set TIMx_AF2 */
      htim->Instance->AF2 = tmporx;
 8006916:	6672      	str	r2, [r6, #100]	@ 0x64
    default:
      status = HAL_ERROR;
      break;
  }

  __HAL_UNLOCK(htim);
 8006918:	2200      	movs	r2, #0
 800691a:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c
  HAL_StatusTypeDef status = HAL_OK;
 800691e:	2000      	movs	r0, #0

  return status;
}
 8006920:	bcf0      	pop	{r4, r5, r6, r7}
 8006922:	4770      	bx	lr
  switch (sBreakInputConfig->Source)
 8006924:	2700      	movs	r7, #0
  switch (BreakInput)
 8006926:	2901      	cmp	r1, #1
  switch (sBreakInputConfig->Source)
 8006928:	46bc      	mov	ip, r7
 800692a:	463c      	mov	r4, r7
 800692c:	463d      	mov	r5, r7
  switch (BreakInput)
 800692e:	d1e1      	bne.n	80068f4 <HAL_TIMEx_ConfigBreakInput+0x30>
      tmporx |= (sBreakInputConfig->Polarity << bkin_polarity_bitpos) & bkin_polarity_mask;
 8006930:	6890      	ldr	r0, [r2, #8]
      tmporx = htim->Instance->AF1;
 8006932:	681e      	ldr	r6, [r3, #0]
      tmporx |= (sBreakInputConfig->Enable << bkin_enable_bitpos) & bkin_enable_mask;
 8006934:	6851      	ldr	r1, [r2, #4]
      tmporx |= (sBreakInputConfig->Polarity << bkin_polarity_bitpos) & bkin_polarity_mask;
 8006936:	40b8      	lsls	r0, r7
      tmporx = htim->Instance->AF1;
 8006938:	6e37      	ldr	r7, [r6, #96]	@ 0x60
      tmporx |= (sBreakInputConfig->Enable << bkin_enable_bitpos) & bkin_enable_mask;
 800693a:	fa01 f10c 	lsl.w	r1, r1, ip
 800693e:	ea81 0207 	eor.w	r2, r1, r7
 8006942:	402a      	ands	r2, r5
 8006944:	407a      	eors	r2, r7
      tmporx |= (sBreakInputConfig->Polarity << bkin_polarity_bitpos) & bkin_polarity_mask;
 8006946:	ea80 0102 	eor.w	r1, r0, r2
 800694a:	4021      	ands	r1, r4
 800694c:	404a      	eors	r2, r1
      htim->Instance->AF1 = tmporx;
 800694e:	6632      	str	r2, [r6, #96]	@ 0x60
      break;
 8006950:	e7e2      	b.n	8006918 <HAL_TIMEx_ConfigBreakInput+0x54>
  __HAL_UNLOCK(htim);
 8006952:	2200      	movs	r2, #0
 8006954:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c
  switch (BreakInput)
 8006958:	2001      	movs	r0, #1
}
 800695a:	bcf0      	pop	{r4, r5, r6, r7}
 800695c:	4770      	bx	lr
  __HAL_LOCK(htim);
 800695e:	2002      	movs	r0, #2
}
 8006960:	4770      	bx	lr
 8006962:	bf00      	nop
 8006964:	0800a4c0 	.word	0x0800a4c0
 8006968:	0800a440 	.word	0x0800a440
 800696c:	0800a480 	.word	0x0800a480
 8006970:	0800a400 	.word	0x0800a400

08006974 <HAL_TIMEx_CommutCallback>:
/**
  * @brief  Commutation callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
 8006974:	4770      	bx	lr
 8006976:	bf00      	nop

08006978 <HAL_TIMEx_BreakCallback>:
/**
  * @brief  Break detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
 8006978:	4770      	bx	lr
 800697a:	bf00      	nop

0800697c <HAL_TIMEx_Break2Callback>:
/**
  * @brief  Break2 detection callback in non blocking mode
  * @param  htim: TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_Break2Callback(TIM_HandleTypeDef *htim)
 800697c:	4770      	bx	lr
 800697e:	bf00      	nop

08006980 <HAL_TIMEx_EncoderIndexCallback>:
/**
  * @brief  Encoder index callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_EncoderIndexCallback(TIM_HandleTypeDef *htim)
 8006980:	4770      	bx	lr
 8006982:	bf00      	nop

08006984 <HAL_TIMEx_DirectionChangeCallback>:
/**
  * @brief  Direction change callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_DirectionChangeCallback(TIM_HandleTypeDef *htim)
 8006984:	4770      	bx	lr
 8006986:	bf00      	nop

08006988 <HAL_TIMEx_IndexErrorCallback>:
/**
  * @brief  Index error callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_IndexErrorCallback(TIM_HandleTypeDef *htim)
 8006988:	4770      	bx	lr
 800698a:	bf00      	nop

0800698c <HAL_TIMEx_TransitionErrorCallback>:
/**
  * @brief  Transition error callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_TransitionErrorCallback(TIM_HandleTypeDef *htim)
 800698c:	4770      	bx	lr
 800698e:	bf00      	nop

08006990 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 8006990:	b570      	push	{r4, r5, r6, lr}
 8006992:	4604      	mov	r4, r0
  uint32_t pclk;

  /* Check the parameters */
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  if (UART_INSTANCE_LOWPOWER(huart))
 8006994:	6803      	ldr	r3, [r0, #0]
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8006996:	6882      	ldr	r2, [r0, #8]
 8006998:	6900      	ldr	r0, [r0, #16]
 800699a:	6961      	ldr	r1, [r4, #20]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800699c:	681d      	ldr	r5, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800699e:	4302      	orrs	r2, r0
 80069a0:	430a      	orrs	r2, r1
 80069a2:	69e0      	ldr	r0, [r4, #28]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80069a4:	4995      	ldr	r1, [pc, #596]	@ (8006bfc <UART_SetConfig+0x26c>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80069a6:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80069a8:	4029      	ands	r1, r5
 80069aa:	430a      	orrs	r2, r1
 80069ac:	601a      	str	r2, [r3, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80069ae:	685a      	ldr	r2, [r3, #4]
 80069b0:	68e1      	ldr	r1, [r4, #12]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);

  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 80069b2:	6a65      	ldr	r5, [r4, #36]	@ 0x24
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80069b4:	f422 5240 	bic.w	r2, r2, #12288	@ 0x3000
 80069b8:	430a      	orrs	r2, r1
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 80069ba:	4991      	ldr	r1, [pc, #580]	@ (8006c00 <UART_SetConfig+0x270>)
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80069bc:	605a      	str	r2, [r3, #4]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 80069be:	428b      	cmp	r3, r1
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 80069c0:	6899      	ldr	r1, [r3, #8]
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 80069c2:	69a2      	ldr	r2, [r4, #24]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 80069c4:	f021 416e 	bic.w	r1, r1, #3992977408	@ 0xee000000
 80069c8:	f421 6130 	bic.w	r1, r1, #2816	@ 0xb00
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 80069cc:	f000 80bb 	beq.w	8006b46 <UART_SetConfig+0x1b6>
    tmpreg |= huart->Init.OneBitSampling;
 80069d0:	6a26      	ldr	r6, [r4, #32]
 80069d2:	4332      	orrs	r2, r6
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 80069d4:	430a      	orrs	r2, r1
 80069d6:	609a      	str	r2, [r3, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 80069d8:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 80069da:	f022 020f 	bic.w	r2, r2, #15
 80069de:	432a      	orrs	r2, r5
 80069e0:	62da      	str	r2, [r3, #44]	@ 0x2c

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 80069e2:	4a88      	ldr	r2, [pc, #544]	@ (8006c04 <UART_SetConfig+0x274>)
 80069e4:	4293      	cmp	r3, r2
 80069e6:	d035      	beq.n	8006a54 <UART_SetConfig+0xc4>
 80069e8:	4a87      	ldr	r2, [pc, #540]	@ (8006c08 <UART_SetConfig+0x278>)
 80069ea:	4293      	cmp	r3, r2
 80069ec:	d00e      	beq.n	8006a0c <UART_SetConfig+0x7c>
 80069ee:	4a87      	ldr	r2, [pc, #540]	@ (8006c0c <UART_SetConfig+0x27c>)
 80069f0:	4293      	cmp	r3, r2
 80069f2:	f000 8098 	beq.w	8006b26 <UART_SetConfig+0x196>
 80069f6:	4a86      	ldr	r2, [pc, #536]	@ (8006c10 <UART_SetConfig+0x280>)
 80069f8:	4293      	cmp	r3, r2
 80069fa:	d03f      	beq.n	8006a7c <UART_SetConfig+0xec>

      /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
          (lpuart_ker_ck_pres > (4096U * huart->Init.BaudRate)))
      {
        ret = HAL_ERROR;
 80069fc:	2001      	movs	r0, #1
  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
  huart->NbRxDataToProcess = 1;

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 80069fe:	2300      	movs	r3, #0
  huart->NbRxDataToProcess = 1;
 8006a00:	f04f 1201 	mov.w	r2, #65537	@ 0x10001
  huart->TxISR = NULL;
 8006a04:	e9c4 331d 	strd	r3, r3, [r4, #116]	@ 0x74
  huart->NbRxDataToProcess = 1;
 8006a08:	66a2      	str	r2, [r4, #104]	@ 0x68

  return ret;
}
 8006a0a:	bd70      	pop	{r4, r5, r6, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
 8006a0c:	4b81      	ldr	r3, [pc, #516]	@ (8006c14 <UART_SetConfig+0x284>)
 8006a0e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8006a12:	f003 030c 	and.w	r3, r3, #12
 8006a16:	2b0c      	cmp	r3, #12
 8006a18:	d8f0      	bhi.n	80069fc <UART_SetConfig+0x6c>
 8006a1a:	a201      	add	r2, pc, #4	@ (adr r2, 8006a20 <UART_SetConfig+0x90>)
 8006a1c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8006a20:	08006b1b 	.word	0x08006b1b
 8006a24:	080069fd 	.word	0x080069fd
 8006a28:	080069fd 	.word	0x080069fd
 8006a2c:	080069fd 	.word	0x080069fd
 8006a30:	08006a95 	.word	0x08006a95
 8006a34:	080069fd 	.word	0x080069fd
 8006a38:	080069fd 	.word	0x080069fd
 8006a3c:	080069fd 	.word	0x080069fd
 8006a40:	08006add 	.word	0x08006add
 8006a44:	080069fd 	.word	0x080069fd
 8006a48:	080069fd 	.word	0x080069fd
 8006a4c:	080069fd 	.word	0x080069fd
 8006a50:	08006aad 	.word	0x08006aad
 8006a54:	4b6f      	ldr	r3, [pc, #444]	@ (8006c14 <UART_SetConfig+0x284>)
 8006a56:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8006a5a:	f003 0303 	and.w	r3, r3, #3
 8006a5e:	2b02      	cmp	r3, #2
 8006a60:	d03c      	beq.n	8006adc <UART_SetConfig+0x14c>
 8006a62:	2b03      	cmp	r3, #3
 8006a64:	d022      	beq.n	8006aac <UART_SetConfig+0x11c>
 8006a66:	2b01      	cmp	r3, #1
 8006a68:	d014      	beq.n	8006a94 <UART_SetConfig+0x104>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8006a6a:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
 8006a6e:	f000 80bc 	beq.w	8006bea <UART_SetConfig+0x25a>
        pclk = HAL_RCC_GetPCLK2Freq();
 8006a72:	f7ff f8f3 	bl	8005c5c <HAL_RCC_GetPCLK2Freq>
    if (pclk != 0U)
 8006a76:	b9a8      	cbnz	r0, 8006aa4 <UART_SetConfig+0x114>
        pclk = (uint32_t) HSI_VALUE;
 8006a78:	2000      	movs	r0, #0
 8006a7a:	e7c0      	b.n	80069fe <UART_SetConfig+0x6e>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8006a7c:	4b65      	ldr	r3, [pc, #404]	@ (8006c14 <UART_SetConfig+0x284>)
 8006a7e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8006a82:	f003 03c0 	and.w	r3, r3, #192	@ 0xc0
 8006a86:	2b80      	cmp	r3, #128	@ 0x80
 8006a88:	d028      	beq.n	8006adc <UART_SetConfig+0x14c>
 8006a8a:	d859      	bhi.n	8006b40 <UART_SetConfig+0x1b0>
 8006a8c:	2b00      	cmp	r3, #0
 8006a8e:	d044      	beq.n	8006b1a <UART_SetConfig+0x18a>
 8006a90:	2b40      	cmp	r3, #64	@ 0x40
 8006a92:	d1b3      	bne.n	80069fc <UART_SetConfig+0x6c>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8006a94:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
 8006a98:	f000 80aa 	beq.w	8006bf0 <UART_SetConfig+0x260>
        pclk = HAL_RCC_GetSysClockFreq();
 8006a9c:	f7fe ff8a 	bl	80059b4 <HAL_RCC_GetSysClockFreq>
    if (pclk != 0U)
 8006aa0:	2800      	cmp	r0, #0
 8006aa2:	d0e9      	beq.n	8006a78 <UART_SetConfig+0xe8>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8006aa4:	6a65      	ldr	r5, [r4, #36]	@ 0x24
 8006aa6:	e006      	b.n	8006ab6 <UART_SetConfig+0x126>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8006aa8:	2b30      	cmp	r3, #48	@ 0x30
 8006aaa:	d1a7      	bne.n	80069fc <UART_SetConfig+0x6c>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8006aac:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
 8006ab0:	d018      	beq.n	8006ae4 <UART_SetConfig+0x154>
        pclk = (uint32_t) LSE_VALUE;
 8006ab2:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8006ab6:	6863      	ldr	r3, [r4, #4]
 8006ab8:	4a57      	ldr	r2, [pc, #348]	@ (8006c18 <UART_SetConfig+0x288>)
 8006aba:	f832 1015 	ldrh.w	r1, [r2, r5, lsl #1]
 8006abe:	fbb0 f0f1 	udiv	r0, r0, r1
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8006ac2:	f64f 72ef 	movw	r2, #65519	@ 0xffef
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8006ac6:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 8006aca:	fbb0 f0f3 	udiv	r0, r0, r3
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8006ace:	f1a0 0310 	sub.w	r3, r0, #16
 8006ad2:	4293      	cmp	r3, r2
 8006ad4:	d892      	bhi.n	80069fc <UART_SetConfig+0x6c>
          huart->Instance->BRR = usartdiv;
 8006ad6:	6823      	ldr	r3, [r4, #0]
 8006ad8:	60d8      	str	r0, [r3, #12]
 8006ada:	e7cd      	b.n	8006a78 <UART_SetConfig+0xe8>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8006adc:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
        pclk = (uint32_t) HSI_VALUE;
 8006ae0:	484e      	ldr	r0, [pc, #312]	@ (8006c1c <UART_SetConfig+0x28c>)
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8006ae2:	d1e8      	bne.n	8006ab6 <UART_SetConfig+0x126>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8006ae4:	6862      	ldr	r2, [r4, #4]
 8006ae6:	4b4c      	ldr	r3, [pc, #304]	@ (8006c18 <UART_SetConfig+0x288>)
 8006ae8:	f833 1015 	ldrh.w	r1, [r3, r5, lsl #1]
 8006aec:	fbb0 f0f1 	udiv	r0, r0, r1
 8006af0:	0853      	lsrs	r3, r2, #1
 8006af2:	eb03 0340 	add.w	r3, r3, r0, lsl #1
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8006af6:	f64f 71ef 	movw	r1, #65519	@ 0xffef
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8006afa:	fbb3 f3f2 	udiv	r3, r3, r2
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8006afe:	f1a3 0210 	sub.w	r2, r3, #16
 8006b02:	428a      	cmp	r2, r1
 8006b04:	f63f af7a 	bhi.w	80069fc <UART_SetConfig+0x6c>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 8006b08:	f023 020f 	bic.w	r2, r3, #15
        huart->Instance->BRR = brrtemp;
 8006b0c:	6821      	ldr	r1, [r4, #0]
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 8006b0e:	b292      	uxth	r2, r2
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8006b10:	f3c3 0342 	ubfx	r3, r3, #1, #3
        huart->Instance->BRR = brrtemp;
 8006b14:	4313      	orrs	r3, r2
 8006b16:	60cb      	str	r3, [r1, #12]
 8006b18:	e7ae      	b.n	8006a78 <UART_SetConfig+0xe8>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8006b1a:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
 8006b1e:	d05d      	beq.n	8006bdc <UART_SetConfig+0x24c>
        pclk = HAL_RCC_GetPCLK1Freq();
 8006b20:	f7ff f88a 	bl	8005c38 <HAL_RCC_GetPCLK1Freq>
        break;
 8006b24:	e7a7      	b.n	8006a76 <UART_SetConfig+0xe6>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8006b26:	4b3b      	ldr	r3, [pc, #236]	@ (8006c14 <UART_SetConfig+0x284>)
 8006b28:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8006b2c:	f003 0330 	and.w	r3, r3, #48	@ 0x30
 8006b30:	2b20      	cmp	r3, #32
 8006b32:	d0d3      	beq.n	8006adc <UART_SetConfig+0x14c>
 8006b34:	d8b8      	bhi.n	8006aa8 <UART_SetConfig+0x118>
 8006b36:	2b00      	cmp	r3, #0
 8006b38:	d0ef      	beq.n	8006b1a <UART_SetConfig+0x18a>
 8006b3a:	2b10      	cmp	r3, #16
 8006b3c:	d0aa      	beq.n	8006a94 <UART_SetConfig+0x104>
 8006b3e:	e75d      	b.n	80069fc <UART_SetConfig+0x6c>
 8006b40:	2bc0      	cmp	r3, #192	@ 0xc0
 8006b42:	d0b3      	beq.n	8006aac <UART_SetConfig+0x11c>
 8006b44:	e75a      	b.n	80069fc <UART_SetConfig+0x6c>
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8006b46:	4311      	orrs	r1, r2
 8006b48:	6099      	str	r1, [r3, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 8006b4a:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
 8006b4c:	4931      	ldr	r1, [pc, #196]	@ (8006c14 <UART_SetConfig+0x284>)
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 8006b4e:	f022 020f 	bic.w	r2, r2, #15
 8006b52:	432a      	orrs	r2, r5
 8006b54:	62da      	str	r2, [r3, #44]	@ 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
 8006b56:	f8d1 3088 	ldr.w	r3, [r1, #136]	@ 0x88
 8006b5a:	f403 6340 	and.w	r3, r3, #3072	@ 0xc00
 8006b5e:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8006b62:	d048      	beq.n	8006bf6 <UART_SetConfig+0x266>
 8006b64:	d833      	bhi.n	8006bce <UART_SetConfig+0x23e>
 8006b66:	b37b      	cbz	r3, 8006bc8 <UART_SetConfig+0x238>
 8006b68:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8006b6c:	f47f af46 	bne.w	80069fc <UART_SetConfig+0x6c>
        pclk = HAL_RCC_GetSysClockFreq();
 8006b70:	f7fe ff20 	bl	80059b4 <HAL_RCC_GetSysClockFreq>
    if (pclk != 0U)
 8006b74:	2800      	cmp	r0, #0
 8006b76:	f43f af7f 	beq.w	8006a78 <UART_SetConfig+0xe8>
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 8006b7a:	6a65      	ldr	r5, [r4, #36]	@ 0x24
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8006b7c:	6866      	ldr	r6, [r4, #4]
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 8006b7e:	4b26      	ldr	r3, [pc, #152]	@ (8006c18 <UART_SetConfig+0x288>)
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8006b80:	eb06 0146 	add.w	r1, r6, r6, lsl #1
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 8006b84:	f833 2015 	ldrh.w	r2, [r3, r5, lsl #1]
 8006b88:	fbb0 f3f2 	udiv	r3, r0, r2
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8006b8c:	4299      	cmp	r1, r3
 8006b8e:	f63f af35 	bhi.w	80069fc <UART_SetConfig+0x6c>
 8006b92:	ebb3 3f06 	cmp.w	r3, r6, lsl #12
 8006b96:	f63f af31 	bhi.w	80069fc <UART_SetConfig+0x6c>
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8006b9a:	2300      	movs	r3, #0
 8006b9c:	4619      	mov	r1, r3
 8006b9e:	f7f9 fb3f 	bl	8000220 <__aeabi_uldivmod>
 8006ba2:	0872      	lsrs	r2, r6, #1
 8006ba4:	0203      	lsls	r3, r0, #8
 8006ba6:	0209      	lsls	r1, r1, #8
 8006ba8:	ea41 6110 	orr.w	r1, r1, r0, lsr #24
 8006bac:	1898      	adds	r0, r3, r2
 8006bae:	f141 0100 	adc.w	r1, r1, #0
 8006bb2:	4632      	mov	r2, r6
 8006bb4:	2300      	movs	r3, #0
 8006bb6:	f7f9 fb33 	bl	8000220 <__aeabi_uldivmod>
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 8006bba:	4b19      	ldr	r3, [pc, #100]	@ (8006c20 <UART_SetConfig+0x290>)
 8006bbc:	f5a0 7240 	sub.w	r2, r0, #768	@ 0x300
 8006bc0:	429a      	cmp	r2, r3
 8006bc2:	f63f af1b 	bhi.w	80069fc <UART_SetConfig+0x6c>
 8006bc6:	e786      	b.n	8006ad6 <UART_SetConfig+0x146>
        pclk = HAL_RCC_GetPCLK1Freq();
 8006bc8:	f7ff f836 	bl	8005c38 <HAL_RCC_GetPCLK1Freq>
        break;
 8006bcc:	e7d2      	b.n	8006b74 <UART_SetConfig+0x1e4>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8006bce:	f5b3 6f40 	cmp.w	r3, #3072	@ 0xc00
 8006bd2:	f47f af13 	bne.w	80069fc <UART_SetConfig+0x6c>
        pclk = (uint32_t) LSE_VALUE;
 8006bd6:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
 8006bda:	e7cf      	b.n	8006b7c <UART_SetConfig+0x1ec>
        pclk = HAL_RCC_GetPCLK1Freq();
 8006bdc:	f7ff f82c 	bl	8005c38 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 8006be0:	2800      	cmp	r0, #0
 8006be2:	f43f af49 	beq.w	8006a78 <UART_SetConfig+0xe8>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8006be6:	6a65      	ldr	r5, [r4, #36]	@ 0x24
 8006be8:	e77c      	b.n	8006ae4 <UART_SetConfig+0x154>
        pclk = HAL_RCC_GetPCLK2Freq();
 8006bea:	f7ff f837 	bl	8005c5c <HAL_RCC_GetPCLK2Freq>
        break;
 8006bee:	e7f7      	b.n	8006be0 <UART_SetConfig+0x250>
        pclk = HAL_RCC_GetSysClockFreq();
 8006bf0:	f7fe fee0 	bl	80059b4 <HAL_RCC_GetSysClockFreq>
        break;
 8006bf4:	e7f4      	b.n	8006be0 <UART_SetConfig+0x250>
        pclk = (uint32_t) HSI_VALUE;
 8006bf6:	4809      	ldr	r0, [pc, #36]	@ (8006c1c <UART_SetConfig+0x28c>)
 8006bf8:	e7c0      	b.n	8006b7c <UART_SetConfig+0x1ec>
 8006bfa:	bf00      	nop
 8006bfc:	cfff69f3 	.word	0xcfff69f3
 8006c00:	40008000 	.word	0x40008000
 8006c04:	40013800 	.word	0x40013800
 8006c08:	40004400 	.word	0x40004400
 8006c0c:	40004800 	.word	0x40004800
 8006c10:	40004c00 	.word	0x40004c00
 8006c14:	40021000 	.word	0x40021000
 8006c18:	0800a500 	.word	0x0800a500
 8006c1c:	00f42400 	.word	0x00f42400
 8006c20:	000ffcff 	.word	0x000ffcff

08006c24 <UART_AdvFeatureConfig>:
{
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 8006c24:	6a83      	ldr	r3, [r0, #40]	@ 0x28
 8006c26:	071a      	lsls	r2, r3, #28
{
 8006c28:	b410      	push	{r4}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 8006c2a:	d506      	bpl.n	8006c3a <UART_AdvFeatureConfig+0x16>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 8006c2c:	6801      	ldr	r1, [r0, #0]
 8006c2e:	6b84      	ldr	r4, [r0, #56]	@ 0x38
 8006c30:	684a      	ldr	r2, [r1, #4]
 8006c32:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
 8006c36:	4322      	orrs	r2, r4
 8006c38:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8006c3a:	07dc      	lsls	r4, r3, #31
 8006c3c:	d506      	bpl.n	8006c4c <UART_AdvFeatureConfig+0x28>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 8006c3e:	6801      	ldr	r1, [r0, #0]
 8006c40:	6ac4      	ldr	r4, [r0, #44]	@ 0x2c
 8006c42:	684a      	ldr	r2, [r1, #4]
 8006c44:	f422 3200 	bic.w	r2, r2, #131072	@ 0x20000
 8006c48:	4322      	orrs	r2, r4
 8006c4a:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 8006c4c:	0799      	lsls	r1, r3, #30
 8006c4e:	d506      	bpl.n	8006c5e <UART_AdvFeatureConfig+0x3a>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 8006c50:	6801      	ldr	r1, [r0, #0]
 8006c52:	6b04      	ldr	r4, [r0, #48]	@ 0x30
 8006c54:	684a      	ldr	r2, [r1, #4]
 8006c56:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 8006c5a:	4322      	orrs	r2, r4
 8006c5c:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 8006c5e:	075a      	lsls	r2, r3, #29
 8006c60:	d506      	bpl.n	8006c70 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 8006c62:	6801      	ldr	r1, [r0, #0]
 8006c64:	6b44      	ldr	r4, [r0, #52]	@ 0x34
 8006c66:	684a      	ldr	r2, [r1, #4]
 8006c68:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
 8006c6c:	4322      	orrs	r2, r4
 8006c6e:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8006c70:	06dc      	lsls	r4, r3, #27
 8006c72:	d506      	bpl.n	8006c82 <UART_AdvFeatureConfig+0x5e>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 8006c74:	6801      	ldr	r1, [r0, #0]
 8006c76:	6bc4      	ldr	r4, [r0, #60]	@ 0x3c
 8006c78:	688a      	ldr	r2, [r1, #8]
 8006c7a:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
 8006c7e:	4322      	orrs	r2, r4
 8006c80:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 8006c82:	0699      	lsls	r1, r3, #26
 8006c84:	d506      	bpl.n	8006c94 <UART_AdvFeatureConfig+0x70>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 8006c86:	6801      	ldr	r1, [r0, #0]
 8006c88:	6c04      	ldr	r4, [r0, #64]	@ 0x40
 8006c8a:	688a      	ldr	r2, [r1, #8]
 8006c8c:	f422 5200 	bic.w	r2, r2, #8192	@ 0x2000
 8006c90:	4322      	orrs	r2, r4
 8006c92:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 8006c94:	065a      	lsls	r2, r3, #25
 8006c96:	d509      	bpl.n	8006cac <UART_AdvFeatureConfig+0x88>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8006c98:	6801      	ldr	r1, [r0, #0]
 8006c9a:	6c44      	ldr	r4, [r0, #68]	@ 0x44
 8006c9c:	684a      	ldr	r2, [r1, #4]
 8006c9e:	f422 1280 	bic.w	r2, r2, #1048576	@ 0x100000
 8006ca2:	4322      	orrs	r2, r4
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8006ca4:	f5b4 1f80 	cmp.w	r4, #1048576	@ 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8006ca8:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8006caa:	d00b      	beq.n	8006cc4 <UART_AdvFeatureConfig+0xa0>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 8006cac:	061b      	lsls	r3, r3, #24
 8006cae:	d506      	bpl.n	8006cbe <UART_AdvFeatureConfig+0x9a>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8006cb0:	6802      	ldr	r2, [r0, #0]
 8006cb2:	6cc1      	ldr	r1, [r0, #76]	@ 0x4c
 8006cb4:	6853      	ldr	r3, [r2, #4]
 8006cb6:	f423 2300 	bic.w	r3, r3, #524288	@ 0x80000
 8006cba:	430b      	orrs	r3, r1
 8006cbc:	6053      	str	r3, [r2, #4]
  }
}
 8006cbe:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006cc2:	4770      	bx	lr
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 8006cc4:	684a      	ldr	r2, [r1, #4]
 8006cc6:	6c84      	ldr	r4, [r0, #72]	@ 0x48
 8006cc8:	f422 02c0 	bic.w	r2, r2, #6291456	@ 0x600000
 8006ccc:	4322      	orrs	r2, r4
 8006cce:	604a      	str	r2, [r1, #4]
 8006cd0:	e7ec      	b.n	8006cac <UART_AdvFeatureConfig+0x88>
 8006cd2:	bf00      	nop

08006cd4 <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 8006cd4:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8006cd6:	2300      	movs	r3, #0
{
 8006cd8:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8006cda:	f8c0 3090 	str.w	r3, [r0, #144]	@ 0x90

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
 8006cde:	f7fd fae7 	bl	80042b0 <HAL_GetTick>

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8006ce2:	6822      	ldr	r2, [r4, #0]
 8006ce4:	6813      	ldr	r3, [r2, #0]
 8006ce6:	071b      	lsls	r3, r3, #28
  tickstart = HAL_GetTick();
 8006ce8:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8006cea:	d40f      	bmi.n	8006d0c <UART_CheckIdleState+0x38>
      return HAL_TIMEOUT;
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 8006cec:	6813      	ldr	r3, [r2, #0]
 8006cee:	0759      	lsls	r1, r3, #29
 8006cf0:	d431      	bmi.n	8006d56 <UART_CheckIdleState+0x82>
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
  huart->RxState = HAL_UART_STATE_READY;
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8006cf2:	2300      	movs	r3, #0
  huart->gState = HAL_UART_STATE_READY;
 8006cf4:	2220      	movs	r2, #32
 8006cf6:	f8c4 2088 	str.w	r2, [r4, #136]	@ 0x88
  huart->RxEventType = HAL_UART_RXEVENT_TC;

  __HAL_UNLOCK(huart);

  return HAL_OK;
 8006cfa:	4618      	mov	r0, r3
  huart->RxState = HAL_UART_STATE_READY;
 8006cfc:	f8c4 208c 	str.w	r2, [r4, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8006d00:	66e3      	str	r3, [r4, #108]	@ 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
 8006d02:	6723      	str	r3, [r4, #112]	@ 0x70
      __HAL_UNLOCK(huart);
 8006d04:	2300      	movs	r3, #0
 8006d06:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
}
 8006d0a:	bd38      	pop	{r3, r4, r5, pc}
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8006d0c:	69d3      	ldr	r3, [r2, #28]
 8006d0e:	0298      	lsls	r0, r3, #10
 8006d10:	d4ec      	bmi.n	8006cec <UART_CheckIdleState+0x18>
 8006d12:	e00c      	b.n	8006d2e <UART_CheckIdleState+0x5a>
      {

        return HAL_TIMEOUT;
      }

      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
 8006d14:	6819      	ldr	r1, [r3, #0]
 8006d16:	0749      	lsls	r1, r1, #29
 8006d18:	461a      	mov	r2, r3
 8006d1a:	d505      	bpl.n	8006d28 <UART_CheckIdleState+0x54>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
 8006d1c:	69d9      	ldr	r1, [r3, #28]
 8006d1e:	0708      	lsls	r0, r1, #28
 8006d20:	d44a      	bmi.n	8006db8 <UART_CheckIdleState+0xe4>
          /* Process Unlocked */
          __HAL_UNLOCK(huart);

          return HAL_ERROR;
        }
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 8006d22:	69d9      	ldr	r1, [r3, #28]
 8006d24:	0509      	lsls	r1, r1, #20
 8006d26:	d475      	bmi.n	8006e14 <UART_CheckIdleState+0x140>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8006d28:	69db      	ldr	r3, [r3, #28]
 8006d2a:	0298      	lsls	r0, r3, #10
 8006d2c:	d4de      	bmi.n	8006cec <UART_CheckIdleState+0x18>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8006d2e:	f7fd fabf 	bl	80042b0 <HAL_GetTick>
 8006d32:	1b43      	subs	r3, r0, r5
 8006d34:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
 8006d38:	6823      	ldr	r3, [r4, #0]
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8006d3a:	d3eb      	bcc.n	8006d14 <UART_CheckIdleState+0x40>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006d3c:	e853 2f00 	ldrex	r2, [r3]
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE));
 8006d40:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006d44:	e843 2100 	strex	r1, r2, [r3]
 8006d48:	2900      	cmp	r1, #0
 8006d4a:	d1f7      	bne.n	8006d3c <UART_CheckIdleState+0x68>
      huart->gState = HAL_UART_STATE_READY;
 8006d4c:	2320      	movs	r3, #32
 8006d4e:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
      return HAL_TIMEOUT;
 8006d52:	2003      	movs	r0, #3
 8006d54:	e7d6      	b.n	8006d04 <UART_CheckIdleState+0x30>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8006d56:	69d3      	ldr	r3, [r2, #28]
 8006d58:	025b      	lsls	r3, r3, #9
 8006d5a:	d4ca      	bmi.n	8006cf2 <UART_CheckIdleState+0x1e>
 8006d5c:	e00d      	b.n	8006d7a <UART_CheckIdleState+0xa6>
      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
 8006d5e:	681a      	ldr	r2, [r3, #0]
 8006d60:	0750      	lsls	r0, r2, #29
 8006d62:	d507      	bpl.n	8006d74 <UART_CheckIdleState+0xa0>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
 8006d64:	69da      	ldr	r2, [r3, #28]
 8006d66:	0711      	lsls	r1, r2, #28
 8006d68:	f100 8082 	bmi.w	8006e70 <UART_CheckIdleState+0x19c>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 8006d6c:	69da      	ldr	r2, [r3, #28]
 8006d6e:	0512      	lsls	r2, r2, #20
 8006d70:	f100 80ac 	bmi.w	8006ecc <UART_CheckIdleState+0x1f8>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8006d74:	69db      	ldr	r3, [r3, #28]
 8006d76:	025b      	lsls	r3, r3, #9
 8006d78:	d4bb      	bmi.n	8006cf2 <UART_CheckIdleState+0x1e>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8006d7a:	f7fd fa99 	bl	80042b0 <HAL_GetTick>
 8006d7e:	1b43      	subs	r3, r0, r5
 8006d80:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8006d84:	6823      	ldr	r3, [r4, #0]
 8006d86:	d3ea      	bcc.n	8006d5e <UART_CheckIdleState+0x8a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006d88:	e853 2f00 	ldrex	r2, [r3]
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 8006d8c:	f422 7290 	bic.w	r2, r2, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006d90:	e843 2100 	strex	r1, r2, [r3]
 8006d94:	2900      	cmp	r1, #0
 8006d96:	d1f7      	bne.n	8006d88 <UART_CheckIdleState+0xb4>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006d98:	f103 0208 	add.w	r2, r3, #8
 8006d9c:	e852 2f00 	ldrex	r2, [r2]
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8006da0:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006da4:	f103 0008 	add.w	r0, r3, #8
 8006da8:	e840 2100 	strex	r1, r2, [r0]
 8006dac:	2900      	cmp	r1, #0
 8006dae:	d1f3      	bne.n	8006d98 <UART_CheckIdleState+0xc4>
      huart->RxState = HAL_UART_STATE_READY;
 8006db0:	2320      	movs	r3, #32
 8006db2:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
      return HAL_TIMEOUT;
 8006db6:	e7cc      	b.n	8006d52 <UART_CheckIdleState+0x7e>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 8006db8:	2208      	movs	r2, #8
 8006dba:	621a      	str	r2, [r3, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006dbc:	e853 2f00 	ldrex	r2, [r3]
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 8006dc0:	f422 7290 	bic.w	r2, r2, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006dc4:	e843 2100 	strex	r1, r2, [r3]
 8006dc8:	2900      	cmp	r1, #0
 8006dca:	d1f7      	bne.n	8006dbc <UART_CheckIdleState+0xe8>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 8006dcc:	4856      	ldr	r0, [pc, #344]	@ (8006f28 <UART_CheckIdleState+0x254>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006dce:	f103 0208 	add.w	r2, r3, #8
 8006dd2:	e852 2f00 	ldrex	r2, [r2]
 8006dd6:	4002      	ands	r2, r0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006dd8:	f103 0508 	add.w	r5, r3, #8
 8006ddc:	e845 2100 	strex	r1, r2, [r5]
 8006de0:	2900      	cmp	r1, #0
 8006de2:	d1f4      	bne.n	8006dce <UART_CheckIdleState+0xfa>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8006de4:	6ee2      	ldr	r2, [r4, #108]	@ 0x6c
 8006de6:	2a01      	cmp	r2, #1
 8006de8:	d00b      	beq.n	8006e02 <UART_CheckIdleState+0x12e>
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8006dea:	2200      	movs	r2, #0
  huart->RxState = HAL_UART_STATE_READY;
 8006dec:	2020      	movs	r0, #32
          huart->ErrorCode = HAL_UART_ERROR_ORE;
 8006dee:	2108      	movs	r1, #8
  huart->RxState = HAL_UART_STATE_READY;
 8006df0:	f8c4 008c 	str.w	r0, [r4, #140]	@ 0x8c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 8006df4:	6762      	str	r2, [r4, #116]	@ 0x74
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8006df6:	66e2      	str	r2, [r4, #108]	@ 0x6c
          __HAL_UNLOCK(huart);
 8006df8:	f884 2084 	strb.w	r2, [r4, #132]	@ 0x84
          huart->ErrorCode = HAL_UART_ERROR_ORE;
 8006dfc:	f8c4 1090 	str.w	r1, [r4, #144]	@ 0x90
          return HAL_ERROR;
 8006e00:	e79c      	b.n	8006d3c <UART_CheckIdleState+0x68>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006e02:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8006e06:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006e0a:	e843 2100 	strex	r1, r2, [r3]
 8006e0e:	2900      	cmp	r1, #0
 8006e10:	d1f7      	bne.n	8006e02 <UART_CheckIdleState+0x12e>
 8006e12:	e7ea      	b.n	8006dea <UART_CheckIdleState+0x116>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 8006e14:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 8006e18:	621a      	str	r2, [r3, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006e1a:	e853 2f00 	ldrex	r2, [r3]
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 8006e1e:	f422 7290 	bic.w	r2, r2, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006e22:	e843 2100 	strex	r1, r2, [r3]
 8006e26:	2900      	cmp	r1, #0
 8006e28:	d1f7      	bne.n	8006e1a <UART_CheckIdleState+0x146>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 8006e2a:	483f      	ldr	r0, [pc, #252]	@ (8006f28 <UART_CheckIdleState+0x254>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006e2c:	f103 0208 	add.w	r2, r3, #8
 8006e30:	e852 2f00 	ldrex	r2, [r2]
 8006e34:	4002      	ands	r2, r0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006e36:	f103 0508 	add.w	r5, r3, #8
 8006e3a:	e845 2100 	strex	r1, r2, [r5]
 8006e3e:	2900      	cmp	r1, #0
 8006e40:	d1f4      	bne.n	8006e2c <UART_CheckIdleState+0x158>
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8006e42:	6ee2      	ldr	r2, [r4, #108]	@ 0x6c
 8006e44:	2a01      	cmp	r2, #1
 8006e46:	d00a      	beq.n	8006e5e <UART_CheckIdleState+0x18a>
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8006e48:	2200      	movs	r2, #0
  huart->RxState = HAL_UART_STATE_READY;
 8006e4a:	2120      	movs	r1, #32
 8006e4c:	f8c4 108c 	str.w	r1, [r4, #140]	@ 0x8c
  huart->RxISR = NULL;
 8006e50:	6762      	str	r2, [r4, #116]	@ 0x74
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8006e52:	66e2      	str	r2, [r4, #108]	@ 0x6c
          __HAL_UNLOCK(huart);
 8006e54:	f884 2084 	strb.w	r2, [r4, #132]	@ 0x84
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 8006e58:	f8c4 1090 	str.w	r1, [r4, #144]	@ 0x90
          return HAL_TIMEOUT;
 8006e5c:	e76e      	b.n	8006d3c <UART_CheckIdleState+0x68>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006e5e:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8006e62:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006e66:	e843 2100 	strex	r1, r2, [r3]
 8006e6a:	2900      	cmp	r1, #0
 8006e6c:	d1f7      	bne.n	8006e5e <UART_CheckIdleState+0x18a>
 8006e6e:	e7eb      	b.n	8006e48 <UART_CheckIdleState+0x174>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 8006e70:	2208      	movs	r2, #8
 8006e72:	621a      	str	r2, [r3, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006e74:	e853 2f00 	ldrex	r2, [r3]
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 8006e78:	f422 7290 	bic.w	r2, r2, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006e7c:	e843 2100 	strex	r1, r2, [r3]
 8006e80:	2900      	cmp	r1, #0
 8006e82:	d1f7      	bne.n	8006e74 <UART_CheckIdleState+0x1a0>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 8006e84:	4828      	ldr	r0, [pc, #160]	@ (8006f28 <UART_CheckIdleState+0x254>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006e86:	f103 0208 	add.w	r2, r3, #8
 8006e8a:	e852 2f00 	ldrex	r2, [r2]
 8006e8e:	4002      	ands	r2, r0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006e90:	f103 0508 	add.w	r5, r3, #8
 8006e94:	e845 2100 	strex	r1, r2, [r5]
 8006e98:	2900      	cmp	r1, #0
 8006e9a:	d1f4      	bne.n	8006e86 <UART_CheckIdleState+0x1b2>
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8006e9c:	6ee2      	ldr	r2, [r4, #108]	@ 0x6c
 8006e9e:	2a01      	cmp	r2, #1
 8006ea0:	d00b      	beq.n	8006eba <UART_CheckIdleState+0x1e6>
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8006ea2:	2200      	movs	r2, #0
  huart->RxState = HAL_UART_STATE_READY;
 8006ea4:	2020      	movs	r0, #32
          huart->ErrorCode = HAL_UART_ERROR_ORE;
 8006ea6:	2108      	movs	r1, #8
  huart->RxState = HAL_UART_STATE_READY;
 8006ea8:	f8c4 008c 	str.w	r0, [r4, #140]	@ 0x8c
  huart->RxISR = NULL;
 8006eac:	6762      	str	r2, [r4, #116]	@ 0x74
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8006eae:	66e2      	str	r2, [r4, #108]	@ 0x6c
          __HAL_UNLOCK(huart);
 8006eb0:	f884 2084 	strb.w	r2, [r4, #132]	@ 0x84
          huart->ErrorCode = HAL_UART_ERROR_ORE;
 8006eb4:	f8c4 1090 	str.w	r1, [r4, #144]	@ 0x90
          return HAL_ERROR;
 8006eb8:	e766      	b.n	8006d88 <UART_CheckIdleState+0xb4>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006eba:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8006ebe:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006ec2:	e843 2100 	strex	r1, r2, [r3]
 8006ec6:	2900      	cmp	r1, #0
 8006ec8:	d1f7      	bne.n	8006eba <UART_CheckIdleState+0x1e6>
 8006eca:	e7ea      	b.n	8006ea2 <UART_CheckIdleState+0x1ce>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 8006ecc:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 8006ed0:	621a      	str	r2, [r3, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006ed2:	e853 2f00 	ldrex	r2, [r3]
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 8006ed6:	f422 7290 	bic.w	r2, r2, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006eda:	e843 2100 	strex	r1, r2, [r3]
 8006ede:	2900      	cmp	r1, #0
 8006ee0:	d1f7      	bne.n	8006ed2 <UART_CheckIdleState+0x1fe>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 8006ee2:	4811      	ldr	r0, [pc, #68]	@ (8006f28 <UART_CheckIdleState+0x254>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006ee4:	f103 0208 	add.w	r2, r3, #8
 8006ee8:	e852 2f00 	ldrex	r2, [r2]
 8006eec:	4002      	ands	r2, r0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006eee:	f103 0508 	add.w	r5, r3, #8
 8006ef2:	e845 2100 	strex	r1, r2, [r5]
 8006ef6:	2900      	cmp	r1, #0
 8006ef8:	d1f4      	bne.n	8006ee4 <UART_CheckIdleState+0x210>
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8006efa:	6ee2      	ldr	r2, [r4, #108]	@ 0x6c
 8006efc:	2a01      	cmp	r2, #1
 8006efe:	d00a      	beq.n	8006f16 <UART_CheckIdleState+0x242>
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8006f00:	2200      	movs	r2, #0
  huart->RxState = HAL_UART_STATE_READY;
 8006f02:	2120      	movs	r1, #32
 8006f04:	f8c4 108c 	str.w	r1, [r4, #140]	@ 0x8c
  huart->RxISR = NULL;
 8006f08:	6762      	str	r2, [r4, #116]	@ 0x74
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8006f0a:	66e2      	str	r2, [r4, #108]	@ 0x6c
          __HAL_UNLOCK(huart);
 8006f0c:	f884 2084 	strb.w	r2, [r4, #132]	@ 0x84
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 8006f10:	f8c4 1090 	str.w	r1, [r4, #144]	@ 0x90
          return HAL_TIMEOUT;
 8006f14:	e738      	b.n	8006d88 <UART_CheckIdleState+0xb4>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006f16:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8006f1a:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006f1e:	e843 2100 	strex	r1, r2, [r3]
 8006f22:	2900      	cmp	r1, #0
 8006f24:	d1f7      	bne.n	8006f16 <UART_CheckIdleState+0x242>
 8006f26:	e7eb      	b.n	8006f00 <UART_CheckIdleState+0x22c>
 8006f28:	effffffe 	.word	0xeffffffe

08006f2c <HAL_UART_Init>:
  if (huart == NULL)
 8006f2c:	b380      	cbz	r0, 8006f90 <HAL_UART_Init+0x64>
  if (huart->gState == HAL_UART_STATE_RESET)
 8006f2e:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
{
 8006f32:	b510      	push	{r4, lr}
 8006f34:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_RESET)
 8006f36:	b333      	cbz	r3, 8006f86 <HAL_UART_Init+0x5a>
  __HAL_UART_DISABLE(huart);
 8006f38:	6822      	ldr	r2, [r4, #0]
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 8006f3a:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
  huart->gState = HAL_UART_STATE_BUSY;
 8006f3c:	2324      	movs	r3, #36	@ 0x24
 8006f3e:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  __HAL_UART_DISABLE(huart);
 8006f42:	6813      	ldr	r3, [r2, #0]
 8006f44:	f023 0301 	bic.w	r3, r3, #1
 8006f48:	6013      	str	r3, [r2, #0]
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 8006f4a:	b9c1      	cbnz	r1, 8006f7e <HAL_UART_Init+0x52>
  if (UART_SetConfig(huart) == HAL_ERROR)
 8006f4c:	4620      	mov	r0, r4
 8006f4e:	f7ff fd1f 	bl	8006990 <UART_SetConfig>
 8006f52:	2801      	cmp	r0, #1
 8006f54:	d011      	beq.n	8006f7a <HAL_UART_Init+0x4e>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8006f56:	6823      	ldr	r3, [r4, #0]
 8006f58:	685a      	ldr	r2, [r3, #4]
 8006f5a:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
 8006f5e:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8006f60:	689a      	ldr	r2, [r3, #8]
 8006f62:	f022 022a 	bic.w	r2, r2, #42	@ 0x2a
 8006f66:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 8006f68:	681a      	ldr	r2, [r3, #0]
 8006f6a:	f042 0201 	orr.w	r2, r2, #1
  return (UART_CheckIdleState(huart));
 8006f6e:	4620      	mov	r0, r4
  __HAL_UART_ENABLE(huart);
 8006f70:	601a      	str	r2, [r3, #0]
}
 8006f72:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return (UART_CheckIdleState(huart));
 8006f76:	f7ff bead 	b.w	8006cd4 <UART_CheckIdleState>
}
 8006f7a:	2001      	movs	r0, #1
 8006f7c:	bd10      	pop	{r4, pc}
    UART_AdvFeatureConfig(huart);
 8006f7e:	4620      	mov	r0, r4
 8006f80:	f7ff fe50 	bl	8006c24 <UART_AdvFeatureConfig>
 8006f84:	e7e2      	b.n	8006f4c <HAL_UART_Init+0x20>
    huart->Lock = HAL_UNLOCKED;
 8006f86:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
    HAL_UART_MspInit(huart);
 8006f8a:	f7fc ffdf 	bl	8003f4c <HAL_UART_MspInit>
 8006f8e:	e7d3      	b.n	8006f38 <HAL_UART_Init+0xc>
}
 8006f90:	2001      	movs	r0, #1
 8006f92:	4770      	bx	lr

08006f94 <HAL_UARTEx_DisableFifoMode>:

  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));

  /* Process Locked */
  __HAL_LOCK(huart);
 8006f94:	f890 3084 	ldrb.w	r3, [r0, #132]	@ 0x84
 8006f98:	2b01      	cmp	r3, #1
 8006f9a:	d017      	beq.n	8006fcc <HAL_UARTEx_DisableFifoMode+0x38>

  huart->gState = HAL_UART_STATE_BUSY;

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8006f9c:	6802      	ldr	r2, [r0, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 8006f9e:	2324      	movs	r3, #36	@ 0x24
{
 8006fa0:	b410      	push	{r4}
  huart->gState = HAL_UART_STATE_BUSY;
 8006fa2:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8006fa6:	6811      	ldr	r1, [r2, #0]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 8006fa8:	6814      	ldr	r4, [r2, #0]

  /* Disable FIFO mode */
  CLEAR_BIT(tmpcr1, USART_CR1_FIFOEN);
  huart->FifoMode = UART_FIFOMODE_DISABLE;
 8006faa:	2300      	movs	r3, #0
  __HAL_UART_DISABLE(huart);
 8006fac:	f024 0401 	bic.w	r4, r4, #1
  CLEAR_BIT(tmpcr1, USART_CR1_FIFOEN);
 8006fb0:	f021 5100 	bic.w	r1, r1, #536870912	@ 0x20000000
  __HAL_UART_DISABLE(huart);
 8006fb4:	6014      	str	r4, [r2, #0]
  huart->FifoMode = UART_FIFOMODE_DISABLE;
 8006fb6:	6643      	str	r3, [r0, #100]	@ 0x64

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8006fb8:	6011      	str	r1, [r2, #0]

  huart->gState = HAL_UART_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 8006fba:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
  huart->gState = HAL_UART_STATE_READY;
 8006fbe:	2220      	movs	r2, #32
 8006fc0:	f8c0 2088 	str.w	r2, [r0, #136]	@ 0x88

  return HAL_OK;
}
 8006fc4:	f85d 4b04 	ldr.w	r4, [sp], #4
  return HAL_OK;
 8006fc8:	4618      	mov	r0, r3
}
 8006fca:	4770      	bx	lr
  __HAL_LOCK(huart);
 8006fcc:	2002      	movs	r0, #2
}
 8006fce:	4770      	bx	lr

08006fd0 <HAL_UARTEx_SetTxFifoThreshold>:
  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
  assert_param(IS_UART_TXFIFO_THRESHOLD(Threshold));

  /* Process Locked */
  __HAL_LOCK(huart);
 8006fd0:	f890 2084 	ldrb.w	r2, [r0, #132]	@ 0x84
 8006fd4:	2a01      	cmp	r2, #1
 8006fd6:	d037      	beq.n	8007048 <HAL_UARTEx_SetTxFifoThreshold+0x78>

  huart->gState = HAL_UART_STATE_BUSY;
 8006fd8:	4603      	mov	r3, r0

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8006fda:	6802      	ldr	r2, [r0, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 8006fdc:	2024      	movs	r0, #36	@ 0x24
{
 8006fde:	b530      	push	{r4, r5, lr}
  huart->gState = HAL_UART_STATE_BUSY;
 8006fe0:	f8c3 0088 	str.w	r0, [r3, #136]	@ 0x88
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8006fe4:	6814      	ldr	r4, [r2, #0]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 8006fe6:	6810      	ldr	r0, [r2, #0]
 8006fe8:	f020 0001 	bic.w	r0, r0, #1
 8006fec:	6010      	str	r0, [r2, #0]

  /* Update TX threshold configuration */
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 8006fee:	6890      	ldr	r0, [r2, #8]
 8006ff0:	f020 4060 	bic.w	r0, r0, #3758096384	@ 0xe0000000
 8006ff4:	4301      	orrs	r1, r0
  uint8_t rx_fifo_threshold;
  uint8_t tx_fifo_threshold;
  static const uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
  static const uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};

  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 8006ff6:	6e58      	ldr	r0, [r3, #100]	@ 0x64
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 8006ff8:	6091      	str	r1, [r2, #8]
  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 8006ffa:	b310      	cbz	r0, 8007042 <HAL_UARTEx_SetTxFifoThreshold+0x72>
  }
  else
  {
    rx_fifo_depth = RX_FIFO_DEPTH;
    tx_fifo_depth = TX_FIFO_DEPTH;
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 8006ffc:	6891      	ldr	r1, [r2, #8]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 8006ffe:	6890      	ldr	r0, [r2, #8]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
                               (uint16_t)denominator[tx_fifo_threshold];
 8007000:	4d12      	ldr	r5, [pc, #72]	@ (800704c <HAL_UARTEx_SetTxFifoThreshold+0x7c>)
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8007002:	f3c1 6c42 	ubfx	ip, r1, #25, #3
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 8007006:	ea4f 7e50 	mov.w	lr, r0, lsr #29
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 800700a:	4911      	ldr	r1, [pc, #68]	@ (8007050 <HAL_UARTEx_SetTxFifoThreshold+0x80>)
 800700c:	f811 000e 	ldrb.w	r0, [r1, lr]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8007010:	f811 100c 	ldrb.w	r1, [r1, ip]
                               (uint16_t)denominator[tx_fifo_threshold];
 8007014:	f815 e00e 	ldrb.w	lr, [r5, lr]
                               (uint16_t)denominator[rx_fifo_threshold];
 8007018:	f815 500c 	ldrb.w	r5, [r5, ip]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 800701c:	00c0      	lsls	r0, r0, #3
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 800701e:	00c9      	lsls	r1, r1, #3
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8007020:	fbb0 f0fe 	udiv	r0, r0, lr
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8007024:	fbb1 f1f5 	udiv	r1, r1, r5
 8007028:	f8a3 1068 	strh.w	r1, [r3, #104]	@ 0x68
  __HAL_UNLOCK(huart);
 800702c:	2100      	movs	r1, #0
 800702e:	f8a3 006a 	strh.w	r0, [r3, #106]	@ 0x6a
  huart->gState = HAL_UART_STATE_READY;
 8007032:	2520      	movs	r5, #32
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8007034:	6014      	str	r4, [r2, #0]
  __HAL_UNLOCK(huart);
 8007036:	f883 1084 	strb.w	r1, [r3, #132]	@ 0x84
  return HAL_OK;
 800703a:	4608      	mov	r0, r1
  huart->gState = HAL_UART_STATE_READY;
 800703c:	f8c3 5088 	str.w	r5, [r3, #136]	@ 0x88
}
 8007040:	bd30      	pop	{r4, r5, pc}
    huart->NbRxDataToProcess = 1U;
 8007042:	2101      	movs	r1, #1
    huart->NbTxDataToProcess = 1U;
 8007044:	4608      	mov	r0, r1
 8007046:	e7ef      	b.n	8007028 <HAL_UARTEx_SetTxFifoThreshold+0x58>
  __HAL_LOCK(huart);
 8007048:	2002      	movs	r0, #2
}
 800704a:	4770      	bx	lr
 800704c:	0800a518 	.word	0x0800a518
 8007050:	0800a520 	.word	0x0800a520

08007054 <HAL_UARTEx_SetRxFifoThreshold>:
  __HAL_LOCK(huart);
 8007054:	f890 2084 	ldrb.w	r2, [r0, #132]	@ 0x84
 8007058:	2a01      	cmp	r2, #1
 800705a:	d037      	beq.n	80070cc <HAL_UARTEx_SetRxFifoThreshold+0x78>
  huart->gState = HAL_UART_STATE_BUSY;
 800705c:	4603      	mov	r3, r0
  tmpcr1 = READ_REG(huart->Instance->CR1);
 800705e:	6802      	ldr	r2, [r0, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 8007060:	2024      	movs	r0, #36	@ 0x24
{
 8007062:	b530      	push	{r4, r5, lr}
  huart->gState = HAL_UART_STATE_BUSY;
 8007064:	f8c3 0088 	str.w	r0, [r3, #136]	@ 0x88
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8007068:	6814      	ldr	r4, [r2, #0]
  __HAL_UART_DISABLE(huart);
 800706a:	6810      	ldr	r0, [r2, #0]
 800706c:	f020 0001 	bic.w	r0, r0, #1
 8007070:	6010      	str	r0, [r2, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 8007072:	6890      	ldr	r0, [r2, #8]
 8007074:	f020 6060 	bic.w	r0, r0, #234881024	@ 0xe000000
 8007078:	4301      	orrs	r1, r0
  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 800707a:	6e58      	ldr	r0, [r3, #100]	@ 0x64
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 800707c:	6091      	str	r1, [r2, #8]
  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 800707e:	b310      	cbz	r0, 80070c6 <HAL_UARTEx_SetRxFifoThreshold+0x72>
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 8007080:	6891      	ldr	r1, [r2, #8]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 8007082:	6890      	ldr	r0, [r2, #8]
                               (uint16_t)denominator[tx_fifo_threshold];
 8007084:	4d12      	ldr	r5, [pc, #72]	@ (80070d0 <HAL_UARTEx_SetRxFifoThreshold+0x7c>)
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8007086:	f3c1 6c42 	ubfx	ip, r1, #25, #3
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 800708a:	ea4f 7e50 	mov.w	lr, r0, lsr #29
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 800708e:	4911      	ldr	r1, [pc, #68]	@ (80070d4 <HAL_UARTEx_SetRxFifoThreshold+0x80>)
 8007090:	f811 000e 	ldrb.w	r0, [r1, lr]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8007094:	f811 100c 	ldrb.w	r1, [r1, ip]
                               (uint16_t)denominator[tx_fifo_threshold];
 8007098:	f815 e00e 	ldrb.w	lr, [r5, lr]
                               (uint16_t)denominator[rx_fifo_threshold];
 800709c:	f815 500c 	ldrb.w	r5, [r5, ip]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 80070a0:	00c0      	lsls	r0, r0, #3
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 80070a2:	00c9      	lsls	r1, r1, #3
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 80070a4:	fbb0 f0fe 	udiv	r0, r0, lr
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 80070a8:	fbb1 f1f5 	udiv	r1, r1, r5
 80070ac:	f8a3 1068 	strh.w	r1, [r3, #104]	@ 0x68
  __HAL_UNLOCK(huart);
 80070b0:	2100      	movs	r1, #0
 80070b2:	f8a3 006a 	strh.w	r0, [r3, #106]	@ 0x6a
  huart->gState = HAL_UART_STATE_READY;
 80070b6:	2520      	movs	r5, #32
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 80070b8:	6014      	str	r4, [r2, #0]
  __HAL_UNLOCK(huart);
 80070ba:	f883 1084 	strb.w	r1, [r3, #132]	@ 0x84
  return HAL_OK;
 80070be:	4608      	mov	r0, r1
  huart->gState = HAL_UART_STATE_READY;
 80070c0:	f8c3 5088 	str.w	r5, [r3, #136]	@ 0x88
}
 80070c4:	bd30      	pop	{r4, r5, pc}
    huart->NbRxDataToProcess = 1U;
 80070c6:	2101      	movs	r1, #1
    huart->NbTxDataToProcess = 1U;
 80070c8:	4608      	mov	r0, r1
 80070ca:	e7ef      	b.n	80070ac <HAL_UARTEx_SetRxFifoThreshold+0x58>
  __HAL_LOCK(huart);
 80070cc:	2002      	movs	r0, #2
}
 80070ce:	4770      	bx	lr
 80070d0:	0800a518 	.word	0x0800a518
 80070d4:	0800a520 	.word	0x0800a520

080070d8 <osKernelStart>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osKernelStart (void)
{
 80070d8:	b508      	push	{r3, lr}
  vTaskStartScheduler();
 80070da:	f000 fe11 	bl	8007d00 <vTaskStartScheduler>
  
  return osOK;
}
 80070de:	2000      	movs	r0, #0
 80070e0:	bd08      	pop	{r3, pc}
 80070e2:	bf00      	nop

080070e4 <osThreadCreate>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
 80070e4:	b510      	push	{r4, lr}
 80070e6:	4684      	mov	ip, r0
 80070e8:	460b      	mov	r3, r1

    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
              thread_def->buffer, thread_def->controlblock);
#else
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 80070ea:	f8bc 2010 	ldrh.w	r2, [ip, #16]
 80070ee:	f8dc 1000 	ldr.w	r1, [ip]
                   thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
 80070f2:	f9bc c008 	ldrsh.w	ip, [ip, #8]
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 80070f6:	6840      	ldr	r0, [r0, #4]
{
 80070f8:	b084      	sub	sp, #16
  if (priority != osPriorityError) {
 80070fa:	f1bc 0f84 	cmp.w	ip, #132	@ 0x84
    fpriority += (priority - osPriorityIdle);
 80070fe:	bf14      	ite	ne
 8007100:	f10c 0403 	addne.w	r4, ip, #3
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 8007104:	2400      	moveq	r4, #0
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8007106:	9400      	str	r4, [sp, #0]
 8007108:	ac03      	add	r4, sp, #12
 800710a:	9401      	str	r4, [sp, #4]
 800710c:	f000 fcba 	bl	8007a84 <xTaskCreate>
 8007110:	2801      	cmp	r0, #1
                   &handle) != pdPASS)  {
    return NULL;
  }     
#endif
  
  return handle;
 8007112:	bf0c      	ite	eq
 8007114:	9803      	ldreq	r0, [sp, #12]
    return NULL;
 8007116:	2000      	movne	r0, #0
}
 8007118:	b004      	add	sp, #16
 800711a:	bd10      	pop	{r4, pc}

0800711c <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 800711c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8007120:	4604      	mov	r4, r0
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
 8007122:	f000 fed1 	bl	8007ec8 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
 8007126:	4a51      	ldr	r2, [pc, #324]	@ (800726c <pvPortMalloc+0x150>)
 8007128:	6815      	ldr	r5, [r2, #0]
 800712a:	2d00      	cmp	r5, #0
 800712c:	d035      	beq.n	800719a <pvPortMalloc+0x7e>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 800712e:	4b50      	ldr	r3, [pc, #320]	@ (8007270 <pvPortMalloc+0x154>)
 8007130:	681e      	ldr	r6, [r3, #0]
 8007132:	4234      	tst	r4, r6
 8007134:	d12b      	bne.n	800718e <pvPortMalloc+0x72>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
 8007136:	b354      	cbz	r4, 800718e <pvPortMalloc+0x72>
			{
				xWantedSize += xHeapStructSize;
 8007138:	f104 0008 	add.w	r0, r4, #8

				/* Ensure that blocks are always aligned to the required number
				of bytes. */
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 800713c:	0764      	lsls	r4, r4, #29
				{
					/* Byte alignment required. */
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 800713e:	bf1c      	itt	ne
 8007140:	f020 0007 	bicne.w	r0, r0, #7
 8007144:	3008      	addne	r0, #8
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 8007146:	b310      	cbz	r0, 800718e <pvPortMalloc+0x72>
 8007148:	f8df e138 	ldr.w	lr, [pc, #312]	@ 8007284 <pvPortMalloc+0x168>
 800714c:	f8de c000 	ldr.w	ip, [lr]
 8007150:	4584      	cmp	ip, r0
 8007152:	d31c      	bcc.n	800718e <pvPortMalloc+0x72>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
 8007154:	4c47      	ldr	r4, [pc, #284]	@ (8007274 <pvPortMalloc+0x158>)
 8007156:	6823      	ldr	r3, [r4, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8007158:	e003      	b.n	8007162 <pvPortMalloc+0x46>
 800715a:	681a      	ldr	r2, [r3, #0]
 800715c:	b122      	cbz	r2, 8007168 <pvPortMalloc+0x4c>
 800715e:	461c      	mov	r4, r3
 8007160:	4613      	mov	r3, r2
 8007162:	6859      	ldr	r1, [r3, #4]
 8007164:	4281      	cmp	r1, r0
 8007166:	d3f8      	bcc.n	800715a <pvPortMalloc+0x3e>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
 8007168:	42ab      	cmp	r3, r5
 800716a:	d010      	beq.n	800718e <pvPortMalloc+0x72>
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 800716c:	681a      	ldr	r2, [r3, #0]
 800716e:	6022      	str	r2, [r4, #0]

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 8007170:	1a0a      	subs	r2, r1, r0
 8007172:	2a10      	cmp	r2, #16
 8007174:	d946      	bls.n	8007204 <pvPortMalloc+0xe8>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 8007176:	181c      	adds	r4, r3, r0
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 8007178:	0761      	lsls	r1, r4, #29
 800717a:	d02c      	beq.n	80071d6 <pvPortMalloc+0xba>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 800717c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007180:	f383 8811 	msr	BASEPRI, r3
 8007184:	f3bf 8f6f 	isb	sy
 8007188:	f3bf 8f4f 	dsb	sy
 800718c:	e7fe      	b.n	800718c <pvPortMalloc+0x70>
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 800718e:	f000 fea3 	bl	8007ed8 <xTaskResumeAll>
void *pvReturn = NULL;
 8007192:	2400      	movs	r4, #0
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
 8007194:	4620      	mov	r0, r4
 8007196:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;
 800719a:	4b37      	ldr	r3, [pc, #220]	@ (8007278 <pvPortMalloc+0x15c>)

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 800719c:	4835      	ldr	r0, [pc, #212]	@ (8007274 <pvPortMalloc+0x158>)
	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 800719e:	4f34      	ldr	r7, [pc, #208]	@ (8007270 <pvPortMalloc+0x154>)
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 80071a0:	075d      	lsls	r5, r3, #29
	uxAddress -= xHeapStructSize;
 80071a2:	4d36      	ldr	r5, [pc, #216]	@ (800727c <pvPortMalloc+0x160>)
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 80071a4:	bf18      	it	ne
 80071a6:	3307      	addne	r3, #7
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80071a8:	f025 0507 	bic.w	r5, r5, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80071ac:	bf18      	it	ne
 80071ae:	f023 0307 	bicne.w	r3, r3, #7
	pxEnd = ( void * ) uxAddress;
 80071b2:	6015      	str	r5, [r2, #0]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 80071b4:	4a32      	ldr	r2, [pc, #200]	@ (8007280 <pvPortMalloc+0x164>)
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 80071b6:	6003      	str	r3, [r0, #0]
 80071b8:	4619      	mov	r1, r3
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 80071ba:	1aeb      	subs	r3, r5, r3
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 80071bc:	6013      	str	r3, [r2, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 80071be:	4a31      	ldr	r2, [pc, #196]	@ (8007284 <pvPortMalloc+0x168>)
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 80071c0:	f04f 4600 	mov.w	r6, #2147483648	@ 0x80000000
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 80071c4:	6013      	str	r3, [r2, #0]
	xStart.xBlockSize = ( size_t ) 0;
 80071c6:	2200      	movs	r2, #0
 80071c8:	6042      	str	r2, [r0, #4]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 80071ca:	603e      	str	r6, [r7, #0]
	pxEnd->pxNextFreeBlock = NULL;
 80071cc:	e9c5 2200 	strd	r2, r2, [r5]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 80071d0:	e9c1 5300 	strd	r5, r3, [r1]
}
 80071d4:	e7ad      	b.n	8007132 <pvPortMalloc+0x16>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 80071d6:	6062      	str	r2, [r4, #4]
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 80071d8:	4a26      	ldr	r2, [pc, #152]	@ (8007274 <pvPortMalloc+0x158>)
						pxBlock->xBlockSize = xWantedSize;
 80071da:	6058      	str	r0, [r3, #4]
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 80071dc:	4617      	mov	r7, r2
 80071de:	6812      	ldr	r2, [r2, #0]
 80071e0:	4294      	cmp	r4, r2
 80071e2:	d8fb      	bhi.n	80071dc <pvPortMalloc+0xc0>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 80071e4:	6879      	ldr	r1, [r7, #4]
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 80071e6:	f8d4 8004 	ldr.w	r8, [r4, #4]
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 80071ea:	eb07 0901 	add.w	r9, r7, r1
 80071ee:	454c      	cmp	r4, r9
 80071f0:	d028      	beq.n	8007244 <pvPortMalloc+0x128>
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 80071f2:	eb04 0108 	add.w	r1, r4, r8
 80071f6:	428a      	cmp	r2, r1
 80071f8:	d02e      	beq.n	8007258 <pvPortMalloc+0x13c>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 80071fa:	6022      	str	r2, [r4, #0]
 80071fc:	4601      	mov	r1, r0

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 80071fe:	42a7      	cmp	r7, r4
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8007200:	bf18      	it	ne
 8007202:	603c      	strne	r4, [r7, #0]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8007204:	481e      	ldr	r0, [pc, #120]	@ (8007280 <pvPortMalloc+0x164>)
 8007206:	6804      	ldr	r4, [r0, #0]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8007208:	ebac 0201 	sub.w	r2, ip, r1
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 800720c:	42a2      	cmp	r2, r4
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 800720e:	bf38      	it	cc
 8007210:	6002      	strcc	r2, [r0, #0]
					xNumberOfSuccessfulAllocations++;
 8007212:	481d      	ldr	r0, [pc, #116]	@ (8007288 <pvPortMalloc+0x16c>)
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8007214:	f8ce 2000 	str.w	r2, [lr]
					xNumberOfSuccessfulAllocations++;
 8007218:	6802      	ldr	r2, [r0, #0]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 800721a:	4331      	orrs	r1, r6
					pxBlock->pxNextFreeBlock = NULL;
 800721c:	2500      	movs	r5, #0
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800721e:	f103 0408 	add.w	r4, r3, #8
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 8007222:	6059      	str	r1, [r3, #4]
					xNumberOfSuccessfulAllocations++;
 8007224:	3201      	adds	r2, #1
					pxBlock->pxNextFreeBlock = NULL;
 8007226:	601d      	str	r5, [r3, #0]
					xNumberOfSuccessfulAllocations++;
 8007228:	6002      	str	r2, [r0, #0]
	( void ) xTaskResumeAll();
 800722a:	f000 fe55 	bl	8007ed8 <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 800722e:	0763      	lsls	r3, r4, #29
 8007230:	d0b0      	beq.n	8007194 <pvPortMalloc+0x78>
 8007232:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007236:	f383 8811 	msr	BASEPRI, r3
 800723a:	f3bf 8f6f 	isb	sy
 800723e:	f3bf 8f4f 	dsb	sy
 8007242:	e7fe      	b.n	8007242 <pvPortMalloc+0x126>
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 8007244:	4488      	add	r8, r1
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8007246:	eb07 0108 	add.w	r1, r7, r8
 800724a:	428a      	cmp	r2, r1
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 800724c:	f8c7 8004 	str.w	r8, [r7, #4]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8007250:	d001      	beq.n	8007256 <pvPortMalloc+0x13a>
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8007252:	6859      	ldr	r1, [r3, #4]
 8007254:	e7d6      	b.n	8007204 <pvPortMalloc+0xe8>
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8007256:	463c      	mov	r4, r7
		if( pxIterator->pxNextFreeBlock != pxEnd )
 8007258:	42aa      	cmp	r2, r5
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 800725a:	bf1c      	itt	ne
 800725c:	6851      	ldrne	r1, [r2, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 800725e:	6812      	ldrne	r2, [r2, #0]
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
 8007260:	6022      	str	r2, [r4, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8007262:	bf1c      	itt	ne
 8007264:	4441      	addne	r1, r8
 8007266:	6061      	strne	r1, [r4, #4]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8007268:	6859      	ldr	r1, [r3, #4]
 800726a:	e7c8      	b.n	80071fe <pvPortMalloc+0xe2>
 800726c:	20001a54 	.word	0x20001a54
 8007270:	20001a40 	.word	0x20001a40
 8007274:	20001a58 	.word	0x20001a58
 8007278:	20001a60 	.word	0x20001a60
 800727c:	20002658 	.word	0x20002658
 8007280:	20001a4c 	.word	0x20001a4c
 8007284:	20001a50 	.word	0x20001a50
 8007288:	20001a48 	.word	0x20001a48

0800728c <vPortFree>:
	if( pv != NULL )
 800728c:	b1d0      	cbz	r0, 80072c4 <vPortFree+0x38>
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 800728e:	4a2c      	ldr	r2, [pc, #176]	@ (8007340 <vPortFree+0xb4>)
 8007290:	f850 3c04 	ldr.w	r3, [r0, #-4]
 8007294:	6812      	ldr	r2, [r2, #0]
 8007296:	4213      	tst	r3, r2
 8007298:	d00b      	beq.n	80072b2 <vPortFree+0x26>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 800729a:	f850 1c08 	ldr.w	r1, [r0, #-8]
 800729e:	b191      	cbz	r1, 80072c6 <vPortFree+0x3a>
 80072a0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80072a4:	f383 8811 	msr	BASEPRI, r3
 80072a8:	f3bf 8f6f 	isb	sy
 80072ac:	f3bf 8f4f 	dsb	sy
 80072b0:	e7fe      	b.n	80072b0 <vPortFree+0x24>
 80072b2:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80072b6:	f383 8811 	msr	BASEPRI, r3
 80072ba:	f3bf 8f6f 	isb	sy
 80072be:	f3bf 8f4f 	dsb	sy
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 80072c2:	e7fe      	b.n	80072c2 <vPortFree+0x36>
 80072c4:	4770      	bx	lr
{
 80072c6:	b570      	push	{r4, r5, r6, lr}
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 80072c8:	ea23 0302 	bic.w	r3, r3, r2
{
 80072cc:	b082      	sub	sp, #8
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 80072ce:	f840 3c04 	str.w	r3, [r0, #-4]
					xFreeBytesRemaining += pxLink->xBlockSize;
 80072d2:	4c1c      	ldr	r4, [pc, #112]	@ (8007344 <vPortFree+0xb8>)
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 80072d4:	9001      	str	r0, [sp, #4]
				vTaskSuspendAll();
 80072d6:	f000 fdf7 	bl	8007ec8 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 80072da:	9801      	ldr	r0, [sp, #4]
 80072dc:	6822      	ldr	r2, [r4, #0]
 80072de:	f850 5c04 	ldr.w	r5, [r0, #-4]
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 80072e2:	4b19      	ldr	r3, [pc, #100]	@ (8007348 <vPortFree+0xbc>)
					xFreeBytesRemaining += pxLink->xBlockSize;
 80072e4:	1951      	adds	r1, r2, r5
 80072e6:	6021      	str	r1, [r4, #0]
		puc -= xHeapStructSize;
 80072e8:	f1a0 0208 	sub.w	r2, r0, #8
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 80072ec:	4619      	mov	r1, r3
 80072ee:	681b      	ldr	r3, [r3, #0]
 80072f0:	429a      	cmp	r2, r3
 80072f2:	d8fb      	bhi.n	80072ec <vPortFree+0x60>
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 80072f4:	684e      	ldr	r6, [r1, #4]
 80072f6:	198c      	adds	r4, r1, r6
 80072f8:	42a2      	cmp	r2, r4
 80072fa:	d011      	beq.n	8007320 <vPortFree+0x94>
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 80072fc:	eb02 0e05 	add.w	lr, r2, r5
 8007300:	4573      	cmp	r3, lr
 8007302:	d013      	beq.n	800732c <vPortFree+0xa0>
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 8007304:	f840 3c08 	str.w	r3, [r0, #-8]
	if( pxIterator != pxBlockToInsert )
 8007308:	4291      	cmp	r1, r2
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 800730a:	bf18      	it	ne
 800730c:	600a      	strne	r2, [r1, #0]
					xNumberOfSuccessfulFrees++;
 800730e:	4a0f      	ldr	r2, [pc, #60]	@ (800734c <vPortFree+0xc0>)
 8007310:	6813      	ldr	r3, [r2, #0]
 8007312:	3301      	adds	r3, #1
 8007314:	6013      	str	r3, [r2, #0]
}
 8007316:	b002      	add	sp, #8
 8007318:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				( void ) xTaskResumeAll();
 800731c:	f000 bddc 	b.w	8007ed8 <xTaskResumeAll>
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 8007320:	4435      	add	r5, r6
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8007322:	194a      	adds	r2, r1, r5
 8007324:	4293      	cmp	r3, r2
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 8007326:	604d      	str	r5, [r1, #4]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8007328:	d1f1      	bne.n	800730e <vPortFree+0x82>
 800732a:	460a      	mov	r2, r1
		if( pxIterator->pxNextFreeBlock != pxEnd )
 800732c:	4808      	ldr	r0, [pc, #32]	@ (8007350 <vPortFree+0xc4>)
 800732e:	6800      	ldr	r0, [r0, #0]
 8007330:	4283      	cmp	r3, r0
 8007332:	d003      	beq.n	800733c <vPortFree+0xb0>
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8007334:	e9d3 0400 	ldrd	r0, r4, [r3]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8007338:	1963      	adds	r3, r4, r5
 800733a:	6053      	str	r3, [r2, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 800733c:	6010      	str	r0, [r2, #0]
 800733e:	e7e3      	b.n	8007308 <vPortFree+0x7c>
 8007340:	20001a40 	.word	0x20001a40
 8007344:	20001a50 	.word	0x20001a50
 8007348:	20001a58 	.word	0x20001a58
 800734c:	20001a44 	.word	0x20001a44
 8007350:	20001a54 	.word	0x20001a54

08007354 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8007354:	f100 0308 	add.w	r3, r0, #8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8007358:	f04f 31ff 	mov.w	r1, #4294967295
	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 800735c:	2200      	movs	r2, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 800735e:	e9c0 3101 	strd	r3, r1, [r0, #4]
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8007362:	e9c0 3303 	strd	r3, r3, [r0, #12]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8007366:	6002      	str	r2, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 8007368:	4770      	bx	lr
 800736a:	bf00      	nop

0800736c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
 800736c:	2300      	movs	r3, #0
 800736e:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 8007370:	4770      	bx	lr
 8007372:	bf00      	nop

08007374 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 8007374:	6842      	ldr	r2, [r0, #4]
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;

	( pxList->uxNumberOfItems )++;
 8007376:	6803      	ldr	r3, [r0, #0]
{
 8007378:	b410      	push	{r4}
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 800737a:	6894      	ldr	r4, [r2, #8]
	( pxList->uxNumberOfItems )++;
 800737c:	3301      	adds	r3, #1
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 800737e:	e9c1 2401 	strd	r2, r4, [r1, #4]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8007382:	6061      	str	r1, [r4, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8007384:	6091      	str	r1, [r2, #8]
}
 8007386:	f85d 4b04 	ldr.w	r4, [sp], #4
	pxNewListItem->pxContainer = pxList;
 800738a:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 800738c:	6003      	str	r3, [r0, #0]
}
 800738e:	4770      	bx	lr

08007390 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 8007390:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8007392:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8007394:	1c6b      	adds	r3, r5, #1
 8007396:	d010      	beq.n	80073ba <vListInsert+0x2a>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 8007398:	f100 0308 	add.w	r3, r0, #8
 800739c:	461c      	mov	r4, r3
 800739e:	685b      	ldr	r3, [r3, #4]
 80073a0:	681a      	ldr	r2, [r3, #0]
 80073a2:	42aa      	cmp	r2, r5
 80073a4:	d9fa      	bls.n	800739c <vListInsert+0xc>

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;

	( pxList->uxNumberOfItems )++;
 80073a6:	6802      	ldr	r2, [r0, #0]
	pxNewListItem->pxNext = pxIterator->pxNext;
 80073a8:	604b      	str	r3, [r1, #4]
	( pxList->uxNumberOfItems )++;
 80073aa:	3201      	adds	r2, #1
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 80073ac:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 80073ae:	608c      	str	r4, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 80073b0:	6061      	str	r1, [r4, #4]
	pxNewListItem->pxContainer = pxList;
 80073b2:	6108      	str	r0, [r1, #16]
}
 80073b4:	bc30      	pop	{r4, r5}
	( pxList->uxNumberOfItems )++;
 80073b6:	6002      	str	r2, [r0, #0]
}
 80073b8:	4770      	bx	lr
		pxIterator = pxList->xListEnd.pxPrevious;
 80073ba:	6904      	ldr	r4, [r0, #16]
	pxNewListItem->pxNext = pxIterator->pxNext;
 80073bc:	6863      	ldr	r3, [r4, #4]
 80073be:	e7f2      	b.n	80073a6 <vListInsert+0x16>

080073c0 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
 80073c0:	6903      	ldr	r3, [r0, #16]
{
 80073c2:	b410      	push	{r4}

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 80073c4:	e9d0 1201 	ldrd	r1, r2, [r0, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 80073c8:	685c      	ldr	r4, [r3, #4]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 80073ca:	608a      	str	r2, [r1, #8]
	if( pxList->pxIndex == pxItemToRemove )
 80073cc:	4284      	cmp	r4, r0
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 80073ce:	6051      	str	r1, [r2, #4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 80073d0:	bf08      	it	eq
 80073d2:	605a      	streq	r2, [r3, #4]
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
	( pxList->uxNumberOfItems )--;
 80073d4:	681a      	ldr	r2, [r3, #0]

	return pxList->uxNumberOfItems;
}
 80073d6:	f85d 4b04 	ldr.w	r4, [sp], #4
	pxItemToRemove->pxContainer = NULL;
 80073da:	2100      	movs	r1, #0
	( pxList->uxNumberOfItems )--;
 80073dc:	3a01      	subs	r2, #1
	pxItemToRemove->pxContainer = NULL;
 80073de:	6101      	str	r1, [r0, #16]
	( pxList->uxNumberOfItems )--;
 80073e0:	601a      	str	r2, [r3, #0]
	return pxList->uxNumberOfItems;
 80073e2:	6818      	ldr	r0, [r3, #0]
}
 80073e4:	4770      	bx	lr
 80073e6:	bf00      	nop

080073e8 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(
 80073e8:	4808      	ldr	r0, [pc, #32]	@ (800740c <prvPortStartFirstTask+0x24>)
 80073ea:	6800      	ldr	r0, [r0, #0]
 80073ec:	6800      	ldr	r0, [r0, #0]
 80073ee:	f380 8808 	msr	MSP, r0
 80073f2:	f04f 0000 	mov.w	r0, #0
 80073f6:	f380 8814 	msr	CONTROL, r0
 80073fa:	b662      	cpsie	i
 80073fc:	b661      	cpsie	f
 80073fe:	f3bf 8f4f 	dsb	sy
 8007402:	f3bf 8f6f 	isb	sy
 8007406:	df00      	svc	0
 8007408:	bf00      	nop
					" dsb					\n"
					" isb					\n"
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
 800740a:	0000      	.short	0x0000
 800740c:	e000ed08 	.word	0xe000ed08

08007410 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 8007410:	f8df 000c 	ldr.w	r0, [pc, #12]	@ 8007420 <vPortEnableVFP+0x10>
 8007414:	6801      	ldr	r1, [r0, #0]
 8007416:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 800741a:	6001      	str	r1, [r0, #0]
 800741c:	4770      	bx	lr
		"								\n"
		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
		"	str r1, [r0]				\n"
		"	bx r14						"
	);
}
 800741e:	0000      	.short	0x0000
 8007420:	e000ed88 	.word	0xe000ed88

08007424 <prvTaskExitError>:
	configASSERT( uxCriticalNesting == ~0UL );
 8007424:	4b0e      	ldr	r3, [pc, #56]	@ (8007460 <prvTaskExitError+0x3c>)
 8007426:	681b      	ldr	r3, [r3, #0]
{
 8007428:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0;
 800742a:	2200      	movs	r2, #0
	configASSERT( uxCriticalNesting == ~0UL );
 800742c:	3301      	adds	r3, #1
volatile uint32_t ulDummy = 0;
 800742e:	9201      	str	r2, [sp, #4]
	configASSERT( uxCriticalNesting == ~0UL );
 8007430:	d008      	beq.n	8007444 <prvTaskExitError+0x20>
 8007432:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007436:	f383 8811 	msr	BASEPRI, r3
 800743a:	f3bf 8f6f 	isb	sy
 800743e:	f3bf 8f4f 	dsb	sy
 8007442:	e7fe      	b.n	8007442 <prvTaskExitError+0x1e>
 8007444:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007448:	f383 8811 	msr	BASEPRI, r3
 800744c:	f3bf 8f6f 	isb	sy
 8007450:	f3bf 8f4f 	dsb	sy
	while( ulDummy == 0 )
 8007454:	9b01      	ldr	r3, [sp, #4]
 8007456:	2b00      	cmp	r3, #0
 8007458:	d0fc      	beq.n	8007454 <prvTaskExitError+0x30>
}
 800745a:	b002      	add	sp, #8
 800745c:	4770      	bx	lr
 800745e:	bf00      	nop
 8007460:	20000564 	.word	0x20000564

08007464 <pxPortInitialiseStack>:
{
 8007464:	b410      	push	{r4}
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8007466:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 800746a:	4c07      	ldr	r4, [pc, #28]	@ (8007488 <pxPortInitialiseStack+0x24>)
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 800746c:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 8007470:	f021 0101 	bic.w	r1, r1, #1
	*pxTopOfStack = portINITIAL_EXC_RETURN;
 8007474:	f06f 0302 	mvn.w	r3, #2
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8007478:	e940 4103 	strd	r4, r1, [r0, #-12]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
 800747c:	e940 3209 	strd	r3, r2, [r0, #-36]	@ 0x24
}
 8007480:	f85d 4b04 	ldr.w	r4, [sp], #4
 8007484:	3844      	subs	r0, #68	@ 0x44
 8007486:	4770      	bx	lr
 8007488:	08007425 	.word	0x08007425
 800748c:	00000000 	.word	0x00000000

08007490 <SVC_Handler>:
	__asm volatile (
 8007490:	4b07      	ldr	r3, [pc, #28]	@ (80074b0 <pxCurrentTCBConst2>)
 8007492:	6819      	ldr	r1, [r3, #0]
 8007494:	6808      	ldr	r0, [r1, #0]
 8007496:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800749a:	f380 8809 	msr	PSP, r0
 800749e:	f3bf 8f6f 	isb	sy
 80074a2:	f04f 0000 	mov.w	r0, #0
 80074a6:	f380 8811 	msr	BASEPRI, r0
 80074aa:	4770      	bx	lr
 80074ac:	f3af 8000 	nop.w

080074b0 <pxCurrentTCBConst2>:
 80074b0:	20002790 	.word	0x20002790

080074b4 <vPortEnterCritical>:
 80074b4:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80074b8:	f383 8811 	msr	BASEPRI, r3
 80074bc:	f3bf 8f6f 	isb	sy
 80074c0:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
 80074c4:	4a0b      	ldr	r2, [pc, #44]	@ (80074f4 <vPortEnterCritical+0x40>)
 80074c6:	6813      	ldr	r3, [r2, #0]
 80074c8:	3301      	adds	r3, #1
	if( uxCriticalNesting == 1 )
 80074ca:	2b01      	cmp	r3, #1
	uxCriticalNesting++;
 80074cc:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 1 )
 80074ce:	d000      	beq.n	80074d2 <vPortEnterCritical+0x1e>
}
 80074d0:	4770      	bx	lr
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 80074d2:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 80074d6:	f8d3 3d04 	ldr.w	r3, [r3, #3332]	@ 0xd04
 80074da:	b2db      	uxtb	r3, r3
 80074dc:	2b00      	cmp	r3, #0
 80074de:	d0f7      	beq.n	80074d0 <vPortEnterCritical+0x1c>
 80074e0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80074e4:	f383 8811 	msr	BASEPRI, r3
 80074e8:	f3bf 8f6f 	isb	sy
 80074ec:	f3bf 8f4f 	dsb	sy
 80074f0:	e7fe      	b.n	80074f0 <vPortEnterCritical+0x3c>
 80074f2:	bf00      	nop
 80074f4:	20000564 	.word	0x20000564

080074f8 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
 80074f8:	4a08      	ldr	r2, [pc, #32]	@ (800751c <vPortExitCritical+0x24>)
 80074fa:	6813      	ldr	r3, [r2, #0]
 80074fc:	b943      	cbnz	r3, 8007510 <vPortExitCritical+0x18>
 80074fe:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007502:	f383 8811 	msr	BASEPRI, r3
 8007506:	f3bf 8f6f 	isb	sy
 800750a:	f3bf 8f4f 	dsb	sy
 800750e:	e7fe      	b.n	800750e <vPortExitCritical+0x16>
	uxCriticalNesting--;
 8007510:	3b01      	subs	r3, #1
 8007512:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8007514:	b90b      	cbnz	r3, 800751a <vPortExitCritical+0x22>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 8007516:	f383 8811 	msr	BASEPRI, r3
}
 800751a:	4770      	bx	lr
 800751c:	20000564 	.word	0x20000564

08007520 <PendSV_Handler>:
	__asm volatile
 8007520:	f3ef 8009 	mrs	r0, PSP
 8007524:	f3bf 8f6f 	isb	sy
 8007528:	4b15      	ldr	r3, [pc, #84]	@ (8007580 <pxCurrentTCBConst>)
 800752a:	681a      	ldr	r2, [r3, #0]
 800752c:	f01e 0f10 	tst.w	lr, #16
 8007530:	bf08      	it	eq
 8007532:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 8007536:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800753a:	6010      	str	r0, [r2, #0]
 800753c:	e92d 0009 	stmdb	sp!, {r0, r3}
 8007540:	f04f 0050 	mov.w	r0, #80	@ 0x50
 8007544:	f380 8811 	msr	BASEPRI, r0
 8007548:	f3bf 8f4f 	dsb	sy
 800754c:	f3bf 8f6f 	isb	sy
 8007550:	f000 fce2 	bl	8007f18 <vTaskSwitchContext>
 8007554:	f04f 0000 	mov.w	r0, #0
 8007558:	f380 8811 	msr	BASEPRI, r0
 800755c:	bc09      	pop	{r0, r3}
 800755e:	6819      	ldr	r1, [r3, #0]
 8007560:	6808      	ldr	r0, [r1, #0]
 8007562:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007566:	f01e 0f10 	tst.w	lr, #16
 800756a:	bf08      	it	eq
 800756c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 8007570:	f380 8809 	msr	PSP, r0
 8007574:	f3bf 8f6f 	isb	sy
 8007578:	4770      	bx	lr
 800757a:	bf00      	nop
 800757c:	f3af 8000 	nop.w

08007580 <pxCurrentTCBConst>:
 8007580:	20002790 	.word	0x20002790

08007584 <SysTick_Handler>:
{
 8007584:	b508      	push	{r3, lr}
	__asm volatile
 8007586:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800758a:	f383 8811 	msr	BASEPRI, r3
 800758e:	f3bf 8f6f 	isb	sy
 8007592:	f3bf 8f4f 	dsb	sy
		if( xTaskIncrementTick() != pdFALSE )
 8007596:	f000 fcaf 	bl	8007ef8 <xTaskIncrementTick>
 800759a:	b128      	cbz	r0, 80075a8 <SysTick_Handler+0x24>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 800759c:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 80075a0:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 80075a4:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
	__asm volatile
 80075a8:	2300      	movs	r3, #0
 80075aa:	f383 8811 	msr	BASEPRI, r3
}
 80075ae:	bd08      	pop	{r3, pc}

080075b0 <xPortStartScheduler>:
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 80075b0:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 80075b4:	4a48      	ldr	r2, [pc, #288]	@ (80076d8 <xPortStartScheduler+0x128>)
 80075b6:	f8d3 1d00 	ldr.w	r1, [r3, #3328]	@ 0xd00
 80075ba:	4291      	cmp	r1, r2
 80075bc:	d041      	beq.n	8007642 <xPortStartScheduler+0x92>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 80075be:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	@ 0xd00
 80075c2:	4b46      	ldr	r3, [pc, #280]	@ (80076dc <xPortStartScheduler+0x12c>)
 80075c4:	429a      	cmp	r2, r3
 80075c6:	d033      	beq.n	8007630 <xPortStartScheduler+0x80>
{
 80075c8:	b570      	push	{r4, r5, r6, lr}
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 80075ca:	4b45      	ldr	r3, [pc, #276]	@ (80076e0 <xPortStartScheduler+0x130>)
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 80075cc:	4c45      	ldr	r4, [pc, #276]	@ (80076e4 <xPortStartScheduler+0x134>)
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 80075ce:	781a      	ldrb	r2, [r3, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 80075d0:	4845      	ldr	r0, [pc, #276]	@ (80076e8 <xPortStartScheduler+0x138>)
{
 80075d2:	b084      	sub	sp, #16
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 80075d4:	21ff      	movs	r1, #255	@ 0xff
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 80075d6:	b2d2      	uxtb	r2, r2
 80075d8:	9202      	str	r2, [sp, #8]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 80075da:	7019      	strb	r1, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 80075dc:	781b      	ldrb	r3, [r3, #0]
 80075de:	b2db      	uxtb	r3, r3
 80075e0:	f88d 3007 	strb.w	r3, [sp, #7]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 80075e4:	f89d 3007 	ldrb.w	r3, [sp, #7]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 80075e8:	f89d 2007 	ldrb.w	r2, [sp, #7]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 80075ec:	f003 0350 	and.w	r3, r3, #80	@ 0x50
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 80075f0:	2107      	movs	r1, #7
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 80075f2:	0612      	lsls	r2, r2, #24
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 80075f4:	7023      	strb	r3, [r4, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 80075f6:	6001      	str	r1, [r0, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 80075f8:	bf48      	it	mi
 80075fa:	2206      	movmi	r2, #6
 80075fc:	d50f      	bpl.n	800761e <xPortStartScheduler+0x6e>
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 80075fe:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8007602:	005b      	lsls	r3, r3, #1
 8007604:	b2db      	uxtb	r3, r3
 8007606:	f88d 3007 	strb.w	r3, [sp, #7]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 800760a:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800760e:	061b      	lsls	r3, r3, #24
 8007610:	4611      	mov	r1, r2
 8007612:	f102 32ff 	add.w	r2, r2, #4294967295
 8007616:	d4f2      	bmi.n	80075fe <xPortStartScheduler+0x4e>
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 8007618:	2903      	cmp	r1, #3
 800761a:	d01b      	beq.n	8007654 <xPortStartScheduler+0xa4>
 800761c:	6001      	str	r1, [r0, #0]
	__asm volatile
 800761e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007622:	f383 8811 	msr	BASEPRI, r3
 8007626:	f3bf 8f6f 	isb	sy
 800762a:	f3bf 8f4f 	dsb	sy
 800762e:	e7fe      	b.n	800762e <xPortStartScheduler+0x7e>
 8007630:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007634:	f383 8811 	msr	BASEPRI, r3
 8007638:	f3bf 8f6f 	isb	sy
 800763c:	f3bf 8f4f 	dsb	sy
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 8007640:	e7fe      	b.n	8007640 <xPortStartScheduler+0x90>
 8007642:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007646:	f383 8811 	msr	BASEPRI, r3
 800764a:	f3bf 8f6f 	isb	sy
 800764e:	f3bf 8f4f 	dsb	sy
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 8007652:	e7fe      	b.n	8007652 <xPortStartScheduler+0xa2>
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 8007654:	9b02      	ldr	r3, [sp, #8]
 8007656:	4a22      	ldr	r2, [pc, #136]	@ (80076e0 <xPortStartScheduler+0x130>)
	uxCriticalNesting = 0;
 8007658:	4d24      	ldr	r5, [pc, #144]	@ (80076ec <xPortStartScheduler+0x13c>)
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 800765a:	f04f 24e0 	mov.w	r4, #3758153728	@ 0xe000e000
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 800765e:	f44f 7140 	mov.w	r1, #768	@ 0x300
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 8007662:	b2db      	uxtb	r3, r3
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 8007664:	6001      	str	r1, [r0, #0]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 8007666:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8007668:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	@ 0xd20
 800766c:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 8007670:	f8c4 3d20 	str.w	r3, [r4, #3360]	@ 0xd20
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8007674:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	@ 0xd20
 8007678:	f043 4370 	orr.w	r3, r3, #4026531840	@ 0xf0000000
 800767c:	f8c4 3d20 	str.w	r3, [r4, #3360]	@ 0xd20
	uxCriticalNesting = 0;
 8007680:	2600      	movs	r6, #0
	vPortSetupTimerInterrupt();
 8007682:	f7fa fdb5 	bl	80021f0 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 8007686:	602e      	str	r6, [r5, #0]
	vPortEnableVFP();
 8007688:	f7ff fec2 	bl	8007410 <vPortEnableVFP>
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 800768c:	f8d4 3f34 	ldr.w	r3, [r4, #3892]	@ 0xf34
 8007690:	f043 4340 	orr.w	r3, r3, #3221225472	@ 0xc0000000
 8007694:	f8c4 3f34 	str.w	r3, [r4, #3892]	@ 0xf34
	prvPortStartFirstTask();
 8007698:	f7ff fea6 	bl	80073e8 <prvPortStartFirstTask>
	vTaskSwitchContext();
 800769c:	f000 fc3c 	bl	8007f18 <vTaskSwitchContext>
	configASSERT( uxCriticalNesting == ~0UL );
 80076a0:	682b      	ldr	r3, [r5, #0]
volatile uint32_t ulDummy = 0;
 80076a2:	9603      	str	r6, [sp, #12]
	configASSERT( uxCriticalNesting == ~0UL );
 80076a4:	3301      	adds	r3, #1
 80076a6:	d008      	beq.n	80076ba <xPortStartScheduler+0x10a>
 80076a8:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80076ac:	f383 8811 	msr	BASEPRI, r3
 80076b0:	f3bf 8f6f 	isb	sy
 80076b4:	f3bf 8f4f 	dsb	sy
 80076b8:	e7fe      	b.n	80076b8 <xPortStartScheduler+0x108>
 80076ba:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80076be:	f383 8811 	msr	BASEPRI, r3
 80076c2:	f3bf 8f6f 	isb	sy
 80076c6:	f3bf 8f4f 	dsb	sy
	while( ulDummy == 0 )
 80076ca:	9b03      	ldr	r3, [sp, #12]
 80076cc:	2b00      	cmp	r3, #0
 80076ce:	d0fc      	beq.n	80076ca <xPortStartScheduler+0x11a>
}
 80076d0:	2000      	movs	r0, #0
 80076d2:	b004      	add	sp, #16
 80076d4:	bd70      	pop	{r4, r5, r6, pc}
 80076d6:	bf00      	nop
 80076d8:	410fc271 	.word	0x410fc271
 80076dc:	410fc270 	.word	0x410fc270
 80076e0:	e000e400 	.word	0xe000e400
 80076e4:	20002664 	.word	0x20002664
 80076e8:	20002660 	.word	0x20002660
 80076ec:	20000564 	.word	0x20000564

080076f0 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 80076f0:	b580      	push	{r7, lr}
 80076f2:	4d16      	ldr	r5, [pc, #88]	@ (800774c <prvIdleTask+0x5c>)
 80076f4:	4f16      	ldr	r7, [pc, #88]	@ (8007750 <prvIdleTask+0x60>)
 80076f6:	4e17      	ldr	r6, [pc, #92]	@ (8007754 <prvIdleTask+0x64>)
 80076f8:	f8df 805c 	ldr.w	r8, [pc, #92]	@ 8007758 <prvIdleTask+0x68>
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
			{
				taskYIELD();
 80076fc:	f04f 2ae0 	mov.w	sl, #3758153728	@ 0xe000e000
 8007700:	f04f 5980 	mov.w	r9, #268435456	@ 0x10000000
 8007704:	e014      	b.n	8007730 <prvIdleTask+0x40>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
 8007706:	f7ff fed5 	bl	80074b4 <vPortEnterCritical>
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800770a:	68fb      	ldr	r3, [r7, #12]
 800770c:	68dc      	ldr	r4, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800770e:	1d20      	adds	r0, r4, #4
 8007710:	f7ff fe56 	bl	80073c0 <uxListRemove>
				--uxCurrentNumberOfTasks;
 8007714:	6833      	ldr	r3, [r6, #0]
 8007716:	3b01      	subs	r3, #1
 8007718:	6033      	str	r3, [r6, #0]
				--uxDeletedTasksWaitingCleanUp;
 800771a:	682b      	ldr	r3, [r5, #0]
 800771c:	3b01      	subs	r3, #1
 800771e:	602b      	str	r3, [r5, #0]
			}
			taskEXIT_CRITICAL();
 8007720:	f7ff feea 	bl	80074f8 <vPortExitCritical>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
 8007724:	6b20      	ldr	r0, [r4, #48]	@ 0x30
 8007726:	f7ff fdb1 	bl	800728c <vPortFree>
			vPortFree( pxTCB );
 800772a:	4620      	mov	r0, r4
 800772c:	f7ff fdae 	bl	800728c <vPortFree>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8007730:	682b      	ldr	r3, [r5, #0]
 8007732:	2b00      	cmp	r3, #0
 8007734:	d1e7      	bne.n	8007706 <prvIdleTask+0x16>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8007736:	f8d8 3000 	ldr.w	r3, [r8]
 800773a:	2b01      	cmp	r3, #1
 800773c:	d9f8      	bls.n	8007730 <prvIdleTask+0x40>
				taskYIELD();
 800773e:	f8ca 9d04 	str.w	r9, [sl, #3332]	@ 0xd04
 8007742:	f3bf 8f4f 	dsb	sy
 8007746:	f3bf 8f6f 	isb	sy
 800774a:	e7f1      	b.n	8007730 <prvIdleTask+0x40>
 800774c:	200026a8 	.word	0x200026a8
 8007750:	200026ac 	.word	0x200026ac
 8007754:	20002690 	.word	0x20002690
 8007758:	20002704 	.word	0x20002704

0800775c <prvAddCurrentTaskToDelayedList>:

#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 800775c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 800775e:	4b1b      	ldr	r3, [pc, #108]	@ (80077cc <prvAddCurrentTaskToDelayedList+0x70>)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8007760:	4e1b      	ldr	r6, [pc, #108]	@ (80077d0 <prvAddCurrentTaskToDelayedList+0x74>)
const TickType_t xConstTickCount = xTickCount;
 8007762:	681c      	ldr	r4, [r3, #0]
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8007764:	6833      	ldr	r3, [r6, #0]
{
 8007766:	4605      	mov	r5, r0
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8007768:	1d18      	adds	r0, r3, #4
{
 800776a:	460f      	mov	r7, r1
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800776c:	f7ff fe28 	bl	80073c0 <uxListRemove>
 8007770:	b940      	cbnz	r0, 8007784 <prvAddCurrentTaskToDelayedList+0x28>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
 8007772:	6833      	ldr	r3, [r6, #0]
 8007774:	4917      	ldr	r1, [pc, #92]	@ (80077d4 <prvAddCurrentTaskToDelayedList+0x78>)
 8007776:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8007778:	2201      	movs	r2, #1
 800777a:	409a      	lsls	r2, r3
 800777c:	680b      	ldr	r3, [r1, #0]
 800777e:	ea23 0302 	bic.w	r3, r3, r2
 8007782:	600b      	str	r3, [r1, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8007784:	1c6b      	adds	r3, r5, #1
 8007786:	d017      	beq.n	80077b8 <prvAddCurrentTaskToDelayedList+0x5c>
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8007788:	6833      	ldr	r3, [r6, #0]
 800778a:	1964      	adds	r4, r4, r5
 800778c:	605c      	str	r4, [r3, #4]

			if( xTimeToWake < xConstTickCount )
 800778e:	d307      	bcc.n	80077a0 <prvAddCurrentTaskToDelayedList+0x44>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8007790:	4b11      	ldr	r3, [pc, #68]	@ (80077d8 <prvAddCurrentTaskToDelayedList+0x7c>)
 8007792:	6818      	ldr	r0, [r3, #0]
 8007794:	6831      	ldr	r1, [r6, #0]

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8007796:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800779a:	3104      	adds	r1, #4
 800779c:	f7ff bdf8 	b.w	8007390 <vListInsert>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80077a0:	4b0e      	ldr	r3, [pc, #56]	@ (80077dc <prvAddCurrentTaskToDelayedList+0x80>)
 80077a2:	6818      	ldr	r0, [r3, #0]
 80077a4:	6831      	ldr	r1, [r6, #0]
 80077a6:	3104      	adds	r1, #4
 80077a8:	f7ff fdf2 	bl	8007390 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 80077ac:	4b0c      	ldr	r3, [pc, #48]	@ (80077e0 <prvAddCurrentTaskToDelayedList+0x84>)
 80077ae:	681a      	ldr	r2, [r3, #0]
 80077b0:	42a2      	cmp	r2, r4
					xNextTaskUnblockTime = xTimeToWake;
 80077b2:	bf88      	it	hi
 80077b4:	601c      	strhi	r4, [r3, #0]
}
 80077b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 80077b8:	2f00      	cmp	r7, #0
 80077ba:	d0e5      	beq.n	8007788 <prvAddCurrentTaskToDelayedList+0x2c>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80077bc:	6831      	ldr	r1, [r6, #0]
 80077be:	4809      	ldr	r0, [pc, #36]	@ (80077e4 <prvAddCurrentTaskToDelayedList+0x88>)
}
 80077c0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80077c4:	3104      	adds	r1, #4
 80077c6:	f7ff bdd5 	b.w	8007374 <vListInsertEnd>
 80077ca:	bf00      	nop
 80077cc:	2000268c 	.word	0x2000268c
 80077d0:	20002790 	.word	0x20002790
 80077d4:	20002688 	.word	0x20002688
 80077d8:	200026d4 	.word	0x200026d4
 80077dc:	200026d8 	.word	0x200026d8
 80077e0:	20002670 	.word	0x20002670
 80077e4:	20002694 	.word	0x20002694

080077e8 <xTaskIncrementTick.part.0>:
BaseType_t xTaskIncrementTick( void )
 80077e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 80077ec:	4b48      	ldr	r3, [pc, #288]	@ (8007910 <xTaskIncrementTick.part.0+0x128>)
 80077ee:	681d      	ldr	r5, [r3, #0]
 80077f0:	3501      	adds	r5, #1
BaseType_t xTaskIncrementTick( void )
 80077f2:	b083      	sub	sp, #12
		xTickCount = xConstTickCount;
 80077f4:	601d      	str	r5, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 80077f6:	2d00      	cmp	r5, #0
 80077f8:	d041      	beq.n	800787e <xTaskIncrementTick.part.0+0x96>
 80077fa:	4b46      	ldr	r3, [pc, #280]	@ (8007914 <xTaskIncrementTick.part.0+0x12c>)
 80077fc:	9301      	str	r3, [sp, #4]
		if( xConstTickCount >= xNextTaskUnblockTime )
 80077fe:	681b      	ldr	r3, [r3, #0]
 8007800:	429d      	cmp	r5, r3
 8007802:	d349      	bcc.n	8007898 <xTaskIncrementTick.part.0+0xb0>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8007804:	4e44      	ldr	r6, [pc, #272]	@ (8007918 <xTaskIncrementTick.part.0+0x130>)
 8007806:	f8df 8124 	ldr.w	r8, [pc, #292]	@ 800792c <xTaskIncrementTick.part.0+0x144>
 800780a:	6833      	ldr	r3, [r6, #0]
 800780c:	f8df 9120 	ldr.w	r9, [pc, #288]	@ 8007930 <xTaskIncrementTick.part.0+0x148>
 8007810:	681c      	ldr	r4, [r3, #0]
 8007812:	2c00      	cmp	r4, #0
 8007814:	d076      	beq.n	8007904 <xTaskIncrementTick.part.0+0x11c>
					prvAddTaskToReadyList( pxTCB );
 8007816:	4f41      	ldr	r7, [pc, #260]	@ (800791c <xTaskIncrementTick.part.0+0x134>)
BaseType_t xSwitchRequired = pdFALSE;
 8007818:	2400      	movs	r4, #0
 800781a:	e022      	b.n	8007862 <xTaskIncrementTick.part.0+0x7a>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800781c:	f7ff fdd0 	bl	80073c0 <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8007820:	f8db 2028 	ldr.w	r2, [fp, #40]	@ 0x28
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8007824:	f10b 0018 	add.w	r0, fp, #24
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8007828:	b10a      	cbz	r2, 800782e <xTaskIncrementTick.part.0+0x46>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800782a:	f7ff fdc9 	bl	80073c0 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800782e:	f8db 002c 	ldr.w	r0, [fp, #44]	@ 0x2c
 8007832:	683b      	ldr	r3, [r7, #0]
 8007834:	2201      	movs	r2, #1
 8007836:	4082      	lsls	r2, r0
 8007838:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800783c:	431a      	orrs	r2, r3
 800783e:	4651      	mov	r1, sl
 8007840:	eb08 0080 	add.w	r0, r8, r0, lsl #2
 8007844:	603a      	str	r2, [r7, #0]
 8007846:	f7ff fd95 	bl	8007374 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800784a:	f8d9 2000 	ldr.w	r2, [r9]
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800784e:	6830      	ldr	r0, [r6, #0]
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8007850:	f8db 102c 	ldr.w	r1, [fp, #44]	@ 0x2c
 8007854:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8007856:	6803      	ldr	r3, [r0, #0]
							xSwitchRequired = pdTRUE;
 8007858:	4291      	cmp	r1, r2
 800785a:	bf28      	it	cs
 800785c:	2401      	movcs	r4, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800785e:	2b00      	cmp	r3, #0
 8007860:	d050      	beq.n	8007904 <xTaskIncrementTick.part.0+0x11c>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8007862:	6833      	ldr	r3, [r6, #0]
 8007864:	68db      	ldr	r3, [r3, #12]
 8007866:	f8d3 b00c 	ldr.w	fp, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 800786a:	f8db 2004 	ldr.w	r2, [fp, #4]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800786e:	f10b 0a04 	add.w	sl, fp, #4
					if( xConstTickCount < xItemValue )
 8007872:	4295      	cmp	r5, r2
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8007874:	4650      	mov	r0, sl
					if( xConstTickCount < xItemValue )
 8007876:	d2d1      	bcs.n	800781c <xTaskIncrementTick.part.0+0x34>
						xNextTaskUnblockTime = xItemValue;
 8007878:	9b01      	ldr	r3, [sp, #4]
 800787a:	601a      	str	r2, [r3, #0]
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
 800787c:	e011      	b.n	80078a2 <xTaskIncrementTick.part.0+0xba>
			taskSWITCH_DELAYED_LISTS();
 800787e:	4b26      	ldr	r3, [pc, #152]	@ (8007918 <xTaskIncrementTick.part.0+0x130>)
 8007880:	681a      	ldr	r2, [r3, #0]
 8007882:	6812      	ldr	r2, [r2, #0]
 8007884:	b30a      	cbz	r2, 80078ca <xTaskIncrementTick.part.0+0xe2>
 8007886:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800788a:	f383 8811 	msr	BASEPRI, r3
 800788e:	f3bf 8f6f 	isb	sy
 8007892:	f3bf 8f4f 	dsb	sy
 8007896:	e7fe      	b.n	8007896 <xTaskIncrementTick.part.0+0xae>
 8007898:	f8df 8090 	ldr.w	r8, [pc, #144]	@ 800792c <xTaskIncrementTick.part.0+0x144>
 800789c:	f8df 9090 	ldr.w	r9, [pc, #144]	@ 8007930 <xTaskIncrementTick.part.0+0x148>
BaseType_t xSwitchRequired = pdFALSE;
 80078a0:	2400      	movs	r4, #0
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 80078a2:	f8d9 3000 	ldr.w	r3, [r9]
			if( xYieldPending != pdFALSE )
 80078a6:	491e      	ldr	r1, [pc, #120]	@ (8007920 <xTaskIncrementTick.part.0+0x138>)
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 80078a8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80078aa:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80078ae:	009b      	lsls	r3, r3, #2
 80078b0:	f858 2003 	ldr.w	r2, [r8, r3]
			if( xYieldPending != pdFALSE )
 80078b4:	680b      	ldr	r3, [r1, #0]
				xSwitchRequired = pdTRUE;
 80078b6:	2a02      	cmp	r2, #2
 80078b8:	bf28      	it	cs
 80078ba:	2401      	movcs	r4, #1
				xSwitchRequired = pdTRUE;
 80078bc:	2b00      	cmp	r3, #0
}
 80078be:	bf0c      	ite	eq
 80078c0:	4620      	moveq	r0, r4
 80078c2:	2001      	movne	r0, #1
 80078c4:	b003      	add	sp, #12
 80078c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			taskSWITCH_DELAYED_LISTS();
 80078ca:	4a16      	ldr	r2, [pc, #88]	@ (8007924 <xTaskIncrementTick.part.0+0x13c>)
 80078cc:	6818      	ldr	r0, [r3, #0]
 80078ce:	6811      	ldr	r1, [r2, #0]
 80078d0:	6019      	str	r1, [r3, #0]
 80078d2:	4915      	ldr	r1, [pc, #84]	@ (8007928 <xTaskIncrementTick.part.0+0x140>)
 80078d4:	6010      	str	r0, [r2, #0]
 80078d6:	680a      	ldr	r2, [r1, #0]
 80078d8:	3201      	adds	r2, #1
 80078da:	600a      	str	r2, [r1, #0]
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80078dc:	681a      	ldr	r2, [r3, #0]
 80078de:	6812      	ldr	r2, [r2, #0]
 80078e0:	b93a      	cbnz	r2, 80078f2 <xTaskIncrementTick.part.0+0x10a>
		xNextTaskUnblockTime = portMAX_DELAY;
 80078e2:	4b0c      	ldr	r3, [pc, #48]	@ (8007914 <xTaskIncrementTick.part.0+0x12c>)
 80078e4:	9301      	str	r3, [sp, #4]
 80078e6:	461a      	mov	r2, r3
 80078e8:	f04f 33ff 	mov.w	r3, #4294967295
 80078ec:	6013      	str	r3, [r2, #0]
 80078ee:	4613      	mov	r3, r2
 80078f0:	e785      	b.n	80077fe <xTaskIncrementTick.part.0+0x16>
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80078f2:	681b      	ldr	r3, [r3, #0]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 80078f4:	4a07      	ldr	r2, [pc, #28]	@ (8007914 <xTaskIncrementTick.part.0+0x12c>)
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80078f6:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 80078f8:	9201      	str	r2, [sp, #4]
 80078fa:	68db      	ldr	r3, [r3, #12]
 80078fc:	685b      	ldr	r3, [r3, #4]
 80078fe:	6013      	str	r3, [r2, #0]
 8007900:	4613      	mov	r3, r2
}
 8007902:	e77c      	b.n	80077fe <xTaskIncrementTick.part.0+0x16>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8007904:	9a01      	ldr	r2, [sp, #4]
 8007906:	f04f 33ff 	mov.w	r3, #4294967295
 800790a:	6013      	str	r3, [r2, #0]
					break;
 800790c:	e7c9      	b.n	80078a2 <xTaskIncrementTick.part.0+0xba>
 800790e:	bf00      	nop
 8007910:	2000268c 	.word	0x2000268c
 8007914:	20002670 	.word	0x20002670
 8007918:	200026d8 	.word	0x200026d8
 800791c:	20002688 	.word	0x20002688
 8007920:	2000267c 	.word	0x2000267c
 8007924:	200026d4 	.word	0x200026d4
 8007928:	20002678 	.word	0x20002678
 800792c:	20002704 	.word	0x20002704
 8007930:	20002790 	.word	0x20002790

08007934 <xTaskResumeAll.part.0>:
BaseType_t xTaskResumeAll( void )
 8007934:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		--uxSchedulerSuspended;
 8007938:	4d48      	ldr	r5, [pc, #288]	@ (8007a5c <xTaskResumeAll.part.0+0x128>)
BaseType_t xTaskResumeAll( void )
 800793a:	b083      	sub	sp, #12
	taskENTER_CRITICAL();
 800793c:	f7ff fdba 	bl	80074b4 <vPortEnterCritical>
		--uxSchedulerSuspended;
 8007940:	682b      	ldr	r3, [r5, #0]
 8007942:	3b01      	subs	r3, #1
 8007944:	602b      	str	r3, [r5, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8007946:	682b      	ldr	r3, [r5, #0]
 8007948:	2b00      	cmp	r3, #0
 800794a:	d16e      	bne.n	8007a2a <xTaskResumeAll.part.0+0xf6>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 800794c:	4b44      	ldr	r3, [pc, #272]	@ (8007a60 <xTaskResumeAll.part.0+0x12c>)
 800794e:	681b      	ldr	r3, [r3, #0]
 8007950:	2b00      	cmp	r3, #0
 8007952:	d06a      	beq.n	8007a2a <xTaskResumeAll.part.0+0xf6>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8007954:	f8df a120 	ldr.w	sl, [pc, #288]	@ 8007a78 <xTaskResumeAll.part.0+0x144>
 8007958:	f8da 2000 	ldr.w	r2, [sl]
 800795c:	2a00      	cmp	r2, #0
 800795e:	d079      	beq.n	8007a54 <xTaskResumeAll.part.0+0x120>
 8007960:	4b40      	ldr	r3, [pc, #256]	@ (8007a64 <xTaskResumeAll.part.0+0x130>)
 8007962:	4e41      	ldr	r6, [pc, #260]	@ (8007a68 <xTaskResumeAll.part.0+0x134>)
 8007964:	f8df 9114 	ldr.w	r9, [pc, #276]	@ 8007a7c <xTaskResumeAll.part.0+0x148>
 8007968:	f8df 8114 	ldr.w	r8, [pc, #276]	@ 8007a80 <xTaskResumeAll.part.0+0x14c>
 800796c:	9301      	str	r3, [sp, #4]
					prvAddTaskToReadyList( pxTCB );
 800796e:	2701      	movs	r7, #1
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8007970:	f8da 200c 	ldr.w	r2, [sl, #12]
 8007974:	f8d2 b00c 	ldr.w	fp, [r2, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8007978:	f10b 0404 	add.w	r4, fp, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800797c:	f10b 0018 	add.w	r0, fp, #24
 8007980:	f7ff fd1e 	bl	80073c0 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8007984:	4620      	mov	r0, r4
 8007986:	f7ff fd1b 	bl	80073c0 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800798a:	f8db 002c 	ldr.w	r0, [fp, #44]	@ 0x2c
 800798e:	6831      	ldr	r1, [r6, #0]
 8007990:	fa07 f200 	lsl.w	r2, r7, r0
 8007994:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8007998:	430a      	orrs	r2, r1
 800799a:	eb09 0080 	add.w	r0, r9, r0, lsl #2
 800799e:	4621      	mov	r1, r4
 80079a0:	6032      	str	r2, [r6, #0]
 80079a2:	f7ff fce7 	bl	8007374 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 80079a6:	f8d8 2000 	ldr.w	r2, [r8]
 80079aa:	f8db 102c 	ldr.w	r1, [fp, #44]	@ 0x2c
 80079ae:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 80079b0:	4291      	cmp	r1, r2
 80079b2:	d341      	bcc.n	8007a38 <xTaskResumeAll.part.0+0x104>
						xYieldPending = pdTRUE;
 80079b4:	9b01      	ldr	r3, [sp, #4]
 80079b6:	601f      	str	r7, [r3, #0]
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 80079b8:	f8da 2000 	ldr.w	r2, [sl]
 80079bc:	2a00      	cmp	r2, #0
 80079be:	d1d7      	bne.n	8007970 <xTaskResumeAll.part.0+0x3c>
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80079c0:	4b2a      	ldr	r3, [pc, #168]	@ (8007a6c <xTaskResumeAll.part.0+0x138>)
 80079c2:	681a      	ldr	r2, [r3, #0]
 80079c4:	6812      	ldr	r2, [r2, #0]
 80079c6:	2a00      	cmp	r2, #0
 80079c8:	d03f      	beq.n	8007a4a <xTaskResumeAll.part.0+0x116>
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80079ca:	681a      	ldr	r2, [r3, #0]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 80079cc:	4b28      	ldr	r3, [pc, #160]	@ (8007a70 <xTaskResumeAll.part.0+0x13c>)
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80079ce:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 80079d0:	68d2      	ldr	r2, [r2, #12]
 80079d2:	6852      	ldr	r2, [r2, #4]
 80079d4:	601a      	str	r2, [r3, #0]
					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 80079d6:	4e27      	ldr	r6, [pc, #156]	@ (8007a74 <xTaskResumeAll.part.0+0x140>)
 80079d8:	6834      	ldr	r4, [r6, #0]
					if( xPendedCounts > ( TickType_t ) 0U )
 80079da:	b194      	cbz	r4, 8007a02 <xTaskResumeAll.part.0+0xce>
								xYieldPending = pdTRUE;
 80079dc:	2701      	movs	r7, #1
 80079de:	e006      	b.n	80079ee <xTaskResumeAll.part.0+0xba>
 80079e0:	f7ff ff02 	bl	80077e8 <xTaskIncrementTick.part.0>
							if( xTaskIncrementTick() != pdFALSE )
 80079e4:	b108      	cbz	r0, 80079ea <xTaskResumeAll.part.0+0xb6>
								xYieldPending = pdTRUE;
 80079e6:	9b01      	ldr	r3, [sp, #4]
 80079e8:	601f      	str	r7, [r3, #0]
						} while( xPendedCounts > ( TickType_t ) 0U );
 80079ea:	3c01      	subs	r4, #1
 80079ec:	d008      	beq.n	8007a00 <xTaskResumeAll.part.0+0xcc>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80079ee:	682b      	ldr	r3, [r5, #0]
 80079f0:	2b00      	cmp	r3, #0
 80079f2:	d0f5      	beq.n	80079e0 <xTaskResumeAll.part.0+0xac>
		++xPendedTicks;
 80079f4:	6833      	ldr	r3, [r6, #0]
						} while( xPendedCounts > ( TickType_t ) 0U );
 80079f6:	3c01      	subs	r4, #1
		++xPendedTicks;
 80079f8:	f103 0301 	add.w	r3, r3, #1
 80079fc:	6033      	str	r3, [r6, #0]
						} while( xPendedCounts > ( TickType_t ) 0U );
 80079fe:	d1f6      	bne.n	80079ee <xTaskResumeAll.part.0+0xba>
						xPendedTicks = 0;
 8007a00:	6034      	str	r4, [r6, #0]
				if( xYieldPending != pdFALSE )
 8007a02:	9b01      	ldr	r3, [sp, #4]
 8007a04:	681b      	ldr	r3, [r3, #0]
 8007a06:	b183      	cbz	r3, 8007a2a <xTaskResumeAll.part.0+0xf6>
					taskYIELD_IF_USING_PREEMPTION();
 8007a08:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8007a0c:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8007a10:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8007a14:	f3bf 8f4f 	dsb	sy
 8007a18:	f3bf 8f6f 	isb	sy
	taskEXIT_CRITICAL();
 8007a1c:	f7ff fd6c 	bl	80074f8 <vPortExitCritical>
						xAlreadyYielded = pdTRUE;
 8007a20:	2401      	movs	r4, #1
}
 8007a22:	4620      	mov	r0, r4
 8007a24:	b003      	add	sp, #12
 8007a26:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	taskEXIT_CRITICAL();
 8007a2a:	f7ff fd65 	bl	80074f8 <vPortExitCritical>
BaseType_t xAlreadyYielded = pdFALSE;
 8007a2e:	2400      	movs	r4, #0
}
 8007a30:	4620      	mov	r0, r4
 8007a32:	b003      	add	sp, #12
 8007a34:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8007a38:	f8da 2000 	ldr.w	r2, [sl]
 8007a3c:	2a00      	cmp	r2, #0
 8007a3e:	d197      	bne.n	8007970 <xTaskResumeAll.part.0+0x3c>
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8007a40:	4b0a      	ldr	r3, [pc, #40]	@ (8007a6c <xTaskResumeAll.part.0+0x138>)
 8007a42:	681a      	ldr	r2, [r3, #0]
 8007a44:	6812      	ldr	r2, [r2, #0]
 8007a46:	2a00      	cmp	r2, #0
 8007a48:	d1bf      	bne.n	80079ca <xTaskResumeAll.part.0+0x96>
		xNextTaskUnblockTime = portMAX_DELAY;
 8007a4a:	4b09      	ldr	r3, [pc, #36]	@ (8007a70 <xTaskResumeAll.part.0+0x13c>)
 8007a4c:	f04f 32ff 	mov.w	r2, #4294967295
 8007a50:	601a      	str	r2, [r3, #0]
 8007a52:	e7c0      	b.n	80079d6 <xTaskResumeAll.part.0+0xa2>
 8007a54:	4b03      	ldr	r3, [pc, #12]	@ (8007a64 <xTaskResumeAll.part.0+0x130>)
 8007a56:	9301      	str	r3, [sp, #4]
 8007a58:	e7bd      	b.n	80079d6 <xTaskResumeAll.part.0+0xa2>
 8007a5a:	bf00      	nop
 8007a5c:	20002668 	.word	0x20002668
 8007a60:	20002690 	.word	0x20002690
 8007a64:	2000267c 	.word	0x2000267c
 8007a68:	20002688 	.word	0x20002688
 8007a6c:	200026d8 	.word	0x200026d8
 8007a70:	20002670 	.word	0x20002670
 8007a74:	20002680 	.word	0x20002680
 8007a78:	200026c0 	.word	0x200026c0
 8007a7c:	20002704 	.word	0x20002704
 8007a80:	20002790 	.word	0x20002790

08007a84 <xTaskCreate>:
	{
 8007a84:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 8007a88:	0095      	lsls	r5, r2, #2
	{
 8007a8a:	4680      	mov	r8, r0
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 8007a8c:	4628      	mov	r0, r5
	{
 8007a8e:	460e      	mov	r6, r1
 8007a90:	4699      	mov	r9, r3
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 8007a92:	f7ff fb43 	bl	800711c <pvPortMalloc>
			if( pxStack != NULL )
 8007a96:	2800      	cmp	r0, #0
 8007a98:	f000 80ac 	beq.w	8007bf4 <xTaskCreate+0x170>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 8007a9c:	4607      	mov	r7, r0
 8007a9e:	2054      	movs	r0, #84	@ 0x54
 8007aa0:	f7ff fb3c 	bl	800711c <pvPortMalloc>
				if( pxNewTCB != NULL )
 8007aa4:	4604      	mov	r4, r0
 8007aa6:	2800      	cmp	r0, #0
 8007aa8:	f000 80a1 	beq.w	8007bee <xTaskCreate+0x16a>
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 8007aac:	3d04      	subs	r5, #4
 8007aae:	443d      	add	r5, r7
					pxNewTCB->pxStack = pxStack;
 8007ab0:	6307      	str	r7, [r0, #48]	@ 0x30
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 8007ab2:	f025 0507 	bic.w	r5, r5, #7
	if( pcName != NULL )
 8007ab6:	2e00      	cmp	r6, #0
 8007ab8:	f000 80af 	beq.w	8007c1a <xTaskCreate+0x196>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007abc:	7833      	ldrb	r3, [r6, #0]
 8007abe:	f880 3034 	strb.w	r3, [r0, #52]	@ 0x34
			if( pcName[ x ] == ( char ) 0x00 )
 8007ac2:	2b00      	cmp	r3, #0
 8007ac4:	d036      	beq.n	8007b34 <xTaskCreate+0xb0>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007ac6:	7873      	ldrb	r3, [r6, #1]
 8007ac8:	f880 3035 	strb.w	r3, [r0, #53]	@ 0x35
			if( pcName[ x ] == ( char ) 0x00 )
 8007acc:	b393      	cbz	r3, 8007b34 <xTaskCreate+0xb0>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007ace:	78b3      	ldrb	r3, [r6, #2]
 8007ad0:	f880 3036 	strb.w	r3, [r0, #54]	@ 0x36
			if( pcName[ x ] == ( char ) 0x00 )
 8007ad4:	b373      	cbz	r3, 8007b34 <xTaskCreate+0xb0>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007ad6:	78f3      	ldrb	r3, [r6, #3]
 8007ad8:	f880 3037 	strb.w	r3, [r0, #55]	@ 0x37
			if( pcName[ x ] == ( char ) 0x00 )
 8007adc:	b353      	cbz	r3, 8007b34 <xTaskCreate+0xb0>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007ade:	7933      	ldrb	r3, [r6, #4]
 8007ae0:	f880 3038 	strb.w	r3, [r0, #56]	@ 0x38
			if( pcName[ x ] == ( char ) 0x00 )
 8007ae4:	b333      	cbz	r3, 8007b34 <xTaskCreate+0xb0>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007ae6:	7973      	ldrb	r3, [r6, #5]
 8007ae8:	f880 3039 	strb.w	r3, [r0, #57]	@ 0x39
			if( pcName[ x ] == ( char ) 0x00 )
 8007aec:	b313      	cbz	r3, 8007b34 <xTaskCreate+0xb0>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007aee:	79b3      	ldrb	r3, [r6, #6]
 8007af0:	f880 303a 	strb.w	r3, [r0, #58]	@ 0x3a
			if( pcName[ x ] == ( char ) 0x00 )
 8007af4:	b1f3      	cbz	r3, 8007b34 <xTaskCreate+0xb0>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007af6:	79f3      	ldrb	r3, [r6, #7]
 8007af8:	f880 303b 	strb.w	r3, [r0, #59]	@ 0x3b
			if( pcName[ x ] == ( char ) 0x00 )
 8007afc:	b1d3      	cbz	r3, 8007b34 <xTaskCreate+0xb0>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007afe:	7a33      	ldrb	r3, [r6, #8]
 8007b00:	f880 303c 	strb.w	r3, [r0, #60]	@ 0x3c
			if( pcName[ x ] == ( char ) 0x00 )
 8007b04:	b1b3      	cbz	r3, 8007b34 <xTaskCreate+0xb0>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007b06:	7a73      	ldrb	r3, [r6, #9]
 8007b08:	f880 303d 	strb.w	r3, [r0, #61]	@ 0x3d
			if( pcName[ x ] == ( char ) 0x00 )
 8007b0c:	b193      	cbz	r3, 8007b34 <xTaskCreate+0xb0>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007b0e:	7ab3      	ldrb	r3, [r6, #10]
 8007b10:	f880 303e 	strb.w	r3, [r0, #62]	@ 0x3e
			if( pcName[ x ] == ( char ) 0x00 )
 8007b14:	b173      	cbz	r3, 8007b34 <xTaskCreate+0xb0>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007b16:	7af3      	ldrb	r3, [r6, #11]
 8007b18:	f880 303f 	strb.w	r3, [r0, #63]	@ 0x3f
			if( pcName[ x ] == ( char ) 0x00 )
 8007b1c:	b153      	cbz	r3, 8007b34 <xTaskCreate+0xb0>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007b1e:	7b33      	ldrb	r3, [r6, #12]
 8007b20:	f880 3040 	strb.w	r3, [r0, #64]	@ 0x40
			if( pcName[ x ] == ( char ) 0x00 )
 8007b24:	b133      	cbz	r3, 8007b34 <xTaskCreate+0xb0>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007b26:	7b73      	ldrb	r3, [r6, #13]
 8007b28:	f880 3041 	strb.w	r3, [r0, #65]	@ 0x41
			if( pcName[ x ] == ( char ) 0x00 )
 8007b2c:	b113      	cbz	r3, 8007b34 <xTaskCreate+0xb0>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007b2e:	7bb3      	ldrb	r3, [r6, #14]
 8007b30:	f880 3042 	strb.w	r3, [r0, #66]	@ 0x42
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8007b34:	2300      	movs	r3, #0
 8007b36:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 8007b3a:	9e08      	ldr	r6, [sp, #32]
 8007b3c:	2e06      	cmp	r6, #6
 8007b3e:	bf28      	it	cs
 8007b40:	2606      	movcs	r6, #6
		pxNewTCB->uxMutexesHeld = 0;
 8007b42:	f04f 0a00 	mov.w	sl, #0
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8007b46:	1d27      	adds	r7, r4, #4
	pxNewTCB->uxPriority = uxPriority;
 8007b48:	62e6      	str	r6, [r4, #44]	@ 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
 8007b4a:	6466      	str	r6, [r4, #68]	@ 0x44
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8007b4c:	4638      	mov	r0, r7
		pxNewTCB->uxMutexesHeld = 0;
 8007b4e:	f8c4 a048 	str.w	sl, [r4, #72]	@ 0x48
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8007b52:	f7ff fc0b 	bl	800736c <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8007b56:	f1c6 0607 	rsb	r6, r6, #7
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 8007b5a:	f104 0018 	add.w	r0, r4, #24
 8007b5e:	f7ff fc05 	bl	800736c <vListInitialiseItem>
		pxNewTCB->ulNotifiedValue = 0;
 8007b62:	f8c4 a04c 	str.w	sl, [r4, #76]	@ 0x4c
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8007b66:	61a6      	str	r6, [r4, #24]
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8007b68:	f884 a050 	strb.w	sl, [r4, #80]	@ 0x50
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8007b6c:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 8007b6e:	6264      	str	r4, [r4, #36]	@ 0x24
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8007b70:	464a      	mov	r2, r9
 8007b72:	4641      	mov	r1, r8
 8007b74:	4628      	mov	r0, r5
 8007b76:	f7ff fc75 	bl	8007464 <pxPortInitialiseStack>
	if( pxCreatedTask != NULL )
 8007b7a:	9b09      	ldr	r3, [sp, #36]	@ 0x24
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8007b7c:	6020      	str	r0, [r4, #0]
	if( pxCreatedTask != NULL )
 8007b7e:	b103      	cbz	r3, 8007b82 <xTaskCreate+0xfe>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8007b80:	601c      	str	r4, [r3, #0]
	taskENTER_CRITICAL();
 8007b82:	f7ff fc97 	bl	80074b4 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 8007b86:	4a39      	ldr	r2, [pc, #228]	@ (8007c6c <xTaskCreate+0x1e8>)
		if( pxCurrentTCB == NULL )
 8007b88:	4d39      	ldr	r5, [pc, #228]	@ (8007c70 <xTaskCreate+0x1ec>)
		uxCurrentNumberOfTasks++;
 8007b8a:	6813      	ldr	r3, [r2, #0]
 8007b8c:	3301      	adds	r3, #1
 8007b8e:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
 8007b90:	682b      	ldr	r3, [r5, #0]
 8007b92:	2b00      	cmp	r3, #0
 8007b94:	d038      	beq.n	8007c08 <xTaskCreate+0x184>
			if( xSchedulerRunning == pdFALSE )
 8007b96:	4e37      	ldr	r6, [pc, #220]	@ (8007c74 <xTaskCreate+0x1f0>)
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8007b98:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
			if( xSchedulerRunning == pdFALSE )
 8007b9a:	6833      	ldr	r3, [r6, #0]
 8007b9c:	b373      	cbz	r3, 8007bfc <xTaskCreate+0x178>
 8007b9e:	f8df 80f8 	ldr.w	r8, [pc, #248]	@ 8007c98 <xTaskCreate+0x214>
		prvAddTaskToReadyList( pxNewTCB );
 8007ba2:	4a35      	ldr	r2, [pc, #212]	@ (8007c78 <xTaskCreate+0x1f4>)
 8007ba4:	4639      	mov	r1, r7
		uxTaskNumber++;
 8007ba6:	4f35      	ldr	r7, [pc, #212]	@ (8007c7c <xTaskCreate+0x1f8>)
 8007ba8:	683b      	ldr	r3, [r7, #0]
 8007baa:	3301      	adds	r3, #1
 8007bac:	603b      	str	r3, [r7, #0]
		prvAddTaskToReadyList( pxNewTCB );
 8007bae:	6817      	ldr	r7, [r2, #0]
 8007bb0:	2301      	movs	r3, #1
 8007bb2:	4083      	lsls	r3, r0
 8007bb4:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8007bb8:	433b      	orrs	r3, r7
 8007bba:	eb08 0080 	add.w	r0, r8, r0, lsl #2
 8007bbe:	6013      	str	r3, [r2, #0]
 8007bc0:	f7ff fbd8 	bl	8007374 <vListInsertEnd>
	taskEXIT_CRITICAL();
 8007bc4:	f7ff fc98 	bl	80074f8 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 8007bc8:	6833      	ldr	r3, [r6, #0]
 8007bca:	b173      	cbz	r3, 8007bea <xTaskCreate+0x166>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 8007bcc:	682a      	ldr	r2, [r5, #0]
 8007bce:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 8007bd0:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 8007bd2:	429a      	cmp	r2, r3
 8007bd4:	d209      	bcs.n	8007bea <xTaskCreate+0x166>
			taskYIELD_IF_USING_PREEMPTION();
 8007bd6:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8007bda:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8007bde:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8007be2:	f3bf 8f4f 	dsb	sy
 8007be6:	f3bf 8f6f 	isb	sy
			xReturn = pdPASS;
 8007bea:	2001      	movs	r0, #1
		return xReturn;
 8007bec:	e004      	b.n	8007bf8 <xTaskCreate+0x174>
					vPortFree( pxStack );
 8007bee:	4638      	mov	r0, r7
 8007bf0:	f7ff fb4c 	bl	800728c <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8007bf4:	f04f 30ff 	mov.w	r0, #4294967295
	}
 8007bf8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8007bfc:	682b      	ldr	r3, [r5, #0]
 8007bfe:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8007c00:	4283      	cmp	r3, r0
					pxCurrentTCB = pxNewTCB;
 8007c02:	bf98      	it	ls
 8007c04:	602c      	strls	r4, [r5, #0]
 8007c06:	e7ca      	b.n	8007b9e <xTaskCreate+0x11a>
			pxCurrentTCB = pxNewTCB;
 8007c08:	602c      	str	r4, [r5, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8007c0a:	6813      	ldr	r3, [r2, #0]
 8007c0c:	2b01      	cmp	r3, #1
 8007c0e:	d007      	beq.n	8007c20 <xTaskCreate+0x19c>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8007c10:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
 8007c12:	f8df 8084 	ldr.w	r8, [pc, #132]	@ 8007c98 <xTaskCreate+0x214>
 8007c16:	4e17      	ldr	r6, [pc, #92]	@ (8007c74 <xTaskCreate+0x1f0>)
 8007c18:	e7c3      	b.n	8007ba2 <xTaskCreate+0x11e>
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
 8007c1a:	f880 6034 	strb.w	r6, [r0, #52]	@ 0x34
 8007c1e:	e78c      	b.n	8007b3a <xTaskCreate+0xb6>
 8007c20:	f8df 8074 	ldr.w	r8, [pc, #116]	@ 8007c98 <xTaskCreate+0x214>
 8007c24:	4646      	mov	r6, r8
 8007c26:	f108 098c 	add.w	r9, r8, #140	@ 0x8c
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8007c2a:	4630      	mov	r0, r6
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8007c2c:	3614      	adds	r6, #20
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8007c2e:	f7ff fb91 	bl	8007354 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8007c32:	454e      	cmp	r6, r9
 8007c34:	d1f9      	bne.n	8007c2a <xTaskCreate+0x1a6>
	vListInitialise( &xDelayedTaskList1 );
 8007c36:	f8df 9064 	ldr.w	r9, [pc, #100]	@ 8007c9c <xTaskCreate+0x218>
	vListInitialise( &xDelayedTaskList2 );
 8007c3a:	4e11      	ldr	r6, [pc, #68]	@ (8007c80 <xTaskCreate+0x1fc>)
	vListInitialise( &xDelayedTaskList1 );
 8007c3c:	4648      	mov	r0, r9
 8007c3e:	f7ff fb89 	bl	8007354 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8007c42:	4630      	mov	r0, r6
 8007c44:	f7ff fb86 	bl	8007354 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8007c48:	480e      	ldr	r0, [pc, #56]	@ (8007c84 <xTaskCreate+0x200>)
 8007c4a:	f7ff fb83 	bl	8007354 <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 8007c4e:	480e      	ldr	r0, [pc, #56]	@ (8007c88 <xTaskCreate+0x204>)
 8007c50:	f7ff fb80 	bl	8007354 <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 8007c54:	480d      	ldr	r0, [pc, #52]	@ (8007c8c <xTaskCreate+0x208>)
 8007c56:	f7ff fb7d 	bl	8007354 <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
 8007c5a:	4b0d      	ldr	r3, [pc, #52]	@ (8007c90 <xTaskCreate+0x20c>)
		prvAddTaskToReadyList( pxNewTCB );
 8007c5c:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
	pxDelayedTaskList = &xDelayedTaskList1;
 8007c5e:	f8c3 9000 	str.w	r9, [r3]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8007c62:	4b0c      	ldr	r3, [pc, #48]	@ (8007c94 <xTaskCreate+0x210>)
 8007c64:	601e      	str	r6, [r3, #0]
 8007c66:	4e03      	ldr	r6, [pc, #12]	@ (8007c74 <xTaskCreate+0x1f0>)
}
 8007c68:	e79b      	b.n	8007ba2 <xTaskCreate+0x11e>
 8007c6a:	bf00      	nop
 8007c6c:	20002690 	.word	0x20002690
 8007c70:	20002790 	.word	0x20002790
 8007c74:	20002684 	.word	0x20002684
 8007c78:	20002688 	.word	0x20002688
 8007c7c:	20002674 	.word	0x20002674
 8007c80:	200026dc 	.word	0x200026dc
 8007c84:	200026c0 	.word	0x200026c0
 8007c88:	200026ac 	.word	0x200026ac
 8007c8c:	20002694 	.word	0x20002694
 8007c90:	200026d8 	.word	0x200026d8
 8007c94:	200026d4 	.word	0x200026d4
 8007c98:	20002704 	.word	0x20002704
 8007c9c:	200026f0 	.word	0x200026f0

08007ca0 <vTaskDelay>:
	{
 8007ca0:	b510      	push	{r4, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
 8007ca2:	b950      	cbnz	r0, 8007cba <vTaskDelay+0x1a>
			portYIELD_WITHIN_API();
 8007ca4:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8007ca8:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8007cac:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8007cb0:	f3bf 8f4f 	dsb	sy
 8007cb4:	f3bf 8f6f 	isb	sy
	}
 8007cb8:	bd10      	pop	{r4, pc}
			configASSERT( uxSchedulerSuspended == 0 );
 8007cba:	4c10      	ldr	r4, [pc, #64]	@ (8007cfc <vTaskDelay+0x5c>)
 8007cbc:	6821      	ldr	r1, [r4, #0]
 8007cbe:	b141      	cbz	r1, 8007cd2 <vTaskDelay+0x32>
 8007cc0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007cc4:	f383 8811 	msr	BASEPRI, r3
 8007cc8:	f3bf 8f6f 	isb	sy
 8007ccc:	f3bf 8f4f 	dsb	sy
 8007cd0:	e7fe      	b.n	8007cd0 <vTaskDelay+0x30>
	++uxSchedulerSuspended;
 8007cd2:	6823      	ldr	r3, [r4, #0]
 8007cd4:	3301      	adds	r3, #1
 8007cd6:	6023      	str	r3, [r4, #0]
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 8007cd8:	f7ff fd40 	bl	800775c <prvAddCurrentTaskToDelayedList>
	configASSERT( uxSchedulerSuspended );
 8007cdc:	6823      	ldr	r3, [r4, #0]
 8007cde:	b943      	cbnz	r3, 8007cf2 <vTaskDelay+0x52>
 8007ce0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007ce4:	f383 8811 	msr	BASEPRI, r3
 8007ce8:	f3bf 8f6f 	isb	sy
 8007cec:	f3bf 8f4f 	dsb	sy
 8007cf0:	e7fe      	b.n	8007cf0 <vTaskDelay+0x50>
 8007cf2:	f7ff fe1f 	bl	8007934 <xTaskResumeAll.part.0>
		if( xAlreadyYielded == pdFALSE )
 8007cf6:	2800      	cmp	r0, #0
 8007cf8:	d0d4      	beq.n	8007ca4 <vTaskDelay+0x4>
	}
 8007cfa:	bd10      	pop	{r4, pc}
 8007cfc:	20002668 	.word	0x20002668

08007d00 <vTaskStartScheduler>:
{
 8007d00:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 8007d04:	f44f 7000 	mov.w	r0, #512	@ 0x200
 8007d08:	f7ff fa08 	bl	800711c <pvPortMalloc>
			if( pxStack != NULL )
 8007d0c:	2800      	cmp	r0, #0
 8007d0e:	d079      	beq.n	8007e04 <vTaskStartScheduler+0x104>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 8007d10:	4605      	mov	r5, r0
 8007d12:	2054      	movs	r0, #84	@ 0x54
 8007d14:	f7ff fa02 	bl	800711c <pvPortMalloc>
				if( pxNewTCB != NULL )
 8007d18:	4604      	mov	r4, r0
 8007d1a:	2800      	cmp	r0, #0
 8007d1c:	d06f      	beq.n	8007dfe <vTaskStartScheduler+0xfe>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007d1e:	2600      	movs	r6, #0
 8007d20:	4b57      	ldr	r3, [pc, #348]	@ (8007e80 <vTaskStartScheduler+0x180>)
 8007d22:	6343      	str	r3, [r0, #52]	@ 0x34
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8007d24:	1d07      	adds	r7, r0, #4
		pxNewTCB->uxMutexesHeld = 0;
 8007d26:	e9c0 6611 	strd	r6, r6, [r0, #68]	@ 0x44
					pxNewTCB->pxStack = pxStack;
 8007d2a:	6305      	str	r5, [r0, #48]	@ 0x30
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007d2c:	f880 6038 	strb.w	r6, [r0, #56]	@ 0x38
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8007d30:	f880 6043 	strb.w	r6, [r0, #67]	@ 0x43
	pxNewTCB->uxPriority = uxPriority;
 8007d34:	62c6      	str	r6, [r0, #44]	@ 0x2c
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8007d36:	4638      	mov	r0, r7
 8007d38:	f7ff fb18 	bl	800736c <vListInitialiseItem>
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 8007d3c:	f505 75fe 	add.w	r5, r5, #508	@ 0x1fc
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 8007d40:	f104 0018 	add.w	r0, r4, #24
 8007d44:	f7ff fb12 	bl	800736c <vListInitialiseItem>
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 8007d48:	f025 0507 	bic.w	r5, r5, #7
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8007d4c:	2307      	movs	r3, #7
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8007d4e:	4632      	mov	r2, r6
		pxNewTCB->ulNotifiedValue = 0;
 8007d50:	64e6      	str	r6, [r4, #76]	@ 0x4c
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8007d52:	494c      	ldr	r1, [pc, #304]	@ (8007e84 <vTaskStartScheduler+0x184>)
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8007d54:	61a3      	str	r3, [r4, #24]
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8007d56:	f884 6050 	strb.w	r6, [r4, #80]	@ 0x50
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8007d5a:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 8007d5c:	6264      	str	r4, [r4, #36]	@ 0x24
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8007d5e:	4628      	mov	r0, r5
 8007d60:	f7ff fb80 	bl	8007464 <pxPortInitialiseStack>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8007d64:	4b48      	ldr	r3, [pc, #288]	@ (8007e88 <vTaskStartScheduler+0x188>)
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8007d66:	6020      	str	r0, [r4, #0]
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8007d68:	601c      	str	r4, [r3, #0]
	taskENTER_CRITICAL();
 8007d6a:	f7ff fba3 	bl	80074b4 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 8007d6e:	4a47      	ldr	r2, [pc, #284]	@ (8007e8c <vTaskStartScheduler+0x18c>)
		if( pxCurrentTCB == NULL )
 8007d70:	4e47      	ldr	r6, [pc, #284]	@ (8007e90 <vTaskStartScheduler+0x190>)
		uxCurrentNumberOfTasks++;
 8007d72:	6813      	ldr	r3, [r2, #0]
 8007d74:	3301      	adds	r3, #1
 8007d76:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
 8007d78:	6833      	ldr	r3, [r6, #0]
 8007d7a:	2b00      	cmp	r3, #0
 8007d7c:	d051      	beq.n	8007e22 <vTaskStartScheduler+0x122>
			if( xSchedulerRunning == pdFALSE )
 8007d7e:	4d45      	ldr	r5, [pc, #276]	@ (8007e94 <vTaskStartScheduler+0x194>)
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8007d80:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
			if( xSchedulerRunning == pdFALSE )
 8007d82:	682b      	ldr	r3, [r5, #0]
 8007d84:	2b00      	cmp	r3, #0
 8007d86:	d046      	beq.n	8007e16 <vTaskStartScheduler+0x116>
 8007d88:	f8df 8134 	ldr.w	r8, [pc, #308]	@ 8007ec0 <vTaskStartScheduler+0x1c0>
		prvAddTaskToReadyList( pxNewTCB );
 8007d8c:	4a42      	ldr	r2, [pc, #264]	@ (8007e98 <vTaskStartScheduler+0x198>)
 8007d8e:	4639      	mov	r1, r7
		uxTaskNumber++;
 8007d90:	4f42      	ldr	r7, [pc, #264]	@ (8007e9c <vTaskStartScheduler+0x19c>)
 8007d92:	683b      	ldr	r3, [r7, #0]
 8007d94:	3301      	adds	r3, #1
 8007d96:	603b      	str	r3, [r7, #0]
		prvAddTaskToReadyList( pxNewTCB );
 8007d98:	6817      	ldr	r7, [r2, #0]
 8007d9a:	2301      	movs	r3, #1
 8007d9c:	4083      	lsls	r3, r0
 8007d9e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8007da2:	433b      	orrs	r3, r7
 8007da4:	eb08 0080 	add.w	r0, r8, r0, lsl #2
 8007da8:	6013      	str	r3, [r2, #0]
 8007daa:	f7ff fae3 	bl	8007374 <vListInsertEnd>
	taskEXIT_CRITICAL();
 8007dae:	f7ff fba3 	bl	80074f8 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 8007db2:	682b      	ldr	r3, [r5, #0]
 8007db4:	b173      	cbz	r3, 8007dd4 <vTaskStartScheduler+0xd4>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 8007db6:	6832      	ldr	r2, [r6, #0]
 8007db8:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 8007dba:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 8007dbc:	429a      	cmp	r2, r3
 8007dbe:	d209      	bcs.n	8007dd4 <vTaskStartScheduler+0xd4>
			taskYIELD_IF_USING_PREEMPTION();
 8007dc0:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8007dc4:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8007dc8:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8007dcc:	f3bf 8f4f 	dsb	sy
 8007dd0:	f3bf 8f6f 	isb	sy
 8007dd4:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007dd8:	f383 8811 	msr	BASEPRI, r3
 8007ddc:	f3bf 8f6f 	isb	sy
 8007de0:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
 8007de4:	4a2e      	ldr	r2, [pc, #184]	@ (8007ea0 <vTaskStartScheduler+0x1a0>)
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 8007de6:	4b2f      	ldr	r3, [pc, #188]	@ (8007ea4 <vTaskStartScheduler+0x1a4>)
		xNextTaskUnblockTime = portMAX_DELAY;
 8007de8:	f04f 30ff 	mov.w	r0, #4294967295
 8007dec:	6010      	str	r0, [r2, #0]
		xSchedulerRunning = pdTRUE;
 8007dee:	2101      	movs	r1, #1
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 8007df0:	2200      	movs	r2, #0
		xSchedulerRunning = pdTRUE;
 8007df2:	6029      	str	r1, [r5, #0]
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 8007df4:	601a      	str	r2, [r3, #0]
}
 8007df6:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		if( xPortStartScheduler() != pdFALSE )
 8007dfa:	f7ff bbd9 	b.w	80075b0 <xPortStartScheduler>
					vPortFree( pxStack );
 8007dfe:	4628      	mov	r0, r5
 8007e00:	f7ff fa44 	bl	800728c <vPortFree>
 8007e04:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007e08:	f383 8811 	msr	BASEPRI, r3
 8007e0c:	f3bf 8f6f 	isb	sy
 8007e10:	f3bf 8f4f 	dsb	sy
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8007e14:	e7fe      	b.n	8007e14 <vTaskStartScheduler+0x114>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8007e16:	6833      	ldr	r3, [r6, #0]
 8007e18:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8007e1a:	4283      	cmp	r3, r0
					pxCurrentTCB = pxNewTCB;
 8007e1c:	bf98      	it	ls
 8007e1e:	6034      	strls	r4, [r6, #0]
 8007e20:	e7b2      	b.n	8007d88 <vTaskStartScheduler+0x88>
			pxCurrentTCB = pxNewTCB;
 8007e22:	6034      	str	r4, [r6, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8007e24:	6813      	ldr	r3, [r2, #0]
 8007e26:	2b01      	cmp	r3, #1
 8007e28:	d004      	beq.n	8007e34 <vTaskStartScheduler+0x134>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8007e2a:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
 8007e2c:	f8df 8090 	ldr.w	r8, [pc, #144]	@ 8007ec0 <vTaskStartScheduler+0x1c0>
 8007e30:	4d18      	ldr	r5, [pc, #96]	@ (8007e94 <vTaskStartScheduler+0x194>)
 8007e32:	e7ab      	b.n	8007d8c <vTaskStartScheduler+0x8c>
 8007e34:	f8df 8088 	ldr.w	r8, [pc, #136]	@ 8007ec0 <vTaskStartScheduler+0x1c0>
 8007e38:	4645      	mov	r5, r8
 8007e3a:	f108 098c 	add.w	r9, r8, #140	@ 0x8c
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8007e3e:	4628      	mov	r0, r5
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8007e40:	3514      	adds	r5, #20
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8007e42:	f7ff fa87 	bl	8007354 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8007e46:	454d      	cmp	r5, r9
 8007e48:	d1f9      	bne.n	8007e3e <vTaskStartScheduler+0x13e>
	vListInitialise( &xDelayedTaskList1 );
 8007e4a:	f8df 9078 	ldr.w	r9, [pc, #120]	@ 8007ec4 <vTaskStartScheduler+0x1c4>
	vListInitialise( &xDelayedTaskList2 );
 8007e4e:	4d16      	ldr	r5, [pc, #88]	@ (8007ea8 <vTaskStartScheduler+0x1a8>)
	vListInitialise( &xDelayedTaskList1 );
 8007e50:	4648      	mov	r0, r9
 8007e52:	f7ff fa7f 	bl	8007354 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8007e56:	4628      	mov	r0, r5
 8007e58:	f7ff fa7c 	bl	8007354 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8007e5c:	4813      	ldr	r0, [pc, #76]	@ (8007eac <vTaskStartScheduler+0x1ac>)
 8007e5e:	f7ff fa79 	bl	8007354 <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 8007e62:	4813      	ldr	r0, [pc, #76]	@ (8007eb0 <vTaskStartScheduler+0x1b0>)
 8007e64:	f7ff fa76 	bl	8007354 <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 8007e68:	4812      	ldr	r0, [pc, #72]	@ (8007eb4 <vTaskStartScheduler+0x1b4>)
 8007e6a:	f7ff fa73 	bl	8007354 <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
 8007e6e:	4b12      	ldr	r3, [pc, #72]	@ (8007eb8 <vTaskStartScheduler+0x1b8>)
		prvAddTaskToReadyList( pxNewTCB );
 8007e70:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
	pxDelayedTaskList = &xDelayedTaskList1;
 8007e72:	f8c3 9000 	str.w	r9, [r3]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8007e76:	4b11      	ldr	r3, [pc, #68]	@ (8007ebc <vTaskStartScheduler+0x1bc>)
 8007e78:	601d      	str	r5, [r3, #0]
 8007e7a:	4d06      	ldr	r5, [pc, #24]	@ (8007e94 <vTaskStartScheduler+0x194>)
}
 8007e7c:	e786      	b.n	8007d8c <vTaskStartScheduler+0x8c>
 8007e7e:	bf00      	nop
 8007e80:	454c4449 	.word	0x454c4449
 8007e84:	080076f1 	.word	0x080076f1
 8007e88:	2000266c 	.word	0x2000266c
 8007e8c:	20002690 	.word	0x20002690
 8007e90:	20002790 	.word	0x20002790
 8007e94:	20002684 	.word	0x20002684
 8007e98:	20002688 	.word	0x20002688
 8007e9c:	20002674 	.word	0x20002674
 8007ea0:	20002670 	.word	0x20002670
 8007ea4:	2000268c 	.word	0x2000268c
 8007ea8:	200026dc 	.word	0x200026dc
 8007eac:	200026c0 	.word	0x200026c0
 8007eb0:	200026ac 	.word	0x200026ac
 8007eb4:	20002694 	.word	0x20002694
 8007eb8:	200026d8 	.word	0x200026d8
 8007ebc:	200026d4 	.word	0x200026d4
 8007ec0:	20002704 	.word	0x20002704
 8007ec4:	200026f0 	.word	0x200026f0

08007ec8 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 8007ec8:	4a02      	ldr	r2, [pc, #8]	@ (8007ed4 <vTaskSuspendAll+0xc>)
 8007eca:	6813      	ldr	r3, [r2, #0]
 8007ecc:	3301      	adds	r3, #1
 8007ece:	6013      	str	r3, [r2, #0]
}
 8007ed0:	4770      	bx	lr
 8007ed2:	bf00      	nop
 8007ed4:	20002668 	.word	0x20002668

08007ed8 <xTaskResumeAll>:
	configASSERT( uxSchedulerSuspended );
 8007ed8:	4b06      	ldr	r3, [pc, #24]	@ (8007ef4 <xTaskResumeAll+0x1c>)
 8007eda:	681b      	ldr	r3, [r3, #0]
 8007edc:	b943      	cbnz	r3, 8007ef0 <xTaskResumeAll+0x18>
 8007ede:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007ee2:	f383 8811 	msr	BASEPRI, r3
 8007ee6:	f3bf 8f6f 	isb	sy
 8007eea:	f3bf 8f4f 	dsb	sy
 8007eee:	e7fe      	b.n	8007eee <xTaskResumeAll+0x16>
 8007ef0:	f7ff bd20 	b.w	8007934 <xTaskResumeAll.part.0>
 8007ef4:	20002668 	.word	0x20002668

08007ef8 <xTaskIncrementTick>:
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8007ef8:	4b05      	ldr	r3, [pc, #20]	@ (8007f10 <xTaskIncrementTick+0x18>)
 8007efa:	681b      	ldr	r3, [r3, #0]
 8007efc:	b90b      	cbnz	r3, 8007f02 <xTaskIncrementTick+0xa>
 8007efe:	f7ff bc73 	b.w	80077e8 <xTaskIncrementTick.part.0>
		++xPendedTicks;
 8007f02:	4a04      	ldr	r2, [pc, #16]	@ (8007f14 <xTaskIncrementTick+0x1c>)
 8007f04:	6813      	ldr	r3, [r2, #0]
 8007f06:	3301      	adds	r3, #1
}
 8007f08:	2000      	movs	r0, #0
		++xPendedTicks;
 8007f0a:	6013      	str	r3, [r2, #0]
}
 8007f0c:	4770      	bx	lr
 8007f0e:	bf00      	nop
 8007f10:	20002668 	.word	0x20002668
 8007f14:	20002680 	.word	0x20002680

08007f18 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8007f18:	4b16      	ldr	r3, [pc, #88]	@ (8007f74 <vTaskSwitchContext+0x5c>)
 8007f1a:	681b      	ldr	r3, [r3, #0]
 8007f1c:	b11b      	cbz	r3, 8007f26 <vTaskSwitchContext+0xe>
		xYieldPending = pdTRUE;
 8007f1e:	4b16      	ldr	r3, [pc, #88]	@ (8007f78 <vTaskSwitchContext+0x60>)
 8007f20:	2201      	movs	r2, #1
 8007f22:	601a      	str	r2, [r3, #0]
 8007f24:	4770      	bx	lr
		xYieldPending = pdFALSE;
 8007f26:	4914      	ldr	r1, [pc, #80]	@ (8007f78 <vTaskSwitchContext+0x60>)
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8007f28:	4a14      	ldr	r2, [pc, #80]	@ (8007f7c <vTaskSwitchContext+0x64>)
		xYieldPending = pdFALSE;
 8007f2a:	600b      	str	r3, [r1, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8007f2c:	6813      	ldr	r3, [r2, #0]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 8007f2e:	fab3 f383 	clz	r3, r3
 8007f32:	b2db      	uxtb	r3, r3
 8007f34:	f1c3 031f 	rsb	r3, r3, #31
 8007f38:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8007f3c:	4910      	ldr	r1, [pc, #64]	@ (8007f80 <vTaskSwitchContext+0x68>)
 8007f3e:	009a      	lsls	r2, r3, #2
 8007f40:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 8007f44:	5888      	ldr	r0, [r1, r2]
 8007f46:	b940      	cbnz	r0, 8007f5a <vTaskSwitchContext+0x42>
	__asm volatile
 8007f48:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007f4c:	f383 8811 	msr	BASEPRI, r3
 8007f50:	f3bf 8f6f 	isb	sy
 8007f54:	f3bf 8f4f 	dsb	sy
 8007f58:	e7fe      	b.n	8007f58 <vTaskSwitchContext+0x40>
 8007f5a:	6858      	ldr	r0, [r3, #4]
 8007f5c:	3208      	adds	r2, #8
 8007f5e:	6840      	ldr	r0, [r0, #4]
 8007f60:	6058      	str	r0, [r3, #4]
 8007f62:	440a      	add	r2, r1
 8007f64:	4290      	cmp	r0, r2
 8007f66:	bf04      	itt	eq
 8007f68:	6840      	ldreq	r0, [r0, #4]
 8007f6a:	6058      	streq	r0, [r3, #4]
 8007f6c:	4b05      	ldr	r3, [pc, #20]	@ (8007f84 <vTaskSwitchContext+0x6c>)
 8007f6e:	68c2      	ldr	r2, [r0, #12]
 8007f70:	601a      	str	r2, [r3, #0]
}
 8007f72:	4770      	bx	lr
 8007f74:	20002668 	.word	0x20002668
 8007f78:	2000267c 	.word	0x2000267c
 8007f7c:	20002688 	.word	0x20002688
 8007f80:	20002704 	.word	0x20002704
 8007f84:	20002790 	.word	0x20002790

08007f88 <VBS_GetAvBusVoltage_V>:
    temp = 0U;
  }
  else
  {
#endif
    temp = (uint32_t)(pHandle->AvBusVoltage_d);
 8007f88:	88c3      	ldrh	r3, [r0, #6]
    temp *= pHandle->ConversionFactor;
 8007f8a:	8840      	ldrh	r0, [r0, #2]
 8007f8c:	fb03 f000 	mul.w	r0, r3, r0
    temp /= 65536U;
#ifdef NULL_PTR_CHECK_BUS_VOLT
  }
#endif
  return ((uint16_t)temp);
}
 8007f90:	0c00      	lsrs	r0, r0, #16
 8007f92:	4770      	bx	lr

08007f94 <Circle_Limitation>:
  *  @f$v_q = \sqrt(MaxModule^2-v_d^2\ ) @f$

  *
  */
__weak qd_t Circle_Limitation(const CircleLimitation_Handle_t *pHandle, qd_t Vqd)
{
 8007f94:	b570      	push	{r4, r5, r6, lr}
    int32_t square_limit;
    int32_t vd_square_limit;
    int32_t new_q;
    int32_t new_d;

    maxModule = (int32_t)pHandle->MaxModule;
 8007f96:	8803      	ldrh	r3, [r0, #0]
 8007f98:	140d      	asrs	r5, r1, #16
 8007f9a:	b20c      	sxth	r4, r1

    square_q = ((int32_t)(Vqd.q)) * Vqd.q;
    square_d = ((int32_t)(Vqd.d)) * Vqd.d;
 8007f9c:	fb05 f205 	mul.w	r2, r5, r5
    square_limit = maxModule * maxModule;
 8007fa0:	fb03 f303 	mul.w	r3, r3, r3
    vd_square_limit = ((int32_t)pHandle->MaxVd) * ((int32_t)pHandle->MaxVd);
    square_sum = square_q + square_d;
 8007fa4:	fb04 2104 	mla	r1, r4, r4, r2

    if (square_sum > square_limit)
 8007fa8:	428b      	cmp	r3, r1
{
 8007faa:	b084      	sub	sp, #16
    if (square_sum > square_limit)
 8007fac:	da0f      	bge.n	8007fce <Circle_Limitation+0x3a>
    vd_square_limit = ((int32_t)pHandle->MaxVd) * ((int32_t)pHandle->MaxVd);
 8007fae:	8846      	ldrh	r6, [r0, #2]
 8007fb0:	fb06 f006 	mul.w	r0, r6, r6
    {
      if (square_d <= vd_square_limit)
 8007fb4:	4282      	cmp	r2, r0
 8007fb6:	dd13      	ble.n	8007fe0 <Circle_Limitation+0x4c>
        new_d = Vqd.d;
      }
      else
      {
        new_d = (int32_t)pHandle->MaxVd;
        if (Vqd.d < 0)
 8007fb8:	2d00      	cmp	r5, #0
#if defined CIRCLE_LIMITATION_SQRT_M0
        square_temp = (square_limit - vd_square_limit) / 1048576;
        new_q = SqrtTable[square_temp];
#else
        square_temp = square_limit - vd_square_limit;
        new_q = MCM_Sqrt(square_temp);
 8007fba:	eba3 0000 	sub.w	r0, r3, r0
          new_d = -new_d;
 8007fbe:	bfb8      	it	lt
 8007fc0:	4276      	neglt	r6, r6
        new_q = MCM_Sqrt(square_temp);
 8007fc2:	f7f9 fa75 	bl	80014b0 <MCM_Sqrt>
#endif
        if (Vqd.q < 0)
 8007fc6:	2c00      	cmp	r4, #0
        {
          /* Nothing to do */
        }
      }
      local_vqd.q = (int16_t)new_q;
      local_vqd.d = (int16_t)new_d;
 8007fc8:	b235      	sxth	r5, r6
        if (Vqd.q < 0)
 8007fca:	db0e      	blt.n	8007fea <Circle_Limitation+0x56>
      local_vqd.q = (int16_t)new_q;
 8007fcc:	b204      	sxth	r4, r0
    }
#ifdef NULL_PTR_CHECK_CRC_LIM
  }
#endif
  return (local_vqd);
 8007fce:	b2a4      	uxth	r4, r4
 8007fd0:	2000      	movs	r0, #0
 8007fd2:	f364 000f 	bfi	r0, r4, #0, #16
 8007fd6:	b2ad      	uxth	r5, r5
 8007fd8:	f365 401f 	bfi	r0, r5, #16, #16
}
 8007fdc:	b004      	add	sp, #16
 8007fde:	bd70      	pop	{r4, r5, r6, pc}
        new_q = MCM_Sqrt(square_temp);
 8007fe0:	1a98      	subs	r0, r3, r2
 8007fe2:	f7f9 fa65 	bl	80014b0 <MCM_Sqrt>
        if (Vqd.q < 0)
 8007fe6:	2c00      	cmp	r4, #0
 8007fe8:	daf0      	bge.n	8007fcc <Circle_Limitation+0x38>
          new_q = - new_q;
 8007fea:	4240      	negs	r0, r0
      local_vqd.q = (int16_t)new_q;
 8007fec:	b204      	sxth	r4, r0
      local_vqd.d = (int16_t)new_d;
 8007fee:	e7ee      	b.n	8007fce <Circle_Limitation+0x3a>

08007ff0 <MCPA_dataLog>:
  * @brief  Allocates and fills buffer with asynchronous data to be sent to controller
  *
  * @param  *pHandle Pointer to the MCPA Handle
  */
void MCPA_dataLog(MCPA_Handle_t *pHandle)
{
 8007ff0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
#endif
    uint32_t *logValue;
    uint16_t *logValue16;
    uint8_t i;

    if (pHandle->HFIndex == pHandle->HFRateBuff) /*  */
 8007ff2:	7fc3      	ldrb	r3, [r0, #31]
 8007ff4:	f890 2022 	ldrb.w	r2, [r0, #34]	@ 0x22
 8007ff8:	429a      	cmp	r2, r3
{
 8007ffa:	4604      	mov	r4, r0
    if (pHandle->HFIndex == pHandle->HFRateBuff) /*  */
 8007ffc:	d002      	beq.n	8008004 <MCPA_dataLog+0x14>
      }
    }
    else
    {
      /* Nothing to log just waiting next call to MCPA_datalog */
      pHandle->HFIndex++;
 8007ffe:	3301      	adds	r3, #1
 8008000:	77c3      	strb	r3, [r0, #31]
    }
#ifdef NULL_PTR_CHECK_MCPA
  }
#endif
}
 8008002:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (0U == pHandle->bufferIndex)
 8008004:	8b05      	ldrh	r5, [r0, #24]
      pHandle->HFIndex = 0U;
 8008006:	2300      	movs	r3, #0
 8008008:	77c3      	strb	r3, [r0, #31]
      if (0U == pHandle->bufferIndex)
 800800a:	b1a5      	cbz	r5, 8008036 <MCPA_dataLog+0x46>
 800800c:	6961      	ldr	r1, [r4, #20]
      if ((pHandle->bufferIndex > 0U)  && (pHandle->bufferIndex <= pHandle->bufferTxTriggerBuff))
 800800e:	8ba2      	ldrh	r2, [r4, #28]
 8008010:	42aa      	cmp	r2, r5
 8008012:	d24e      	bcs.n	80080b2 <MCPA_dataLog+0xc2>
 8008014:	f894 3026 	ldrb.w	r3, [r4, #38]	@ 0x26
        if (pHandle->MFRateBuff == 254U) /* MFRateBuff = 254 means we dump MF data once per buffer */
 8008018:	2bfe      	cmp	r3, #254	@ 0xfe
 800801a:	d066      	beq.n	80080ea <MCPA_dataLog+0xfa>
        *logValue16 = pHandle->MarkBuff; /* MarkBuff is actually 8 bits, but we add also 8 bits of the ASYNCID=0 after
 800801c:	f894 302a 	ldrb.w	r3, [r4, #42]	@ 0x2a
 8008020:	534b      	strh	r3, [r1, r5]
        pHandle->pTransportLayer->fSendPacket(pHandle->pTransportLayer, pHandle->currentBuffer,
 8008022:	8b22      	ldrh	r2, [r4, #24]
 8008024:	6820      	ldr	r0, [r4, #0]
 8008026:	3202      	adds	r2, #2
 8008028:	2309      	movs	r3, #9
 800802a:	6845      	ldr	r5, [r0, #4]
 800802c:	b292      	uxth	r2, r2
 800802e:	47a8      	blx	r5
        pHandle->bufferIndex = 0U;
 8008030:	2300      	movs	r3, #0
 8008032:	8323      	strh	r3, [r4, #24]
}
 8008034:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (0U == pHandle->pTransportLayer->fGetBuffer (pHandle->pTransportLayer,
 8008036:	4601      	mov	r1, r0
 8008038:	2209      	movs	r2, #9
 800803a:	f851 0b14 	ldr.w	r0, [r1], #20
 800803e:	6803      	ldr	r3, [r0, #0]
 8008040:	4798      	blx	r3
 8008042:	b390      	cbz	r0, 80080aa <MCPA_dataLog+0xba>
          *logValue = GLOBAL_TIMESTAMP; /* 32 first bits is used to store Timestamp */
 8008044:	4b49      	ldr	r3, [pc, #292]	@ (800816c <MCPA_dataLog+0x17c>)
 8008046:	6961      	ldr	r1, [r4, #20]
 8008048:	681b      	ldr	r3, [r3, #0]
 800804a:	600b      	str	r3, [r1, #0]
          if (pHandle->Mark == pHandle->MarkBuff)
 800804c:	f894 0029 	ldrb.w	r0, [r4, #41]	@ 0x29
 8008050:	f894 202a 	ldrb.w	r2, [r4, #42]	@ 0x2a
          pHandle->MFIndex = 0U; /* Restart the motif from scratch at each buffer */
 8008054:	f884 5020 	strb.w	r5, [r4, #32]
          pHandle->bufferIndex = 4U;
 8008058:	2304      	movs	r3, #4
          if (pHandle->Mark == pHandle->MarkBuff)
 800805a:	4282      	cmp	r2, r0
          pHandle->bufferIndex = 4U;
 800805c:	8323      	strh	r3, [r4, #24]
          if (pHandle->Mark == pHandle->MarkBuff)
 800805e:	d101      	bne.n	8008064 <MCPA_dataLog+0x74>
 8008060:	461d      	mov	r5, r3
      if ((pHandle->bufferIndex > 0U)  && (pHandle->bufferIndex <= pHandle->bufferTxTriggerBuff))
 8008062:	e7d4      	b.n	800800e <MCPA_dataLog+0x1e>
            pHandle->MFNumBuff           = pHandle->MFNum;
 8008064:	f894 3027 	ldrb.w	r3, [r4, #39]	@ 0x27
            pHandle->HFNumBuff           = pHandle->HFNum;
 8008068:	f894 2023 	ldrb.w	r2, [r4, #35]	@ 0x23
            pHandle->MFRateBuff          = pHandle->MFRate;
 800806c:	f894 1025 	ldrb.w	r1, [r4, #37]	@ 0x25
            pHandle->HFRateBuff          = pHandle->HFRate;
 8008070:	f894 5021 	ldrb.w	r5, [r4, #33]	@ 0x21
            pHandle->HFNumBuff           = pHandle->HFNum;
 8008074:	f884 2024 	strb.w	r2, [r4, #36]	@ 0x24
            pHandle->MFNumBuff           = pHandle->MFNum;
 8008078:	f884 3028 	strb.w	r3, [r4, #40]	@ 0x28
                         ((uint32_t)pHandle->HFNum + (uint32_t)pHandle->MFNum) * 4U); /* We store pointer here,
 800807c:	441a      	add	r2, r3
            pHandle->bufferTxTriggerBuff = pHandle->bufferTxTrigger;
 800807e:	8b63      	ldrh	r3, [r4, #26]
            pHandle->MarkBuff            = pHandle->Mark;
 8008080:	f884 002a 	strb.w	r0, [r4, #42]	@ 0x2a
            (void)memcpy(pHandle->dataPtrTableBuff, pHandle->dataPtrTable,
 8008084:	0092      	lsls	r2, r2, #2
            pHandle->MFRateBuff          = pHandle->MFRate;
 8008086:	f884 1026 	strb.w	r1, [r4, #38]	@ 0x26
            pHandle->bufferTxTriggerBuff = pHandle->bufferTxTrigger;
 800808a:	83a3      	strh	r3, [r4, #28]
            (void)memcpy(pHandle->dataPtrTableBuff, pHandle->dataPtrTable,
 800808c:	e9d4 1001 	ldrd	r1, r0, [r4, #4]
            pHandle->HFRateBuff          = pHandle->HFRate;
 8008090:	f884 5022 	strb.w	r5, [r4, #34]	@ 0x22
            (void)memcpy(pHandle->dataPtrTableBuff, pHandle->dataPtrTable,
 8008094:	f002 f852 	bl	800a13c <memcpy>
                         (uint32_t)pHandle->HFNum + (uint32_t)pHandle->MFNum); /* 1 size byte per ID */
 8008098:	f894 2023 	ldrb.w	r2, [r4, #35]	@ 0x23
 800809c:	f894 3027 	ldrb.w	r3, [r4, #39]	@ 0x27
            (void)memcpy(pHandle->dataSizeTableBuff, pHandle->dataSizeTable,
 80080a0:	e9d4 1003 	ldrd	r1, r0, [r4, #12]
 80080a4:	441a      	add	r2, r3
 80080a6:	f002 f849 	bl	800a13c <memcpy>
      if ((pHandle->bufferIndex > 0U)  && (pHandle->bufferIndex <= pHandle->bufferTxTriggerBuff))
 80080aa:	8b25      	ldrh	r5, [r4, #24]
 80080ac:	2d00      	cmp	r5, #0
 80080ae:	d1ad      	bne.n	800800c <MCPA_dataLog+0x1c>
}
 80080b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        for (i = 0U; i < pHandle->HFNumBuff; i++)
 80080b2:	f894 6024 	ldrb.w	r6, [r4, #36]	@ 0x24
        logValue16 = (uint16_t *)&pHandle->currentBuffer[pHandle->bufferIndex]; //cstat !MISRAC2012-Rule-11.3
 80080b6:	194b      	adds	r3, r1, r5
        for (i = 0U; i < pHandle->HFNumBuff; i++)
 80080b8:	b36e      	cbz	r6, 8008116 <MCPA_dataLog+0x126>
 80080ba:	68a2      	ldr	r2, [r4, #8]
 80080bc:	eb03 0c46 	add.w	ip, r3, r6, lsl #1
 80080c0:	3a04      	subs	r2, #4
          *logValue16 = *((uint16_t *) pHandle->dataPtrTableBuff[i]) ; //cstat !MISRAC2012-Rule-11.5
 80080c2:	f852 0f04 	ldr.w	r0, [r2, #4]!
 80080c6:	8800      	ldrh	r0, [r0, #0]
 80080c8:	f823 0b02 	strh.w	r0, [r3], #2
          pHandle->bufferIndex = pHandle->bufferIndex + 2U;
 80080cc:	8b25      	ldrh	r5, [r4, #24]
 80080ce:	3502      	adds	r5, #2
 80080d0:	b2ad      	uxth	r5, r5
        for (i = 0U; i < pHandle->HFNumBuff; i++)
 80080d2:	459c      	cmp	ip, r3
          pHandle->bufferIndex = pHandle->bufferIndex + 2U;
 80080d4:	8325      	strh	r5, [r4, #24]
        for (i = 0U; i < pHandle->HFNumBuff; i++)
 80080d6:	d1f4      	bne.n	80080c2 <MCPA_dataLog+0xd2>
        if (pHandle->MFRateBuff < 254U)
 80080d8:	f894 3026 	ldrb.w	r3, [r4, #38]	@ 0x26
      if (pHandle->bufferIndex > pHandle->bufferTxTriggerBuff)
 80080dc:	8ba2      	ldrh	r2, [r4, #28]
        if (pHandle->MFRateBuff < 254U)
 80080de:	2bfd      	cmp	r3, #253	@ 0xfd
 80080e0:	4618      	mov	r0, r3
 80080e2:	d91d      	bls.n	8008120 <MCPA_dataLog+0x130>
      if (pHandle->bufferIndex > pHandle->bufferTxTriggerBuff)
 80080e4:	4295      	cmp	r5, r2
 80080e6:	d897      	bhi.n	8008018 <MCPA_dataLog+0x28>
}
 80080e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
          for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 80080ea:	f894 3024 	ldrb.w	r3, [r4, #36]	@ 0x24
 80080ee:	f894 0028 	ldrb.w	r0, [r4, #40]	@ 0x28
 80080f2:	4418      	add	r0, r3
 80080f4:	4298      	cmp	r0, r3
 80080f6:	dd91      	ble.n	800801c <MCPA_dataLog+0x2c>
            *logValue = *((uint32_t *)pHandle->dataPtrTableBuff[i]); //cstat !MISRAC2012-Rule-11.5
 80080f8:	68a7      	ldr	r7, [r4, #8]
            pHandle->bufferIndex = pHandle->bufferIndex + pHandle->dataSizeTableBuff[i];
 80080fa:	6926      	ldr	r6, [r4, #16]
            *logValue = *((uint32_t *)pHandle->dataPtrTableBuff[i]); //cstat !MISRAC2012-Rule-11.5
 80080fc:	f857 2023 	ldr.w	r2, [r7, r3, lsl #2]
 8008100:	6812      	ldr	r2, [r2, #0]
 8008102:	514a      	str	r2, [r1, r5]
          for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8008104:	1c5a      	adds	r2, r3, #1
            pHandle->bufferIndex = pHandle->bufferIndex + pHandle->dataSizeTableBuff[i];
 8008106:	5cf3      	ldrb	r3, [r6, r3]
 8008108:	442b      	add	r3, r5
 800810a:	b29d      	uxth	r5, r3
          for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 800810c:	b2d3      	uxtb	r3, r2
 800810e:	4283      	cmp	r3, r0
            pHandle->bufferIndex = pHandle->bufferIndex + pHandle->dataSizeTableBuff[i];
 8008110:	8325      	strh	r5, [r4, #24]
          for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8008112:	dbf3      	blt.n	80080fc <MCPA_dataLog+0x10c>
 8008114:	e782      	b.n	800801c <MCPA_dataLog+0x2c>
        if (pHandle->MFRateBuff < 254U)
 8008116:	f894 0026 	ldrb.w	r0, [r4, #38]	@ 0x26
 800811a:	28fd      	cmp	r0, #253	@ 0xfd
 800811c:	f63f af71 	bhi.w	8008002 <MCPA_dataLog+0x12>
          if (pHandle->MFIndex == pHandle->MFRateBuff)
 8008120:	f894 3020 	ldrb.w	r3, [r4, #32]
 8008124:	4283      	cmp	r3, r0
 8008126:	d006      	beq.n	8008136 <MCPA_dataLog+0x146>
            pHandle->MFIndex ++;
 8008128:	3301      	adds	r3, #1
 800812a:	f884 3020 	strb.w	r3, [r4, #32]
      if (pHandle->bufferIndex > pHandle->bufferTxTriggerBuff)
 800812e:	4295      	cmp	r5, r2
 8008130:	f63f af74 	bhi.w	800801c <MCPA_dataLog+0x2c>
}
 8008134:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8008136:	f894 7028 	ldrb.w	r7, [r4, #40]	@ 0x28
 800813a:	4437      	add	r7, r6
            pHandle->MFIndex = 0U;
 800813c:	2300      	movs	r3, #0
            for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 800813e:	42b7      	cmp	r7, r6
            pHandle->MFIndex = 0U;
 8008140:	f884 3020 	strb.w	r3, [r4, #32]
            for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8008144:	ddf3      	ble.n	800812e <MCPA_dataLog+0x13e>
              *logValue = *((uint32_t *)pHandle->dataPtrTableBuff[i]); //cstat !MISRAC2012-Rule-11.5
 8008146:	f8d4 e008 	ldr.w	lr, [r4, #8]
              pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 800814a:	f8d4 c010 	ldr.w	ip, [r4, #16]
              *logValue = *((uint32_t *)pHandle->dataPtrTableBuff[i]); //cstat !MISRAC2012-Rule-11.5
 800814e:	f85e 3026 	ldr.w	r3, [lr, r6, lsl #2]
 8008152:	681b      	ldr	r3, [r3, #0]
 8008154:	514b      	str	r3, [r1, r5]
              pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 8008156:	f81c 3006 	ldrb.w	r3, [ip, r6]
            for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 800815a:	1c70      	adds	r0, r6, #1
              pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 800815c:	442b      	add	r3, r5
            for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 800815e:	b2c6      	uxtb	r6, r0
              pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 8008160:	b29d      	uxth	r5, r3
            for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8008162:	42be      	cmp	r6, r7
              pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 8008164:	8325      	strh	r5, [r4, #24]
            for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8008166:	dbf2      	blt.n	800814e <MCPA_dataLog+0x15e>
 8008168:	e7e1      	b.n	800812e <MCPA_dataLog+0x13e>
 800816a:	bf00      	nop
 800816c:	20002794 	.word	0x20002794

08008170 <MCPA_flushDataLog>:
#endif
    uint32_t *logValue;
    uint16_t *logValue16;
    uint8_t i;

    if (pHandle->bufferIndex > 0U)
 8008170:	8b03      	ldrh	r3, [r0, #24]
 8008172:	b19b      	cbz	r3, 800819c <MCPA_flushDataLog+0x2c>
{
 8008174:	b570      	push	{r4, r5, r6, lr}
    {  /* If buffer is allocated, we must send it */
      if (pHandle->MFRateBuff == 254U) /* In case of flush, we must respect the packet format to allow
 8008176:	f890 2026 	ldrb.w	r2, [r0, #38]	@ 0x26
                                          proper decoding */
      {
        for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
        {
         logValue = (uint32_t *)&pHandle->currentBuffer[pHandle->bufferIndex]; //cstat !MISRAC2012-Rule-11.3
 800817a:	6941      	ldr	r1, [r0, #20]
      if (pHandle->MFRateBuff == 254U) /* In case of flush, we must respect the packet format to allow
 800817c:	2afe      	cmp	r2, #254	@ 0xfe
 800817e:	4604      	mov	r4, r0
 8008180:	d00d      	beq.n	800819e <MCPA_flushDataLog+0x2e>
      else
      {
        /* Nothing to do */
      }
      logValue16 = (uint16_t *)&pHandle->currentBuffer[pHandle->bufferIndex]; //cstat !MISRAC2012-Rule-11.3
      *logValue16 = pHandle->MarkBuff; /* MarkBuff is actually 8 bits, but we add also 8 bits of the ASYNCID=0 after
 8008182:	f894 202a 	ldrb.w	r2, [r4, #42]	@ 0x2a
 8008186:	52ca      	strh	r2, [r1, r3]
                                          the MARK */
      pHandle->pTransportLayer->fSendPacket (pHandle->pTransportLayer, pHandle->currentBuffer,
 8008188:	8b22      	ldrh	r2, [r4, #24]
 800818a:	6820      	ldr	r0, [r4, #0]
 800818c:	3202      	adds	r2, #2
 800818e:	2309      	movs	r3, #9
 8008190:	6845      	ldr	r5, [r0, #4]
 8008192:	b292      	uxth	r2, r2
 8008194:	47a8      	blx	r5
                                             pHandle->bufferIndex + 2U, MCTL_ASYNC);
      pHandle->bufferIndex = 0U;
 8008196:	2300      	movs	r3, #0
 8008198:	8323      	strh	r3, [r4, #24]
      /* Nothing to do */
    }
#ifdef NULL_PTR_CHECK_MCPA
  }
#endif
}
 800819a:	bd70      	pop	{r4, r5, r6, pc}
 800819c:	4770      	bx	lr
        for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 800819e:	f890 2024 	ldrb.w	r2, [r0, #36]	@ 0x24
 80081a2:	f890 c028 	ldrb.w	ip, [r0, #40]	@ 0x28
 80081a6:	4494      	add	ip, r2
 80081a8:	4562      	cmp	r2, ip
 80081aa:	daea      	bge.n	8008182 <MCPA_flushDataLog+0x12>
         *logValue = *((uint32_t *)pHandle->dataPtrTableBuff[i]); //cstat !MISRAC2012-Rule-11.5
 80081ac:	6886      	ldr	r6, [r0, #8]
         pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 80081ae:	6905      	ldr	r5, [r0, #16]
         *logValue = *((uint32_t *)pHandle->dataPtrTableBuff[i]); //cstat !MISRAC2012-Rule-11.5
 80081b0:	f856 0022 	ldr.w	r0, [r6, r2, lsl #2]
 80081b4:	6800      	ldr	r0, [r0, #0]
 80081b6:	50c8      	str	r0, [r1, r3]
         pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 80081b8:	5ca8      	ldrb	r0, [r5, r2]
        for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 80081ba:	3201      	adds	r2, #1
         pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 80081bc:	4403      	add	r3, r0
        for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 80081be:	b2d2      	uxtb	r2, r2
         pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 80081c0:	b29b      	uxth	r3, r3
        for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 80081c2:	4562      	cmp	r2, ip
         pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 80081c4:	8323      	strh	r3, [r4, #24]
        for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 80081c6:	dbf3      	blt.n	80081b0 <MCPA_flushDataLog+0x40>
 80081c8:	e7db      	b.n	8008182 <MCPA_flushDataLog+0x12>
 80081ca:	bf00      	nop

080081cc <MCPA_cfgLog>:
  *
  * @param  *pHandle Pointer to the MCPA Handle
  * @param  *cfgdata Configuration of the Async communication
  */
uint8_t MCPA_cfgLog(MCPA_Handle_t *pHandle, uint8_t *cfgdata)
{
 80081cc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    uint8_t i;
    uint16_t logSize = 0U; /* Max size of a log per iteration (HF+MF) */
    uint16_t newID, buffSize;
    uint8_t *pCfgData = cfgdata;

    buffSize = *((uint16_t *)pCfgData); //cstat !MISRAC2012-Rule-11.3
 80081d0:	880f      	ldrh	r7, [r1, #0]
{
 80081d2:	4604      	mov	r4, r0

    if (buffSize == 0U)
 80081d4:	2f00      	cmp	r7, #0
 80081d6:	d046      	beq.n	8008266 <MCPA_cfgLog+0x9a>
    { 
      /* Switch Off condition */
      MCPA_stopDataLog(pHandle);
    }
    else if (buffSize > pHandle->pTransportLayer->txAsyncMaxPayload)
 80081d8:	6803      	ldr	r3, [r0, #0]
 80081da:	89db      	ldrh	r3, [r3, #14]
 80081dc:	42bb      	cmp	r3, r7
 80081de:	d33f      	bcc.n	8008260 <MCPA_cfgLog+0x94>
    {
      result = MCP_ERROR_NO_TXASYNC_SPACE;
    }
    else
    {
      pHandle->HFRate = *((uint8_t *)&pCfgData[2]);
 80081e0:	788b      	ldrb	r3, [r1, #2]
 80081e2:	f880 3021 	strb.w	r3, [r0, #33]	@ 0x21
      pHandle->HFNum  = *((uint8_t *)&pCfgData[3]);
 80081e6:	f891 8003 	ldrb.w	r8, [r1, #3]
 80081ea:	f880 8023 	strb.w	r8, [r0, #35]	@ 0x23
      pHandle->MFRate = *((uint8_t *)&pCfgData[4]);
 80081ee:	790b      	ldrb	r3, [r1, #4]
 80081f0:	f880 3025 	strb.w	r3, [r0, #37]	@ 0x25
      pHandle->MFNum  = *((uint8_t *)&pCfgData[5]);
 80081f4:	794b      	ldrb	r3, [r1, #5]
      pCfgData = &pCfgData[6]; /* Start of the HF IDs */

      if ((pHandle->HFNum + pHandle->MFNum) <= pHandle->nbrOfDataLog)
 80081f6:	7f82      	ldrb	r2, [r0, #30]
      pHandle->MFNum  = *((uint8_t *)&pCfgData[5]);
 80081f8:	f880 3027 	strb.w	r3, [r0, #39]	@ 0x27
      if ((pHandle->HFNum + pHandle->MFNum) <= pHandle->nbrOfDataLog)
 80081fc:	4443      	add	r3, r8
 80081fe:	4293      	cmp	r3, r2
 8008200:	dc57      	bgt.n	80082b2 <MCPA_cfgLog+0xe6>
      pCfgData = &pCfgData[6]; /* Start of the HF IDs */
 8008202:	1d8e      	adds	r6, r1, #6
      {
        for (i = 0; i < (pHandle->HFNum + pHandle->MFNum); i++)
 8008204:	2b00      	cmp	r3, #0
 8008206:	d057      	beq.n	80082b8 <MCPA_cfgLog+0xec>
    uint16_t logSize = 0U; /* Max size of a log per iteration (HF+MF) */
 8008208:	f04f 0800 	mov.w	r8, #0
        for (i = 0; i < (pHandle->HFNum + pHandle->MFNum); i++)
 800820c:	4645      	mov	r5, r8
 800820e:	e011      	b.n	8008234 <MCPA_cfgLog+0x68>
        {
          newID = *((uint16_t *)pCfgData); //cstat !MISRAC2012-Rule-11.3
          (void)RI_GetPtrReg(newID, &pHandle->dataPtrTable[i]);
          /* HF Data are fixed to 2 bytes */
          pHandle->dataSizeTable[i] = (i < pHandle->HFNum ) ? 2U : RI_GetIDSize(newID);
 8008210:	68e3      	ldr	r3, [r4, #12]
 8008212:	5558      	strb	r0, [r3, r5]
          pCfgData++; /* Point to the next UID */
          pCfgData++;
          logSize = logSize+pHandle->dataSizeTable[i];
 8008214:	68e2      	ldr	r2, [r4, #12]
        for (i = 0; i < (pHandle->HFNum + pHandle->MFNum); i++)
 8008216:	f894 3023 	ldrb.w	r3, [r4, #35]	@ 0x23
 800821a:	f894 1027 	ldrb.w	r1, [r4, #39]	@ 0x27
          logSize = logSize+pHandle->dataSizeTable[i];
 800821e:	5d52      	ldrb	r2, [r2, r5]
        for (i = 0; i < (pHandle->HFNum + pHandle->MFNum); i++)
 8008220:	f105 0c01 	add.w	ip, r5, #1
 8008224:	fa5f f58c 	uxtb.w	r5, ip
 8008228:	440b      	add	r3, r1
          logSize = logSize+pHandle->dataSizeTable[i];
 800822a:	4442      	add	r2, r8
        for (i = 0; i < (pHandle->HFNum + pHandle->MFNum); i++)
 800822c:	429d      	cmp	r5, r3
          logSize = logSize+pHandle->dataSizeTable[i];
 800822e:	fa1f f882 	uxth.w	r8, r2
        for (i = 0; i < (pHandle->HFNum + pHandle->MFNum); i++)
 8008232:	da11      	bge.n	8008258 <MCPA_cfgLog+0x8c>
          newID = *((uint16_t *)pCfgData); //cstat !MISRAC2012-Rule-11.3
 8008234:	f836 9b02 	ldrh.w	r9, [r6], #2
          (void)RI_GetPtrReg(newID, &pHandle->dataPtrTable[i]);
 8008238:	6861      	ldr	r1, [r4, #4]
 800823a:	4648      	mov	r0, r9
 800823c:	eb01 0185 	add.w	r1, r1, r5, lsl #2
 8008240:	f7fb f9d0 	bl	80035e4 <RI_GetPtrReg>
          pHandle->dataSizeTable[i] = (i < pHandle->HFNum ) ? 2U : RI_GetIDSize(newID);
 8008244:	f894 3023 	ldrb.w	r3, [r4, #35]	@ 0x23
 8008248:	42ab      	cmp	r3, r5
 800824a:	f04f 0002 	mov.w	r0, #2
 800824e:	d8df      	bhi.n	8008210 <MCPA_cfgLog+0x44>
 8008250:	4648      	mov	r0, r9
 8008252:	f7fb f9bb 	bl	80035cc <RI_GetIDSize>
 8008256:	e7db      	b.n	8008210 <MCPA_cfgLog+0x44>
        }

        /* Smallest packet must be able to contain logSize Markbyte AsyncID and TimeStamp */
        if (buffSize < (logSize + 2U + 4U))
 8008258:	f108 0206 	add.w	r2, r8, #6
 800825c:	4297      	cmp	r7, r2
 800825e:	d210      	bcs.n	8008282 <MCPA_cfgLog+0xb6>
      result = MCP_ERROR_NO_TXASYNC_SPACE;
 8008260:	2009      	movs	r0, #9
    }
#ifdef NULL_PTR_CHECK_MCPA
  }
#endif
  return (result);
}
 8008262:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  if (pHandle->bufferIndex > 0U)
 8008266:	8b03      	ldrh	r3, [r0, #24]
  pHandle->Mark = 0U;
 8008268:	f880 7029 	strb.w	r7, [r0, #41]	@ 0x29
  if (pHandle->bufferIndex > 0U)
 800826c:	b9ab      	cbnz	r3, 800829a <MCPA_cfgLog+0xce>
  pHandle->bufferIndex = 0U;
 800826e:	2300      	movs	r3, #0
 8008270:	8323      	strh	r3, [r4, #24]
  pHandle->MarkBuff    = 0U;
 8008272:	f884 302a 	strb.w	r3, [r4, #42]	@ 0x2a
  pHandle->HFIndex     = 0U;
 8008276:	77e3      	strb	r3, [r4, #31]
  pHandle->HFRateBuff  = 0U; /* We do not want to miss any sample at the restart */
 8008278:	f884 3022 	strb.w	r3, [r4, #34]	@ 0x22
  uint8_t result = MCP_CMD_OK;
 800827c:	2000      	movs	r0, #0
}
 800827e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
          pHandle->bufferTxTrigger = buffSize-logSize - 2U; /* 2 is required to add the last Mark byte and NUL
 8008282:	3f02      	subs	r7, #2
 8008284:	eba7 0708 	sub.w	r7, r7, r8
 8008288:	8367      	strh	r7, [r4, #26]
          pHandle->Mark = *((uint8_t *)pCfgData);
 800828a:	7833      	ldrb	r3, [r6, #0]
 800828c:	f884 3029 	strb.w	r3, [r4, #41]	@ 0x29
          if (0U == pHandle->Mark)
 8008290:	2b00      	cmp	r3, #0
 8008292:	d1f3      	bne.n	800827c <MCPA_cfgLog+0xb0>
  if (pHandle->bufferIndex > 0U)
 8008294:	8b23      	ldrh	r3, [r4, #24]
 8008296:	2b00      	cmp	r3, #0
 8008298:	d0e9      	beq.n	800826e <MCPA_cfgLog+0xa2>
    logValue16 = (uint16_t *)&pHandle->currentBuffer[pHandle->bufferIndex]; //cstat !MISRAC2012-Rule-11.3
 800829a:	6961      	ldr	r1, [r4, #20]
    *logValue16 = pHandle->MarkBuff; /* MarkBuff is actually 8 bits, but we add also 8 bits of the ASYNCID=0 after
 800829c:	f894 202a 	ldrb.w	r2, [r4, #42]	@ 0x2a
 80082a0:	52ca      	strh	r2, [r1, r3]
    pHandle->pTransportLayer->fSendPacket (pHandle->pTransportLayer, pHandle->currentBuffer,
 80082a2:	8b22      	ldrh	r2, [r4, #24]
 80082a4:	6820      	ldr	r0, [r4, #0]
 80082a6:	3202      	adds	r2, #2
 80082a8:	6845      	ldr	r5, [r0, #4]
 80082aa:	b292      	uxth	r2, r2
 80082ac:	2309      	movs	r3, #9
 80082ae:	47a8      	blx	r5
 80082b0:	e7dd      	b.n	800826e <MCPA_cfgLog+0xa2>
        result = MCP_ERROR_BAD_RAW_FORMAT;
 80082b2:	200a      	movs	r0, #10
}
 80082b4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        for (i = 0; i < (pHandle->HFNum + pHandle->MFNum); i++)
 80082b8:	2206      	movs	r2, #6
    uint16_t logSize = 0U; /* Max size of a log per iteration (HF+MF) */
 80082ba:	4698      	mov	r8, r3
 80082bc:	e7ce      	b.n	800825c <MCPA_cfgLog+0x90>
 80082be:	bf00      	nop

080082c0 <NTC_SetFaultState>:
    hFault = MC_SW_ERROR;
  }
  else
  {
#endif
    if (pHandle->hSensitivity > 0 )
 80082c0:	f9b0 1010 	ldrsh.w	r1, [r0, #16]
    {
      if (pHandle->hAvTemp_d > pHandle->hOverTempThreshold)
 80082c4:	8843      	ldrh	r3, [r0, #2]
 80082c6:	8982      	ldrh	r2, [r0, #12]
    if (pHandle->hSensitivity > 0 )
 80082c8:	2900      	cmp	r1, #0
 80082ca:	dd08      	ble.n	80082de <NTC_SetFaultState+0x1e>
      if (pHandle->hAvTemp_d > pHandle->hOverTempThreshold)
 80082cc:	4293      	cmp	r3, r2
 80082ce:	d804      	bhi.n	80082da <NTC_SetFaultState+0x1a>
      {
        hFault = MC_OVER_TEMP;
      }
      else if (pHandle->hAvTemp_d < pHandle->hOverTempDeactThreshold)
 80082d0:	89c2      	ldrh	r2, [r0, #14]
 80082d2:	429a      	cmp	r2, r3
 80082d4:	d908      	bls.n	80082e8 <NTC_SetFaultState+0x28>
      {
        hFault = MC_NO_ERROR;
 80082d6:	2000      	movs	r0, #0
 80082d8:	4770      	bx	lr
    }
    else
    {
      if (pHandle->hAvTemp_d < pHandle->hOverTempThreshold)
      {
        hFault = MC_OVER_TEMP;
 80082da:	2008      	movs	r0, #8
    }
#ifdef NULL_PTR_CHECK_NTC_TEMP_SENS
  }
#endif
  return (hFault);
}
 80082dc:	4770      	bx	lr
      if (pHandle->hAvTemp_d < pHandle->hOverTempThreshold)
 80082de:	4293      	cmp	r3, r2
 80082e0:	d3fb      	bcc.n	80082da <NTC_SetFaultState+0x1a>
      else if (pHandle->hAvTemp_d > pHandle->hOverTempDeactThreshold)
 80082e2:	89c2      	ldrh	r2, [r0, #14]
 80082e4:	429a      	cmp	r2, r3
 80082e6:	d3f6      	bcc.n	80082d6 <NTC_SetFaultState+0x16>
        hFault = pHandle->hFaultState;
 80082e8:	8900      	ldrh	r0, [r0, #8]
 80082ea:	4770      	bx	lr

080082ec <NTC_Init>:
    /* Nothing to do */
  }
  else
  {
#endif
    if (REAL_SENSOR == pHandle->bSensorType)
 80082ec:	7803      	ldrb	r3, [r0, #0]
 80082ee:	b94b      	cbnz	r3, 8008304 <NTC_Init+0x18>
    /* nothing to do */
  }
  else
  {
#endif
    if (pHandle->hSensitivity > 0 ) 
 80082f0:	f9b0 3010 	ldrsh.w	r3, [r0, #16]
 80082f4:	2b00      	cmp	r3, #0
 80082f6:	bfcc      	ite	gt
 80082f8:	2300      	movgt	r3, #0
 80082fa:	2301      	movle	r3, #1
 80082fc:	425b      	negs	r3, r3
 80082fe:	b29b      	uxth	r3, r3
    {
      pHandle->hAvTemp_d = 0U;
    }
    else
    {
      pHandle->hAvTemp_d = 0xFFFFU;
 8008300:	8043      	strh	r3, [r0, #2]
}
 8008302:	4770      	bx	lr
      pHandle->hAvTemp_d = pHandle->hExpectedTemp_d;
 8008304:	8883      	ldrh	r3, [r0, #4]
      pHandle->hAvTemp_d = 0xFFFFU;
 8008306:	8043      	strh	r3, [r0, #2]
      pHandle->hFaultState = MC_NO_ERROR;
 8008308:	2200      	movs	r2, #0
 800830a:	8102      	strh	r2, [r0, #8]
}
 800830c:	4770      	bx	lr
 800830e:	bf00      	nop

08008310 <NTC_CalcAvTemp>:
  * @param pHandle : Pointer on Handle structure of TemperatureSensor component
  *
  * @retval Fault status : Error reported in case of an over temperature detection
  */
__weak uint16_t NTC_CalcAvTemp(NTC_Handle_t *pHandle, uint16_t rawValue)
{
 8008310:	b510      	push	{r4, lr}
    returnValue = 0U;
  }
  else
  {
#endif
    if (REAL_SENSOR == pHandle->bSensorType)
 8008312:	7803      	ldrb	r3, [r0, #0]
{
 8008314:	4604      	mov	r4, r0
    if (REAL_SENSOR == pHandle->bSensorType)
 8008316:	b983      	cbnz	r3, 800833a <NTC_CalcAvTemp+0x2a>
    {
      uint16_t hAux;
      hAux = rawValue;

      if (0xFFFFU == hAux)
 8008318:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 800831c:	4299      	cmp	r1, r3
 800831e:	d007      	beq.n	8008330 <NTC_CalcAvTemp+0x20>
        /* Nothing to do */
      }
      else
      {
        uint32_t wtemp;
        wtemp = (uint32_t)(pHandle->hLowPassFilterBW) - 1U;
 8008320:	8943      	ldrh	r3, [r0, #10]
        wtemp *= ((uint32_t)pHandle->hAvTemp_d);
 8008322:	8842      	ldrh	r2, [r0, #2]
        wtemp = (uint32_t)(pHandle->hLowPassFilterBW) - 1U;
 8008324:	1e58      	subs	r0, r3, #1
        wtemp += hAux;
 8008326:	fb00 1102 	mla	r1, r0, r2, r1
        wtemp /= ((uint32_t)pHandle->hLowPassFilterBW);
 800832a:	fbb1 f1f3 	udiv	r1, r1, r3

        pHandle->hAvTemp_d = (uint16_t)wtemp;
 800832e:	8061      	strh	r1, [r4, #2]
      }

      pHandle->hFaultState = NTC_SetFaultState(pHandle);
 8008330:	4620      	mov	r0, r4
 8008332:	f7ff ffc5 	bl	80082c0 <NTC_SetFaultState>
 8008336:	8120      	strh	r0, [r4, #8]
    returnValue = pHandle->hFaultState;
#ifdef NULL_PTR_CHECK_NTC_TEMP_SENS
  }
#endif
  return (returnValue);
}
 8008338:	bd10      	pop	{r4, pc}
 800833a:	2000      	movs	r0, #0
      pHandle->hFaultState = NTC_SetFaultState(pHandle);
 800833c:	8120      	strh	r0, [r4, #8]
}
 800833e:	bd10      	pop	{r4, pc}

08008340 <NTC_GetAvTemp_C>:
  else
  {
#endif
    int32_t wTemp;

    if (REAL_SENSOR == pHandle->bSensorType)
 8008340:	7803      	ldrb	r3, [r0, #0]
 8008342:	b95b      	cbnz	r3, 800835c <NTC_GetAvTemp_C+0x1c>
    {
      wTemp = (int32_t)pHandle->hAvTemp_d;
 8008344:	8842      	ldrh	r2, [r0, #2]
      wTemp -= ((int32_t)pHandle->wV0);
 8008346:	6941      	ldr	r1, [r0, #20]
      wTemp *= pHandle->hSensitivity;
 8008348:	f9b0 3010 	ldrsh.w	r3, [r0, #16]
#ifndef FULL_MISRA_C_COMPLIANCY_NTC_TEMP
      //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
      wTemp = (wTemp >> 16) + (int32_t)pHandle->hT0;
 800834c:	8b00      	ldrh	r0, [r0, #24]
      wTemp -= ((int32_t)pHandle->wV0);
 800834e:	1a52      	subs	r2, r2, r1
      wTemp *= pHandle->hSensitivity;
 8008350:	fb02 f303 	mul.w	r3, r2, r3
      wTemp = (wTemp >> 16) + (int32_t)pHandle->hT0;
 8008354:	eb00 4023 	add.w	r0, r0, r3, asr #16
    returnValue = (int16_t)wTemp;
#ifdef NULL_PTR_CHECK_NTC_TEMP_SENS
  }
#endif
  return (returnValue);
}
 8008358:	b200      	sxth	r0, r0
 800835a:	4770      	bx	lr
      wTemp = (int32_t)pHandle->hExpectedTemp_C;
 800835c:	88c0      	ldrh	r0, [r0, #6]
}
 800835e:	b200      	sxth	r0, r0
 8008360:	4770      	bx	lr
 8008362:	bf00      	nop

08008364 <OL_Init>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->hVoltage = pHandle->hDefaultVoltage;
 8008364:	8803      	ldrh	r3, [r0, #0]
 8008366:	8103      	strh	r3, [r0, #8]
    pHandle->pVSS = pVSS;
 8008368:	60c1      	str	r1, [r0, #12]
#ifdef NULL_PTR_CHECK_OPEN_LOOP
  }
#endif
}
 800836a:	4770      	bx	lr

0800836c <OL_VqdConditioning>:
  Vqd.q = ((MC_NULL == pHandle) ? 0 : pHandle->hVoltage);
#else
  Vqd.q = (pHandle->hVoltage);
#endif
  return (Vqd);
}
 800836c:	8900      	ldrh	r0, [r0, #8]
{
 800836e:	b082      	sub	sp, #8
}
 8008370:	b002      	add	sp, #8
 8008372:	4770      	bx	lr

08008374 <OL_Calc>:
    /* Nothing to do */
  }
  else
  {
#endif
    if (true ==  pHandle->VFMode)
 8008374:	7883      	ldrb	r3, [r0, #2]
 8008376:	b173      	cbz	r3, 8008396 <OL_Calc+0x22>
    {
      /* V/F mode true means enabled */
      if (pHandle->pVSS->_Super.hAvrMecSpeedUnit >= 0)
 8008378:	68c2      	ldr	r2, [r0, #12]
      {
        pHandle->hVoltage = pHandle->hVFOffset + (pHandle->hVFSlope * pHandle->pVSS->_Super.hAvrMecSpeedUnit);
 800837a:	88c3      	ldrh	r3, [r0, #6]
      if (pHandle->pVSS->_Super.hAvrMecSpeedUnit >= 0)
 800837c:	f9b2 100c 	ldrsh.w	r1, [r2, #12]
        pHandle->hVoltage = pHandle->hVFOffset + (pHandle->hVFSlope * pHandle->pVSS->_Super.hAvrMecSpeedUnit);
 8008380:	8882      	ldrh	r2, [r0, #4]
 8008382:	fb13 f301 	smulbb	r3, r3, r1
      if (pHandle->pVSS->_Super.hAvrMecSpeedUnit >= 0)
 8008386:	2900      	cmp	r1, #0
        pHandle->hVoltage = pHandle->hVFOffset + (pHandle->hVFSlope * pHandle->pVSS->_Super.hAvrMecSpeedUnit);
 8008388:	b29b      	uxth	r3, r3
      if (pHandle->pVSS->_Super.hAvrMecSpeedUnit >= 0)
 800838a:	db02      	blt.n	8008392 <OL_Calc+0x1e>
        pHandle->hVoltage = pHandle->hVFOffset + (pHandle->hVFSlope * pHandle->pVSS->_Super.hAvrMecSpeedUnit);
 800838c:	441a      	add	r2, r3
 800838e:	8102      	strh	r2, [r0, #8]
 8008390:	4770      	bx	lr
      }
      else
      {
        pHandle->hVoltage = pHandle->hVFOffset - (pHandle->hVFSlope * pHandle->pVSS->_Super.hAvrMecSpeedUnit);
 8008392:	1ad2      	subs	r2, r2, r3
 8008394:	8102      	strh	r2, [r0, #8]
      /* Nothing to do */
    }
#ifdef NULL_PTR_CHECK_OPEN_LOOP
  }
#endif
}
 8008396:	4770      	bx	lr

08008398 <PID_HandleInit>:
  {
#endif
    pHandle->hKpGain =  pHandle->hDefKpGain;
    pHandle->hKiGain =  pHandle->hDefKiGain;
    pHandle->hKdGain =  pHandle->hDefKdGain;
    pHandle->wIntegralTerm = 0;
 8008398:	2300      	movs	r3, #0
    pHandle->hKpGain =  pHandle->hDefKpGain;
 800839a:	6801      	ldr	r1, [r0, #0]
    pHandle->hKdGain =  pHandle->hDefKdGain;
 800839c:	8c02      	ldrh	r2, [r0, #32]
    pHandle->hKpGain =  pHandle->hDefKpGain;
 800839e:	6041      	str	r1, [r0, #4]
    pHandle->hKdGain =  pHandle->hDefKdGain;
 80083a0:	8442      	strh	r2, [r0, #34]	@ 0x22
    pHandle->wIntegralTerm = 0;
 80083a2:	6083      	str	r3, [r0, #8]
    pHandle->wPrevProcessVarError = 0;
 80083a4:	6283      	str	r3, [r0, #40]	@ 0x28
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 80083a6:	4770      	bx	lr

080083a8 <PID_SetKP>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->hKpGain = hKpGain;
 80083a8:	8081      	strh	r1, [r0, #4]
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 80083aa:	4770      	bx	lr

080083ac <PID_SetKI>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->hKiGain = hKiGain;
 80083ac:	80c1      	strh	r1, [r0, #6]
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 80083ae:	4770      	bx	lr

080083b0 <PID_GetKP>:
#ifdef NULL_PTR_CHECK_PID_REG
  return ((MC_NULL == pHandle) ? 0 : pHandle->hKpGain);
#else
  return (pHandle->hKpGain);
#endif
}
 80083b0:	f9b0 0004 	ldrsh.w	r0, [r0, #4]
 80083b4:	4770      	bx	lr
 80083b6:	bf00      	nop

080083b8 <PID_GetKI>:
#ifdef NULL_PTR_CHECK_PID_REG
  return ((MC_NULL == pHandle) ? 0 : pHandle->hKiGain);
#else
  return (pHandle->hKiGain);
#endif
}
 80083b8:	f9b0 0006 	ldrsh.w	r0, [r0, #6]
 80083bc:	4770      	bx	lr
 80083be:	bf00      	nop

080083c0 <PID_SetIntegralTerm>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->wIntegralTerm = wIntegralTermValue;
 80083c0:	6081      	str	r1, [r0, #8]
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
  return;
}
 80083c2:	4770      	bx	lr

080083c4 <PID_GetKPDivisorPOW2>:
#ifdef NULL_PTR_CHECK_PID_REG
  return ((MC_NULL == pHandle) ? 0U : pHandle->hKpDivisorPOW2);
#else
  return (pHandle->hKpDivisorPOW2);
#endif
}
 80083c4:	8b80      	ldrh	r0, [r0, #28]
 80083c6:	4770      	bx	lr

080083c8 <PID_SetKPDivisorPOW2>:
  }
  else
  {
#endif
    pHandle->hKpDivisorPOW2 = hKpDivisorPOW2;
    pHandle->hKpDivisor = (((uint16_t)1) << hKpDivisorPOW2);
 80083c8:	2301      	movs	r3, #1
 80083ca:	408b      	lsls	r3, r1
    pHandle->hKpDivisorPOW2 = hKpDivisorPOW2;
 80083cc:	8381      	strh	r1, [r0, #28]
    pHandle->hKpDivisor = (((uint16_t)1) << hKpDivisorPOW2);
 80083ce:	8303      	strh	r3, [r0, #24]
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 80083d0:	4770      	bx	lr
 80083d2:	bf00      	nop

080083d4 <PID_GetKIDivisor>:
#ifdef NULL_PTR_CHECK_PID_REG
  return ((MC_NULL == pHandle) ? 0U : pHandle->hKiDivisor);
#else
  return (pHandle->hKiDivisor);
#endif
}
 80083d4:	8b40      	ldrh	r0, [r0, #26]
 80083d6:	4770      	bx	lr

080083d8 <PID_GetKIDivisorPOW2>:
#ifdef NULL_PTR_CHECK_PID_REG
  return ((MC_NULL == pHandle) ? 0U : pHandle->hKiDivisorPOW2);
#else
  return (pHandle->hKiDivisorPOW2);
#endif
}
 80083d8:	8bc0      	ldrh	r0, [r0, #30]
 80083da:	4770      	bx	lr

080083dc <PID_SetLowerIntegralTermLimit>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->wLowerIntegralLimit = wLowerLimit;
 80083dc:	6101      	str	r1, [r0, #16]
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 80083de:	4770      	bx	lr

080083e0 <PID_SetUpperIntegralTermLimit>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->wUpperIntegralLimit = wUpperLimit;
 80083e0:	60c1      	str	r1, [r0, #12]
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 80083e2:	4770      	bx	lr

080083e4 <PID_SetKIDivisorPOW2>:
{
 80083e4:	b538      	push	{r3, r4, r5, lr}
    uint32_t wKiDiv = (((uint32_t)1) << hKiDivisorPOW2);
 80083e6:	2301      	movs	r3, #1
{
 80083e8:	460c      	mov	r4, r1
    uint32_t wKiDiv = (((uint32_t)1) << hKiDivisorPOW2);
 80083ea:	408b      	lsls	r3, r1
    PID_SetUpperIntegralTermLimit(pHandle, (int32_t)INT16_MAX * (int32_t)wKiDiv);
 80083ec:	f647 71ff 	movw	r1, #32767	@ 0x7fff
 80083f0:	40a1      	lsls	r1, r4
    pHandle->hKiDivisorPOW2 = hKiDivisorPOW2;
 80083f2:	83c4      	strh	r4, [r0, #30]
    pHandle->hKiDivisor = (uint16_t)wKiDiv;
 80083f4:	8343      	strh	r3, [r0, #26]
{
 80083f6:	4605      	mov	r5, r0
    PID_SetUpperIntegralTermLimit(pHandle, (int32_t)INT16_MAX * (int32_t)wKiDiv);
 80083f8:	f7ff fff2 	bl	80083e0 <PID_SetUpperIntegralTermLimit>
    PID_SetLowerIntegralTermLimit(pHandle, (int32_t)(-INT16_MAX) * (int32_t)wKiDiv);
 80083fc:	4902      	ldr	r1, [pc, #8]	@ (8008408 <PID_SetKIDivisorPOW2+0x24>)
 80083fe:	4628      	mov	r0, r5
 8008400:	40a1      	lsls	r1, r4
 8008402:	f7ff ffeb 	bl	80083dc <PID_SetLowerIntegralTermLimit>
}
 8008406:	bd38      	pop	{r3, r4, r5, pc}
 8008408:	ffff8001 	.word	0xffff8001

0800840c <PID_SetKD>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->hKdGain = hKdGain;
 800840c:	8441      	strh	r1, [r0, #34]	@ 0x22
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 800840e:	4770      	bx	lr

08008410 <PID_GetKD>:
#ifdef NULL_PTR_CHECK_PID_REG
  return ((MC_NULL == pHandle) ? 0 : pHandle->hKdGain);
#else
  return (pHandle->hKdGain);
#endif
}
 8008410:	f9b0 0022 	ldrsh.w	r0, [r0, #34]	@ 0x22
 8008414:	4770      	bx	lr
 8008416:	bf00      	nop

08008418 <PID_GetKDDivisorPOW2>:
#ifdef NULL_PTR_CHECK_PID_REG
  return ((MC_NULL == pHandle) ? 0U : pHandle->hKdDivisorPOW2);
#else
  return (pHandle->hKdDivisorPOW2);
#endif
}
 8008418:	8cc0      	ldrh	r0, [r0, #38]	@ 0x26
 800841a:	4770      	bx	lr

0800841c <PID_SetKDDivisorPOW2>:
  }
  else
  {
#endif
    pHandle->hKdDivisorPOW2 = hKdDivisorPOW2;
    pHandle->hKdDivisor = (((uint16_t)1) << hKdDivisorPOW2);
 800841c:	2301      	movs	r3, #1
 800841e:	408b      	lsls	r3, r1
    pHandle->hKdDivisorPOW2 = hKdDivisorPOW2;
 8008420:	84c1      	strh	r1, [r0, #38]	@ 0x26
    pHandle->hKdDivisor = (((uint16_t)1) << hKdDivisorPOW2);
 8008422:	8483      	strh	r3, [r0, #36]	@ 0x24
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 8008424:	4770      	bx	lr
 8008426:	bf00      	nop

08008428 <PI_Controller>:
    int32_t wDischarge = 0;
    int16_t hUpperOutputLimit = pHandle->hUpperOutputLimit;
    int16_t hLowerOutputLimit = pHandle->hLowerOutputLimit;

    /* Proportional term computation*/
    wProportional_Term = pHandle->hKpGain * wProcessVarError;
 8008428:	f9b0 2004 	ldrsh.w	r2, [r0, #4]
{
 800842c:	4603      	mov	r3, r0
 800842e:	b530      	push	{r4, r5, lr}

    /* Integral term computation */
    if (0 == pHandle->hKiGain)
 8008430:	f9b0 4006 	ldrsh.w	r4, [r0, #6]
    int16_t hLowerOutputLimit = pHandle->hLowerOutputLimit;
 8008434:	f9b3 c016 	ldrsh.w	ip, [r3, #22]
    int16_t hUpperOutputLimit = pHandle->hUpperOutputLimit;
 8008438:	f9b0 0014 	ldrsh.w	r0, [r0, #20]
    wProportional_Term = pHandle->hKpGain * wProcessVarError;
 800843c:	fb01 f202 	mul.w	r2, r1, r2
    if (0 == pHandle->hKiGain)
 8008440:	b17c      	cbz	r4, 8008462 <PI_Controller+0x3a>
    {
      pHandle->wIntegralTerm = 0;
    }
    else
    {
      wIntegral_Term = pHandle->hKiGain * wProcessVarError;
 8008442:	fb04 f101 	mul.w	r1, r4, r1
        {
          /* Nothing to do */
        }
      }

      if (wIntegral_sum_temp > pHandle->wUpperIntegralLimit)
 8008446:	e9d3 5402 	ldrd	r5, r4, [r3, #8]
      if (wIntegral_sum_temp < 0)
 800844a:	eb15 0e01 	adds.w	lr, r5, r1
 800844e:	d41d      	bmi.n	800848c <PI_Controller+0x64>
            wIntegral_sum_temp = -INT32_MAX;
 8008450:	420d      	tst	r5, r1
 8008452:	4914      	ldr	r1, [pc, #80]	@ (80084a4 <PI_Controller+0x7c>)
 8008454:	bf48      	it	mi
 8008456:	468e      	movmi	lr, r1
      if (wIntegral_sum_temp > pHandle->wUpperIntegralLimit)
 8008458:	45a6      	cmp	lr, r4
 800845a:	dc02      	bgt.n	8008462 <PI_Controller+0x3a>
      {
        pHandle->wIntegralTerm = pHandle->wUpperIntegralLimit;
      }
      else if (wIntegral_sum_temp < pHandle->wLowerIntegralLimit)
 800845c:	691c      	ldr	r4, [r3, #16]
 800845e:	4574      	cmp	r4, lr
 8008460:	dd1d      	ble.n	800849e <PI_Controller+0x76>
    /* WARNING: the below instruction is not MISRA compliant, user should verify
               that Cortex-M3 assembly instruction ASR (arithmetic shift right)
               is used by the compiler to perform the shifts (instead of LSR
               logical shift right)*/
    //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
    wOutput_32 = (wProportional_Term >> pHandle->hKpDivisorPOW2) + (pHandle->wIntegralTerm >> pHandle->hKiDivisorPOW2);
 8008462:	8b99      	ldrh	r1, [r3, #28]
 8008464:	410a      	asrs	r2, r1
 8008466:	8bd9      	ldrh	r1, [r3, #30]
 8008468:	fa44 f101 	asr.w	r1, r4, r1
 800846c:	440a      	add	r2, r1
#else
    wOutput_32 = (wProportional_Term / (int32_t)pHandle->hKpDivisor)
              + (pHandle->wIntegralTerm / (int32_t)pHandle->hKiDivisor);
#endif

    if (wOutput_32 > hUpperOutputLimit)
 800846e:	4290      	cmp	r0, r2
 8008470:	da03      	bge.n	800847a <PI_Controller+0x52>
    {
      wDischarge = hUpperOutputLimit - wOutput_32;
 8008472:	1a82      	subs	r2, r0, r2
    else
    {
      /* Nothing to do here */
    }

    pHandle->wIntegralTerm += wDischarge;
 8008474:	4414      	add	r4, r2
 8008476:	609c      	str	r4, [r3, #8]
    returnValue = (int16_t)wOutput_32;
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
  return (returnValue);
}
 8008478:	bd30      	pop	{r4, r5, pc}
    else if (wOutput_32 < hLowerOutputLimit)
 800847a:	4594      	cmp	ip, r2
      wDischarge = hLowerOutputLimit - wOutput_32;
 800847c:	bfc5      	ittet	gt
 800847e:	ebac 0202 	subgt.w	r2, ip, r2
    pHandle->wIntegralTerm += wDischarge;
 8008482:	18a4      	addgt	r4, r4, r2
    returnValue = (int16_t)wOutput_32;
 8008484:	b210      	sxthle	r0, r2
      wOutput_32 = hLowerOutputLimit;
 8008486:	4660      	movgt	r0, ip
    pHandle->wIntegralTerm += wDischarge;
 8008488:	609c      	str	r4, [r3, #8]
}
 800848a:	bd30      	pop	{r4, r5, pc}
        if (pHandle->wIntegralTerm > 0)
 800848c:	2d00      	cmp	r5, #0
 800848e:	dde3      	ble.n	8008458 <PI_Controller+0x30>
          if (wIntegral_Term > 0)
 8008490:	2900      	cmp	r1, #0
 8008492:	dde1      	ble.n	8008458 <PI_Controller+0x30>
      if (wIntegral_sum_temp > pHandle->wUpperIntegralLimit)
 8008494:	f06f 4100 	mvn.w	r1, #2147483648	@ 0x80000000
 8008498:	428c      	cmp	r4, r1
 800849a:	d1e2      	bne.n	8008462 <PI_Controller+0x3a>
 800849c:	46a6      	mov	lr, r4
        pHandle->wIntegralTerm = wIntegral_sum_temp;
 800849e:	4674      	mov	r4, lr
 80084a0:	e7df      	b.n	8008462 <PI_Controller+0x3a>
 80084a2:	bf00      	nop
 80084a4:	80000001 	.word	0x80000001

080084a8 <PQD_CalcElMotorPower>:
  }
  else
  {
#endif
    int32_t wAux;
    qd_t Iqd = pHandle->pFOCVars->Iqd;
 80084a8:	6882      	ldr	r2, [r0, #8]
{
 80084aa:	b500      	push	{lr}
    qd_t Vqd = pHandle->pFOCVars->Vqd;

    wAux = ((int32_t)Iqd.q * (int32_t)Vqd.q)
         + ((int32_t)Iqd.d * (int32_t)Vqd.d);
 80084ac:	89d1      	ldrh	r1, [r2, #14]
 80084ae:	f8b2 e018 	ldrh.w	lr, [r2, #24]
    wAux = ((int32_t)Iqd.q * (int32_t)Vqd.q)
 80084b2:	8993      	ldrh	r3, [r2, #12]
 80084b4:	f8b2 c016 	ldrh.w	ip, [r2, #22]
         + ((int32_t)Iqd.d * (int32_t)Vqd.d);
 80084b8:	fb11 f20e 	smulbb	r2, r1, lr
    wAux /= 65536;
 80084bc:	fb13 230c 	smlabb	r3, r3, ip, r2
 80084c0:	2b00      	cmp	r3, #0

    /* pHandle->hAvrgElMotorPower += (wAux - pHandle->hAvrgElMotorPower) >> 4 */
    pHandle->hAvrgElMotorPower += (int16_t)((wAux - (int32_t)pHandle->hAvrgElMotorPower) / 16);
 80084c2:	f9b0 2000 	ldrsh.w	r2, [r0]
    wAux /= 65536;
 80084c6:	bfbc      	itt	lt
 80084c8:	f503 437f 	addlt.w	r3, r3, #65280	@ 0xff00
 80084cc:	33ff      	addlt	r3, #255	@ 0xff
    pHandle->hAvrgElMotorPower += (int16_t)((wAux - (int32_t)pHandle->hAvrgElMotorPower) / 16);
 80084ce:	ebd2 4323 	rsbs	r3, r2, r3, asr #16
 80084d2:	bf48      	it	mi
 80084d4:	330f      	addmi	r3, #15
 80084d6:	eb02 1223 	add.w	r2, r2, r3, asr #4
 80084da:	8002      	strh	r2, [r0, #0]

#ifdef NULL_PTR_CHECK_PQD_MOT_POW_MEAS
  }
#endif
}
 80084dc:	f85d fb04 	ldr.w	pc, [sp], #4

080084e0 <PQD_GetAvrgElMotorPowerW>:
  * 
  * @param pHandle pointer on the related component instance.
  * @retval float_t The average measured motor power expressed in Watts.
  */
__weak float_t PQD_GetAvrgElMotorPowerW(const PQD_MotorPowMeas_Handle_t *pHandle)
{
 80084e0:	b510      	push	{r4, lr}
  else
  {
#endif

  /* First perform an integer multiplication, then a float one. */
  PowerW = ((float_t)pHandle->hAvrgElMotorPower * (float_t)VBS_GetAvBusVoltage_V(pHandle->pVBS)) * pHandle->ConvFact;
 80084e2:	f9b0 3000 	ldrsh.w	r3, [r0]
 80084e6:	ee07 3a90 	vmov	s15, r3
{
 80084ea:	ed2d 8b02 	vpush	{d8}
 80084ee:	4604      	mov	r4, r0
  PowerW = ((float_t)pHandle->hAvrgElMotorPower * (float_t)VBS_GetAvBusVoltage_V(pHandle->pVBS)) * pHandle->ConvFact;
 80084f0:	68c0      	ldr	r0, [r0, #12]
 80084f2:	eeb8 8ae7 	vcvt.f32.s32	s16, s15
 80084f6:	f7ff fd47 	bl	8007f88 <VBS_GetAvBusVoltage_V>
 80084fa:	edd4 7a01 	vldr	s15, [r4, #4]
 80084fe:	ee68 7a27 	vmul.f32	s15, s16, s15

#ifdef NULL_PTR_CHECK_PQD_MOT_POW_MEAS
  }
#endif
  return (PowerW);
}
 8008502:	ecbd 8b02 	vpop	{d8}
  PowerW = ((float_t)pHandle->hAvrgElMotorPower * (float_t)VBS_GetAvBusVoltage_V(pHandle->pVBS)) * pHandle->ConvFact;
 8008506:	ee00 0a10 	vmov	s0, r0
 800850a:	eeb8 0a40 	vcvt.f32.u32	s0, s0
}
 800850e:	ee27 0a80 	vmul.f32	s0, s15, s0
 8008512:	bd10      	pop	{r4, pc}

08008514 <R3_1_GetPhaseCurrents>:
  * @brief  Computes and stores in the handler the latest converted motor phase currents in ab_t format.
  *
  */
__weak void R3_1_GetPhaseCurrents(PWMC_Handle_t *pHdl, ab_t *Iab)
{
  if (MC_NULL == Iab)
 8008514:	b1c1      	cbz	r1, 8008548 <R3_1_GetPhaseCurrents+0x34>

    PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl;  //cstat !MISRAC2012-Rule-11.3
#if defined (__ICCARM__)
  #pragma cstat_restore = "MISRAC2012-Rule-11.3"
#endif /* __ICCARM__ */
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8008516:	f8d0 209c 	ldr.w	r2, [r0, #156]	@ 0x9c
{
 800851a:	b470      	push	{r4, r5, r6}
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 800851c:	e9d2 3400 	ldrd	r3, r4, [r2]
    ADC_TypeDef * ADCx = pHandle->pParams_str->ADCx;
    uint8_t Sector;

    Sector = (uint8_t)pHandle->_Super.Sector;
    ADCDataReg1 = ADCx->JDR1;
 8008520:	f8d3 5080 	ldr.w	r5, [r3, #128]	@ 0x80
    ADCDataReg2 = ADCx->JDR2;
 8008524:	f8d3 6084 	ldr.w	r6, [r3, #132]	@ 0x84
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 8008528:	6863      	ldr	r3, [r4, #4]
    Sector = (uint8_t)pHandle->_Super.Sector;
 800852a:	f890 207a 	ldrb.w	r2, [r0, #122]	@ 0x7a
 800852e:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
 8008532:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 8008536:	6063      	str	r3, [r4, #4]

    /* disable ADC trigger source */
    /* LL_TIM_CC_DisableChannel(TIMx, LL_TIM_CHANNEL_CH4) */
    LL_TIM_SetTriggerOutput(TIMx, LL_TIM_TRGO_RESET);

    switch (Sector)
 8008538:	2a05      	cmp	r2, #5
 800853a:	f200 809e 	bhi.w	800867a <R3_1_GetPhaseCurrents+0x166>
 800853e:	e8df f002 	tbb	[pc, r2]
 8008542:	1f11      	.short	0x1f11
 8008544:	1104041f 	.word	0x1104041f
 8008548:	4770      	bx	lr
      case SECTOR_4:
      case SECTOR_5:
      {
        /* Current on Phase C is not accessible     */
        /* Ia = PhaseAOffset - ADC converted value) */
        Aux = (int32_t)(pHandle->PhaseAOffset) - (int32_t)(ADCDataReg1);
 800854a:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88

        /* Saturation of Ia */
        if (Aux < -INT16_MAX)
 800854e:	4a4e      	ldr	r2, [pc, #312]	@ (8008688 <R3_1_GetPhaseCurrents+0x174>)
        Aux = (int32_t)(pHandle->PhaseAOffset) - (int32_t)(ADCDataReg1);
 8008550:	1b5b      	subs	r3, r3, r5
        if (Aux < -INT16_MAX)
 8008552:	4293      	cmp	r3, r2
 8008554:	db22      	blt.n	800859c <R3_1_GetPhaseCurrents+0x88>
        {
          Iab->a = -INT16_MAX;
        }
        else  if (Aux > INT16_MAX)
 8008556:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 800855a:	f2c0 808b 	blt.w	8008674 <R3_1_GetPhaseCurrents+0x160>
 800855e:	f647 7cff 	movw	ip, #32767	@ 0x7fff
 8008562:	e01c      	b.n	800859e <R3_1_GetPhaseCurrents+0x8a>
      case SECTOR_6:
      case SECTOR_1:
      {
        /* Current on Phase A is not accessible     */
        /* Ib = PhaseBOffset - ADC converted value) */
        Aux = (int32_t)(pHandle->PhaseBOffset) - (int32_t)(ADCDataReg1);
 8008564:	f8d0 408c 	ldr.w	r4, [r0, #140]	@ 0x8c

        /* Saturation of Ib */
        if (Aux < -INT16_MAX)
 8008568:	4b47      	ldr	r3, [pc, #284]	@ (8008688 <R3_1_GetPhaseCurrents+0x174>)
        Aux = (int32_t)(pHandle->PhaseBOffset) - (int32_t)(ADCDataReg1);
 800856a:	1b64      	subs	r4, r4, r5
        if (Aux < -INT16_MAX)
 800856c:	429c      	cmp	r4, r3
 800856e:	db2d      	blt.n	80085cc <R3_1_GetPhaseCurrents+0xb8>
        {
          Iab->b = -INT16_MAX;
        }
        else  if (Aux > INT16_MAX)
 8008570:	f5b4 4f00 	cmp.w	r4, #32768	@ 0x8000
 8008574:	db7b      	blt.n	800866e <R3_1_GetPhaseCurrents+0x15a>
 8008576:	f647 72ff 	movw	r2, #32767	@ 0x7fff
 800857a:	4614      	mov	r4, r2
 800857c:	4615      	mov	r5, r2
 800857e:	e029      	b.n	80085d4 <R3_1_GetPhaseCurrents+0xc0>
      case SECTOR_2:
      case SECTOR_3:
      {
        /* Current on Phase B is not accessible     */
        /* Ia = PhaseAOffset - ADC converted value) */
        Aux = (int32_t)(pHandle->PhaseAOffset) - (int32_t)(ADCDataReg1);
 8008580:	f8d0 4088 	ldr.w	r4, [r0, #136]	@ 0x88

        /* Saturation of Ia */
        if (Aux < -INT16_MAX)
 8008584:	4b40      	ldr	r3, [pc, #256]	@ (8008688 <R3_1_GetPhaseCurrents+0x174>)
        Aux = (int32_t)(pHandle->PhaseAOffset) - (int32_t)(ADCDataReg1);
 8008586:	1b64      	subs	r4, r4, r5
        if (Aux < -INT16_MAX)
 8008588:	429c      	cmp	r4, r3
 800858a:	db30      	blt.n	80085ee <R3_1_GetPhaseCurrents+0xda>
        {
          Iab->a = -INT16_MAX;
        }
        else  if (Aux > INT16_MAX)
 800858c:	f5b4 4f00 	cmp.w	r4, #32768	@ 0x8000
 8008590:	db69      	blt.n	8008666 <R3_1_GetPhaseCurrents+0x152>
 8008592:	f647 73ff 	movw	r3, #32767	@ 0x7fff
 8008596:	461c      	mov	r4, r3
 8008598:	469c      	mov	ip, r3
 800859a:	e02c      	b.n	80085f6 <R3_1_GetPhaseCurrents+0xe2>
 800859c:	4694      	mov	ip, r2
        Aux = (int32_t)(pHandle->PhaseBOffset) - (int32_t)(ADCDataReg2);
 800859e:	f8d0 208c 	ldr.w	r2, [r0, #140]	@ 0x8c
        if (Aux < -INT16_MAX)
 80085a2:	4d39      	ldr	r5, [pc, #228]	@ (8008688 <R3_1_GetPhaseCurrents+0x174>)
          Iab->a = -INT16_MAX;
 80085a4:	f8a1 c000 	strh.w	ip, [r1]
        Aux = (int32_t)(pHandle->PhaseBOffset) - (int32_t)(ADCDataReg2);
 80085a8:	1b92      	subs	r2, r2, r6
        if (Aux < -INT16_MAX)
 80085aa:	42aa      	cmp	r2, r5
 80085ac:	da31      	bge.n	8008612 <R3_1_GetPhaseCurrents+0xfe>
          Iab->b = -INT16_MAX;
 80085ae:	804d      	strh	r5, [r1, #2]
        break;
    }

    pHandle->_Super.Ia = Iab->a;
    pHandle->_Super.Ib = Iab->b;
    pHandle->_Super.Ic = -Iab->a - Iab->b;
 80085b0:	fa1f f38c 	uxth.w	r3, ip
 80085b4:	f248 0201 	movw	r2, #32769	@ 0x8001
 80085b8:	4413      	add	r3, r2
 80085ba:	425b      	negs	r3, r3
    pHandle->_Super.Ib = Iab->b;
 80085bc:	f8a0 5064 	strh.w	r5, [r0, #100]	@ 0x64
    pHandle->_Super.Ia = Iab->a;
 80085c0:	f8a0 c062 	strh.w	ip, [r0, #98]	@ 0x62
  }
}
 80085c4:	bc70      	pop	{r4, r5, r6}
    pHandle->_Super.Ic = -Iab->a - Iab->b;
 80085c6:	f8a0 3066 	strh.w	r3, [r0, #102]	@ 0x66
}
 80085ca:	4770      	bx	lr
 80085cc:	461c      	mov	r4, r3
 80085ce:	f248 0201 	movw	r2, #32769	@ 0x8001
 80085d2:	461d      	mov	r5, r3
        Aux = (int32_t)(ADCDataReg2) - (int32_t)(pHandle->PhaseCOffset); /* -Ic */
 80085d4:	f8d0 3090 	ldr.w	r3, [r0, #144]	@ 0x90
          Iab->b = -INT16_MAX;
 80085d8:	804d      	strh	r5, [r1, #2]
        Aux = (int32_t)(ADCDataReg2) - (int32_t)(pHandle->PhaseCOffset); /* -Ic */
 80085da:	1af3      	subs	r3, r6, r3
        Aux -= (int32_t)Iab->b;             /* Ia  */
 80085dc:	1b1b      	subs	r3, r3, r4
        if (Aux > INT16_MAX)
 80085de:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 80085e2:	db21      	blt.n	8008628 <R3_1_GetPhaseCurrents+0x114>
          Iab->a = INT16_MAX;
 80085e4:	f647 73ff 	movw	r3, #32767	@ 0x7fff
 80085e8:	800b      	strh	r3, [r1, #0]
 80085ea:	469c      	mov	ip, r3
 80085ec:	e7e4      	b.n	80085b8 <R3_1_GetPhaseCurrents+0xa4>
 80085ee:	461c      	mov	r4, r3
 80085f0:	46a4      	mov	ip, r4
 80085f2:	f248 0301 	movw	r3, #32769	@ 0x8001
        Aux = (int32_t)(ADCDataReg2) - (int32_t)(pHandle->PhaseCOffset); /* -Ic */
 80085f6:	f8d0 2090 	ldr.w	r2, [r0, #144]	@ 0x90
          Iab->a = -INT16_MAX;
 80085fa:	f8a1 c000 	strh.w	ip, [r1]
        Aux = (int32_t)(ADCDataReg2) - (int32_t)(pHandle->PhaseCOffset); /* -Ic */
 80085fe:	1ab2      	subs	r2, r6, r2
        Aux -= (int32_t)Iab->a;             /* Ib */
 8008600:	1b12      	subs	r2, r2, r4
        if (Aux > INT16_MAX)
 8008602:	f5b2 4f00 	cmp.w	r2, #32768	@ 0x8000
 8008606:	db17      	blt.n	8008638 <R3_1_GetPhaseCurrents+0x124>
          Iab->b = INT16_MAX;
 8008608:	f647 72ff 	movw	r2, #32767	@ 0x7fff
 800860c:	804a      	strh	r2, [r1, #2]
 800860e:	4615      	mov	r5, r2
 8008610:	e7d2      	b.n	80085b8 <R3_1_GetPhaseCurrents+0xa4>
        else  if (Aux > INT16_MAX)
 8008612:	f5b2 4f00 	cmp.w	r2, #32768	@ 0x8000
 8008616:	db20      	blt.n	800865a <R3_1_GetPhaseCurrents+0x146>
          Iab->b = INT16_MAX;
 8008618:	f647 73ff 	movw	r3, #32767	@ 0x7fff
 800861c:	461a      	mov	r2, r3
 800861e:	804b      	strh	r3, [r1, #2]
 8008620:	4615      	mov	r5, r2
    pHandle->_Super.Ic = -Iab->a - Iab->b;
 8008622:	fa1f f38c 	uxth.w	r3, ip
 8008626:	e7c7      	b.n	80085b8 <R3_1_GetPhaseCurrents+0xa4>
        else  if (Aux < -INT16_MAX)
 8008628:	4c17      	ldr	r4, [pc, #92]	@ (8008688 <R3_1_GetPhaseCurrents+0x174>)
 800862a:	42a3      	cmp	r3, r4
 800862c:	da0f      	bge.n	800864e <R3_1_GetPhaseCurrents+0x13a>
          Iab->a = -INT16_MAX;
 800862e:	800c      	strh	r4, [r1, #0]
 8008630:	f248 0301 	movw	r3, #32769	@ 0x8001
 8008634:	46a4      	mov	ip, r4
 8008636:	e7bf      	b.n	80085b8 <R3_1_GetPhaseCurrents+0xa4>
        else  if (Aux < -INT16_MAX)
 8008638:	4d13      	ldr	r5, [pc, #76]	@ (8008688 <R3_1_GetPhaseCurrents+0x174>)
 800863a:	42aa      	cmp	r2, r5
 800863c:	da03      	bge.n	8008646 <R3_1_GetPhaseCurrents+0x132>
          Iab->b = -INT16_MAX;
 800863e:	804d      	strh	r5, [r1, #2]
 8008640:	f248 0201 	movw	r2, #32769	@ 0x8001
 8008644:	e7b8      	b.n	80085b8 <R3_1_GetPhaseCurrents+0xa4>
          Iab->b = (int16_t)Aux;
 8008646:	b215      	sxth	r5, r2
 8008648:	804d      	strh	r5, [r1, #2]
    pHandle->_Super.Ic = -Iab->a - Iab->b;
 800864a:	b292      	uxth	r2, r2
 800864c:	e7b4      	b.n	80085b8 <R3_1_GetPhaseCurrents+0xa4>
          Iab->a = (int16_t)Aux;
 800864e:	fa0f fc83 	sxth.w	ip, r3
 8008652:	f8a1 c000 	strh.w	ip, [r1]
    pHandle->_Super.Ic = -Iab->a - Iab->b;
 8008656:	b29b      	uxth	r3, r3
 8008658:	e7ae      	b.n	80085b8 <R3_1_GetPhaseCurrents+0xa4>
          Iab->b = (int16_t)Aux;
 800865a:	b215      	sxth	r5, r2
 800865c:	804d      	strh	r5, [r1, #2]
    pHandle->_Super.Ic = -Iab->a - Iab->b;
 800865e:	fa1f f38c 	uxth.w	r3, ip
 8008662:	b292      	uxth	r2, r2
 8008664:	e7a8      	b.n	80085b8 <R3_1_GetPhaseCurrents+0xa4>
          Iab->a = (int16_t)Aux;
 8008666:	fa0f fc84 	sxth.w	ip, r4
    pHandle->_Super.Ic = -Iab->a - Iab->b;
 800866a:	b2a3      	uxth	r3, r4
 800866c:	e7c3      	b.n	80085f6 <R3_1_GetPhaseCurrents+0xe2>
          Iab->b = (int16_t)Aux;
 800866e:	b225      	sxth	r5, r4
    pHandle->_Super.Ic = -Iab->a - Iab->b;
 8008670:	b2a2      	uxth	r2, r4
 8008672:	e7af      	b.n	80085d4 <R3_1_GetPhaseCurrents+0xc0>
          Iab->a = (int16_t)Aux;
 8008674:	fa0f fc83 	sxth.w	ip, r3
 8008678:	e791      	b.n	800859e <R3_1_GetPhaseCurrents+0x8a>
    pHandle->_Super.Ia = Iab->a;
 800867a:	f9b1 c000 	ldrsh.w	ip, [r1]
    pHandle->_Super.Ib = Iab->b;
 800867e:	f9b1 5002 	ldrsh.w	r5, [r1, #2]
    pHandle->_Super.Ic = -Iab->a - Iab->b;
 8008682:	880b      	ldrh	r3, [r1, #0]
 8008684:	884a      	ldrh	r2, [r1, #2]
 8008686:	e797      	b.n	80085b8 <R3_1_GetPhaseCurrents+0xa4>
 8008688:	ffff8001 	.word	0xffff8001

0800868c <R3_1_SetADCSampPointPolarization>:
  *
  * @param  pHdl: Handler of the current instance of the PWM component.
  * @retval uint16_t Returns the return value of R3_1_WriteTIMRegisters.
  */
uint16_t R3_1_SetADCSampPointPolarization(PWMC_Handle_t *pHdl)
{
 800868c:	b410      	push	{r4}
#endif /* __ICCARM__ */
  PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
#if defined (__ICCARM__)
  #pragma cstat_restore = "MISRAC2012-Rule-11.3"
#endif /* __ICCARM__ */
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 800868e:	f8d0 309c 	ldr.w	r3, [r0, #156]	@ 0x9c
  pHandle->_Super.Sector = pHandle->PolarizationSector;
 8008692:	f890 4099 	ldrb.w	r4, [r0, #153]	@ 0x99
 8008696:	f880 407a 	strb.w	r4, [r0, #122]	@ 0x7a
  return R3_1_WriteTIMRegisters(&pHandle->_Super, (pHandle->Half_PWMPeriod - (uint16_t)1));
 800869a:	f8b0 2094 	ldrh.w	r2, [r0, #148]	@ 0x94
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 800869e:	685b      	ldr	r3, [r3, #4]
  uint16_t Aux;


  LL_TIM_OC_SetCompareCH1(TIMx, (uint32_t) pHandle->_Super.CntPhA);
 80086a0:	f8b0 4050 	ldrh.w	r4, [r0, #80]	@ 0x50
  WRITE_REG(TIMx->CCR1, CompareValue);
 80086a4:	635c      	str	r4, [r3, #52]	@ 0x34
  return R3_1_WriteTIMRegisters(&pHandle->_Super, (pHandle->Half_PWMPeriod - (uint16_t)1));
 80086a6:	3a01      	subs	r2, #1
  LL_TIM_OC_SetCompareCH2(TIMx, (uint32_t) pHandle->_Super.CntPhB);
 80086a8:	f8b0 4052 	ldrh.w	r4, [r0, #82]	@ 0x52
  LL_TIM_OC_SetCompareCH3(TIMx, (uint32_t) pHandle->_Super.CntPhC);
 80086ac:	f8b0 0054 	ldrh.w	r0, [r0, #84]	@ 0x54
  WRITE_REG(TIMx->CCR2, CompareValue);
 80086b0:	639c      	str	r4, [r3, #56]	@ 0x38
  return R3_1_WriteTIMRegisters(&pHandle->_Super, (pHandle->Half_PWMPeriod - (uint16_t)1));
 80086b2:	b292      	uxth	r2, r2
  WRITE_REG(TIMx->CCR3, CompareValue);
 80086b4:	63d8      	str	r0, [r3, #60]	@ 0x3c
  WRITE_REG(TIMx->CCR4, CompareValue);
 80086b6:	641a      	str	r2, [r3, #64]	@ 0x40
  LL_TIM_OC_SetCompareCH4(TIMx, (uint32_t) SamplingPoint);

  /* Limit for update event */

//  if ( LL_TIM_CC_IsEnabledChannel(TIMx, LL_TIM_CHANNEL_CH4) == 1u )
  if (((TIMx->CR2) & TIM_CR2_MMS_Msk) != LL_TIM_TRGO_RESET)
 80086b8:	4904      	ldr	r1, [pc, #16]	@ (80086cc <R3_1_SetADCSampPointPolarization+0x40>)
 80086ba:	685b      	ldr	r3, [r3, #4]
}
 80086bc:	f85d 4b04 	ldr.w	r4, [sp], #4
  if (((TIMx->CR2) & TIM_CR2_MMS_Msk) != LL_TIM_TRGO_RESET)
 80086c0:	420b      	tst	r3, r1
}
 80086c2:	bf14      	ite	ne
 80086c4:	2001      	movne	r0, #1
 80086c6:	2000      	moveq	r0, #0
 80086c8:	4770      	bx	lr
 80086ca:	bf00      	nop
 80086cc:	02000070 	.word	0x02000070

080086d0 <R3_1_HFCurrentsPolarizationAB>:
  * @param  Iab: Pointer to the structure that will receive motor current
  *         of phase A and B in ab_t format.
  */
static void R3_1_HFCurrentsPolarizationAB(PWMC_Handle_t *pHdl, ab_t *Iab)
{
  if (MC_NULL == Iab)
 80086d0:	b321      	cbz	r1, 800871c <R3_1_HFCurrentsPolarizationAB+0x4c>
#endif /* __ICCARM__ */
    PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
#if defined (__ICCARM__)
  #pragma cstat_restore = "MISRAC2012-Rule-11.3"
#endif /* __ICCARM__ */
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 80086d2:	f8d0 209c 	ldr.w	r2, [r0, #156]	@ 0x9c
 80086d6:	e9d2 3200 	ldrd	r3, r2, [r2]
{
 80086da:	b430      	push	{r4, r5}
    ADC_TypeDef * ADCx = pHandle->pParams_str->ADCx;
    uint32_t ADCDataReg1 = ADCx->JDR1;
 80086dc:	f8d3 4080 	ldr.w	r4, [r3, #128]	@ 0x80
    uint32_t ADCDataReg2 = ADCx->JDR2;
 80086e0:	f8d3 5084 	ldr.w	r5, [r3, #132]	@ 0x84
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 80086e4:	6853      	ldr	r3, [r2, #4]
 80086e6:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
 80086ea:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 80086ee:	6053      	str	r3, [r2, #4]

    /* disable ADC trigger source */
    /* LL_TIM_CC_DisableChannel(TIMx, LL_TIM_CHANNEL_CH4) */
    LL_TIM_SetTriggerOutput(TIMx, LL_TIM_TRGO_RESET);

    if (pHandle->PolarizationCounter < NB_CONVERSIONS)
 80086f0:	f890 3098 	ldrb.w	r3, [r0, #152]	@ 0x98
 80086f4:	2b0f      	cmp	r3, #15
 80086f6:	d80d      	bhi.n	8008714 <R3_1_HFCurrentsPolarizationAB+0x44>
    {
      pHandle-> PhaseAOffset += ADCDataReg1;
 80086f8:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
      pHandle-> PhaseBOffset += ADCDataReg2;
 80086fc:	f8d0 208c 	ldr.w	r2, [r0, #140]	@ 0x8c
      pHandle-> PhaseAOffset += ADCDataReg1;
 8008700:	441c      	add	r4, r3
      pHandle->PolarizationCounter++;
 8008702:	f890 3098 	ldrb.w	r3, [r0, #152]	@ 0x98
      pHandle-> PhaseBOffset += ADCDataReg2;
 8008706:	442a      	add	r2, r5
      pHandle->PolarizationCounter++;
 8008708:	3301      	adds	r3, #1
      pHandle-> PhaseBOffset += ADCDataReg2;
 800870a:	e9c0 4222 	strd	r4, r2, [r0, #136]	@ 0x88
      pHandle->PolarizationCounter++;
 800870e:	b2db      	uxtb	r3, r3
 8008710:	f880 3098 	strb.w	r3, [r0, #152]	@ 0x98
    {
      /* Nothing to do */
    }

    /* during offset calibration no current is flowing in the phases */
    Iab->a = 0;
 8008714:	2300      	movs	r3, #0
    Iab->b = 0;
  }
}
 8008716:	bc30      	pop	{r4, r5}
    Iab->a = 0;
 8008718:	600b      	str	r3, [r1, #0]
}
 800871a:	4770      	bx	lr
 800871c:	4770      	bx	lr
 800871e:	bf00      	nop

08008720 <R3_1_HFCurrentsPolarizationC>:
  *                Min value: 0 (low sides ON)
  *                Max value: PWM_PERIOD_CYCLES/2 (low sides OFF)
  */
static void R3_1_HFCurrentsPolarizationC(PWMC_Handle_t *pHdl, ab_t *Iab)
{
  if (MC_NULL == Iab)
 8008720:	b301      	cbz	r1, 8008764 <R3_1_HFCurrentsPolarizationC+0x44>
#endif /* __ICCARM__ */
    PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
#if defined (__ICCARM__)
  #pragma cstat_restore = "MISRAC2012-Rule-11.3"
#endif /* __ICCARM__ */
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8008722:	f8d0 309c 	ldr.w	r3, [r0, #156]	@ 0x9c
    ADC_TypeDef * ADCx = pHandle->pParams_str->ADCx;
 8008726:	e9d3 3200 	ldrd	r3, r2, [r3]
{
 800872a:	b410      	push	{r4}
    uint32_t ADCDataReg2 = ADCx->JDR2;
 800872c:	f8d3 4084 	ldr.w	r4, [r3, #132]	@ 0x84
 8008730:	6853      	ldr	r3, [r2, #4]
 8008732:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
 8008736:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 800873a:	6053      	str	r3, [r2, #4]

    /* disable ADC trigger source */
    /* LL_TIM_CC_DisableChannel(TIMx, LL_TIM_CHANNEL_CH4) */
    LL_TIM_SetTriggerOutput(TIMx, LL_TIM_TRGO_RESET);

    if (pHandle->PolarizationCounter < NB_CONVERSIONS)
 800873c:	f890 3098 	ldrb.w	r3, [r0, #152]	@ 0x98
 8008740:	2b0f      	cmp	r3, #15
 8008742:	d80a      	bhi.n	800875a <R3_1_HFCurrentsPolarizationC+0x3a>
    {
      /* Phase C is read from SECTOR_1, second value */
      pHandle-> PhaseCOffset += ADCDataReg2;
      pHandle->PolarizationCounter++;
 8008744:	f890 3098 	ldrb.w	r3, [r0, #152]	@ 0x98
      pHandle-> PhaseCOffset += ADCDataReg2;
 8008748:	f8d0 2090 	ldr.w	r2, [r0, #144]	@ 0x90
      pHandle->PolarizationCounter++;
 800874c:	3301      	adds	r3, #1
      pHandle-> PhaseCOffset += ADCDataReg2;
 800874e:	4422      	add	r2, r4
      pHandle->PolarizationCounter++;
 8008750:	b2db      	uxtb	r3, r3
      pHandle-> PhaseCOffset += ADCDataReg2;
 8008752:	f8c0 2090 	str.w	r2, [r0, #144]	@ 0x90
      pHandle->PolarizationCounter++;
 8008756:	f880 3098 	strb.w	r3, [r0, #152]	@ 0x98
    {
      /* Nothing to do */
    }

    /* during offset calibration no current is flowing in the phases */
    Iab->a = 0;
 800875a:	2300      	movs	r3, #0
    Iab->b = 0;
  }
}
 800875c:	f85d 4b04 	ldr.w	r4, [sp], #4
    Iab->a = 0;
 8008760:	600b      	str	r3, [r1, #0]
}
 8008762:	4770      	bx	lr
 8008764:	4770      	bx	lr
 8008766:	bf00      	nop

08008768 <R3_1_SwitchOnPWM>:
#endif /* __ICCARM__ */
  PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
#if defined (__ICCARM__)
  #pragma cstat_restore = "MISRAC2012-Rule-11.3"
#endif /* __ICCARM__ */
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8008768:	f8d0 309c 	ldr.w	r3, [r0, #156]	@ 0x9c
  pHandle->ADCRegularLocked = true;

  pHandle->_Super.TurnOnLowSidesAction = false;

  /* Set all duty to 50% */
  LL_TIM_OC_SetCompareCH1(TIMx, ((uint32_t)pHandle->Half_PWMPeriod / (uint32_t)2));
 800876c:	f8b0 2094 	ldrh.w	r2, [r0, #148]	@ 0x94
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8008770:	685b      	ldr	r3, [r3, #4]
  pHandle->ADCRegularLocked = true;
 8008772:	f04f 0c01 	mov.w	ip, #1
{
 8008776:	b5f0      	push	{r4, r5, r6, r7, lr}
  LL_TIM_OC_SetCompareCH1(TIMx, ((uint32_t)pHandle->Half_PWMPeriod / (uint32_t)2));
 8008778:	fa22 f10c 	lsr.w	r1, r2, ip
  pHandle->_Super.TurnOnLowSidesAction = false;
 800877c:	f04f 0e00 	mov.w	lr, #0
 8008780:	f880 e07c 	strb.w	lr, [r0, #124]	@ 0x7c
  pHandle->ADCRegularLocked = true;
 8008784:	f880 c0a0 	strb.w	ip, [r0, #160]	@ 0xa0
  LL_TIM_OC_SetCompareCH2(TIMx, ((uint32_t)pHandle->Half_PWMPeriod / (uint32_t)2));
  LL_TIM_OC_SetCompareCH3(TIMx, ((uint32_t)pHandle->Half_PWMPeriod / (uint32_t)2));
  LL_TIM_OC_SetCompareCH4(TIMx, ((uint32_t)pHandle->Half_PWMPeriod - (uint32_t)5));
 8008788:	3a05      	subs	r2, #5
  WRITE_REG(TIMx->CCR1, CompareValue);
 800878a:	6359      	str	r1, [r3, #52]	@ 0x34
  WRITE_REG(TIMx->CCR2, CompareValue);
 800878c:	6399      	str	r1, [r3, #56]	@ 0x38
  WRITE_REG(TIMx->CCR3, CompareValue);
 800878e:	63d9      	str	r1, [r3, #60]	@ 0x3c
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8008790:	f06f 0101 	mvn.w	r1, #1
  WRITE_REG(TIMx->CCR4, CompareValue);
 8008794:	641a      	str	r2, [r3, #64]	@ 0x40
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8008796:	6119      	str	r1, [r3, #16]
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 8008798:	691a      	ldr	r2, [r3, #16]
 800879a:	07d2      	lsls	r2, r2, #31
 800879c:	d5fc      	bpl.n	8008798 <R3_1_SwitchOnPWM+0x30>
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 800879e:	f06f 0201 	mvn.w	r2, #1
 80087a2:	611a      	str	r2, [r3, #16]
    /* Nothing to do */
  }
  LL_TIM_ClearFlag_UPDATE(TIMx);

  /* Main PWM Output Enable */
  TIMx->BDTR |= LL_TIM_OSSI_ENABLE;
 80087a4:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 80087a6:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 80087aa:	645a      	str	r2, [r3, #68]	@ 0x44
  SET_BIT(TIMx->BDTR, TIM_BDTR_MOE);
 80087ac:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 80087ae:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 80087b2:	645a      	str	r2, [r3, #68]	@ 0x44
  LL_TIM_EnableAllOutputs(TIMx);

  if ((ES_GPIO == pHandle->_Super.LowSideOutputs))
 80087b4:	f890 207b 	ldrb.w	r2, [r0, #123]	@ 0x7b
 80087b8:	2a02      	cmp	r2, #2
 80087ba:	d007      	beq.n	80087cc <R3_1_SwitchOnPWM+0x64>
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 80087bc:	f06f 0201 	mvn.w	r2, #1
 80087c0:	611a      	str	r2, [r3, #16]
  SET_BIT(TIMx->DIER, TIM_DIER_UIE);
 80087c2:	68da      	ldr	r2, [r3, #12]
 80087c4:	f042 0201 	orr.w	r2, r2, #1
 80087c8:	60da      	str	r2, [r3, #12]
  }
  /* Clear Update Flag */
  LL_TIM_ClearFlag_UPDATE(TIMx);
  /* Enable Update IRQ */
  LL_TIM_EnableIT_UPDATE(TIMx);
}
 80087ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if ((TIMx->CCER & TIMxCCER_MASK_CH123) != 0U)
 80087cc:	6a19      	ldr	r1, [r3, #32]
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_u_port, pHandle->_Super.pwm_en_u_pin);
 80087ce:	6bc7      	ldr	r7, [r0, #60]	@ 0x3c
 80087d0:	f8b0 c048 	ldrh.w	ip, [r0, #72]	@ 0x48
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 80087d4:	6c05      	ldr	r5, [r0, #64]	@ 0x40
 80087d6:	f8b0 604a 	ldrh.w	r6, [r0, #74]	@ 0x4a
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 80087da:	6c44      	ldr	r4, [r0, #68]	@ 0x44
 80087dc:	f8b0 004c 	ldrh.w	r0, [r0, #76]	@ 0x4c
    if ((TIMx->CCER & TIMxCCER_MASK_CH123) != 0U)
 80087e0:	f240 5255 	movw	r2, #1365	@ 0x555
 80087e4:	4211      	tst	r1, r2
 80087e6:	d004      	beq.n	80087f2 <R3_1_SwitchOnPWM+0x8a>
  WRITE_REG(GPIOx->BSRR, PinMask);
 80087e8:	f8c7 c018 	str.w	ip, [r7, #24]
 80087ec:	61ae      	str	r6, [r5, #24]
 80087ee:	61a0      	str	r0, [r4, #24]
}
 80087f0:	e7e4      	b.n	80087bc <R3_1_SwitchOnPWM+0x54>
  WRITE_REG(GPIOx->BRR, PinMask);
 80087f2:	f8c7 c028 	str.w	ip, [r7, #40]	@ 0x28
 80087f6:	62ae      	str	r6, [r5, #40]	@ 0x28
 80087f8:	62a0      	str	r0, [r4, #40]	@ 0x28
}
 80087fa:	e7df      	b.n	80087bc <R3_1_SwitchOnPWM+0x54>

080087fc <R3_1_SwitchOffPWM>:
#endif /* __ICCARM__ */
  PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
#if defined (__ICCARM__)
  #pragma cstat_restore = "MISRAC2012-Rule-11.3"
#endif /* __ICCARM__ */
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 80087fc:	f8d0 309c 	ldr.w	r3, [r0, #156]	@ 0x9c

  pHandle->_Super.TurnOnLowSidesAction = false;

  /* Main PWM Output Disable */
  LL_TIM_DisableAllOutputs(TIMx);
  if (true == pHandle->_Super.BrakeActionLock)
 8008800:	f890 1083 	ldrb.w	r1, [r0, #131]	@ 0x83
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8008804:	685a      	ldr	r2, [r3, #4]
  CLEAR_BIT(TIMx->DIER, TIM_DIER_UIE);
 8008806:	68d3      	ldr	r3, [r2, #12]
 8008808:	f023 0301 	bic.w	r3, r3, #1
 800880c:	60d3      	str	r3, [r2, #12]
  CLEAR_BIT(TIMx->BDTR, TIM_BDTR_MOE);
 800880e:	6c53      	ldr	r3, [r2, #68]	@ 0x44
  pHandle->_Super.TurnOnLowSidesAction = false;
 8008810:	f04f 0c00 	mov.w	ip, #0
 8008814:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
 8008818:	f880 c07c 	strb.w	ip, [r0, #124]	@ 0x7c
 800881c:	6453      	str	r3, [r2, #68]	@ 0x44
  if (true == pHandle->_Super.BrakeActionLock)
 800881e:	b919      	cbnz	r1, 8008828 <R3_1_SwitchOffPWM+0x2c>
  {
    /* Nothing to do */
  }
  else
  {
    if (ES_GPIO == pHandle->_Super.LowSideOutputs)
 8008820:	f890 307b 	ldrb.w	r3, [r0, #123]	@ 0x7b
 8008824:	2b02      	cmp	r3, #2
 8008826:	d00c      	beq.n	8008842 <R3_1_SwitchOffPWM+0x46>
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8008828:	f06f 0301 	mvn.w	r3, #1
 800882c:	6113      	str	r3, [r2, #16]
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 800882e:	6913      	ldr	r3, [r2, #16]
 8008830:	07db      	lsls	r3, r3, #31
 8008832:	d5fc      	bpl.n	800882e <R3_1_SwitchOffPWM+0x32>
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8008834:	f06f 0101 	mvn.w	r1, #1
    /* Nothing to do */
  }
  LL_TIM_ClearFlag_UPDATE(TIMx);

  /* We allow ADC usage for regular conversion on Systick*/
  pHandle->ADCRegularLocked = false;
 8008838:	2300      	movs	r3, #0
 800883a:	6111      	str	r1, [r2, #16]
 800883c:	f880 30a0 	strb.w	r3, [r0, #160]	@ 0xa0
 8008840:	4770      	bx	lr
{
 8008842:	b430      	push	{r4, r5}
      LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 8008844:	e9d0 410f 	ldrd	r4, r1, [r0, #60]	@ 0x3c
      LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_u_port, pHandle->_Super.pwm_en_u_pin);
 8008848:	f8b0 5048 	ldrh.w	r5, [r0, #72]	@ 0x48
      LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 800884c:	6c43      	ldr	r3, [r0, #68]	@ 0x44
  WRITE_REG(GPIOx->BRR, PinMask);
 800884e:	62a5      	str	r5, [r4, #40]	@ 0x28
      LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 8008850:	f8b0 404a 	ldrh.w	r4, [r0, #74]	@ 0x4a
 8008854:	628c      	str	r4, [r1, #40]	@ 0x28
      LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 8008856:	f8b0 104c 	ldrh.w	r1, [r0, #76]	@ 0x4c
 800885a:	6299      	str	r1, [r3, #40]	@ 0x28
 800885c:	f06f 0301 	mvn.w	r3, #1
 8008860:	6113      	str	r3, [r2, #16]
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 8008862:	6913      	ldr	r3, [r2, #16]
 8008864:	07d9      	lsls	r1, r3, #31
 8008866:	d5fc      	bpl.n	8008862 <R3_1_SwitchOffPWM+0x66>
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8008868:	f06f 0101 	mvn.w	r1, #1
  pHandle->ADCRegularLocked = false;
 800886c:	2300      	movs	r3, #0
 800886e:	6111      	str	r1, [r2, #16]
}
 8008870:	bc30      	pop	{r4, r5}
  pHandle->ADCRegularLocked = false;
 8008872:	f880 30a0 	strb.w	r3, [r0, #160]	@ 0xa0
}
 8008876:	4770      	bx	lr

08008878 <R3_1_RLGetPhaseCurrents>:
  }
  else
  {
#endif
    PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8008878:	f8d0 209c 	ldr.w	r2, [r0, #156]	@ 0x9c
    int32_t wAux;

    /* Disable ADC trigger source */
    LL_TIM_SetTriggerOutput(TIMx, LL_TIM_TRGO_RESET);

    wAux = ((int32_t)pHandle->PhaseBOffset)
 800887c:	f8d0 308c 	ldr.w	r3, [r0, #140]	@ 0x8c
{
 8008880:	b410      	push	{r4}
    ADC_TypeDef *ADCx = pHandle->pParams_str->ADCx;
 8008882:	e9d2 4000 	ldrd	r4, r0, [r2]
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 8008886:	6842      	ldr	r2, [r0, #4]
 8008888:	f022 7200 	bic.w	r2, r2, #33554432	@ 0x2000000
 800888c:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
 8008890:	6042      	str	r2, [r0, #4]
         - (int32_t)ADCx->JDR2;
 8008892:	f8d4 0084 	ldr.w	r0, [r4, #132]	@ 0x84
    else
    {
      wAux = -INT16_MAX;
    }

    pStator_Currents->a = (int16_t)wAux;
 8008896:	4a0a      	ldr	r2, [pc, #40]	@ (80088c0 <R3_1_RLGetPhaseCurrents+0x48>)
    pStator_Currents->b = (int16_t)wAux;
#ifdef NULL_PTR_CHECK_R3_1_PWM_CURR_FDB
  }
#endif
}
 8008898:	f85d 4b04 	ldr.w	r4, [sp], #4
    wAux = ((int32_t)pHandle->PhaseBOffset)
 800889c:	1a1b      	subs	r3, r3, r0
      if (wAux < INT16_MAX)
 800889e:	f647 70ff 	movw	r0, #32767	@ 0x7fff
 80088a2:	4283      	cmp	r3, r0
 80088a4:	bfa8      	it	ge
 80088a6:	4603      	movge	r3, r0
    pStator_Currents->a = (int16_t)wAux;
 80088a8:	4293      	cmp	r3, r2
 80088aa:	bfb8      	it	lt
 80088ac:	4613      	movlt	r3, r2
 80088ae:	b21b      	sxth	r3, r3
 80088b0:	2200      	movs	r2, #0
 80088b2:	f363 020f 	bfi	r2, r3, #0, #16
 80088b6:	f363 421f 	bfi	r2, r3, #16, #16
 80088ba:	600a      	str	r2, [r1, #0]
}
 80088bc:	4770      	bx	lr
 80088be:	bf00      	nop
 80088c0:	ffff8001 	.word	0xffff8001

080088c4 <R3_1_RLSwitchOnPWM>:
  }
  else
  {
#endif
    PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 80088c4:	f8d0 209c 	ldr.w	r2, [r0, #156]	@ 0x9c
    ADC_TypeDef *ADCx = pHandle->pParams_str->ADCx;
 80088c8:	e9d2 1300 	ldrd	r1, r3, [r2]
{
 80088cc:	b5f0      	push	{r4, r5, r6, r7, lr}
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 80088ce:	f06f 0201 	mvn.w	r2, #1

    pHandle->ADCRegularLocked=true;
 80088d2:	2401      	movs	r4, #1
 80088d4:	f880 40a0 	strb.w	r4, [r0, #160]	@ 0xa0
 80088d8:	611a      	str	r2, [r3, #16]
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 80088da:	691a      	ldr	r2, [r3, #16]
 80088dc:	07d4      	lsls	r4, r2, #31
 80088de:	d5fc      	bpl.n	80088da <R3_1_RLSwitchOnPWM+0x16>
    }
    /* Clear Update Flag */
    LL_TIM_ClearFlag_UPDATE(TIMx);

    LL_TIM_OC_SetCompareCH1(TIMx, 1U);
    LL_TIM_OC_SetCompareCH4(TIMx, ((uint32_t )pHandle->Half_PWMPeriod) - 5U);
 80088e0:	f8b0 2094 	ldrh.w	r2, [r0, #148]	@ 0x94
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 80088e4:	f06f 0401 	mvn.w	r4, #1
 80088e8:	611c      	str	r4, [r3, #16]
 80088ea:	3a05      	subs	r2, #5
  WRITE_REG(TIMx->CCR1, CompareValue);
 80088ec:	2401      	movs	r4, #1
 80088ee:	635c      	str	r4, [r3, #52]	@ 0x34
  WRITE_REG(TIMx->CCR4, CompareValue);
 80088f0:	641a      	str	r2, [r3, #64]	@ 0x40
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 80088f2:	691a      	ldr	r2, [r3, #16]
 80088f4:	07d2      	lsls	r2, r2, #31
 80088f6:	d5fc      	bpl.n	80088f2 <R3_1_RLSwitchOnPWM+0x2e>
  SET_BIT(TIMx->DIER, TIM_DIER_UIE);
 80088f8:	68da      	ldr	r2, [r3, #12]
 80088fa:	f042 0201 	orr.w	r2, r2, #1
 80088fe:	60da      	str	r2, [r3, #12]

    /* Enable TIMx update interrupt */
    LL_TIM_EnableIT_UPDATE(TIMx);

    /* Main PWM Output Enable */
    TIMx->BDTR |= LL_TIM_OSSI_ENABLE ;
 8008900:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8008902:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 8008906:	645a      	str	r2, [r3, #68]	@ 0x44
  SET_BIT(TIMx->BDTR, TIM_BDTR_MOE);
 8008908:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 800890a:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 800890e:	645a      	str	r2, [r3, #68]	@ 0x44
    LL_TIM_EnableAllOutputs(TIMx);

    if (ES_GPIO ==  pHandle->_Super.LowSideOutputs)
 8008910:	f890 207b 	ldrb.w	r2, [r0, #123]	@ 0x7b
 8008914:	2a02      	cmp	r2, #2
 8008916:	d115      	bne.n	8008944 <R3_1_RLSwitchOnPWM+0x80>
    {
      if ((TIMx->CCER & TIMxCCER_MASK_CH123 ) != 0U)
 8008918:	6a1a      	ldr	r2, [r3, #32]
      {
        LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_u_port, pHandle->_Super.pwm_en_u_pin);
 800891a:	f8d0 c03c 	ldr.w	ip, [r0, #60]	@ 0x3c
        LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 800891e:	6c06      	ldr	r6, [r0, #64]	@ 0x40
        LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 8008920:	6c44      	ldr	r4, [r0, #68]	@ 0x44
        LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_u_port, pHandle->_Super.pwm_en_u_pin);
 8008922:	f8b0 e048 	ldrh.w	lr, [r0, #72]	@ 0x48
        LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 8008926:	f8b0 704a 	ldrh.w	r7, [r0, #74]	@ 0x4a
        LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 800892a:	f8b0 504c 	ldrh.w	r5, [r0, #76]	@ 0x4c
      if ((TIMx->CCER & TIMxCCER_MASK_CH123 ) != 0U)
 800892e:	f240 5355 	movw	r3, #1365	@ 0x555
 8008932:	421a      	tst	r2, r3
  WRITE_REG(GPIOx->BSRR, PinMask);
 8008934:	bf15      	itete	ne
 8008936:	f8cc e018 	strne.w	lr, [ip, #24]
  WRITE_REG(GPIOx->BRR, PinMask);
 800893a:	f8cc e028 	streq.w	lr, [ip, #40]	@ 0x28
  WRITE_REG(GPIOx->BSRR, PinMask);
 800893e:	61b7      	strne	r7, [r6, #24]
  WRITE_REG(GPIOx->BRR, PinMask);
 8008940:	62b7      	streq	r7, [r6, #40]	@ 0x28
 8008942:	62a5      	str	r5, [r4, #40]	@ 0x28
      /* Nothing to do */
    }

    /* Set the sector that correspond to Phase B and C sampling
     * B will be sampled by ADCx */
    pHdl->Sector = SECTOR_4;
 8008944:	2303      	movs	r3, #3
 8008946:	f880 307a 	strb.w	r3, [r0, #122]	@ 0x7a
  MODIFY_REG(ADCx->CR,
 800894a:	688b      	ldr	r3, [r1, #8]
 800894c:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 8008950:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
 8008954:	f043 0308 	orr.w	r3, r3, #8
 8008958:	608b      	str	r3, [r1, #8]
    LL_ADC_INJ_StartConversion(ADCx);

#ifdef NULL_PTR_CHECK_R3_1_PWM_CURR_FDB
  }
#endif
}
 800895a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800895c <R3_1_TurnOnLowSides>:
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 800895c:	f8d0 309c 	ldr.w	r3, [r0, #156]	@ 0x9c
 8008960:	685a      	ldr	r2, [r3, #4]
  pHandle->_Super.TurnOnLowSidesAction = true;
 8008962:	f04f 0c01 	mov.w	ip, #1
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8008966:	f06f 0301 	mvn.w	r3, #1
 800896a:	f880 c07c 	strb.w	ip, [r0, #124]	@ 0x7c
 800896e:	6113      	str	r3, [r2, #16]
  WRITE_REG(TIMx->CCR1, CompareValue);
 8008970:	6351      	str	r1, [r2, #52]	@ 0x34
  WRITE_REG(TIMx->CCR2, CompareValue);
 8008972:	6391      	str	r1, [r2, #56]	@ 0x38
  WRITE_REG(TIMx->CCR3, CompareValue);
 8008974:	63d1      	str	r1, [r2, #60]	@ 0x3c
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 8008976:	6913      	ldr	r3, [r2, #16]
 8008978:	07db      	lsls	r3, r3, #31
 800897a:	d5fc      	bpl.n	8008976 <R3_1_TurnOnLowSides+0x1a>
  SET_BIT(TIMx->BDTR, TIM_BDTR_MOE);
 800897c:	6c53      	ldr	r3, [r2, #68]	@ 0x44
 800897e:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 8008982:	6453      	str	r3, [r2, #68]	@ 0x44
  if ((ES_GPIO == pHandle->_Super.LowSideOutputs))
 8008984:	f890 307b 	ldrb.w	r3, [r0, #123]	@ 0x7b
 8008988:	2b02      	cmp	r3, #2
 800898a:	d000      	beq.n	800898e <R3_1_TurnOnLowSides+0x32>
 800898c:	4770      	bx	lr
    LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 800898e:	e9d0 210f 	ldrd	r2, r1, [r0, #60]	@ 0x3c
{
 8008992:	b410      	push	{r4}
    LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 8008994:	6c43      	ldr	r3, [r0, #68]	@ 0x44
    LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_u_port, pHandle->_Super.pwm_en_u_pin);
 8008996:	f8b0 4048 	ldrh.w	r4, [r0, #72]	@ 0x48
  WRITE_REG(GPIOx->BSRR, PinMask);
 800899a:	6194      	str	r4, [r2, #24]
    LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 800899c:	f8b0 404a 	ldrh.w	r4, [r0, #74]	@ 0x4a
    LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 80089a0:	f8b0 204c 	ldrh.w	r2, [r0, #76]	@ 0x4c
 80089a4:	618c      	str	r4, [r1, #24]
}
 80089a6:	f85d 4b04 	ldr.w	r4, [sp], #4
 80089aa:	619a      	str	r2, [r3, #24]
 80089ac:	4770      	bx	lr
 80089ae:	bf00      	nop

080089b0 <R3_1_SetAOReferenceVoltage>:
  * @param  Data Value between Min_Data=0x000 and Max_Data=0xFFF
  * @retval None
  */
__STATIC_INLINE void LL_DAC_ConvertData12LeftAligned(DAC_TypeDef *DACx, uint32_t DAC_Channel, uint32_t Data)
{
  __IO uint32_t *preg = __DAC_PTR_REG_OFFSET(DACx->DHR12R1, (DAC_Channel >> DAC_REG_DHR12LX_REGOFFSET_BITOFFSET_POS)
 80089b0:	ea4f 4c90 	mov.w	ip, r0, lsr #18
{
 80089b4:	b510      	push	{r4, lr}
 80089b6:	f00c 0c3c 	and.w	ip, ip, #60	@ 0x3c
 80089ba:	f101 0e08 	add.w	lr, r1, #8
 80089be:	b082      	sub	sp, #8
                                             & DAC_REG_DHR_REGOFFSET_MASK_POSBIT0);

  MODIFY_REG(*preg, DAC_DHR12L1_DACC1DHR, Data);
 80089c0:	f85e 300c 	ldr.w	r3, [lr, ip]
 80089c4:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
 80089c8:	f023 03f0 	bic.w	r3, r3, #240	@ 0xf0
 80089cc:	4313      	orrs	r3, r2
 80089ce:	f84e 300c 	str.w	r3, [lr, ip]
  SET_BIT(DACx->SWTRIGR,
 80089d2:	684a      	ldr	r2, [r1, #4]
 80089d4:	f000 0303 	and.w	r3, r0, #3
 80089d8:	4313      	orrs	r3, r2
 80089da:	604b      	str	r3, [r1, #4]
  return ((READ_BIT(DACx->CR,
 80089dc:	680a      	ldr	r2, [r1, #0]
 80089de:	f000 0010 	and.w	r0, r0, #16
 80089e2:	2301      	movs	r3, #1
 80089e4:	4083      	lsls	r3, r0
           == (DAC_CR_EN1 << (DAC_Channel & DAC_CR_CHX_BITOFFSET_MASK))) ? 1UL : 0UL);
 80089e6:	ea33 0202 	bics.w	r2, r3, r2
 80089ea:	d014      	beq.n	8008a16 <R3_1_SetAOReferenceVoltage+0x66>
                                         * (SystemCoreClock / (1000000UL * 2UL)));
 80089ec:	4a14      	ldr	r2, [pc, #80]	@ (8008a40 <R3_1_SetAOReferenceVoltage+0x90>)
 80089ee:	4815      	ldr	r0, [pc, #84]	@ (8008a44 <R3_1_SetAOReferenceVoltage+0x94>)
 80089f0:	6812      	ldr	r2, [r2, #0]
  SET_BIT(DACx->CR,
 80089f2:	680c      	ldr	r4, [r1, #0]
 80089f4:	fba0 0202 	umull	r0, r2, r0, r2
 80089f8:	0cd2      	lsrs	r2, r2, #19
 80089fa:	4323      	orrs	r3, r4
 80089fc:	00d2      	lsls	r2, r2, #3
 80089fe:	600b      	str	r3, [r1, #0]
    volatile uint32_t wait_loop_index = ((LL_DAC_DELAY_STARTUP_VOLTAGE_SETTLING_US)
 8008a00:	9200      	str	r2, [sp, #0]
    while (wait_loop_index != 0UL)
 8008a02:	9b00      	ldr	r3, [sp, #0]
 8008a04:	b12b      	cbz	r3, 8008a12 <R3_1_SetAOReferenceVoltage+0x62>
      wait_loop_index--;
 8008a06:	9b00      	ldr	r3, [sp, #0]
 8008a08:	3b01      	subs	r3, #1
 8008a0a:	9300      	str	r3, [sp, #0]
    while (wait_loop_index != 0UL)
 8008a0c:	9b00      	ldr	r3, [sp, #0]
 8008a0e:	2b00      	cmp	r3, #0
 8008a10:	d1f9      	bne.n	8008a06 <R3_1_SetAOReferenceVoltage+0x56>
}
 8008a12:	b002      	add	sp, #8
 8008a14:	bd10      	pop	{r4, pc}
    volatile uint32_t wait_loop_index = ((LL_DAC_DELAY_VOLTAGE_SETTLING_US) * (SystemCoreClock / (1000000UL * 2UL)));
 8008a16:	4b0a      	ldr	r3, [pc, #40]	@ (8008a40 <R3_1_SetAOReferenceVoltage+0x90>)
 8008a18:	4a0a      	ldr	r2, [pc, #40]	@ (8008a44 <R3_1_SetAOReferenceVoltage+0x94>)
 8008a1a:	681b      	ldr	r3, [r3, #0]
 8008a1c:	fba2 2303 	umull	r2, r3, r2, r3
 8008a20:	0cdb      	lsrs	r3, r3, #19
 8008a22:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8008a26:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 8008a28:	9b01      	ldr	r3, [sp, #4]
 8008a2a:	2b00      	cmp	r3, #0
 8008a2c:	d0f1      	beq.n	8008a12 <R3_1_SetAOReferenceVoltage+0x62>
      wait_loop_index--;
 8008a2e:	9b01      	ldr	r3, [sp, #4]
 8008a30:	3b01      	subs	r3, #1
 8008a32:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 8008a34:	9b01      	ldr	r3, [sp, #4]
 8008a36:	2b00      	cmp	r3, #0
 8008a38:	d1f9      	bne.n	8008a2e <R3_1_SetAOReferenceVoltage+0x7e>
}
 8008a3a:	b002      	add	sp, #8
 8008a3c:	bd10      	pop	{r4, pc}
 8008a3e:	bf00      	nop
 8008a40:	20000558 	.word	0x20000558
 8008a44:	431bde83 	.word	0x431bde83

08008a48 <R3_1_RLTurnOnLowSides>:
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8008a48:	f8d0 309c 	ldr.w	r3, [r0, #156]	@ 0x9c
 8008a4c:	685a      	ldr	r2, [r3, #4]
  pHandle->ADCRegularLocked = true;
 8008a4e:	f04f 0c01 	mov.w	ip, #1
  WRITE_REG(TIMx->CCR1, CompareValue);
 8008a52:	2100      	movs	r1, #0
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8008a54:	f06f 0301 	mvn.w	r3, #1
 8008a58:	f880 c0a0 	strb.w	ip, [r0, #160]	@ 0xa0
  WRITE_REG(TIMx->CCR1, CompareValue);
 8008a5c:	6351      	str	r1, [r2, #52]	@ 0x34
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8008a5e:	6113      	str	r3, [r2, #16]
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 8008a60:	6913      	ldr	r3, [r2, #16]
 8008a62:	07db      	lsls	r3, r3, #31
 8008a64:	d5fc      	bpl.n	8008a60 <R3_1_RLTurnOnLowSides+0x18>
  SET_BIT(TIMx->BDTR, TIM_BDTR_MOE);
 8008a66:	6c53      	ldr	r3, [r2, #68]	@ 0x44
 8008a68:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 8008a6c:	6453      	str	r3, [r2, #68]	@ 0x44
  if (ES_GPIO == pHandle->_Super.LowSideOutputs)
 8008a6e:	f890 307b 	ldrb.w	r3, [r0, #123]	@ 0x7b
 8008a72:	2b02      	cmp	r3, #2
 8008a74:	d000      	beq.n	8008a78 <R3_1_RLTurnOnLowSides+0x30>
 8008a76:	4770      	bx	lr
    LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 8008a78:	e9d0 210f 	ldrd	r2, r1, [r0, #60]	@ 0x3c
{
 8008a7c:	b410      	push	{r4}
    LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 8008a7e:	6c43      	ldr	r3, [r0, #68]	@ 0x44
    LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_u_port, pHandle->_Super.pwm_en_u_pin);
 8008a80:	f8b0 4048 	ldrh.w	r4, [r0, #72]	@ 0x48
 8008a84:	6194      	str	r4, [r2, #24]
    LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 8008a86:	f8b0 404a 	ldrh.w	r4, [r0, #74]	@ 0x4a
    LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 8008a8a:	f8b0 204c 	ldrh.w	r2, [r0, #76]	@ 0x4c
  WRITE_REG(GPIOx->BRR, PinMask);
 8008a8e:	628c      	str	r4, [r1, #40]	@ 0x28
}
 8008a90:	f85d 4b04 	ldr.w	r4, [sp], #4
 8008a94:	629a      	str	r2, [r3, #40]	@ 0x28
 8008a96:	4770      	bx	lr

08008a98 <R3_1_Init>:
  if (MC_NULL == pHandle)
 8008a98:	2800      	cmp	r0, #0
 8008a9a:	f000 8140 	beq.w	8008d1e <R3_1_Init+0x286>
{
 8008a9e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    R3_3_OPAMPParams_t *OPAMPParams = pHandle->pParams_str->OPAMPParams;
 8008aa2:	f8d0 509c 	ldr.w	r5, [r0, #156]	@ 0x9c
    ADC_TypeDef *ADCx = pHandle->pParams_str->ADCx;
 8008aa6:	682e      	ldr	r6, [r5, #0]
    DAC_TypeDef *DAC_OCPCx = pHandle->pParams_str->DAC_OCP_CSelection;
 8008aa8:	6a6c      	ldr	r4, [r5, #36]	@ 0x24
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_EOC);
 8008aaa:	6872      	ldr	r2, [r6, #4]
    COMP_TypeDef *COMP_OCPBx = pHandle->pParams_str->CompOCPBSelection;
 8008aac:	f8d5 a010 	ldr.w	sl, [r5, #16]
{
 8008ab0:	b087      	sub	sp, #28
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_EOC);
 8008ab2:	f04f 0c04 	mov.w	ip, #4
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_EOC);
 8008ab6:	f022 0204 	bic.w	r2, r2, #4
    DAC_TypeDef *DAC_OCPCx = pHandle->pParams_str->DAC_OCP_CSelection;
 8008aba:	9401      	str	r4, [sp, #4]
    DAC_TypeDef *DAC_OVPx = pHandle->pParams_str->DAC_OVP_Selection;
 8008abc:	6aac      	ldr	r4, [r5, #40]	@ 0x28
 8008abe:	9402      	str	r4, [sp, #8]
    COMP_TypeDef *COMP_OVPx = pHandle->pParams_str->CompOVPSelection;
 8008ac0:	e9d5 9805 	ldrd	r9, r8, [r5, #20]
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8008ac4:	686c      	ldr	r4, [r5, #4]
    DAC_TypeDef *DAC_OCPBx = pHandle->pParams_str->DAC_OCP_BSelection;
 8008ac6:	e9d5 1b07 	ldrd	r1, fp, [r5, #28]
 8008aca:	4607      	mov	r7, r0
    COMP_TypeDef *COMP_OCPAx = pHandle->pParams_str->CompOCPASelection;
 8008acc:	e9d5 0302 	ldrd	r0, r3, [r5, #8]
 8008ad0:	6072      	str	r2, [r6, #4]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_EOC);
 8008ad2:	f8c6 c000 	str.w	ip, [r6]
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_JEOC);
 8008ad6:	6872      	ldr	r2, [r6, #4]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_JEOC);
 8008ad8:	f04f 0c20 	mov.w	ip, #32
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_JEOC);
 8008adc:	f022 0220 	bic.w	r2, r2, #32
 8008ae0:	6072      	str	r2, [r6, #4]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_JEOC);
 8008ae2:	f8c6 c000 	str.w	ip, [r6]
      if (TIM1 ==  TIMx)
 8008ae6:	4aaa      	ldr	r2, [pc, #680]	@ (8008d90 <R3_1_Init+0x2f8>)
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_DBGMCU_APB2_GRP1_FreezePeriph(uint32_t Periphs)
{
  SET_BIT(DBGMCU->APB2FZ, Periphs);
 8008ae8:	f8df c2b4 	ldr.w	ip, [pc, #692]	@ 8008da0 <R3_1_Init+0x308>
 8008aec:	4294      	cmp	r4, r2
 8008aee:	f8dc 2010 	ldr.w	r2, [ip, #16]
 8008af2:	bf0c      	ite	eq
 8008af4:	f442 6200 	orreq.w	r2, r2, #2048	@ 0x800
 8008af8:	f442 5200 	orrne.w	r2, r2, #8192	@ 0x2000
 8008afc:	f8cc 2010 	str.w	r2, [ip, #16]
      if (OPAMPParams != NULL)
 8008b00:	b190      	cbz	r0, 8008b28 <R3_1_Init+0x90>
        LL_OPAMP_Enable(OPAMPParams->OPAMPSelect_1[1]);
 8008b02:	e9d0 2c00 	ldrd	r2, ip, [r0]
  * @param  OPAMPx OPAMP instance
  * @retval None
  */
__STATIC_INLINE void LL_OPAMP_Enable(OPAMP_TypeDef *OPAMPx)
{
  SET_BIT(OPAMPx->CSR, OPAMP_CSR_OPAMPxEN);
 8008b06:	f8d2 e000 	ldr.w	lr, [r2]
        LL_OPAMP_Enable(OPAMPParams->OPAMPSelect_2[0]);
 8008b0a:	6980      	ldr	r0, [r0, #24]
 8008b0c:	f04e 0e01 	orr.w	lr, lr, #1
 8008b10:	f8c2 e000 	str.w	lr, [r2]
 8008b14:	f8dc 2000 	ldr.w	r2, [ip]
 8008b18:	f042 0201 	orr.w	r2, r2, #1
 8008b1c:	f8cc 2000 	str.w	r2, [ip]
 8008b20:	6802      	ldr	r2, [r0, #0]
 8008b22:	f042 0201 	orr.w	r2, r2, #1
 8008b26:	6002      	str	r2, [r0, #0]
      if (COMP_OCPAx != NULL)
 8008b28:	b19b      	cbz	r3, 8008b52 <R3_1_Init+0xba>
        if ((pHandle->pParams_str->CompOCPAInvInput_MODE != EXT_MODE) && (DAC_OCPAx != MC_NULL))
 8008b2a:	f895 2063 	ldrb.w	r2, [r5, #99]	@ 0x63
 8008b2e:	2a01      	cmp	r2, #1
 8008b30:	d007      	beq.n	8008b42 <R3_1_Init+0xaa>
 8008b32:	b131      	cbz	r1, 8008b42 <R3_1_Init+0xaa>
          R3_1_SetAOReferenceVoltage(pHandle->pParams_str->DAC_Channel_OCPA, DAC_OCPAx,
 8008b34:	f8b5 205e 	ldrh.w	r2, [r5, #94]	@ 0x5e
 8008b38:	6ae8      	ldr	r0, [r5, #44]	@ 0x2c
 8008b3a:	9303      	str	r3, [sp, #12]
 8008b3c:	f7ff ff38 	bl	80089b0 <R3_1_SetAOReferenceVoltage>
 8008b40:	9b03      	ldr	r3, [sp, #12]
  * @param  COMPx Comparator instance
  * @retval None
  */
__STATIC_INLINE void LL_COMP_Enable(COMP_TypeDef *COMPx)
{
  SET_BIT(COMPx->CSR, COMP_CSR_EN);
 8008b42:	681a      	ldr	r2, [r3, #0]
 8008b44:	f042 0201 	orr.w	r2, r2, #1
 8008b48:	601a      	str	r2, [r3, #0]
  * @param  COMPx Comparator instance
  * @retval None
  */
__STATIC_INLINE void LL_COMP_Lock(COMP_TypeDef *COMPx)
{
  SET_BIT(COMPx->CSR, COMP_CSR_LOCK);
 8008b4a:	681a      	ldr	r2, [r3, #0]
 8008b4c:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
 8008b50:	601a      	str	r2, [r3, #0]
      if (COMP_OCPBx != NULL)
 8008b52:	f1ba 0f00 	cmp.w	sl, #0
 8008b56:	d018      	beq.n	8008b8a <R3_1_Init+0xf2>
        if ((pHandle->pParams_str->CompOCPBInvInput_MODE != EXT_MODE) && (DAC_OCPBx != MC_NULL))
 8008b58:	f895 3064 	ldrb.w	r3, [r5, #100]	@ 0x64
 8008b5c:	2b01      	cmp	r3, #1
 8008b5e:	d008      	beq.n	8008b72 <R3_1_Init+0xda>
 8008b60:	f1bb 0f00 	cmp.w	fp, #0
 8008b64:	d005      	beq.n	8008b72 <R3_1_Init+0xda>
          R3_1_SetAOReferenceVoltage(pHandle->pParams_str->DAC_Channel_OCPB, DAC_OCPBx,
 8008b66:	f8b5 205e 	ldrh.w	r2, [r5, #94]	@ 0x5e
 8008b6a:	6b28      	ldr	r0, [r5, #48]	@ 0x30
 8008b6c:	4659      	mov	r1, fp
 8008b6e:	f7ff ff1f 	bl	80089b0 <R3_1_SetAOReferenceVoltage>
  SET_BIT(COMPx->CSR, COMP_CSR_EN);
 8008b72:	f8da 3000 	ldr.w	r3, [sl]
 8008b76:	f043 0301 	orr.w	r3, r3, #1
 8008b7a:	f8ca 3000 	str.w	r3, [sl]
  SET_BIT(COMPx->CSR, COMP_CSR_LOCK);
 8008b7e:	f8da 3000 	ldr.w	r3, [sl]
 8008b82:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8008b86:	f8ca 3000 	str.w	r3, [sl]
      if (COMP_OCPCx != NULL)
 8008b8a:	f1b9 0f00 	cmp.w	r9, #0
 8008b8e:	d017      	beq.n	8008bc0 <R3_1_Init+0x128>
        if ((pHandle->pParams_str->CompOCPCInvInput_MODE != EXT_MODE)  && (DAC_OCPCx != MC_NULL))
 8008b90:	f895 3065 	ldrb.w	r3, [r5, #101]	@ 0x65
 8008b94:	2b01      	cmp	r3, #1
 8008b96:	d007      	beq.n	8008ba8 <R3_1_Init+0x110>
 8008b98:	9b01      	ldr	r3, [sp, #4]
 8008b9a:	b12b      	cbz	r3, 8008ba8 <R3_1_Init+0x110>
          R3_1_SetAOReferenceVoltage(pHandle->pParams_str->DAC_Channel_OCPC, DAC_OCPCx,
 8008b9c:	f8b5 205e 	ldrh.w	r2, [r5, #94]	@ 0x5e
 8008ba0:	6b68      	ldr	r0, [r5, #52]	@ 0x34
 8008ba2:	4619      	mov	r1, r3
 8008ba4:	f7ff ff04 	bl	80089b0 <R3_1_SetAOReferenceVoltage>
  SET_BIT(COMPx->CSR, COMP_CSR_EN);
 8008ba8:	f8d9 3000 	ldr.w	r3, [r9]
 8008bac:	f043 0301 	orr.w	r3, r3, #1
 8008bb0:	f8c9 3000 	str.w	r3, [r9]
  SET_BIT(COMPx->CSR, COMP_CSR_LOCK);
 8008bb4:	f8d9 3000 	ldr.w	r3, [r9]
 8008bb8:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8008bbc:	f8c9 3000 	str.w	r3, [r9]
      if (COMP_OVPx != NULL)
 8008bc0:	f1b8 0f00 	cmp.w	r8, #0
 8008bc4:	d017      	beq.n	8008bf6 <R3_1_Init+0x15e>
        if ((pHandle->pParams_str->CompOVPInvInput_MODE != EXT_MODE) && (DAC_OVPx != MC_NULL))
 8008bc6:	f895 3066 	ldrb.w	r3, [r5, #102]	@ 0x66
 8008bca:	2b01      	cmp	r3, #1
 8008bcc:	d007      	beq.n	8008bde <R3_1_Init+0x146>
 8008bce:	9b02      	ldr	r3, [sp, #8]
 8008bd0:	b12b      	cbz	r3, 8008bde <R3_1_Init+0x146>
          R3_1_SetAOReferenceVoltage(pHandle->pParams_str->DAC_Channel_OVP, DAC_OVPx,
 8008bd2:	f8b5 2060 	ldrh.w	r2, [r5, #96]	@ 0x60
 8008bd6:	6ba8      	ldr	r0, [r5, #56]	@ 0x38
 8008bd8:	4619      	mov	r1, r3
 8008bda:	f7ff fee9 	bl	80089b0 <R3_1_SetAOReferenceVoltage>
  SET_BIT(COMPx->CSR, COMP_CSR_EN);
 8008bde:	f8d8 3000 	ldr.w	r3, [r8]
 8008be2:	f043 0301 	orr.w	r3, r3, #1
 8008be6:	f8c8 3000 	str.w	r3, [r8]
  SET_BIT(COMPx->CSR, COMP_CSR_LOCK);
 8008bea:	f8d8 3000 	ldr.w	r3, [r8]
 8008bee:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8008bf2:	f8c8 3000 	str.w	r3, [r8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8008bf6:	68b3      	ldr	r3, [r6, #8]
 8008bf8:	07d8      	lsls	r0, r3, #31
 8008bfa:	d45a      	bmi.n	8008cb2 <R3_1_Init+0x21a>
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
 8008bfc:	68b3      	ldr	r3, [r6, #8]
 8008bfe:	f023 4320 	bic.w	r3, r3, #2684354560	@ 0xa0000000
 8008c02:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
 8008c06:	60b3      	str	r3, [r6, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 8008c08:	68b3      	ldr	r3, [r6, #8]
 8008c0a:	00d9      	lsls	r1, r3, #3
 8008c0c:	d418      	bmi.n	8008c40 <R3_1_Init+0x1a8>
  MODIFY_REG(ADCx->CR,
 8008c0e:	68b3      	ldr	r3, [r6, #8]
                                         * (SystemCoreClock / (100000UL * 2UL)));
 8008c10:	4a60      	ldr	r2, [pc, #384]	@ (8008d94 <R3_1_Init+0x2fc>)
 8008c12:	f023 4310 	bic.w	r3, r3, #2415919104	@ 0x90000000
 8008c16:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
 8008c1a:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8008c1e:	60b3      	str	r3, [r6, #8]
 8008c20:	4b5d      	ldr	r3, [pc, #372]	@ (8008d98 <R3_1_Init+0x300>)
 8008c22:	681b      	ldr	r3, [r3, #0]
 8008c24:	099b      	lsrs	r3, r3, #6
 8008c26:	fba2 2303 	umull	r2, r3, r2, r3
 8008c2a:	099b      	lsrs	r3, r3, #6
 8008c2c:	005b      	lsls	r3, r3, #1
    volatile uint32_t wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL)
 8008c2e:	9304      	str	r3, [sp, #16]
    while (wait_loop_index != 0UL)
 8008c30:	9b04      	ldr	r3, [sp, #16]
 8008c32:	b12b      	cbz	r3, 8008c40 <R3_1_Init+0x1a8>
      wait_loop_index--;
 8008c34:	9b04      	ldr	r3, [sp, #16]
 8008c36:	3b01      	subs	r3, #1
 8008c38:	9304      	str	r3, [sp, #16]
    while (wait_loop_index != 0UL)
 8008c3a:	9b04      	ldr	r3, [sp, #16]
 8008c3c:	2b00      	cmp	r3, #0
 8008c3e:	d1f9      	bne.n	8008c34 <R3_1_Init+0x19c>
  MODIFY_REG(ADCx->CR,
 8008c40:	68b3      	ldr	r3, [r6, #8]
 8008c42:	f023 4340 	bic.w	r3, r3, #3221225472	@ 0xc0000000
 8008c46:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
 8008c4a:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8008c4e:	60b3      	str	r3, [r6, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADCAL) == (ADC_CR_ADCAL)) ? 1UL : 0UL);
 8008c50:	68b3      	ldr	r3, [r6, #8]
 8008c52:	2b00      	cmp	r3, #0
 8008c54:	dbfc      	blt.n	8008c50 <R3_1_Init+0x1b8>
  return ((READ_BIT(ADCx->ISR, LL_ADC_FLAG_ADRDY) == (LL_ADC_FLAG_ADRDY)) ? 1UL : 0UL);
 8008c56:	6833      	ldr	r3, [r6, #0]
 8008c58:	07da      	lsls	r2, r3, #31
 8008c5a:	d408      	bmi.n	8008c6e <R3_1_Init+0x1d6>
  MODIFY_REG(ADCx->CR,
 8008c5c:	4a4f      	ldr	r2, [pc, #316]	@ (8008d9c <R3_1_Init+0x304>)
 8008c5e:	68b3      	ldr	r3, [r6, #8]
 8008c60:	4013      	ands	r3, r2
 8008c62:	f043 0301 	orr.w	r3, r3, #1
 8008c66:	60b3      	str	r3, [r6, #8]
  return ((READ_BIT(ADCx->ISR, LL_ADC_FLAG_ADRDY) == (LL_ADC_FLAG_ADRDY)) ? 1UL : 0UL);
 8008c68:	6833      	ldr	r3, [r6, #0]
 8008c6a:	07db      	lsls	r3, r3, #31
 8008c6c:	d5f7      	bpl.n	8008c5e <R3_1_Init+0x1c6>
  MODIFY_REG(ADCx->CR,
 8008c6e:	68b3      	ldr	r3, [r6, #8]
 8008c70:	4a4a      	ldr	r2, [pc, #296]	@ (8008d9c <R3_1_Init+0x304>)
 8008c72:	4013      	ands	r3, r2
 8008c74:	f043 0308 	orr.w	r3, r3, #8
 8008c78:	60b3      	str	r3, [r6, #8]
  MODIFY_REG(ADCx->CR,
 8008c7a:	68b3      	ldr	r3, [r6, #8]
 8008c7c:	4013      	ands	r3, r2
 8008c7e:	f043 0320 	orr.w	r3, r3, #32
 8008c82:	60b3      	str	r3, [r6, #8]
  MODIFY_REG(ADCx->CFGR, ADC_CFGR_JQM | ADC_CFGR_JQDIS, QueueMode);
 8008c84:	68f3      	ldr	r3, [r6, #12]
 8008c86:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 8008c8a:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 8008c8e:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 8008c92:	60f3      	str	r3, [r6, #12]
  MODIFY_REG(ADCx->SQR1, ADC_SQR1_L, SequencerNbRanks);
 8008c94:	6b33      	ldr	r3, [r6, #48]	@ 0x30
 8008c96:	f023 030f 	bic.w	r3, r3, #15
 8008c9a:	6333      	str	r3, [r6, #48]	@ 0x30
  MODIFY_REG(ADCx->CR,
 8008c9c:	68b3      	ldr	r3, [r6, #8]
 8008c9e:	4013      	ands	r3, r2
 8008ca0:	f043 0304 	orr.w	r3, r3, #4
 8008ca4:	60b3      	str	r3, [r6, #8]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_JEOS);
 8008ca6:	2340      	movs	r3, #64	@ 0x40
 8008ca8:	6033      	str	r3, [r6, #0]
  SET_BIT(ADCx->IER, LL_ADC_IT_JEOS);
 8008caa:	6873      	ldr	r3, [r6, #4]
 8008cac:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8008cb0:	6073      	str	r3, [r6, #4]
  volatile uint32_t Brk2Timeout = 1000;
 8008cb2:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 8008cb6:	9305      	str	r3, [sp, #20]
  CLEAR_BIT(TIMx->CR1, TIM_CR1_CEN);
 8008cb8:	6823      	ldr	r3, [r4, #0]
 8008cba:	f023 0301 	bic.w	r3, r3, #1
 8008cbe:	6023      	str	r3, [r4, #0]
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 8008cc0:	6863      	ldr	r3, [r4, #4]
 8008cc2:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
 8008cc6:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 8008cca:	6063      	str	r3, [r4, #4]
  SET_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
 8008ccc:	69a3      	ldr	r3, [r4, #24]
 8008cce:	f043 0308 	orr.w	r3, r3, #8
 8008cd2:	61a3      	str	r3, [r4, #24]
 8008cd4:	69a3      	ldr	r3, [r4, #24]
 8008cd6:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
 8008cda:	61a3      	str	r3, [r4, #24]
 8008cdc:	69e3      	ldr	r3, [r4, #28]
 8008cde:	f043 0308 	orr.w	r3, r3, #8
 8008ce2:	61e3      	str	r3, [r4, #28]
 8008ce4:	69e3      	ldr	r3, [r4, #28]
 8008ce6:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
 8008cea:	61e3      	str	r3, [r4, #28]
  SET_BIT(TIMx->EGR, TIM_EGR_UG);
 8008cec:	6963      	ldr	r3, [r4, #20]
 8008cee:	f043 0301 	orr.w	r3, r3, #1
 8008cf2:	6163      	str	r3, [r4, #20]
  if (2U == pHandle->pParams_str->FreqRatio)
 8008cf4:	f895 3067 	ldrb.w	r3, [r5, #103]	@ 0x67
 8008cf8:	2b02      	cmp	r3, #2
 8008cfa:	d011      	beq.n	8008d20 <R3_1_Init+0x288>
    if (M1 == pHandle->_Super.Motor)
 8008cfc:	f897 3078 	ldrb.w	r3, [r7, #120]	@ 0x78
 8008d00:	b9b3      	cbnz	r3, 8008d30 <R3_1_Init+0x298>
      if (1U == pHandle->pParams_str->RepetitionCounter)
 8008d02:	f895 3062 	ldrb.w	r3, [r5, #98]	@ 0x62
 8008d06:	2b01      	cmp	r3, #1
 8008d08:	d00e      	beq.n	8008d28 <R3_1_Init+0x290>
      else if (3U == pHandle->pParams_str->RepetitionCounter)
 8008d0a:	2b03      	cmp	r3, #3
 8008d0c:	d110      	bne.n	8008d30 <R3_1_Init+0x298>
  WRITE_REG(TIMx->RCR, RepetitionCounter);
 8008d0e:	2201      	movs	r2, #1
 8008d10:	6322      	str	r2, [r4, #48]	@ 0x30
  SET_BIT(TIMx->EGR, TIM_EGR_UG);
 8008d12:	6962      	ldr	r2, [r4, #20]
 8008d14:	f042 0201 	orr.w	r2, r2, #1
 8008d18:	6162      	str	r2, [r4, #20]
  WRITE_REG(TIMx->RCR, RepetitionCounter);
 8008d1a:	6323      	str	r3, [r4, #48]	@ 0x30
}
 8008d1c:	e008      	b.n	8008d30 <R3_1_Init+0x298>
 8008d1e:	4770      	bx	lr
    if (HIGHER_FREQ == pHandle->pParams_str->IsHigherFreqTim)
 8008d20:	f895 3068 	ldrb.w	r3, [r5, #104]	@ 0x68
 8008d24:	2b01      	cmp	r3, #1
 8008d26:	d027      	beq.n	8008d78 <R3_1_Init+0x2e0>
        LL_TIM_SetCounter(TIMx, (uint32_t)(pHandle->Half_PWMPeriod) - 1U);
 8008d28:	f8b7 3094 	ldrh.w	r3, [r7, #148]	@ 0x94
 8008d2c:	3b01      	subs	r3, #1
  WRITE_REG(TIMx->CNT, Counter);
 8008d2e:	6263      	str	r3, [r4, #36]	@ 0x24
  WRITE_REG(TIMx->SR, ~(TIM_SR_BIF));
 8008d30:	f06f 0380 	mvn.w	r3, #128	@ 0x80
 8008d34:	6123      	str	r3, [r4, #16]
  return ((READ_BIT(TIMx->SR, TIM_SR_B2IF) == (TIM_SR_B2IF)) ? 1UL : 0UL);
 8008d36:	6923      	ldr	r3, [r4, #16]
  while ((Brk2Timeout != 0u) && (1U == result))
 8008d38:	9a05      	ldr	r2, [sp, #20]
 8008d3a:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8008d3e:	b172      	cbz	r2, 8008d5e <R3_1_Init+0x2c6>
 8008d40:	b16b      	cbz	r3, 8008d5e <R3_1_Init+0x2c6>
  WRITE_REG(TIMx->SR, ~(TIM_SR_B2IF));
 8008d42:	f46f 7180 	mvn.w	r1, #256	@ 0x100
 8008d46:	e000      	b.n	8008d4a <R3_1_Init+0x2b2>
 8008d48:	b14b      	cbz	r3, 8008d5e <R3_1_Init+0x2c6>
 8008d4a:	6121      	str	r1, [r4, #16]
    Brk2Timeout--;
 8008d4c:	9b05      	ldr	r3, [sp, #20]
 8008d4e:	3b01      	subs	r3, #1
 8008d50:	9305      	str	r3, [sp, #20]
  return ((READ_BIT(TIMx->SR, TIM_SR_B2IF) == (TIM_SR_B2IF)) ? 1UL : 0UL);
 8008d52:	6923      	ldr	r3, [r4, #16]
  while ((Brk2Timeout != 0u) && (1U == result))
 8008d54:	9a05      	ldr	r2, [sp, #20]
 8008d56:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8008d5a:	2a00      	cmp	r2, #0
 8008d5c:	d1f4      	bne.n	8008d48 <R3_1_Init+0x2b0>
  SET_BIT(TIMx->DIER, TIM_DIER_BIE);
 8008d5e:	68e3      	ldr	r3, [r4, #12]
 8008d60:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8008d64:	60e3      	str	r3, [r4, #12]
  SET_BIT(TIMx->CCER, Channels);
 8008d66:	6a23      	ldr	r3, [r4, #32]
 8008d68:	f443 63aa 	orr.w	r3, r3, #1360	@ 0x550
 8008d6c:	f043 0305 	orr.w	r3, r3, #5
 8008d70:	6223      	str	r3, [r4, #32]
}
 8008d72:	b007      	add	sp, #28
 8008d74:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (3U == pHandle->pParams_str->RepetitionCounter)
 8008d78:	f895 2062 	ldrb.w	r2, [r5, #98]	@ 0x62
 8008d7c:	2a03      	cmp	r2, #3
 8008d7e:	d1d3      	bne.n	8008d28 <R3_1_Init+0x290>
  WRITE_REG(TIMx->RCR, RepetitionCounter);
 8008d80:	6323      	str	r3, [r4, #48]	@ 0x30
  SET_BIT(TIMx->EGR, TIM_EGR_UG);
 8008d82:	6963      	ldr	r3, [r4, #20]
 8008d84:	f043 0301 	orr.w	r3, r3, #1
 8008d88:	6163      	str	r3, [r4, #20]
  WRITE_REG(TIMx->RCR, RepetitionCounter);
 8008d8a:	6322      	str	r2, [r4, #48]	@ 0x30
}
 8008d8c:	e7cc      	b.n	8008d28 <R3_1_Init+0x290>
 8008d8e:	bf00      	nop
 8008d90:	40012c00 	.word	0x40012c00
 8008d94:	053e2d63 	.word	0x053e2d63
 8008d98:	20000558 	.word	0x20000558
 8008d9c:	7fffffc0 	.word	0x7fffffc0
 8008da0:	e0042000 	.word	0xe0042000

08008da4 <R3_1_SetOffsetCalib>:
{
 8008da4:	b410      	push	{r4}
  pHandle->PhaseAOffset = offsets->phaseAOffset;
 8008da6:	e9d1 4201 	ldrd	r4, r2, [r1, #4]
 8008daa:	680b      	ldr	r3, [r1, #0]
 8008dac:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  pHdl->offsetCalibStatus = true;
 8008db0:	2301      	movs	r3, #1
  pHandle->PhaseAOffset = offsets->phaseAOffset;
 8008db2:	e9c0 4223 	strd	r4, r2, [r0, #140]	@ 0x8c
  pHdl->offsetCalibStatus = true;
 8008db6:	f880 307f 	strb.w	r3, [r0, #127]	@ 0x7f
}
 8008dba:	f85d 4b04 	ldr.w	r4, [sp], #4
 8008dbe:	4770      	bx	lr

08008dc0 <R3_1_GetOffsetCalib>:
  offsets->phaseAOffset = pHandle->PhaseAOffset;
 8008dc0:	e9d0 2323 	ldrd	r2, r3, [r0, #140]	@ 0x8c
 8008dc4:	f8d0 0088 	ldr.w	r0, [r0, #136]	@ 0x88
 8008dc8:	608b      	str	r3, [r1, #8]
 8008dca:	e9c1 0200 	strd	r0, r2, [r1]
}
 8008dce:	4770      	bx	lr

08008dd0 <R3_1_CurrentReadingPolarization>:
{
 8008dd0:	b5f0      	push	{r4, r5, r6, r7, lr}
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8008dd2:	f8d0 309c 	ldr.w	r3, [r0, #156]	@ 0x9c
  ADC_TypeDef *ADCx = pHandle->pParams_str->ADCx;
 8008dd6:	e9d3 6500 	ldrd	r6, r5, [r3]
  if (true == pHandle->_Super.offsetCalibStatus)
 8008dda:	f890 307f 	ldrb.w	r3, [r0, #127]	@ 0x7f
{
 8008dde:	b083      	sub	sp, #12
 8008de0:	4604      	mov	r4, r0
  if (true == pHandle->_Super.offsetCalibStatus)
 8008de2:	b193      	cbz	r3, 8008e0a <R3_1_CurrentReadingPolarization+0x3a>
  MODIFY_REG(ADCx->CR,
 8008de4:	68b3      	ldr	r3, [r6, #8]
 8008de6:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 8008dea:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
    pHandle->ADC_ExternalPolarityInjected = (uint16_t)LL_ADC_INJ_TRIG_EXT_RISING;
 8008dee:	2280      	movs	r2, #128	@ 0x80
 8008df0:	f043 0308 	orr.w	r3, r3, #8
 8008df4:	60b3      	str	r3, [r6, #8]
 8008df6:	f8a0 2096 	strh.w	r2, [r0, #150]	@ 0x96
  pHandle->_Super.Sector = SECTOR_5;
 8008dfa:	2204      	movs	r2, #4
  pHandle->_Super.BrakeActionLock = false;
 8008dfc:	2300      	movs	r3, #0
  pHandle->_Super.Sector = SECTOR_5;
 8008dfe:	f884 207a 	strb.w	r2, [r4, #122]	@ 0x7a
  pHandle->_Super.BrakeActionLock = false;
 8008e02:	f884 3083 	strb.w	r3, [r4, #131]	@ 0x83
}
 8008e06:	b003      	add	sp, #12
 8008e08:	bdf0      	pop	{r4, r5, r6, r7, pc}
    GetPhaseCurrCbSave = pHandle->_Super.pFctGetPhaseCurrents;
 8008e0a:	6802      	ldr	r2, [r0, #0]
 8008e0c:	9200      	str	r2, [sp, #0]
    pHandle->PhaseAOffset = 0U;
 8008e0e:	e9c0 3322 	strd	r3, r3, [r0, #136]	@ 0x88
    SetSampPointSectXCbSave = pHandle->_Super.pFctSetADCSampPointSectX;
 8008e12:	6942      	ldr	r2, [r0, #20]
 8008e14:	9201      	str	r2, [sp, #4]
    pHandle->PolarizationCounter = 0U;
 8008e16:	f880 3098 	strb.w	r3, [r0, #152]	@ 0x98
    pHandle->PhaseCOffset = 0U;
 8008e1a:	f8c0 3090 	str.w	r3, [r0, #144]	@ 0x90
  CLEAR_BIT(TIMx->CCER, Channels);
 8008e1e:	6a2b      	ldr	r3, [r5, #32]
 8008e20:	f423 63aa 	bic.w	r3, r3, #1360	@ 0x550
 8008e24:	f023 0305 	bic.w	r3, r3, #5
 8008e28:	622b      	str	r3, [r5, #32]
    pHandle->_Super.pFctGetPhaseCurrents = &R3_1_HFCurrentsPolarizationAB;
 8008e2a:	4b34      	ldr	r3, [pc, #208]	@ (8008efc <R3_1_CurrentReadingPolarization+0x12c>)
 8008e2c:	6003      	str	r3, [r0, #0]
    pHandle->_Super.pFctSetADCSampPointSectX = &R3_1_SetADCSampPointPolarization;
 8008e2e:	4b34      	ldr	r3, [pc, #208]	@ (8008f00 <R3_1_CurrentReadingPolarization+0x130>)
 8008e30:	6143      	str	r3, [r0, #20]
    pHandle->ADC_ExternalPolarityInjected = (uint16_t)LL_ADC_INJ_TRIG_EXT_RISING;
 8008e32:	2380      	movs	r3, #128	@ 0x80
 8008e34:	f8a0 3096 	strh.w	r3, [r0, #150]	@ 0x96
  pHandle->PolarizationSector=SECTOR_5;
 8008e38:	2304      	movs	r3, #4
 8008e3a:	f880 3099 	strb.w	r3, [r0, #153]	@ 0x99
  pHandle->_Super.Sector = SECTOR_5;   
 8008e3e:	f880 307a 	strb.w	r3, [r0, #122]	@ 0x7a
    R3_1_SwitchOnPWM(&pHandle->_Super);
 8008e42:	f7ff fc91 	bl	8008768 <R3_1_SwitchOnPWM>
    while (((TIMx->CR2) & TIM_CR2_MMS_Msk) != LL_TIM_TRGO_OC4REF)
 8008e46:	4a2f      	ldr	r2, [pc, #188]	@ (8008f04 <R3_1_CurrentReadingPolarization+0x134>)
 8008e48:	686b      	ldr	r3, [r5, #4]
 8008e4a:	4013      	ands	r3, r2
 8008e4c:	2b70      	cmp	r3, #112	@ 0x70
 8008e4e:	d1fb      	bne.n	8008e48 <R3_1_CurrentReadingPolarization+0x78>
 8008e50:	68b3      	ldr	r3, [r6, #8]
 8008e52:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 8008e56:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
 8008e5a:	f043 0308 	orr.w	r3, r3, #8
 8008e5e:	60b3      	str	r3, [r6, #8]
                           pHandle->pParams_str->RepetitionCounter,
 8008e60:	f8d4 309c 	ldr.w	r3, [r4, #156]	@ 0x9c
    waitForPolarizationEnd(TIMx,
 8008e64:	f104 0798 	add.w	r7, r4, #152	@ 0x98
 8008e68:	f893 2062 	ldrb.w	r2, [r3, #98]	@ 0x62
 8008e6c:	f104 0156 	add.w	r1, r4, #86	@ 0x56
 8008e70:	463b      	mov	r3, r7
 8008e72:	4628      	mov	r0, r5
 8008e74:	460e      	mov	r6, r1
 8008e76:	f7f9 fa17 	bl	80022a8 <waitForPolarizationEnd>
    R3_1_SwitchOffPWM(&pHandle->_Super);
 8008e7a:	4620      	mov	r0, r4
 8008e7c:	f7ff fcbe 	bl	80087fc <R3_1_SwitchOffPWM>
    pHandle->PolarizationCounter = 0U;
 8008e80:	2300      	movs	r3, #0
 8008e82:	f884 3098 	strb.w	r3, [r4, #152]	@ 0x98
  pHandle->PolarizationSector=SECTOR_1;
 8008e86:	f884 3099 	strb.w	r3, [r4, #153]	@ 0x99
  pHandle->_Super.Sector = SECTOR_1;   
 8008e8a:	f884 307a 	strb.w	r3, [r4, #122]	@ 0x7a
    pHandle->_Super.pFctGetPhaseCurrents = &R3_1_HFCurrentsPolarizationC;
 8008e8e:	4b1e      	ldr	r3, [pc, #120]	@ (8008f08 <R3_1_CurrentReadingPolarization+0x138>)
 8008e90:	6023      	str	r3, [r4, #0]
    R3_1_SwitchOnPWM(&pHandle->_Super);
 8008e92:	4620      	mov	r0, r4
 8008e94:	f7ff fc68 	bl	8008768 <R3_1_SwitchOnPWM>
                           pHandle->pParams_str->RepetitionCounter,
 8008e98:	f8d4 209c 	ldr.w	r2, [r4, #156]	@ 0x9c
    waitForPolarizationEnd(TIMx,
 8008e9c:	463b      	mov	r3, r7
 8008e9e:	f892 2062 	ldrb.w	r2, [r2, #98]	@ 0x62
 8008ea2:	4631      	mov	r1, r6
 8008ea4:	4628      	mov	r0, r5
 8008ea6:	f7f9 f9ff 	bl	80022a8 <waitForPolarizationEnd>
    R3_1_SwitchOffPWM(&pHandle->_Super);
 8008eaa:	4620      	mov	r0, r4
 8008eac:	f7ff fca6 	bl	80087fc <R3_1_SwitchOffPWM>
    pHandle->PhaseBOffset /= NB_CONVERSIONS;
 8008eb0:	e9d4 1222 	ldrd	r1, r2, [r4, #136]	@ 0x88
    pHandle->PhaseCOffset /= NB_CONVERSIONS;
 8008eb4:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
    pHandle->PhaseBOffset /= NB_CONVERSIONS;
 8008eb8:	0912      	lsrs	r2, r2, #4
    pHandle->PhaseAOffset /= NB_CONVERSIONS;
 8008eba:	0909      	lsrs	r1, r1, #4
    pHandle->PhaseBOffset /= NB_CONVERSIONS;
 8008ebc:	e9c4 1222 	strd	r1, r2, [r4, #136]	@ 0x88
    if (0U == pHandle->_Super.SWerror)
 8008ec0:	f8b4 2056 	ldrh.w	r2, [r4, #86]	@ 0x56
    pHandle->PhaseCOffset /= NB_CONVERSIONS;
 8008ec4:	091b      	lsrs	r3, r3, #4
 8008ec6:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
    if (0U == pHandle->_Super.SWerror)
 8008eca:	b912      	cbnz	r2, 8008ed2 <R3_1_CurrentReadingPolarization+0x102>
      pHandle->_Super.offsetCalibStatus = true;
 8008ecc:	2301      	movs	r3, #1
 8008ece:	f884 307f 	strb.w	r3, [r4, #127]	@ 0x7f
    LL_TIM_OC_SetCompareCH1 (TIMx, pHandle->Half_PWMPeriod >> 1u);
 8008ed2:	f8b4 3094 	ldrh.w	r3, [r4, #148]	@ 0x94
    pHandle->_Super.pFctGetPhaseCurrents = GetPhaseCurrCbSave;
 8008ed6:	9900      	ldr	r1, [sp, #0]
    pHandle->_Super.pFctSetADCSampPointSectX = SetSampPointSectXCbSave;
 8008ed8:	9a01      	ldr	r2, [sp, #4]
    pHandle->_Super.pFctGetPhaseCurrents = GetPhaseCurrCbSave;
 8008eda:	6021      	str	r1, [r4, #0]
    LL_TIM_OC_SetCompareCH1 (TIMx, pHandle->Half_PWMPeriod >> 1u);
 8008edc:	085b      	lsrs	r3, r3, #1
    pHandle->_Super.pFctSetADCSampPointSectX = SetSampPointSectXCbSave;
 8008ede:	6162      	str	r2, [r4, #20]
  WRITE_REG(TIMx->CCR1, CompareValue);
 8008ee0:	636b      	str	r3, [r5, #52]	@ 0x34
  WRITE_REG(TIMx->CCR2, CompareValue);
 8008ee2:	63ab      	str	r3, [r5, #56]	@ 0x38
  WRITE_REG(TIMx->CCR3, CompareValue);
 8008ee4:	63eb      	str	r3, [r5, #60]	@ 0x3c
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_GenerateEvent_COM(TIM_TypeDef *TIMx)
{
  SET_BIT(TIMx->EGR, TIM_EGR_COMG);
 8008ee6:	696b      	ldr	r3, [r5, #20]
 8008ee8:	f043 0320 	orr.w	r3, r3, #32
 8008eec:	616b      	str	r3, [r5, #20]
  SET_BIT(TIMx->CCER, Channels);
 8008eee:	6a2b      	ldr	r3, [r5, #32]
 8008ef0:	f443 63aa 	orr.w	r3, r3, #1360	@ 0x550
 8008ef4:	f043 0305 	orr.w	r3, r3, #5
 8008ef8:	622b      	str	r3, [r5, #32]
}
 8008efa:	e77e      	b.n	8008dfa <R3_1_CurrentReadingPolarization+0x2a>
 8008efc:	080086d1 	.word	0x080086d1
 8008f00:	0800868d 	.word	0x0800868d
 8008f04:	02000070 	.word	0x02000070
 8008f08:	08008721 	.word	0x08008721

08008f0c <R3_1_SetADCSampPointSectX>:
  if (MC_NULL == pHdl)
 8008f0c:	2800      	cmp	r0, #0
 8008f0e:	d03b      	beq.n	8008f88 <R3_1_SetADCSampPointSectX+0x7c>
{
 8008f10:	b530      	push	{r4, r5, lr}
    if ((uint16_t)(pHandle->Half_PWMPeriod - pHdl->lowDuty) > pHandle->pParams_str->Tafter)
 8008f12:	f8b0 3058 	ldrh.w	r3, [r0, #88]	@ 0x58
 8008f16:	f8b0 e094 	ldrh.w	lr, [r0, #148]	@ 0x94
 8008f1a:	f8d0 109c 	ldr.w	r1, [r0, #156]	@ 0x9c
 8008f1e:	ebae 0203 	sub.w	r2, lr, r3
 8008f22:	f8b1 4054 	ldrh.w	r4, [r1, #84]	@ 0x54
 8008f26:	b292      	uxth	r2, r2
 8008f28:	42a2      	cmp	r2, r4
 8008f2a:	d917      	bls.n	8008f5c <R3_1_SetADCSampPointSectX+0x50>
      pHandle->_Super.Sector = SECTOR_5;
 8008f2c:	2204      	movs	r2, #4
      SamplingPoint =  pHandle->Half_PWMPeriod - (uint16_t)1;
 8008f2e:	f10e 33ff 	add.w	r3, lr, #4294967295
      pHandle->_Super.Sector = SECTOR_5;
 8008f32:	f880 207a 	strb.w	r2, [r0, #122]	@ 0x7a
      SamplingPoint =  pHandle->Half_PWMPeriod - (uint16_t)1;
 8008f36:	b29b      	uxth	r3, r3
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8008f38:	684a      	ldr	r2, [r1, #4]
  LL_TIM_OC_SetCompareCH1(TIMx, (uint32_t) pHandle->_Super.CntPhA);
 8008f3a:	f8b0 5050 	ldrh.w	r5, [r0, #80]	@ 0x50
  LL_TIM_OC_SetCompareCH2(TIMx, (uint32_t) pHandle->_Super.CntPhB);
 8008f3e:	f8b0 4052 	ldrh.w	r4, [r0, #82]	@ 0x52
  LL_TIM_OC_SetCompareCH3(TIMx, (uint32_t) pHandle->_Super.CntPhC);
 8008f42:	f8b0 1054 	ldrh.w	r1, [r0, #84]	@ 0x54
  WRITE_REG(TIMx->CCR1, CompareValue);
 8008f46:	6355      	str	r5, [r2, #52]	@ 0x34
  WRITE_REG(TIMx->CCR2, CompareValue);
 8008f48:	6394      	str	r4, [r2, #56]	@ 0x38
  WRITE_REG(TIMx->CCR3, CompareValue);
 8008f4a:	63d1      	str	r1, [r2, #60]	@ 0x3c
  WRITE_REG(TIMx->CCR4, CompareValue);
 8008f4c:	6413      	str	r3, [r2, #64]	@ 0x40
  if (((TIMx->CR2) & TIM_CR2_MMS_Msk) != LL_TIM_TRGO_RESET)
 8008f4e:	6852      	ldr	r2, [r2, #4]
 8008f50:	4b10      	ldr	r3, [pc, #64]	@ (8008f94 <R3_1_SetADCSampPointSectX+0x88>)
 8008f52:	421a      	tst	r2, r3
 8008f54:	bf14      	ite	ne
 8008f56:	2001      	movne	r0, #1
 8008f58:	2000      	moveq	r0, #0
}
 8008f5a:	bd30      	pop	{r4, r5, pc}
      DeltaDuty = (uint16_t)(pHdl->lowDuty - pHdl->midDuty);
 8008f5c:	f8b0 c05a 	ldrh.w	ip, [r0, #90]	@ 0x5a
 8008f60:	eba3 0c0c 	sub.w	ip, r3, ip
      if (DeltaDuty > ((uint16_t)(pHandle->Half_PWMPeriod - pHdl->lowDuty) * 2U))
 8008f64:	fa1f fc8c 	uxth.w	ip, ip
 8008f68:	ebbc 0f42 	cmp.w	ip, r2, lsl #1
 8008f6c:	d80d      	bhi.n	8008f8a <R3_1_SetADCSampPointSectX+0x7e>
        SamplingPoint = pHdl->lowDuty + pHandle->pParams_str->Tafter;
 8008f6e:	4423      	add	r3, r4
 8008f70:	b29b      	uxth	r3, r3
        if (SamplingPoint >= pHandle->Half_PWMPeriod)
 8008f72:	459e      	cmp	lr, r3
 8008f74:	d8e0      	bhi.n	8008f38 <R3_1_SetADCSampPointSectX+0x2c>
          SamplingPoint = (2U * pHandle->Half_PWMPeriod) - SamplingPoint - (uint16_t)1;
 8008f76:	43db      	mvns	r3, r3
          pHandle->ADC_ExternalPolarityInjected = (uint16_t)LL_ADC_INJ_TRIG_EXT_FALLING;
 8008f78:	f44f 7280 	mov.w	r2, #256	@ 0x100
          SamplingPoint = (2U * pHandle->Half_PWMPeriod) - SamplingPoint - (uint16_t)1;
 8008f7c:	eb03 034e 	add.w	r3, r3, lr, lsl #1
          pHandle->ADC_ExternalPolarityInjected = (uint16_t)LL_ADC_INJ_TRIG_EXT_FALLING;
 8008f80:	f8a0 2096 	strh.w	r2, [r0, #150]	@ 0x96
          SamplingPoint = (2U * pHandle->Half_PWMPeriod) - SamplingPoint - (uint16_t)1;
 8008f84:	b29b      	uxth	r3, r3
 8008f86:	e7d7      	b.n	8008f38 <R3_1_SetADCSampPointSectX+0x2c>
}
 8008f88:	4770      	bx	lr
        SamplingPoint = pHdl->lowDuty - pHandle->pParams_str->Tbefore;
 8008f8a:	f8b1 2058 	ldrh.w	r2, [r1, #88]	@ 0x58
 8008f8e:	1a9b      	subs	r3, r3, r2
 8008f90:	b29b      	uxth	r3, r3
 8008f92:	e7d1      	b.n	8008f38 <R3_1_SetADCSampPointSectX+0x2c>
 8008f94:	02000070 	.word	0x02000070

08008f98 <R3_1_TIMx_UP_IRQHandler>:
  if (MC_NULL == pHandle)
 8008f98:	4602      	mov	r2, r0
 8008f9a:	2800      	cmp	r0, #0
 8008f9c:	d034      	beq.n	8009008 <R3_1_TIMx_UP_IRQHandler+0x70>
{
 8008f9e:	b4f0      	push	{r4, r5, r6, r7}
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8008fa0:	f8d0 009c 	ldr.w	r0, [r0, #156]	@ 0x9c
    ADCx->JSQR = pHandle->pParams_str->ADCConfig[pHandle->_Super.Sector] | (uint32_t) pHandle->ADC_ExternalPolarityInjected;
 8008fa4:	f892 c07a 	ldrb.w	ip, [r2, #122]	@ 0x7a
    ADC_TypeDef *ADCx = pHandle->pParams_str->ADCx;
 8008fa8:	6801      	ldr	r1, [r0, #0]
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8008faa:	e9d0 5401 	ldrd	r5, r4, [r0, #4]
    if (OPAMPParams != NULL)
 8008fae:	b1ac      	cbz	r4, 8008fdc <R3_1_TIMx_UP_IRQHandler+0x44>
      while (ADCx->JSQR != 0x0u)
 8008fb0:	6ccb      	ldr	r3, [r1, #76]	@ 0x4c
 8008fb2:	2b00      	cmp	r3, #0
 8008fb4:	d1fc      	bne.n	8008fb0 <R3_1_TIMx_UP_IRQHandler+0x18>
      operationAmp = OPAMPParams->OPAMPSelect_1[pHandle->_Super.Sector];
 8008fb6:	f854 702c 	ldr.w	r7, [r4, ip, lsl #2]
      if (operationAmp != NULL)
 8008fba:	eb04 048c 	add.w	r4, r4, ip, lsl #2
 8008fbe:	b12f      	cbz	r7, 8008fcc <R3_1_TIMx_UP_IRQHandler+0x34>
        MODIFY_REG(operationAmp->CSR, (OPAMP_CSR_OPAMPINTEN | OPAMP_CSR_VPSEL), OpampConfig);
 8008fc0:	683b      	ldr	r3, [r7, #0]
 8008fc2:	6b26      	ldr	r6, [r4, #48]	@ 0x30
 8008fc4:	f423 7386 	bic.w	r3, r3, #268	@ 0x10c
 8008fc8:	4333      	orrs	r3, r6
 8008fca:	603b      	str	r3, [r7, #0]
      operationAmp = OPAMPParams->OPAMPSelect_2[pHandle->_Super.Sector];
 8008fcc:	69a6      	ldr	r6, [r4, #24]
      if (operationAmp != NULL)
 8008fce:	b12e      	cbz	r6, 8008fdc <R3_1_TIMx_UP_IRQHandler+0x44>
        MODIFY_REG(operationAmp->CSR, (OPAMP_CSR_OPAMPINTEN | OPAMP_CSR_VPSEL), OpampConfig);
 8008fd0:	6833      	ldr	r3, [r6, #0]
 8008fd2:	6ca4      	ldr	r4, [r4, #72]	@ 0x48
 8008fd4:	f423 7386 	bic.w	r3, r3, #268	@ 0x10c
 8008fd8:	4323      	orrs	r3, r4
 8008fda:	6033      	str	r3, [r6, #0]
    ADCx->JSQR = pHandle->pParams_str->ADCConfig[pHandle->_Super.Sector] | (uint32_t) pHandle->ADC_ExternalPolarityInjected;
 8008fdc:	eb00 008c 	add.w	r0, r0, ip, lsl #2
 8008fe0:	f8b2 3096 	ldrh.w	r3, [r2, #150]	@ 0x96
 8008fe4:	6bc0      	ldr	r0, [r0, #60]	@ 0x3c
 8008fe6:	4303      	orrs	r3, r0
 8008fe8:	64cb      	str	r3, [r1, #76]	@ 0x4c
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 8008fea:	686b      	ldr	r3, [r5, #4]
 8008fec:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
 8008ff0:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
    pHandle->ADC_ExternalPolarityInjected = (uint16_t)LL_ADC_INJ_TRIG_EXT_RISING;
 8008ff4:	2180      	movs	r1, #128	@ 0x80
 8008ff6:	f043 0370 	orr.w	r3, r3, #112	@ 0x70
 8008ffa:	606b      	str	r3, [r5, #4]
    tempPointer = &(pHandle->_Super.Motor);
 8008ffc:	f102 0078 	add.w	r0, r2, #120	@ 0x78
}
 8009000:	bcf0      	pop	{r4, r5, r6, r7}
    pHandle->ADC_ExternalPolarityInjected = (uint16_t)LL_ADC_INJ_TRIG_EXT_RISING;
 8009002:	f8a2 1096 	strh.w	r1, [r2, #150]	@ 0x96
}
 8009006:	4770      	bx	lr
 8009008:	4770      	bx	lr
 800900a:	bf00      	nop

0800900c <R3_1_RLDetectionModeEnable>:
  if (false == pHandle->_Super.RLDetectionMode)
 800900c:	f890 107e 	ldrb.w	r1, [r0, #126]	@ 0x7e
{
 8009010:	b410      	push	{r4}
  if (false == pHandle->_Super.RLDetectionMode)
 8009012:	2900      	cmp	r1, #0
 8009014:	d13f      	bne.n	8009096 <R3_1_RLDetectionModeEnable+0x8a>
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009016:	f8d0 309c 	ldr.w	r3, [r0, #156]	@ 0x9c
 800901a:	685b      	ldr	r3, [r3, #4]
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 800901c:	699a      	ldr	r2, [r3, #24]
 800901e:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 8009022:	f022 0273 	bic.w	r2, r2, #115	@ 0x73
 8009026:	f042 0260 	orr.w	r2, r2, #96	@ 0x60
 800902a:	619a      	str	r2, [r3, #24]
  SET_BIT(TIMx->CCER, Channels);
 800902c:	6a1a      	ldr	r2, [r3, #32]
 800902e:	f042 0201 	orr.w	r2, r2, #1
 8009032:	621a      	str	r2, [r3, #32]
  CLEAR_BIT(TIMx->CCER, Channels);
 8009034:	6a1a      	ldr	r2, [r3, #32]
 8009036:	f022 0204 	bic.w	r2, r2, #4
 800903a:	621a      	str	r2, [r3, #32]
  WRITE_REG(TIMx->CCR1, CompareValue);
 800903c:	6359      	str	r1, [r3, #52]	@ 0x34
    if (LS_PWM_TIMER == pHandle->_Super.LowSideOutputs)
 800903e:	f890 207b 	ldrb.w	r2, [r0, #123]	@ 0x7b
 8009042:	2a01      	cmp	r2, #1
  __IO uint32_t *pReg = (__IO uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
 8009044:	f103 0418 	add.w	r4, r3, #24
 8009048:	d033      	beq.n	80090b2 <R3_1_RLDetectionModeEnable+0xa6>
    else if (ES_GPIO ==  pHandle->_Super.LowSideOutputs)
 800904a:	2a02      	cmp	r2, #2
 800904c:	d10f      	bne.n	800906e <R3_1_RLDetectionModeEnable+0x62>
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 800904e:	699a      	ldr	r2, [r3, #24]
 8009050:	f022 7280 	bic.w	r2, r2, #16777216	@ 0x1000000
 8009054:	f422 42e6 	bic.w	r2, r2, #29440	@ 0x7300
 8009058:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
 800905c:	619a      	str	r2, [r3, #24]
  SET_BIT(TIMx->CCER, Channels);
 800905e:	6a1a      	ldr	r2, [r3, #32]
 8009060:	f042 0210 	orr.w	r2, r2, #16
 8009064:	621a      	str	r2, [r3, #32]
  CLEAR_BIT(TIMx->CCER, Channels);
 8009066:	6a1a      	ldr	r2, [r3, #32]
 8009068:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 800906c:	621a      	str	r2, [r3, #32]
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 800906e:	6862      	ldr	r2, [r4, #4]
 8009070:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 8009074:	f022 0273 	bic.w	r2, r2, #115	@ 0x73
 8009078:	f042 0270 	orr.w	r2, r2, #112	@ 0x70
 800907c:	6062      	str	r2, [r4, #4]
  CLEAR_BIT(TIMx->CCER, Channels);
 800907e:	6a1a      	ldr	r2, [r3, #32]
    pHandle->PhaseAOffset = pHandle->PhaseBOffset; /* Use only the offset of phB */
 8009080:	f8d0 108c 	ldr.w	r1, [r0, #140]	@ 0x8c
 8009084:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
 8009088:	621a      	str	r2, [r3, #32]
 800908a:	6a1a      	ldr	r2, [r3, #32]
 800908c:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 8009090:	621a      	str	r2, [r3, #32]
 8009092:	f8c0 1088 	str.w	r1, [r0, #136]	@ 0x88
  pHandle->_Super.pFctTurnOnLowSides = &R3_1_RLTurnOnLowSides;
 8009096:	4b0f      	ldr	r3, [pc, #60]	@ (80090d4 <R3_1_RLDetectionModeEnable+0xc8>)
  pHandle->_Super.pFctSwitchOnPwm = &R3_1_RLSwitchOnPWM;
 8009098:	490f      	ldr	r1, [pc, #60]	@ (80090d8 <R3_1_RLDetectionModeEnable+0xcc>)
  pHandle->_Super.pFctSwitchOffPwm = &R3_1_SwitchOffPWM;
 800909a:	4a10      	ldr	r2, [pc, #64]	@ (80090dc <R3_1_RLDetectionModeEnable+0xd0>)
  pHandle->_Super.pFctGetPhaseCurrents = &R3_1_RLGetPhaseCurrents;
 800909c:	4c10      	ldr	r4, [pc, #64]	@ (80090e0 <R3_1_RLDetectionModeEnable+0xd4>)
  pHandle->_Super.pFctTurnOnLowSides = &R3_1_RLTurnOnLowSides;
 800909e:	6103      	str	r3, [r0, #16]
  pHandle->_Super.RLDetectionMode = true;
 80090a0:	2301      	movs	r3, #1
  pHandle->_Super.pFctGetPhaseCurrents = &R3_1_RLGetPhaseCurrents;
 80090a2:	6004      	str	r4, [r0, #0]
  pHandle->_Super.pFctSwitchOffPwm = &R3_1_SwitchOffPWM;
 80090a4:	e9c0 2101 	strd	r2, r1, [r0, #4]
}
 80090a8:	f85d 4b04 	ldr.w	r4, [sp], #4
  pHandle->_Super.RLDetectionMode = true;
 80090ac:	f880 307e 	strb.w	r3, [r0, #126]	@ 0x7e
}
 80090b0:	4770      	bx	lr
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 80090b2:	699a      	ldr	r2, [r3, #24]
 80090b4:	f022 7280 	bic.w	r2, r2, #16777216	@ 0x1000000
 80090b8:	f422 42e6 	bic.w	r2, r2, #29440	@ 0x7300
 80090bc:	f442 5280 	orr.w	r2, r2, #4096	@ 0x1000
 80090c0:	619a      	str	r2, [r3, #24]
  CLEAR_BIT(TIMx->CCER, Channels);
 80090c2:	6a1a      	ldr	r2, [r3, #32]
 80090c4:	f022 0210 	bic.w	r2, r2, #16
 80090c8:	621a      	str	r2, [r3, #32]
  SET_BIT(TIMx->CCER, Channels);
 80090ca:	6a1a      	ldr	r2, [r3, #32]
 80090cc:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 80090d0:	621a      	str	r2, [r3, #32]
}
 80090d2:	e7cc      	b.n	800906e <R3_1_RLDetectionModeEnable+0x62>
 80090d4:	08008a49 	.word	0x08008a49
 80090d8:	080088c5 	.word	0x080088c5
 80090dc:	080087fd 	.word	0x080087fd
 80090e0:	08008879 	.word	0x08008879

080090e4 <R3_1_RLDetectionModeDisable>:
  if (true ==  pHandle->_Super.RLDetectionMode)
 80090e4:	f890 307e 	ldrb.w	r3, [r0, #126]	@ 0x7e
 80090e8:	2b00      	cmp	r3, #0
 80090ea:	d03d      	beq.n	8009168 <R3_1_RLDetectionModeDisable+0x84>
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 80090ec:	f8d0 309c 	ldr.w	r3, [r0, #156]	@ 0x9c
    LL_TIM_OC_SetCompareCH1(TIMx, ((uint32_t)pHandle->Half_PWMPeriod) >> 1);
 80090f0:	f8b0 1094 	ldrh.w	r1, [r0, #148]	@ 0x94
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 80090f4:	685b      	ldr	r3, [r3, #4]
{
 80090f6:	b410      	push	{r4}
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 80090f8:	699a      	ldr	r2, [r3, #24]
 80090fa:	4c40      	ldr	r4, [pc, #256]	@ (80091fc <R3_1_RLDetectionModeDisable+0x118>)
 80090fc:	4022      	ands	r2, r4
 80090fe:	f042 0260 	orr.w	r2, r2, #96	@ 0x60
 8009102:	619a      	str	r2, [r3, #24]
  SET_BIT(TIMx->CCER, Channels);
 8009104:	6a1a      	ldr	r2, [r3, #32]
 8009106:	f042 0201 	orr.w	r2, r2, #1
 800910a:	621a      	str	r2, [r3, #32]
    if (LS_PWM_TIMER == pHandle->_Super.LowSideOutputs)
 800910c:	f890 207b 	ldrb.w	r2, [r0, #123]	@ 0x7b
 8009110:	2a01      	cmp	r2, #1
    LL_TIM_OC_SetCompareCH1(TIMx, ((uint32_t)pHandle->Half_PWMPeriod) >> 1);
 8009112:	ea4f 0151 	mov.w	r1, r1, lsr #1
    if (LS_PWM_TIMER == pHandle->_Super.LowSideOutputs)
 8009116:	d028      	beq.n	800916a <R3_1_RLDetectionModeDisable+0x86>
    else if (ES_GPIO == pHandle->_Super.LowSideOutputs)
 8009118:	2a02      	cmp	r2, #2
 800911a:	d04a      	beq.n	80091b2 <R3_1_RLDetectionModeDisable+0xce>
  WRITE_REG(TIMx->CCR1, CompareValue);
 800911c:	6359      	str	r1, [r3, #52]	@ 0x34
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 800911e:	699a      	ldr	r2, [r3, #24]
 8009120:	f022 7280 	bic.w	r2, r2, #16777216	@ 0x1000000
 8009124:	f422 42e6 	bic.w	r2, r2, #29440	@ 0x7300
 8009128:	f442 42c0 	orr.w	r2, r2, #24576	@ 0x6000
 800912c:	619a      	str	r2, [r3, #24]
  SET_BIT(TIMx->CCER, Channels);
 800912e:	6a1a      	ldr	r2, [r3, #32]
 8009130:	f042 0210 	orr.w	r2, r2, #16
 8009134:	621a      	str	r2, [r3, #32]
  WRITE_REG(TIMx->CCR2, CompareValue);
 8009136:	6399      	str	r1, [r3, #56]	@ 0x38
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 8009138:	69da      	ldr	r2, [r3, #28]
 800913a:	4022      	ands	r2, r4
 800913c:	f042 0260 	orr.w	r2, r2, #96	@ 0x60
 8009140:	61da      	str	r2, [r3, #28]
  SET_BIT(TIMx->CCER, Channels);
 8009142:	6a1a      	ldr	r2, [r3, #32]
 8009144:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 8009148:	621a      	str	r2, [r3, #32]
    pHandle->_Super.pFctGetPhaseCurrents = &R3_1_GetPhaseCurrents;
 800914a:	4a2d      	ldr	r2, [pc, #180]	@ (8009200 <R3_1_RLDetectionModeDisable+0x11c>)
  WRITE_REG(TIMx->CCR3, CompareValue);
 800914c:	63d9      	str	r1, [r3, #60]	@ 0x3c
    pHandle->_Super.pFctSwitchOnPwm = &R3_1_SwitchOnPWM;
 800914e:	492d      	ldr	r1, [pc, #180]	@ (8009204 <R3_1_RLDetectionModeDisable+0x120>)
    pHandle->_Super.pFctGetPhaseCurrents = &R3_1_GetPhaseCurrents;
 8009150:	6002      	str	r2, [r0, #0]
    pHandle->_Super.pFctSwitchOffPwm = &R3_1_SwitchOffPWM;
 8009152:	4a2d      	ldr	r2, [pc, #180]	@ (8009208 <R3_1_RLDetectionModeDisable+0x124>)
    pHandle->_Super.pFctTurnOnLowSides = &R3_1_TurnOnLowSides;
 8009154:	4c2d      	ldr	r4, [pc, #180]	@ (800920c <R3_1_RLDetectionModeDisable+0x128>)
 8009156:	6104      	str	r4, [r0, #16]
    pHandle->_Super.RLDetectionMode = false;
 8009158:	2300      	movs	r3, #0
    pHandle->_Super.pFctSwitchOffPwm = &R3_1_SwitchOffPWM;
 800915a:	e9c0 2101 	strd	r2, r1, [r0, #4]
}
 800915e:	f85d 4b04 	ldr.w	r4, [sp], #4
    pHandle->_Super.RLDetectionMode = false;
 8009162:	f880 307e 	strb.w	r3, [r0, #126]	@ 0x7e
}
 8009166:	4770      	bx	lr
 8009168:	4770      	bx	lr
  SET_BIT(TIMx->CCER, Channels);
 800916a:	6a1a      	ldr	r2, [r3, #32]
 800916c:	f042 0204 	orr.w	r2, r2, #4
 8009170:	621a      	str	r2, [r3, #32]
  WRITE_REG(TIMx->CCR1, CompareValue);
 8009172:	6359      	str	r1, [r3, #52]	@ 0x34
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 8009174:	699a      	ldr	r2, [r3, #24]
 8009176:	f022 7280 	bic.w	r2, r2, #16777216	@ 0x1000000
 800917a:	f422 42e6 	bic.w	r2, r2, #29440	@ 0x7300
 800917e:	f442 42c0 	orr.w	r2, r2, #24576	@ 0x6000
 8009182:	619a      	str	r2, [r3, #24]
  SET_BIT(TIMx->CCER, Channels);
 8009184:	6a1a      	ldr	r2, [r3, #32]
 8009186:	f042 0210 	orr.w	r2, r2, #16
 800918a:	621a      	str	r2, [r3, #32]
 800918c:	6a1a      	ldr	r2, [r3, #32]
 800918e:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 8009192:	621a      	str	r2, [r3, #32]
  WRITE_REG(TIMx->CCR2, CompareValue);
 8009194:	6399      	str	r1, [r3, #56]	@ 0x38
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 8009196:	69da      	ldr	r2, [r3, #28]
 8009198:	4022      	ands	r2, r4
 800919a:	f042 0260 	orr.w	r2, r2, #96	@ 0x60
 800919e:	61da      	str	r2, [r3, #28]
  SET_BIT(TIMx->CCER, Channels);
 80091a0:	6a1a      	ldr	r2, [r3, #32]
 80091a2:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 80091a6:	621a      	str	r2, [r3, #32]
 80091a8:	6a1a      	ldr	r2, [r3, #32]
 80091aa:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 80091ae:	621a      	str	r2, [r3, #32]
}
 80091b0:	e7cb      	b.n	800914a <R3_1_RLDetectionModeDisable+0x66>
  CLEAR_BIT(TIMx->CCER, Channels);
 80091b2:	6a1a      	ldr	r2, [r3, #32]
 80091b4:	f022 0204 	bic.w	r2, r2, #4
 80091b8:	621a      	str	r2, [r3, #32]
  WRITE_REG(TIMx->CCR1, CompareValue);
 80091ba:	6359      	str	r1, [r3, #52]	@ 0x34
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 80091bc:	699a      	ldr	r2, [r3, #24]
 80091be:	f022 7280 	bic.w	r2, r2, #16777216	@ 0x1000000
 80091c2:	f422 42e6 	bic.w	r2, r2, #29440	@ 0x7300
 80091c6:	f442 42c0 	orr.w	r2, r2, #24576	@ 0x6000
 80091ca:	619a      	str	r2, [r3, #24]
  SET_BIT(TIMx->CCER, Channels);
 80091cc:	6a1a      	ldr	r2, [r3, #32]
 80091ce:	f042 0210 	orr.w	r2, r2, #16
 80091d2:	621a      	str	r2, [r3, #32]
  CLEAR_BIT(TIMx->CCER, Channels);
 80091d4:	6a1a      	ldr	r2, [r3, #32]
 80091d6:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 80091da:	621a      	str	r2, [r3, #32]
  WRITE_REG(TIMx->CCR2, CompareValue);
 80091dc:	6399      	str	r1, [r3, #56]	@ 0x38
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 80091de:	69da      	ldr	r2, [r3, #28]
 80091e0:	4022      	ands	r2, r4
 80091e2:	f042 0260 	orr.w	r2, r2, #96	@ 0x60
 80091e6:	61da      	str	r2, [r3, #28]
  SET_BIT(TIMx->CCER, Channels);
 80091e8:	6a1a      	ldr	r2, [r3, #32]
 80091ea:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 80091ee:	621a      	str	r2, [r3, #32]
  CLEAR_BIT(TIMx->CCER, Channels);
 80091f0:	6a1a      	ldr	r2, [r3, #32]
 80091f2:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 80091f6:	621a      	str	r2, [r3, #32]
}
 80091f8:	e7a7      	b.n	800914a <R3_1_RLDetectionModeDisable+0x66>
 80091fa:	bf00      	nop
 80091fc:	fffeff8c 	.word	0xfffeff8c
 8009200:	08008515 	.word	0x08008515
 8009204:	08008769 	.word	0x08008769
 8009208:	080087fd 	.word	0x080087fd
 800920c:	0800895d 	.word	0x0800895d

08009210 <R3_1_RLDetectionModeSetDuty>:
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009210:	f8d0 209c 	ldr.w	r2, [r0, #156]	@ 0x9c
    val = (((uint32_t)pHandle->Half_PWMPeriod) * ((uint32_t)hDuty)) >> 16;
 8009214:	f8b0 c094 	ldrh.w	ip, [r0, #148]	@ 0x94
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009218:	6852      	ldr	r2, [r2, #4]
{
 800921a:	4603      	mov	r3, r0
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 800921c:	69d0      	ldr	r0, [r2, #28]
 800921e:	f020 7080 	bic.w	r0, r0, #16777216	@ 0x1000000
    val = (((uint32_t)pHandle->Half_PWMPeriod) * ((uint32_t)hDuty)) >> 16;
 8009222:	fb0c f101 	mul.w	r1, ip, r1
 8009226:	f420 40e6 	bic.w	r0, r0, #29440	@ 0x7300
{
 800922a:	b410      	push	{r4}
    val = (((uint32_t)pHandle->Half_PWMPeriod) * ((uint32_t)hDuty)) >> 16;
 800922c:	0c09      	lsrs	r1, r1, #16
    pHandle->ADCRegularLocked = true;
 800922e:	2401      	movs	r4, #1
 8009230:	f440 40e0 	orr.w	r0, r0, #28672	@ 0x7000
 8009234:	f883 40a0 	strb.w	r4, [r3, #160]	@ 0xa0
    pHandle->_Super.CntPhA = (uint16_t)val;
 8009238:	f8a3 1050 	strh.w	r1, [r3, #80]	@ 0x50
 800923c:	61d0      	str	r0, [r2, #28]
    LL_TIM_OC_SetCompareCH4(TIMx, (((uint32_t)pHandle->Half_PWMPeriod) - ((uint32_t)pHandle->_Super.Ton)));
 800923e:	f8b3 0074 	ldrh.w	r0, [r3, #116]	@ 0x74
    LL_TIM_OC_SetCompareCH3(TIMx, (uint32_t)pHandle->_Super.Toff);
 8009242:	f8b3 4076 	ldrh.w	r4, [r3, #118]	@ 0x76
    LL_TIM_OC_SetCompareCH4(TIMx, (((uint32_t)pHandle->Half_PWMPeriod) - ((uint32_t)pHandle->_Super.Ton)));
 8009246:	ebac 0000 	sub.w	r0, ip, r0
  WRITE_REG(TIMx->CCR4, CompareValue);
 800924a:	6410      	str	r0, [r2, #64]	@ 0x40
  WRITE_REG(TIMx->CCR3, CompareValue);
 800924c:	63d4      	str	r4, [r2, #60]	@ 0x3c
  WRITE_REG(TIMx->CCR1, CompareValue);
 800924e:	6351      	str	r1, [r2, #52]	@ 0x34
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 8009250:	6851      	ldr	r1, [r2, #4]
    if (1U ==  pHandle->_Super.SWerror)
 8009252:	f8b3 0056 	ldrh.w	r0, [r3, #86]	@ 0x56
 8009256:	f021 7100 	bic.w	r1, r1, #33554432	@ 0x2000000
 800925a:	f021 0170 	bic.w	r1, r1, #112	@ 0x70
    pHdl->Sector = SECTOR_4;
 800925e:	f04f 0c03 	mov.w	ip, #3
 8009262:	f041 0170 	orr.w	r1, r1, #112	@ 0x70
 8009266:	6051      	str	r1, [r2, #4]
    if (1U ==  pHandle->_Super.SWerror)
 8009268:	2801      	cmp	r0, #1
    pHdl->Sector = SECTOR_4;
 800926a:	f883 c07a 	strb.w	ip, [r3, #122]	@ 0x7a
    if (((TIMx->CR2) & TIM_CR2_MMS_Msk) != LL_TIM_TRGO_RESET)
 800926e:	6852      	ldr	r2, [r2, #4]
    if (1U ==  pHandle->_Super.SWerror)
 8009270:	d007      	beq.n	8009282 <R3_1_RLDetectionModeSetDuty+0x72>
    if (((TIMx->CR2) & TIM_CR2_MMS_Msk) != LL_TIM_TRGO_RESET)
 8009272:	4b07      	ldr	r3, [pc, #28]	@ (8009290 <R3_1_RLDetectionModeSetDuty+0x80>)
}
 8009274:	f85d 4b04 	ldr.w	r4, [sp], #4
    if (((TIMx->CR2) & TIM_CR2_MMS_Msk) != LL_TIM_TRGO_RESET)
 8009278:	421a      	tst	r2, r3
 800927a:	bf14      	ite	ne
 800927c:	2001      	movne	r0, #1
 800927e:	2000      	moveq	r0, #0
}
 8009280:	4770      	bx	lr
      pHandle->_Super.SWerror = 0U;
 8009282:	2200      	movs	r2, #0
}
 8009284:	f85d 4b04 	ldr.w	r4, [sp], #4
      pHandle->_Super.SWerror = 0U;
 8009288:	f8a3 2056 	strh.w	r2, [r3, #86]	@ 0x56
}
 800928c:	4770      	bx	lr
 800928e:	bf00      	nop
 8009290:	02000070 	.word	0x02000070

08009294 <R3_1_RLTurnOnLowSidesAndStart>:
  }
  else
  {
#endif
    PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009294:	f8d0 309c 	ldr.w	r3, [r0, #156]	@ 0x9c
 8009298:	685b      	ldr	r3, [r3, #4]

    pHandle->ADCRegularLocked=true;
 800929a:	2101      	movs	r1, #1
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 800929c:	f06f 0201 	mvn.w	r2, #1
{
 80092a0:	b430      	push	{r4, r5}
    pHandle->ADCRegularLocked=true;
 80092a2:	f880 10a0 	strb.w	r1, [r0, #160]	@ 0xa0
 80092a6:	611a      	str	r2, [r3, #16]
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 80092a8:	691a      	ldr	r2, [r3, #16]
 80092aa:	07d1      	lsls	r1, r2, #31
 80092ac:	d5fc      	bpl.n	80092a8 <R3_1_RLTurnOnLowSidesAndStart+0x14>
    LL_TIM_ClearFlag_UPDATE(TIMx);

    LL_TIM_OC_SetCompareCH1(TIMx, 0x0U);
    LL_TIM_OC_SetCompareCH2(TIMx, 0x0U);
    LL_TIM_OC_SetCompareCH3(TIMx, 0x0U);
    LL_TIM_OC_SetCompareCH4(TIMx, ((uint32_t )pHandle->Half_PWMPeriod) - 5U);
 80092ae:	f8b0 2094 	ldrh.w	r2, [r0, #148]	@ 0x94
  WRITE_REG(TIMx->CCR1, CompareValue);
 80092b2:	2100      	movs	r1, #0
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 80092b4:	f06f 0401 	mvn.w	r4, #1
 80092b8:	3a05      	subs	r2, #5
 80092ba:	611c      	str	r4, [r3, #16]
  WRITE_REG(TIMx->CCR1, CompareValue);
 80092bc:	6359      	str	r1, [r3, #52]	@ 0x34
  WRITE_REG(TIMx->CCR2, CompareValue);
 80092be:	6399      	str	r1, [r3, #56]	@ 0x38
  WRITE_REG(TIMx->CCR3, CompareValue);
 80092c0:	63d9      	str	r1, [r3, #60]	@ 0x3c
  WRITE_REG(TIMx->CCR4, CompareValue);
 80092c2:	641a      	str	r2, [r3, #64]	@ 0x40
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 80092c4:	691a      	ldr	r2, [r3, #16]
 80092c6:	07d2      	lsls	r2, r2, #31
 80092c8:	d5fc      	bpl.n	80092c4 <R3_1_RLTurnOnLowSidesAndStart+0x30>
    {
      /* Nothing to do */
    }

    /* Main PWM Output Enable */
    TIMx->BDTR |= LL_TIM_OSSI_ENABLE ;
 80092ca:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 80092cc:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 80092d0:	645a      	str	r2, [r3, #68]	@ 0x44
  SET_BIT(TIMx->BDTR, TIM_BDTR_MOE);
 80092d2:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 80092d4:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 80092d8:	645a      	str	r2, [r3, #68]	@ 0x44
    LL_TIM_EnableAllOutputs (TIMx);

    if (ES_GPIO == pHandle->_Super.LowSideOutputs )
 80092da:	f890 207b 	ldrb.w	r2, [r0, #123]	@ 0x7b
 80092de:	2a02      	cmp	r2, #2
 80092e0:	d10b      	bne.n	80092fa <R3_1_RLTurnOnLowSidesAndStart+0x66>
    {
      /* It is executed during calibration phase the EN signal shall stay off */
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_u_port, pHandle->_Super.pwm_en_u_pin);
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 80092e2:	e9d0 410f 	ldrd	r4, r1, [r0, #60]	@ 0x3c
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_u_port, pHandle->_Super.pwm_en_u_pin);
 80092e6:	f8b0 5048 	ldrh.w	r5, [r0, #72]	@ 0x48
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 80092ea:	6c42      	ldr	r2, [r0, #68]	@ 0x44
  WRITE_REG(GPIOx->BSRR, PinMask);
 80092ec:	61a5      	str	r5, [r4, #24]
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 80092ee:	f8b0 404a 	ldrh.w	r4, [r0, #74]	@ 0x4a
 80092f2:	618c      	str	r4, [r1, #24]
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 80092f4:	f8b0 104c 	ldrh.w	r1, [r0, #76]	@ 0x4c
 80092f8:	6191      	str	r1, [r2, #24]
    else
    {
      /* Nothing to do */
    }

    pHdl->Sector = SECTOR_4;
 80092fa:	2203      	movs	r2, #3
 80092fc:	f880 207a 	strb.w	r2, [r0, #122]	@ 0x7a
  SET_BIT(TIMx->CCER, Channels);
 8009300:	6a1a      	ldr	r2, [r3, #32]
 8009302:	f442 5280 	orr.w	r2, r2, #4096	@ 0x1000
 8009306:	621a      	str	r2, [r3, #32]
  SET_BIT(TIMx->DIER, TIM_DIER_UIE);
 8009308:	68da      	ldr	r2, [r3, #12]
 800930a:	f042 0201 	orr.w	r2, r2, #1

    LL_TIM_EnableIT_UPDATE(TIMx);
#ifdef NULL_PTR_CHECK_R3_1_PWM_CURR_FDB
  }
#endif
}
 800930e:	bc30      	pop	{r4, r5}
 8009310:	60da      	str	r2, [r3, #12]
 8009312:	4770      	bx	lr

08009314 <RVBS_Clear>:
  {
#endif
    uint16_t aux;
    uint16_t index;

    aux = (pHandle->OverVoltageThreshold + pHandle->UnderVoltageThreshold) / 2U;
 8009314:	f8b0 c00c 	ldrh.w	ip, [r0, #12]
 8009318:	8a42      	ldrh	r2, [r0, #18]
    for (index = 0U; index < pHandle->LowPassFilterBW; index++)
 800931a:	8943      	ldrh	r3, [r0, #10]
    aux = (pHandle->OverVoltageThreshold + pHandle->UnderVoltageThreshold) / 2U;
 800931c:	4494      	add	ip, r2
 800931e:	ea4f 0c5c 	mov.w	ip, ip, lsr #1
{
 8009322:	b430      	push	{r4, r5}
 8009324:	2500      	movs	r5, #0
 8009326:	f36c 050f 	bfi	r5, ip, #0, #16
 800932a:	f36c 451f 	bfi	r5, ip, #16, #16
    for (index = 0U; index < pHandle->LowPassFilterBW; index++)
 800932e:	b14b      	cbz	r3, 8009344 <RVBS_Clear+0x30>
    {
      pHandle->aBuffer[index] = aux;
 8009330:	6944      	ldr	r4, [r0, #20]
 8009332:	2300      	movs	r3, #0
 8009334:	b29a      	uxth	r2, r3
    for (index = 0U; index < pHandle->LowPassFilterBW; index++)
 8009336:	3301      	adds	r3, #1
      pHandle->aBuffer[index] = aux;
 8009338:	f824 c012 	strh.w	ip, [r4, r2, lsl #1]
    for (index = 0U; index < pHandle->LowPassFilterBW; index++)
 800933c:	8941      	ldrh	r1, [r0, #10]
 800933e:	b29a      	uxth	r2, r3
 8009340:	4291      	cmp	r1, r2
 8009342:	d8f7      	bhi.n	8009334 <RVBS_Clear+0x20>
    }
    pHandle->_Super.LatestConv = aux;
    pHandle->_Super.AvBusVoltage_d = aux;
    pHandle->index = 0U;
 8009344:	2300      	movs	r3, #0
    pHandle->_Super.LatestConv = aux;
 8009346:	6045      	str	r5, [r0, #4]
    pHandle->index = 0U;
 8009348:	7643      	strb	r3, [r0, #25]
#ifdef NULL_PTR_CHECK_RDIV_BUS_VLT_SNS
  }
#endif
}
 800934a:	bc30      	pop	{r4, r5}
 800934c:	4770      	bx	lr
 800934e:	bf00      	nop

08009350 <RVBS_Init>:
{
 8009350:	b508      	push	{r3, lr}
    RVBS_Clear(pHandle);
 8009352:	f7ff ffdf 	bl	8009314 <RVBS_Clear>
}
 8009356:	bd08      	pop	{r3, pc}

08009358 <RVBS_CheckFaultState>:
  }
  else
  {
#endif
	/* If both thresholds are equal, single threshold feature is used */
	if (pHandle->OverVoltageThreshold == pHandle->OverVoltageThresholdLow)
 8009358:	8982      	ldrh	r2, [r0, #12]
 800935a:	89c1      	ldrh	r1, [r0, #14]
	{
      if (pHandle->_Super.AvBusVoltage_d > pHandle->OverVoltageThreshold)
 800935c:	88c3      	ldrh	r3, [r0, #6]
	if (pHandle->OverVoltageThreshold == pHandle->OverVoltageThresholdLow)
 800935e:	428a      	cmp	r2, r1
 8009360:	d010      	beq.n	8009384 <RVBS_CheckFaultState+0x2c>
      }
	}
    else
    {
      /* If both thresholds are different, hysteresis feature is used (Brake mode) */
      if (pHandle->_Super.AvBusVoltage_d < pHandle->UnderVoltageThreshold)
 8009362:	f8b0 c012 	ldrh.w	ip, [r0, #18]
 8009366:	459c      	cmp	ip, r3
 8009368:	d80a      	bhi.n	8009380 <RVBS_CheckFaultState+0x28>
{
 800936a:	b410      	push	{r4}
      {
        fault = MC_UNDER_VOLT;
      }
      else if ( false == pHandle->OverVoltageHysteresisUpDir )
 800936c:	7c04      	ldrb	r4, [r0, #16]
 800936e:	b994      	cbnz	r4, 8009396 <RVBS_CheckFaultState+0x3e>
      {
        if (pHandle->_Super.AvBusVoltage_d < pHandle->OverVoltageThresholdLow)
 8009370:	4299      	cmp	r1, r3
 8009372:	d914      	bls.n	800939e <RVBS_CheckFaultState+0x46>
        {
          pHandle->OverVoltageHysteresisUpDir = true;
 8009374:	2301      	movs	r3, #1
 8009376:	7403      	strb	r3, [r0, #16]
        {
          pHandle->OverVoltageHysteresisUpDir = false;
          fault = MC_OVER_VOLT;
        }
        else{
          fault = MC_NO_ERROR;
 8009378:	2000      	movs	r0, #0
    }
#ifdef NULL_PTR_CHECK_RDIV_BUS_VLT_SNS
  }
#endif
  return (fault);
}
 800937a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800937e:	4770      	bx	lr
        fault = MC_UNDER_VOLT;
 8009380:	2004      	movs	r0, #4
 8009382:	4770      	bx	lr
      if (pHandle->_Super.AvBusVoltage_d > pHandle->OverVoltageThreshold)
 8009384:	429a      	cmp	r2, r3
 8009386:	d30c      	bcc.n	80093a2 <RVBS_CheckFaultState+0x4a>
      else if (pHandle->_Super.AvBusVoltage_d < pHandle->UnderVoltageThreshold)
 8009388:	8a40      	ldrh	r0, [r0, #18]
 800938a:	4298      	cmp	r0, r3
 800938c:	bf94      	ite	ls
 800938e:	2000      	movls	r0, #0
 8009390:	2001      	movhi	r0, #1
 8009392:	0080      	lsls	r0, r0, #2
 8009394:	4770      	bx	lr
        if (pHandle->_Super.AvBusVoltage_d > pHandle->OverVoltageThreshold)
 8009396:	429a      	cmp	r2, r3
 8009398:	d2ee      	bcs.n	8009378 <RVBS_CheckFaultState+0x20>
          pHandle->OverVoltageHysteresisUpDir = false;
 800939a:	2300      	movs	r3, #0
 800939c:	7403      	strb	r3, [r0, #16]
          fault = MC_OVER_VOLT;
 800939e:	2002      	movs	r0, #2
 80093a0:	e7eb      	b.n	800937a <RVBS_CheckFaultState+0x22>
 80093a2:	2002      	movs	r0, #2
}
 80093a4:	4770      	bx	lr
 80093a6:	bf00      	nop

080093a8 <RVBS_CalcAvVbus>:
{
 80093a8:	b538      	push	{r3, r4, r5, lr}
    if (0xFFFFU == hAux)
 80093aa:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 80093ae:	4299      	cmp	r1, r3
{
 80093b0:	4604      	mov	r4, r0
    if (0xFFFFU == hAux)
 80093b2:	d021      	beq.n	80093f8 <RVBS_CalcAvVbus+0x50>
      pHandle->aBuffer[pHandle->index] = hAux;
 80093b4:	6943      	ldr	r3, [r0, #20]
 80093b6:	7e45      	ldrb	r5, [r0, #25]
 80093b8:	f823 1015 	strh.w	r1, [r3, r5, lsl #1]
      for (i = 0U; i < (uint8_t)pHandle->LowPassFilterBW; i++)
 80093bc:	f8b0 e00a 	ldrh.w	lr, [r0, #10]
 80093c0:	f01e 02ff 	ands.w	r2, lr, #255	@ 0xff
 80093c4:	d00d      	beq.n	80093e2 <RVBS_CalcAvVbus+0x3a>
 80093c6:	3a01      	subs	r2, #1
 80093c8:	b2d2      	uxtb	r2, r2
 80093ca:	eb03 0042 	add.w	r0, r3, r2, lsl #1
 80093ce:	3b02      	subs	r3, #2
      wtemp = 0u;
 80093d0:	2200      	movs	r2, #0
        wtemp += pHandle->aBuffer[i];
 80093d2:	f833 cf02 	ldrh.w	ip, [r3, #2]!
      for (i = 0U; i < (uint8_t)pHandle->LowPassFilterBW; i++)
 80093d6:	4298      	cmp	r0, r3
        wtemp += pHandle->aBuffer[i];
 80093d8:	4462      	add	r2, ip
      for (i = 0U; i < (uint8_t)pHandle->LowPassFilterBW; i++)
 80093da:	d1fa      	bne.n	80093d2 <RVBS_CalcAvVbus+0x2a>
      wtemp /= pHandle->LowPassFilterBW;
 80093dc:	fbb2 f2fe 	udiv	r2, r2, lr
      pHandle->_Super.AvBusVoltage_d = (uint16_t)wtemp;
 80093e0:	b292      	uxth	r2, r2
      if ((uint16_t)pHandle->index < (pHandle->LowPassFilterBW - 1U))
 80093e2:	f10e 3eff 	add.w	lr, lr, #4294967295
 80093e6:	4575      	cmp	r5, lr
        pHandle->index++;
 80093e8:	bf34      	ite	cc
 80093ea:	3501      	addcc	r5, #1
        pHandle->index = 0U;
 80093ec:	2300      	movcs	r3, #0
      pHandle->_Super.AvBusVoltage_d = (uint16_t)wtemp;
 80093ee:	80e2      	strh	r2, [r4, #6]
      pHandle->_Super.LatestConv = hAux;
 80093f0:	80a1      	strh	r1, [r4, #4]
        pHandle->index++;
 80093f2:	bf34      	ite	cc
 80093f4:	7665      	strbcc	r5, [r4, #25]
        pHandle->index = 0U;
 80093f6:	7663      	strbcs	r3, [r4, #25]
    pHandle->_Super.FaultState = RVBS_CheckFaultState(pHandle);
 80093f8:	4620      	mov	r0, r4
 80093fa:	f7ff ffad 	bl	8009358 <RVBS_CheckFaultState>
 80093fe:	8120      	strh	r0, [r4, #8]
}
 8009400:	bd38      	pop	{r3, r4, r5, pc}
 8009402:	bf00      	nop

08009404 <REMNG_Init>:
  }
  else
  {
#endif
    pHandle->Ext = 0;
    pHandle->TargetFinal = 0;
 8009404:	2300      	movs	r3, #0
    pHandle->RampRemainingStep = 0U;
    pHandle->IncDecAmount = 0;
    pHandle->ScalingFactor = 1U;
 8009406:	2201      	movs	r2, #1
    pHandle->TargetFinal = 0;
 8009408:	e9c0 3301 	strd	r3, r3, [r0, #4]
    pHandle->IncDecAmount = 0;
 800940c:	e9c0 3303 	strd	r3, r3, [r0, #12]
    pHandle->ScalingFactor = 1U;
 8009410:	6142      	str	r2, [r0, #20]
#ifdef NULL_PTR_CHECK_RMP_EXT_MNG
  }
#endif
}
 8009412:	4770      	bx	lr

08009414 <REMNG_Calc>:
  else
  {
#endif
    int32_t current_ref;

    current_ref = pHandle->Ext;
 8009414:	e9d0 2102 	ldrd	r2, r1, [r0, #8]

    /* Update the variable and terminates the ramp if needed */
    if (pHandle->RampRemainingStep > 1U)
 8009418:	2901      	cmp	r1, #1
{
 800941a:	b410      	push	{r4}
 800941c:	4603      	mov	r3, r0
      pHandle->RampRemainingStep --;
    }
    else if (1U == pHandle->RampRemainingStep)
    {
      /* Set the backup value of TargetFinal */
      current_ref = pHandle->TargetFinal * ((int32_t)pHandle->ScalingFactor);
 800941e:	6944      	ldr	r4, [r0, #20]
    if (pHandle->RampRemainingStep > 1U)
 8009420:	d909      	bls.n	8009436 <REMNG_Calc+0x22>
      current_ref += pHandle->IncDecAmount;
 8009422:	6900      	ldr	r0, [r0, #16]
      pHandle->RampRemainingStep --;
 8009424:	3901      	subs	r1, #1
      current_ref += pHandle->IncDecAmount;
 8009426:	4402      	add	r2, r0
      pHandle->RampRemainingStep --;
 8009428:	60d9      	str	r1, [r3, #12]
    {
      /* Do nothing */
    }

    pHandle->Ext = current_ref;
    ret_val = pHandle->Ext / ((int32_t)pHandle->ScalingFactor);
 800942a:	fb92 f0f4 	sdiv	r0, r2, r4
    pHandle->Ext = current_ref;
 800942e:	609a      	str	r2, [r3, #8]
#ifdef NULL_PTR_CHECK_RMP_EXT_MNG
  }
#endif
  return (ret_val);
}
 8009430:	f85d 4b04 	ldr.w	r4, [sp], #4
 8009434:	4770      	bx	lr
    else if (1U == pHandle->RampRemainingStep)
 8009436:	d005      	beq.n	8009444 <REMNG_Calc+0x30>
    ret_val = pHandle->Ext / ((int32_t)pHandle->ScalingFactor);
 8009438:	fb92 f0f4 	sdiv	r0, r2, r4
}
 800943c:	f85d 4b04 	ldr.w	r4, [sp], #4
    pHandle->Ext = current_ref;
 8009440:	609a      	str	r2, [r3, #8]
}
 8009442:	4770      	bx	lr
      current_ref = pHandle->TargetFinal * ((int32_t)pHandle->ScalingFactor);
 8009444:	6840      	ldr	r0, [r0, #4]
 8009446:	fb04 f200 	mul.w	r2, r4, r0
      pHandle->RampRemainingStep = 0U;
 800944a:	2100      	movs	r1, #0
}
 800944c:	f85d 4b04 	ldr.w	r4, [sp], #4
      pHandle->RampRemainingStep = 0U;
 8009450:	60d9      	str	r1, [r3, #12]
    pHandle->Ext = current_ref;
 8009452:	609a      	str	r2, [r3, #8]
}
 8009454:	4770      	bx	lr
 8009456:	bf00      	nop

08009458 <REMNG_RampCompleted>:
    /* Nothing to do */
  }
  else
  {
#endif
    if (0U == pHandle->RampRemainingStep)
 8009458:	68c0      	ldr	r0, [r0, #12]
#ifdef NULL_PTR_CHECK_RMP_EXT_MNG
  }
#endif
  return (retVal);

}
 800945a:	fab0 f080 	clz	r0, r0
 800945e:	0940      	lsrs	r0, r0, #5
 8009460:	4770      	bx	lr
 8009462:	bf00      	nop

08009464 <getScalingFactor>:
  int32_t aux;
  uint8_t i;

  if (Target < 0)
  {
    aux = -Target;
 8009464:	2800      	cmp	r0, #0
 8009466:	bfb8      	it	lt
 8009468:	4240      	neglt	r0, r0
    TargetAbs = (uint32_t)Target;
  }
  for (i = 1U; i < 32U; i++)
  {
    uint32_t limit = (((uint32_t)1) << (31U - i));
    if (TargetAbs >= limit)
 800946a:	f1b0 4f80 	cmp.w	r0, #1073741824	@ 0x40000000
 800946e:	d213      	bcs.n	8009498 <getScalingFactor+0x34>
 8009470:	2302      	movs	r3, #2
    uint32_t limit = (((uint32_t)1) << (31U - i));
 8009472:	f04f 4c00 	mov.w	ip, #2147483648	@ 0x80000000
 8009476:	e001      	b.n	800947c <getScalingFactor+0x18>
  for (i = 1U; i < 32U; i++)
 8009478:	2b20      	cmp	r3, #32
 800947a:	d00a      	beq.n	8009492 <getScalingFactor+0x2e>
    uint32_t limit = (((uint32_t)1) << (31U - i));
 800947c:	fa2c f203 	lsr.w	r2, ip, r3
    if (TargetAbs >= limit)
 8009480:	4290      	cmp	r0, r2
 8009482:	4619      	mov	r1, r3
 8009484:	f103 0301 	add.w	r3, r3, #1
 8009488:	d3f6      	bcc.n	8009478 <getScalingFactor+0x14>
    else
    {
      /* Nothing to do */
    }
  }
  return (((uint32_t)1) << (i - 1U));
 800948a:	3901      	subs	r1, #1
 800948c:	2001      	movs	r0, #1
 800948e:	4088      	lsls	r0, r1
 8009490:	4770      	bx	lr
 8009492:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
 8009496:	4770      	bx	lr
    if (TargetAbs >= limit)
 8009498:	2001      	movs	r0, #1
}
 800949a:	4770      	bx	lr

0800949c <REMNG_ExecRamp>:
{
 800949c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80094a0:	4604      	mov	r4, r0
 80094a2:	460e      	mov	r6, r1
    current_ref = pHandle->Ext / ((int32_t)pHandle->ScalingFactor);
 80094a4:	6880      	ldr	r0, [r0, #8]
 80094a6:	6963      	ldr	r3, [r4, #20]
    if (0U == Durationms)
 80094a8:	4615      	mov	r5, r2
 80094aa:	b962      	cbnz	r2, 80094c6 <REMNG_ExecRamp+0x2a>
      pHandle->ScalingFactor = getScalingFactor(TargetFinal);
 80094ac:	4608      	mov	r0, r1
 80094ae:	f7ff ffd9 	bl	8009464 <getScalingFactor>
      pHandle->Ext = TargetFinal * ((int32_t)pHandle->ScalingFactor);
 80094b2:	fb00 f606 	mul.w	r6, r0, r6
      pHandle->ScalingFactor = getScalingFactor(TargetFinal);
 80094b6:	6160      	str	r0, [r4, #20]
      pHandle->Ext = TargetFinal * ((int32_t)pHandle->ScalingFactor);
 80094b8:	4628      	mov	r0, r5
      pHandle->IncDecAmount = 0;
 80094ba:	e9c4 5003 	strd	r5, r0, [r4, #12]
      pHandle->Ext = TargetFinal * ((int32_t)pHandle->ScalingFactor);
 80094be:	60a6      	str	r6, [r4, #8]
}
 80094c0:	2001      	movs	r0, #1
 80094c2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    current_ref = pHandle->Ext / ((int32_t)pHandle->ScalingFactor);
 80094c6:	fb90 f8f3 	sdiv	r8, r0, r3
      uint32_t wScalingFactor = getScalingFactor(TargetFinal - current_ref);
 80094ca:	eba1 0708 	sub.w	r7, r1, r8
 80094ce:	4638      	mov	r0, r7
 80094d0:	f7ff ffc8 	bl	8009464 <getScalingFactor>
 80094d4:	4682      	mov	sl, r0
      uint32_t wScalingFactor2 = getScalingFactor(current_ref);
 80094d6:	4640      	mov	r0, r8
 80094d8:	f7ff ffc4 	bl	8009464 <getScalingFactor>
 80094dc:	4681      	mov	r9, r0
      uint32_t wScalingFactor3 = getScalingFactor(TargetFinal);
 80094de:	4630      	mov	r0, r6
 80094e0:	f7ff ffc0 	bl	8009464 <getScalingFactor>
      if (wScalingFactor <  wScalingFactor2)
 80094e4:	45ca      	cmp	sl, r9
 80094e6:	d318      	bcc.n	800951a <REMNG_ExecRamp+0x7e>
        if (wScalingFactor2 < wScalingFactor3)
 80094e8:	4548      	cmp	r0, r9
 80094ea:	bf28      	it	cs
 80094ec:	4648      	movcs	r0, r9
      pHandle->Ext = current_ref * ((int32_t)pHandle->ScalingFactor);
 80094ee:	fb08 f300 	mul.w	r3, r8, r0
 80094f2:	60a3      	str	r3, [r4, #8]
      aux = Durationms * ((uint32_t)pHandle->FrequencyHz); /* Check for overflow and use prescaler */
 80094f4:	6823      	ldr	r3, [r4, #0]
      aux /= 1000U;
 80094f6:	4a0b      	ldr	r2, [pc, #44]	@ (8009524 <REMNG_ExecRamp+0x88>)
      pHandle->ScalingFactor = wScalingFactorMin;
 80094f8:	6160      	str	r0, [r4, #20]
      aux = Durationms * ((uint32_t)pHandle->FrequencyHz); /* Check for overflow and use prescaler */
 80094fa:	fb05 f303 	mul.w	r3, r5, r3
      aux /= 1000U;
 80094fe:	fba2 2303 	umull	r2, r3, r2, r3
 8009502:	099b      	lsrs	r3, r3, #6
      pHandle->RampRemainingStep++;
 8009504:	1c5d      	adds	r5, r3, #1
      aux1 = (TargetFinal - current_ref) * ((int32_t)pHandle->ScalingFactor);
 8009506:	fb07 f000 	mul.w	r0, r7, r0
      pHandle->TargetFinal = TargetFinal;
 800950a:	6066      	str	r6, [r4, #4]
      aux1 /= ((int32_t)pHandle->RampRemainingStep);
 800950c:	fb90 f0f5 	sdiv	r0, r0, r5
      pHandle->IncDecAmount = 0;
 8009510:	e9c4 5003 	strd	r5, r0, [r4, #12]
}
 8009514:	2001      	movs	r0, #1
 8009516:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if (wScalingFactor < wScalingFactor3)
 800951a:	4550      	cmp	r0, sl
 800951c:	bf28      	it	cs
 800951e:	4650      	movcs	r0, sl
 8009520:	e7e5      	b.n	80094ee <REMNG_ExecRamp+0x52>
 8009522:	bf00      	nop
 8009524:	10624dd3 	.word	0x10624dd3

08009528 <RUC_Init>:
__weak void RUC_Init(RevUpCtrl_Handle_t *pHandle,
                     SpeednTorqCtrl_Handle_t *pSTC,
                     VirtualSpeedSensor_Handle_t *pVSS,
                     STO_Handle_t *pSNSL,
                     PWMC_Handle_t *pPWM)
{
 8009528:	b500      	push	{lr}
  {
#endif
    RevUpCtrl_PhaseParams_t *pRUCPhaseParams = &pHandle->ParamsData[0];
    uint8_t bPhase = 0U;

    pHandle->pSTC = pSTC;
 800952a:	6681      	str	r1, [r0, #104]	@ 0x68
    pHandle->EnteredZone1 = false;

    while ((pRUCPhaseParams != MC_NULL) && (bPhase < RUC_MAX_PHASE_NUMBER))
    {
      /* Dump HF data for now HF data are forced to 16 bits */
      pRUCPhaseParams = (RevUpCtrl_PhaseParams_t *)pRUCPhaseParams->pNext;  //cstat !MISRAC2012-Rule-11.5
 800952c:	6941      	ldr	r1, [r0, #20]
    pHandle->pSNSL = pSNSL;
 800952e:	e9c0 231b 	strd	r2, r3, [r0, #108]	@ 0x6c
    pHandle->OTFSCLowside = false;
 8009532:	f04f 0c00 	mov.w	ip, #0
    pHandle->pPWM = pPWM;
 8009536:	9b01      	ldr	r3, [sp, #4]
    pHandle->OTFSCLowside = false;
 8009538:	f8a0 c054 	strh.w	ip, [r0, #84]	@ 0x54
    pHandle->pPWM = pPWM;
 800953c:	6743      	str	r3, [r0, #116]	@ 0x74
    while ((pRUCPhaseParams != MC_NULL) && (bPhase < RUC_MAX_PHASE_NUMBER))
 800953e:	b309      	cbz	r1, 8009584 <RUC_Init+0x5c>
      pRUCPhaseParams = (RevUpCtrl_PhaseParams_t *)pRUCPhaseParams->pNext;  //cstat !MISRAC2012-Rule-11.5
 8009540:	688b      	ldr	r3, [r1, #8]
    while ((pRUCPhaseParams != MC_NULL) && (bPhase < RUC_MAX_PHASE_NUMBER))
 8009542:	b323      	cbz	r3, 800958e <RUC_Init+0x66>
      pRUCPhaseParams = (RevUpCtrl_PhaseParams_t *)pRUCPhaseParams->pNext;  //cstat !MISRAC2012-Rule-11.5
 8009544:	689b      	ldr	r3, [r3, #8]
    while ((pRUCPhaseParams != MC_NULL) && (bPhase < RUC_MAX_PHASE_NUMBER))
 8009546:	b32b      	cbz	r3, 8009594 <RUC_Init+0x6c>
      pRUCPhaseParams = (RevUpCtrl_PhaseParams_t *)pRUCPhaseParams->pNext;  //cstat !MISRAC2012-Rule-11.5
 8009548:	689b      	ldr	r3, [r3, #8]
    while ((pRUCPhaseParams != MC_NULL) && (bPhase < RUC_MAX_PHASE_NUMBER))
 800954a:	b333      	cbz	r3, 800959a <RUC_Init+0x72>
 800954c:	689b      	ldr	r3, [r3, #8]
      bPhase++;
 800954e:	f04f 0c05 	mov.w	ip, #5
    while ((pRUCPhaseParams != MC_NULL) && (bPhase < RUC_MAX_PHASE_NUMBER))
 8009552:	b1cb      	cbz	r3, 8009588 <RUC_Init+0x60>
 8009554:	2204      	movs	r2, #4
 8009556:	f04f 0c05 	mov.w	ip, #5
    {
      pHandle->ParamsData[bPhase - 1u].pNext = MC_NULL;

      pHandle->bPhaseNbr = bPhase;

      pHandle->bResetPLLTh = (uint8_t)((RUC_OTF_PLL_RESET_TIMEOUT * pHandle->hRUCFrequencyHz) / 1000U);
 800955a:	8803      	ldrh	r3, [r0, #0]
 800955c:	4910      	ldr	r1, [pc, #64]	@ (80095a0 <RUC_Init+0x78>)
 800955e:	f04f 0e64 	mov.w	lr, #100	@ 0x64
 8009562:	fb0e f303 	mul.w	r3, lr, r3
      pHandle->ParamsData[bPhase - 1u].pNext = MC_NULL;
 8009566:	eb02 0242 	add.w	r2, r2, r2, lsl #1
      pHandle->bResetPLLTh = (uint8_t)((RUC_OTF_PLL_RESET_TIMEOUT * pHandle->hRUCFrequencyHz) / 1000U);
 800956a:	fba1 1303 	umull	r1, r3, r1, r3
      pHandle->ParamsData[bPhase - 1u].pNext = MC_NULL;
 800956e:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8009572:	2100      	movs	r1, #0
      pHandle->bResetPLLTh = (uint8_t)((RUC_OTF_PLL_RESET_TIMEOUT * pHandle->hRUCFrequencyHz) / 1000U);
 8009574:	099b      	lsrs	r3, r3, #6
      pHandle->ParamsData[bPhase - 1u].pNext = MC_NULL;
 8009576:	6151      	str	r1, [r2, #20]
      pHandle->bPhaseNbr = bPhase;
 8009578:	f880 c048 	strb.w	ip, [r0, #72]	@ 0x48
      pHandle->bResetPLLTh = (uint8_t)((RUC_OTF_PLL_RESET_TIMEOUT * pHandle->hRUCFrequencyHz) / 1000U);
 800957c:	f880 3056 	strb.w	r3, [r0, #86]	@ 0x56
    }
#ifdef NULL_PTR_CHECK_REV_UP_CTL
  }
#endif
}
 8009580:	f85d fb04 	ldr.w	pc, [sp], #4
      bPhase++;
 8009584:	f04f 0c01 	mov.w	ip, #1
      pHandle->ParamsData[bPhase - 1u].pNext = MC_NULL;
 8009588:	f10c 32ff 	add.w	r2, ip, #4294967295
 800958c:	e7e5      	b.n	800955a <RUC_Init+0x32>
      bPhase++;
 800958e:	f04f 0c02 	mov.w	ip, #2
 8009592:	e7f9      	b.n	8009588 <RUC_Init+0x60>
 8009594:	f04f 0c03 	mov.w	ip, #3
 8009598:	e7f6      	b.n	8009588 <RUC_Init+0x60>
 800959a:	f04f 0c04 	mov.w	ip, #4
 800959e:	e7f3      	b.n	8009588 <RUC_Init+0x60>
 80095a0:	10624dd3 	.word	0x10624dd3

080095a4 <RUC_Clear>:
  * @param  pHandle: Pointer on Handle structure of RevUp controller.
  * @param  hMotorDirection: Rotor rotation direction.
  *         This parameter must be -1 or +1.
  */
__weak void RUC_Clear(RevUpCtrl_Handle_t *pHandle, int16_t hMotorDirection)
{
 80095a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    /* Nothing to do */
  }
  else
  {
#endif
    VirtualSpeedSensor_Handle_t *pVSS = pHandle->pVSS;
 80095a8:	f8d0 806c 	ldr.w	r8, [r0, #108]	@ 0x6c
    SpeednTorqCtrl_Handle_t *pSTC = pHandle->pSTC;
 80095ac:	6e87      	ldr	r7, [r0, #104]	@ 0x68
    RevUpCtrl_PhaseParams_t *pPhaseParams = pHandle->ParamsData;

    pHandle->hDirection = hMotorDirection;
 80095ae:	80c1      	strh	r1, [r0, #6]
    pHandle->EnteredZone1 = false;

    /* Initializes the rev up stages counter */
    pHandle->bStageCnt = 0U;
 80095b0:	2500      	movs	r5, #0
{
 80095b2:	4604      	mov	r4, r0
    pHandle->bStageCnt = 0U;
 80095b4:	f880 5058 	strb.w	r5, [r0, #88]	@ 0x58
    pHandle->bOTFRelCounter = 0U;
 80095b8:	f880 5053 	strb.w	r5, [r0, #83]	@ 0x53
    pHandle->OTFSCLowside = false;
 80095bc:	f8a0 5054 	strh.w	r5, [r0, #84]	@ 0x54

    /* Calls the clear method of VSS */
    VSS_Clear(pVSS);
 80095c0:	4640      	mov	r0, r8

    /* Sets the STC in torque mode */
    STC_SetControlMode(pSTC, MCM_TORQUE_MODE);

    /* Sets the mechanical starting angle of VSS */
    VSS_SetMecAngle(pVSS, pHandle->hStartingMecAngle * hMotorDirection);
 80095c2:	b28e      	uxth	r6, r1
    VSS_Clear(pVSS);
 80095c4:	f000 fc8a 	bl	8009edc <VSS_Clear>
    STC_SetControlMode(pSTC, MCM_TORQUE_MODE);
 80095c8:	2104      	movs	r1, #4
 80095ca:	4638      	mov	r0, r7
 80095cc:	f000 f8de 	bl	800978c <STC_SetControlMode>
    VSS_SetMecAngle(pVSS, pHandle->hStartingMecAngle * hMotorDirection);
 80095d0:	8863      	ldrh	r3, [r4, #2]
  }
  else
  {
#endif
    pHandle->hElAngleAccu = hMecAngle;
    pHandle->_Super.hMecAngle = pHandle->hElAngleAccu / ((int16_t)pHandle->_Super.bElToMecRatio);
 80095d2:	f898 2001 	ldrb.w	r2, [r8, #1]
 80095d6:	fb13 f306 	smulbb	r3, r3, r6
 80095da:	b21b      	sxth	r3, r3
    pHandle->hElAngleAccu = hMecAngle;
 80095dc:	f8a8 3030 	strh.w	r3, [r8, #48]	@ 0x30
    pHandle->_Super.hElAngle = hMecAngle;
 80095e0:	f8a8 3004 	strh.w	r3, [r8, #4]

    /* Sets to zero the starting torque of STC */
    (void)STC_ExecRamp(pSTC, 0, 0U);
 80095e4:	4629      	mov	r1, r5
    pHandle->_Super.hMecAngle = pHandle->hElAngleAccu / ((int16_t)pHandle->_Super.bElToMecRatio);
 80095e6:	fb93 f3f2 	sdiv	r3, r3, r2
 80095ea:	4638      	mov	r0, r7
 80095ec:	f8a8 3006 	strh.w	r3, [r8, #6]
 80095f0:	462a      	mov	r2, r5
 80095f2:	f000 f8cf 	bl	8009794 <STC_ExecRamp>

    /* Gives the first command to STC and VSS */
    (void)STC_ExecRamp(pSTC, pPhaseParams->hFinalTorque * hMotorDirection, (uint32_t)(pPhaseParams->hDurationms));
 80095f6:	8a21      	ldrh	r1, [r4, #16]
 80095f8:	89a2      	ldrh	r2, [r4, #12]
 80095fa:	fb11 f106 	smulbb	r1, r1, r6
 80095fe:	b209      	sxth	r1, r1
 8009600:	4638      	mov	r0, r7
 8009602:	f000 f8c7 	bl	8009794 <STC_ExecRamp>

    VSS_SetMecAcceleration(pVSS, pPhaseParams->hFinalMecSpeedUnit * hMotorDirection, pPhaseParams->hDurationms);
 8009606:	89e1      	ldrh	r1, [r4, #14]
 8009608:	89a2      	ldrh	r2, [r4, #12]
 800960a:	fb11 f106 	smulbb	r1, r1, r6
 800960e:	b209      	sxth	r1, r1
 8009610:	4640      	mov	r0, r8
 8009612:	f000 fd19 	bl	800a048 <VSS_SetMecAcceleration>

    /* Compute hPhaseRemainingTicks */
    pHandle->hPhaseRemainingTicks = (uint16_t)((((uint32_t)pPhaseParams->hDurationms)
 8009616:	89a3      	ldrh	r3, [r4, #12]
                                              * ((uint32_t)pHandle->hRUCFrequencyHz))
 8009618:	8821      	ldrh	r1, [r4, #0]
                                              / 1000U );
 800961a:	4a07      	ldr	r2, [pc, #28]	@ (8009638 <RUC_Clear+0x94>)

    /* Set the next phases parameter pointer */
    pHandle->pCurrentPhaseParams = (RevUpCtrl_PhaseParams_t *)pPhaseParams->pNext;  //cstat !MISRAC2012-Rule-11.5

    /* Timeout counter for PLL reset during OTF */
    pHandle->bResetPLLCnt = 0U;
 800961c:	f884 5057 	strb.w	r5, [r4, #87]	@ 0x57
                                              * ((uint32_t)pHandle->hRUCFrequencyHz))
 8009620:	fb01 f303 	mul.w	r3, r1, r3
                                              / 1000U );
 8009624:	fba2 2303 	umull	r2, r3, r2, r3
 8009628:	099b      	lsrs	r3, r3, #6
    pHandle->pCurrentPhaseParams = (RevUpCtrl_PhaseParams_t *)pPhaseParams->pNext;  //cstat !MISRAC2012-Rule-11.5
 800962a:	6962      	ldr	r2, [r4, #20]
 800962c:	60a2      	str	r2, [r4, #8]
    pHandle->hPhaseRemainingTicks++;
 800962e:	3301      	adds	r3, #1
 8009630:	80a3      	strh	r3, [r4, #4]
#ifdef NULL_PTR_CHECK_REV_UP_CTL
  }
#endif
}
 8009632:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8009636:	bf00      	nop
 8009638:	10624dd3 	.word	0x10624dd3

0800963c <RUC_Exec>:
    retVal = false;
  }
  else
  {
#endif
    if (pHandle->hPhaseRemainingTicks > 0U)
 800963c:	8883      	ldrh	r3, [r0, #4]
{
 800963e:	b510      	push	{r4, lr}
 8009640:	4604      	mov	r4, r0
    if (pHandle->hPhaseRemainingTicks > 0U)
 8009642:	bb43      	cbnz	r3, 8009696 <RUC_Exec+0x5a>
      /* Nothing to do */
    }

    if (0U == pHandle->hPhaseRemainingTicks)
    {
      if (pHandle->pCurrentPhaseParams != MC_NULL)
 8009644:	68a0      	ldr	r0, [r4, #8]
 8009646:	b328      	cbz	r0, 8009694 <RUC_Exec+0x58>
      {
        /* If it becomes zero the current phase has been completed */
        /* Gives the next command to STC and VSS */
        (void)STC_ExecRamp(pHandle->pSTC, pHandle->pCurrentPhaseParams->hFinalTorque * pHandle->hDirection,
 8009648:	8881      	ldrh	r1, [r0, #4]
 800964a:	88e3      	ldrh	r3, [r4, #6]
 800964c:	8802      	ldrh	r2, [r0, #0]
 800964e:	6ea0      	ldr	r0, [r4, #104]	@ 0x68
 8009650:	fb11 f103 	smulbb	r1, r1, r3
 8009654:	b209      	sxth	r1, r1
 8009656:	f000 f89d 	bl	8009794 <STC_ExecRamp>
                           (uint32_t)(pHandle->pCurrentPhaseParams->hDurationms));

        VSS_SetMecAcceleration(pHandle->pVSS,
                               pHandle->pCurrentPhaseParams->hFinalMecSpeedUnit * pHandle->hDirection,
 800965a:	68a3      	ldr	r3, [r4, #8]
 800965c:	88e0      	ldrh	r0, [r4, #6]
 800965e:	8859      	ldrh	r1, [r3, #2]
        VSS_SetMecAcceleration(pHandle->pVSS,
 8009660:	881a      	ldrh	r2, [r3, #0]
                               pHandle->pCurrentPhaseParams->hFinalMecSpeedUnit * pHandle->hDirection,
 8009662:	fb11 f100 	smulbb	r1, r1, r0
        VSS_SetMecAcceleration(pHandle->pVSS,
 8009666:	b209      	sxth	r1, r1
 8009668:	6ee0      	ldr	r0, [r4, #108]	@ 0x6c
 800966a:	f000 fced 	bl	800a048 <VSS_SetMecAcceleration>
                               pHandle->pCurrentPhaseParams->hDurationms);

        /* Compute hPhaseRemainingTicks */
        pHandle->hPhaseRemainingTicks = (uint16_t)((((uint32_t)pHandle->pCurrentPhaseParams->hDurationms)
 800966e:	68a1      	ldr	r1, [r4, #8]
                                                  * ((uint32_t)pHandle->hRUCFrequencyHz)) / 1000U );
 8009670:	8820      	ldrh	r0, [r4, #0]
        pHandle->hPhaseRemainingTicks = (uint16_t)((((uint32_t)pHandle->pCurrentPhaseParams->hDurationms)
 8009672:	880b      	ldrh	r3, [r1, #0]
                                                  * ((uint32_t)pHandle->hRUCFrequencyHz)) / 1000U );
 8009674:	4a0b      	ldr	r2, [pc, #44]	@ (80096a4 <RUC_Exec+0x68>)
        pHandle->hPhaseRemainingTicks++;

        /* Set the next phases parameter pointer */
        pHandle->pCurrentPhaseParams = pHandle->pCurrentPhaseParams->pNext; //cstat !MISRAC2012-Rule-11.5
 8009676:	6889      	ldr	r1, [r1, #8]
 8009678:	60a1      	str	r1, [r4, #8]
                                                  * ((uint32_t)pHandle->hRUCFrequencyHz)) / 1000U );
 800967a:	fb00 f303 	mul.w	r3, r0, r3
 800967e:	fba2 2303 	umull	r2, r3, r2, r3

        /* Increases the rev up stages counter */
        pHandle->bStageCnt++;
 8009682:	f894 2058 	ldrb.w	r2, [r4, #88]	@ 0x58
                                                  * ((uint32_t)pHandle->hRUCFrequencyHz)) / 1000U );
 8009686:	099b      	lsrs	r3, r3, #6
        pHandle->hPhaseRemainingTicks++;
 8009688:	3301      	adds	r3, #1
        pHandle->bStageCnt++;
 800968a:	3201      	adds	r2, #1
        pHandle->hPhaseRemainingTicks++;
 800968c:	80a3      	strh	r3, [r4, #4]
        pHandle->bStageCnt++;
 800968e:	f884 2058 	strb.w	r2, [r4, #88]	@ 0x58
  bool retVal = true;
 8009692:	2001      	movs	r0, #1
    }
#ifdef NULL_PTR_CHECK_REV_UP_CTL
  }
#endif
  return (retVal);
}
 8009694:	bd10      	pop	{r4, pc}
      pHandle->hPhaseRemainingTicks--;
 8009696:	3b01      	subs	r3, #1
 8009698:	b29b      	uxth	r3, r3
 800969a:	8083      	strh	r3, [r0, #4]
    if (0U == pHandle->hPhaseRemainingTicks)
 800969c:	2b00      	cmp	r3, #0
 800969e:	d0d1      	beq.n	8009644 <RUC_Exec+0x8>
  bool retVal = true;
 80096a0:	2001      	movs	r0, #1
}
 80096a2:	bd10      	pop	{r4, pc}
 80096a4:	10624dd3 	.word	0x10624dd3

080096a8 <RUC_FirstAccelerationStageReached>:
    /* Nothing to do */
  }
  else
  {
#endif
    if (pHandle->bStageCnt >= pHandle->bFirstAccelerationStage)
 80096a8:	f890 2058 	ldrb.w	r2, [r0, #88]	@ 0x58
 80096ac:	f890 0049 	ldrb.w	r0, [r0, #73]	@ 0x49
    }
#ifdef NULL_PTR_CHECK_REV_UP_CTL
  }
#endif
  return (retVal);
}
 80096b0:	4282      	cmp	r2, r0
 80096b2:	bf34      	ite	cc
 80096b4:	2000      	movcc	r0, #0
 80096b6:	2001      	movcs	r0, #1
 80096b8:	4770      	bx	lr
 80096ba:	bf00      	nop

080096bc <SPD_GetAvrgMecSpeedUnit>:
#ifdef NULL_PTR_CHECK_SPD_POS_FBK
  return ((MC_NULL == pHandle) ? 0 : pHandle->hAvrMecSpeedUnit);
#else
  return (pHandle->hAvrMecSpeedUnit);
#endif
}
 80096bc:	f9b0 000c 	ldrsh.w	r0, [r0, #12]
 80096c0:	4770      	bx	lr
 80096c2:	bf00      	nop

080096c4 <SPD_IsMecSpeedReliable>:
    bool SpeedError = false;

    bSpeedErrorNumber = pHandle->bSpeedErrorNumber;

    /* Compute absoulte value of mechanical speed */
    if (*pMecSpeedUnit < 0)
 80096c4:	f9b1 c000 	ldrsh.w	ip, [r1]
{
 80096c8:	4603      	mov	r3, r0
 80096ca:	b510      	push	{r4, lr}
    {
      hAux = -(*pMecSpeedUnit);
 80096cc:	fa1f f18c 	uxth.w	r1, ip
    if (*pMecSpeedUnit < 0)
 80096d0:	f1bc 0f00 	cmp.w	ip, #0
      hAux = -(*pMecSpeedUnit);
 80096d4:	bfb8      	it	lt
 80096d6:	4249      	neglt	r1, r1
    else
    {
      /* Nothing to do */
    }

    if (hAbsMecSpeedUnit < pHandle->hMinReliableMecSpeedUnit)
 80096d8:	f8b3 e016 	ldrh.w	lr, [r3, #22]
    uint8_t bMaximumSpeedErrorsNumber = pHandle->bMaximumSpeedErrorsNumber;
 80096dc:	78c0      	ldrb	r0, [r0, #3]
    bSpeedErrorNumber = pHandle->bSpeedErrorNumber;
 80096de:	781a      	ldrb	r2, [r3, #0]
    if (hAbsMecSpeedUnit > pHandle->hMaxReliableMecSpeedUnit)
 80096e0:	8a9c      	ldrh	r4, [r3, #20]
    {
      /* Nothing to do */
    }

    /* Compute absoulte value of mechanical acceleration */
    if (pHandle->hMecAccelUnitP < 0)
 80096e2:	f9b3 c012 	ldrsh.w	ip, [r3, #18]
      hAux = -(*pMecSpeedUnit);
 80096e6:	bfb8      	it	lt
 80096e8:	b289      	uxthlt	r1, r1
    if (hAbsMecSpeedUnit < pHandle->hMinReliableMecSpeedUnit)
 80096ea:	458e      	cmp	lr, r1
 80096ec:	d816      	bhi.n	800971c <SPD_IsMecSpeedReliable+0x58>
    {
      hAux = -(pHandle->hMecAccelUnitP);
 80096ee:	fa1f fe8c 	uxth.w	lr, ip
    if (pHandle->hMecAccelUnitP < 0)
 80096f2:	f1bc 0f00 	cmp.w	ip, #0
      hAux = -(pHandle->hMecAccelUnitP);
 80096f6:	bfb8      	it	lt
 80096f8:	f1ce 0e00 	rsblt	lr, lr, #0
    else
    {
      hAbsMecAccelUnitP = (uint16_t)pHandle->hMecAccelUnitP;
    }

    if (hAbsMecAccelUnitP > pHandle->hMaxReliableMecAccelUnitP)
 80096fc:	f8b3 c018 	ldrh.w	ip, [r3, #24]
      hAux = -(pHandle->hMecAccelUnitP);
 8009700:	bfb8      	it	lt
 8009702:	fa1f fe8e 	uxthlt.w	lr, lr
    if (hAbsMecAccelUnitP > pHandle->hMaxReliableMecAccelUnitP)
 8009706:	45f4      	cmp	ip, lr
 8009708:	d308      	bcc.n	800971c <SPD_IsMecSpeedReliable+0x58>
    else
    {
      /* Nothing to do */
    }

    if (true == SpeedError)
 800970a:	428c      	cmp	r4, r1
 800970c:	d306      	bcc.n	800971c <SPD_IsMecSpeedReliable+0x58>
        /* Nothing to do */
      }
    }
    else
    {
      if (bSpeedErrorNumber < bMaximumSpeedErrorsNumber)
 800970e:	4290      	cmp	r0, r2
 8009710:	d809      	bhi.n	8009726 <SPD_IsMecSpeedReliable+0x62>
      {
        /* Nothing to do */
      }
    }

    if (bSpeedErrorNumber == bMaximumSpeedErrorsNumber)
 8009712:	1a10      	subs	r0, r2, r0
    else
    {
      /* Nothing to do */
    }

    pHandle->bSpeedErrorNumber = bSpeedErrorNumber;
 8009714:	701a      	strb	r2, [r3, #0]
    if (bSpeedErrorNumber == bMaximumSpeedErrorsNumber)
 8009716:	bf18      	it	ne
 8009718:	2001      	movne	r0, #1
#ifdef NULL_PTR_CHECK_SPD_POS_FBK
  }
#endif
  return (SpeedSensorReliability);
}
 800971a:	bd10      	pop	{r4, pc}
      if (bSpeedErrorNumber < bMaximumSpeedErrorsNumber)
 800971c:	4290      	cmp	r0, r2
 800971e:	d9f8      	bls.n	8009712 <SPD_IsMecSpeedReliable+0x4e>
        bSpeedErrorNumber++;
 8009720:	3201      	adds	r2, #1
 8009722:	b2d2      	uxtb	r2, r2
 8009724:	e7f5      	b.n	8009712 <SPD_IsMecSpeedReliable+0x4e>
        bSpeedErrorNumber = 0u;
 8009726:	2200      	movs	r2, #0
    pHandle->bSpeedErrorNumber = bSpeedErrorNumber;
 8009728:	701a      	strb	r2, [r3, #0]
  bool SpeedSensorReliability = true;
 800972a:	2001      	movs	r0, #1
}
 800972c:	bd10      	pop	{r4, pc}
 800972e:	bf00      	nop

08009730 <SPD_GetS16Speed>:
  }
  else
  {
#endif
    int32_t wAux = (int32_t)pHandle->hAvrMecSpeedUnit;
    wAux *= INT16_MAX;
 8009730:	f9b0 300c 	ldrsh.w	r3, [r0, #12]
    wAux /= (int16_t)pHandle->hMaxReliableMecSpeedUnit;
 8009734:	f9b0 2014 	ldrsh.w	r2, [r0, #20]
    wAux *= INT16_MAX;
 8009738:	ebc3 33c3 	rsb	r3, r3, r3, lsl #15
    wAux /= (int16_t)pHandle->hMaxReliableMecSpeedUnit;
 800973c:	fb93 f0f2 	sdiv	r0, r3, r2
    tempValue = (int16_t)wAux;
#ifdef NULL_PTR_CHECK_SPD_POS_FBK
  }
#endif
  return (tempValue);
}
 8009740:	b200      	sxth	r0, r0
 8009742:	4770      	bx	lr

08009744 <STC_Init>:
  {
#endif
    pHandle->PISpeed = pPI;
    pHandle->SPD = SPD_Handle;
    pHandle->Mode = pHandle->ModeDefault;
    pHandle->SpeedRefUnitExt = ((int32_t)pHandle->MecSpeedRefUnitDefault) * 65536;
 8009744:	f9b0 c02c 	ldrsh.w	ip, [r0, #44]	@ 0x2c
    pHandle->PISpeed = pPI;
 8009748:	6101      	str	r1, [r0, #16]
    pHandle->TorqueRef = ((int32_t)pHandle->TorqueRefDefault) * 65536;
 800974a:	f9b0 102e 	ldrsh.w	r1, [r0, #46]	@ 0x2e
    pHandle->SPD = SPD_Handle;
 800974e:	6142      	str	r2, [r0, #20]
{
 8009750:	b410      	push	{r4}
    pHandle->Mode = pHandle->ModeDefault;
 8009752:	f890 402a 	ldrb.w	r4, [r0, #42]	@ 0x2a
 8009756:	7004      	strb	r4, [r0, #0]
    pHandle->TargetFinal = 0;
 8009758:	2300      	movs	r3, #0
    pHandle->SpeedRefUnitExt = ((int32_t)pHandle->MecSpeedRefUnitDefault) * 65536;
 800975a:	ea4f 440c 	mov.w	r4, ip, lsl #16
    pHandle->TorqueRef = ((int32_t)pHandle->TorqueRefDefault) * 65536;
 800975e:	0409      	lsls	r1, r1, #16
 8009760:	e9c0 4101 	strd	r4, r1, [r0, #4]
    pHandle->TargetFinal = 0;
 8009764:	8043      	strh	r3, [r0, #2]
    pHandle->RampRemainingStep = 0U;
    pHandle->IncDecAmount = 0;
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
}
 8009766:	f85d 4b04 	ldr.w	r4, [sp], #4
    pHandle->RampRemainingStep = 0U;
 800976a:	60c3      	str	r3, [r0, #12]
    pHandle->IncDecAmount = 0;
 800976c:	6183      	str	r3, [r0, #24]
}
 800976e:	4770      	bx	lr

08009770 <STC_SetSpeedSensor>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->SPD = SPD_Handle;
 8009770:	6141      	str	r1, [r0, #20]
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
}
 8009772:	4770      	bx	lr

08009774 <STC_Clear>:
    /* Nothing to do */
  }
  else
  {
#endif
    if (MCM_SPEED_MODE == pHandle->Mode)
 8009774:	7803      	ldrb	r3, [r0, #0]
 8009776:	2b03      	cmp	r3, #3
 8009778:	d000      	beq.n	800977c <STC_Clear+0x8>
      /* Nothing to do */
    }
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
}
 800977a:	4770      	bx	lr
      PID_SetIntegralTerm(pHandle->PISpeed, 0);
 800977c:	6900      	ldr	r0, [r0, #16]
 800977e:	2100      	movs	r1, #0
 8009780:	f7fe be1e 	b.w	80083c0 <PID_SetIntegralTerm>

08009784 <STC_GetMecSpeedRefUnit>:
  return ((MC_NULL == pHandle) ? 0 : (int16_t)(pHandle->SpeedRefUnitExt / 65536));
#else
  return ((int16_t)(pHandle->SpeedRefUnitExt / 65536));
#endif
#endif
}
 8009784:	f9b0 0006 	ldrsh.w	r0, [r0, #6]
 8009788:	4770      	bx	lr
 800978a:	bf00      	nop

0800978c <STC_SetControlMode>:
  }
  else
  {
#endif
    pHandle->Mode = bMode;
    pHandle->RampRemainingStep = 0u; /* Interrupts previous ramp */
 800978c:	2300      	movs	r3, #0
    pHandle->Mode = bMode;
 800978e:	7001      	strb	r1, [r0, #0]
    pHandle->RampRemainingStep = 0u; /* Interrupts previous ramp */
 8009790:	60c3      	str	r3, [r0, #12]
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
}
 8009792:	4770      	bx	lr

08009794 <STC_ExecRamp>:
  * @ref EncAlignCtrl "Encoder Alignment Control",
  * @ref PositionControl "Position Control" loop or
  * speed regulation with @ref SpeedRegulatorPotentiometer Speed potentiometer.
  */
__weak bool STC_ExecRamp(SpeednTorqCtrl_Handle_t *pHandle, int16_t hTargetFinal, uint32_t hDurationms)
{
 8009794:	b410      	push	{r4}
    uint32_t wAux;
    int32_t wAux1;
    int16_t hCurrentReference;

    /* Check if the hTargetFinal is out of the bound of application */
    if (MCM_TORQUE_MODE == pHandle->Mode)
 8009796:	7803      	ldrb	r3, [r0, #0]
 8009798:	2b04      	cmp	r3, #4
 800979a:	d019      	beq.n	80097d0 <STC_ExecRamp+0x3c>
#else
      hCurrentReference = (int16_t)(pHandle->SpeedRefUnitExt / 65536);
#endif

#ifdef CHECK_BOUNDARY
      if ((int32_t)hTargetFinal > (int32_t)pHandle->MaxAppPositiveMecSpeedUnit)
 800979c:	f8b0 c01e 	ldrh.w	ip, [r0, #30]
 80097a0:	458c      	cmp	ip, r1
 80097a2:	da03      	bge.n	80097ac <STC_ExecRamp+0x18>
 80097a4:	2000      	movs	r0, #0
    }
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
  return (allowedRange);
}
 80097a6:	f85d 4b04 	ldr.w	r4, [sp], #4
 80097aa:	4770      	bx	lr
      else if (hTargetFinal < pHandle->MinAppNegativeMecSpeedUnit)
 80097ac:	f9b0 4024 	ldrsh.w	r4, [r0, #36]	@ 0x24
 80097b0:	428c      	cmp	r4, r1
 80097b2:	dcf7      	bgt.n	80097a4 <STC_ExecRamp+0x10>
      else if ((int32_t)hTargetFinal < (int32_t)pHandle->MinAppPositiveMecSpeedUnit)
 80097b4:	8c04      	ldrh	r4, [r0, #32]
 80097b6:	428c      	cmp	r4, r1
 80097b8:	dd03      	ble.n	80097c2 <STC_ExecRamp+0x2e>
        if (hTargetFinal > pHandle->MaxAppNegativeMecSpeedUnit)
 80097ba:	f9b0 4022 	ldrsh.w	r4, [r0, #34]	@ 0x22
 80097be:	428c      	cmp	r4, r1
 80097c0:	dbf0      	blt.n	80097a4 <STC_ExecRamp+0x10>
      hCurrentReference = (int16_t)(pHandle->SpeedRefUnitExt >> 16);
 80097c2:	6844      	ldr	r4, [r0, #4]
      if (0U == hDurationms)
 80097c4:	b9b2      	cbnz	r2, 80097f4 <STC_ExecRamp+0x60>
        if (MCM_SPEED_MODE == pHandle->Mode)
 80097c6:	2b03      	cmp	r3, #3
 80097c8:	d10a      	bne.n	80097e0 <STC_ExecRamp+0x4c>
          pHandle->SpeedRefUnitExt = ((int32_t)hTargetFinal) * 65536;
 80097ca:	0409      	lsls	r1, r1, #16
 80097cc:	6041      	str	r1, [r0, #4]
 80097ce:	e009      	b.n	80097e4 <STC_ExecRamp+0x50>
      if ((int32_t)hTargetFinal > (int32_t)pHandle->MaxPositiveTorque)
 80097d0:	8cc3      	ldrh	r3, [r0, #38]	@ 0x26
 80097d2:	428b      	cmp	r3, r1
 80097d4:	dbe6      	blt.n	80097a4 <STC_ExecRamp+0x10>
      if ((int32_t)hTargetFinal < (int32_t)pHandle->MinNegativeTorque)
 80097d6:	f9b0 3028 	ldrsh.w	r3, [r0, #40]	@ 0x28
 80097da:	428b      	cmp	r3, r1
 80097dc:	dce2      	bgt.n	80097a4 <STC_ExecRamp+0x10>
      if (0U == hDurationms)
 80097de:	b9da      	cbnz	r2, 8009818 <STC_ExecRamp+0x84>
          pHandle->TorqueRef = ((int32_t)hTargetFinal) * 65536;
 80097e0:	0409      	lsls	r1, r1, #16
 80097e2:	6081      	str	r1, [r0, #8]
        pHandle->IncDecAmount = 0;
 80097e4:	2300      	movs	r3, #0
 80097e6:	461a      	mov	r2, r3
        pHandle->RampRemainingStep = 0U;
 80097e8:	60c3      	str	r3, [r0, #12]
        pHandle->IncDecAmount = 0;
 80097ea:	6182      	str	r2, [r0, #24]
}
 80097ec:	f85d 4b04 	ldr.w	r4, [sp], #4
        pHandle->IncDecAmount = 0;
 80097f0:	2001      	movs	r0, #1
}
 80097f2:	4770      	bx	lr
      hCurrentReference = (int16_t)(pHandle->SpeedRefUnitExt >> 16);
 80097f4:	ea4f 4c24 	mov.w	ip, r4, asr #16
        wAux = ((uint32_t)hDurationms) * ((uint32_t)pHandle->STCFrequencyHz);
 80097f8:	8b83      	ldrh	r3, [r0, #28]
        wAux /= 1000U;
 80097fa:	4c09      	ldr	r4, [pc, #36]	@ (8009820 <STC_ExecRamp+0x8c>)
        pHandle->TargetFinal = hTargetFinal;
 80097fc:	8041      	strh	r1, [r0, #2]
        wAux = ((uint32_t)hDurationms) * ((uint32_t)pHandle->STCFrequencyHz);
 80097fe:	fb02 f303 	mul.w	r3, r2, r3
        wAux /= 1000U;
 8009802:	fba4 4303 	umull	r4, r3, r4, r3
        wAux1 = (((int32_t)hTargetFinal) - ((int32_t)hCurrentReference)) * 65536;
 8009806:	eba1 0c0c 	sub.w	ip, r1, ip
        wAux /= 1000U;
 800980a:	099b      	lsrs	r3, r3, #6
        wAux1 = (((int32_t)hTargetFinal) - ((int32_t)hCurrentReference)) * 65536;
 800980c:	ea4f 420c 	mov.w	r2, ip, lsl #16
        pHandle->RampRemainingStep++;
 8009810:	3301      	adds	r3, #1
        wAux1 /= ((int32_t)pHandle->RampRemainingStep);
 8009812:	fb92 f2f3 	sdiv	r2, r2, r3
        pHandle->IncDecAmount = wAux1;
 8009816:	e7e7      	b.n	80097e8 <STC_ExecRamp+0x54>
  return ((int16_t)(pHandle->TorqueRef >> 16));
 8009818:	f9b0 c00a 	ldrsh.w	ip, [r0, #10]
 800981c:	e7ec      	b.n	80097f8 <STC_ExecRamp+0x64>
 800981e:	bf00      	nop
 8009820:	10624dd3 	.word	0x10624dd3

08009824 <STC_CalcTorqueReference>:
  * - Must be called at fixed time equal to hSTCFrequencyHz. It is called
  * passing as parameter the speed sensor used to perform the speed regulation.
  * - Called during START and ALIGNEMENT states of the MC state machine into MediumFrequencyTask.
  */
__weak int16_t STC_CalcTorqueReference(SpeednTorqCtrl_Handle_t *pHandle)
{
 8009824:	b538      	push	{r3, r4, r5, lr}
    int32_t wCurrentReference;
    int16_t hMeasuredSpeed;
    int16_t hTargetSpeed;
    int16_t hError;

    if (MCM_TORQUE_MODE == pHandle->Mode)
 8009826:	7802      	ldrb	r2, [r0, #0]
      wCurrentReference = pHandle->SpeedRefUnitExt;
    }

    /* Update the speed reference or the torque reference according to the mode
       and terminates the ramp if needed */
    if (pHandle->RampRemainingStep > 1U)
 8009828:	68c3      	ldr	r3, [r0, #12]
    if (MCM_TORQUE_MODE == pHandle->Mode)
 800982a:	2a04      	cmp	r2, #4
{
 800982c:	4604      	mov	r4, r0
    if (MCM_TORQUE_MODE == pHandle->Mode)
 800982e:	d012      	beq.n	8009856 <STC_CalcTorqueReference+0x32>
    if (pHandle->RampRemainingStep > 1U)
 8009830:	2b01      	cmp	r3, #1
      wCurrentReference = pHandle->SpeedRefUnitExt;
 8009832:	6845      	ldr	r5, [r0, #4]
    if (pHandle->RampRemainingStep > 1U)
 8009834:	d908      	bls.n	8009848 <STC_CalcTorqueReference+0x24>
    {
      /* Increment/decrement the reference value */
      wCurrentReference += pHandle->IncDecAmount;
 8009836:	6981      	ldr	r1, [r0, #24]

      /* Decrement the number of remaining steps */
      pHandle->RampRemainingStep--;
 8009838:	3b01      	subs	r3, #1
      wCurrentReference += pHandle->IncDecAmount;
 800983a:	440d      	add	r5, r1
      pHandle->RampRemainingStep--;
 800983c:	60c3      	str	r3, [r0, #12]
    else
    {
      /* Do nothing */
    }

    if (MCM_SPEED_MODE == pHandle->Mode)
 800983e:	2a03      	cmp	r2, #3
 8009840:	d011      	beq.n	8009866 <STC_CalcTorqueReference+0x42>
    else
    {
      pHandle->TorqueRef = wCurrentReference;
#ifndef FULL_MISRA_C_COMPLIANCY_SPD_TORQ_CTRL
      //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
      hTorqueReference = (int16_t)(wCurrentReference >> 16);
 8009842:	1428      	asrs	r0, r5, #16
      pHandle->TorqueRef = ((int32_t)hTorqueReference) * 65536;
 8009844:	60a5      	str	r5, [r4, #8]
    }
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
  return (hTorqueReference);
}
 8009846:	bd38      	pop	{r3, r4, r5, pc}
    else if (1U == pHandle->RampRemainingStep)
 8009848:	d1f9      	bne.n	800983e <STC_CalcTorqueReference+0x1a>
      wCurrentReference = ((int32_t)pHandle->TargetFinal) * 65536;
 800984a:	f9b0 5002 	ldrsh.w	r5, [r0, #2]
      pHandle->RampRemainingStep = 0U;
 800984e:	2300      	movs	r3, #0
      wCurrentReference = ((int32_t)pHandle->TargetFinal) * 65536;
 8009850:	042d      	lsls	r5, r5, #16
      pHandle->RampRemainingStep = 0U;
 8009852:	60c3      	str	r3, [r0, #12]
 8009854:	e7f3      	b.n	800983e <STC_CalcTorqueReference+0x1a>
    if (pHandle->RampRemainingStep > 1U)
 8009856:	2b01      	cmp	r3, #1
      wCurrentReference = pHandle->TorqueRef;
 8009858:	6885      	ldr	r5, [r0, #8]
    if (pHandle->RampRemainingStep > 1U)
 800985a:	d911      	bls.n	8009880 <STC_CalcTorqueReference+0x5c>
      wCurrentReference += pHandle->IncDecAmount;
 800985c:	6982      	ldr	r2, [r0, #24]
      pHandle->RampRemainingStep--;
 800985e:	3b01      	subs	r3, #1
      wCurrentReference += pHandle->IncDecAmount;
 8009860:	4415      	add	r5, r2
      pHandle->RampRemainingStep--;
 8009862:	60c3      	str	r3, [r0, #12]
    if (MCM_SPEED_MODE == pHandle->Mode)
 8009864:	e7ed      	b.n	8009842 <STC_CalcTorqueReference+0x1e>
      hMeasuredSpeed = SPD_GetAvrgMecSpeedUnit(pHandle->SPD);
 8009866:	6960      	ldr	r0, [r4, #20]
 8009868:	f7ff ff28 	bl	80096bc <SPD_GetAvrgMecSpeedUnit>
      hError = hTargetSpeed - hMeasuredSpeed;
 800986c:	ebc0 4125 	rsb	r1, r0, r5, asr #16
      hTorqueReference = PI_Controller(pHandle->PISpeed, (int32_t)hError);
 8009870:	b209      	sxth	r1, r1
 8009872:	6920      	ldr	r0, [r4, #16]
 8009874:	f7fe fdd8 	bl	8008428 <PI_Controller>
      pHandle->SpeedRefUnitExt = wCurrentReference;
 8009878:	6065      	str	r5, [r4, #4]
      pHandle->TorqueRef = ((int32_t)hTorqueReference) * 65536;
 800987a:	0405      	lsls	r5, r0, #16
 800987c:	60a5      	str	r5, [r4, #8]
}
 800987e:	bd38      	pop	{r3, r4, r5, pc}
    else if (1U == pHandle->RampRemainingStep)
 8009880:	d1df      	bne.n	8009842 <STC_CalcTorqueReference+0x1e>
      wCurrentReference = ((int32_t)pHandle->TargetFinal) * 65536;
 8009882:	f9b0 5002 	ldrsh.w	r5, [r0, #2]
      pHandle->RampRemainingStep = 0U;
 8009886:	2300      	movs	r3, #0
      wCurrentReference = ((int32_t)pHandle->TargetFinal) * 65536;
 8009888:	042d      	lsls	r5, r5, #16
      pHandle->RampRemainingStep = 0U;
 800988a:	60c3      	str	r3, [r0, #12]
    if (MCM_SPEED_MODE == pHandle->Mode)
 800988c:	e7d9      	b.n	8009842 <STC_CalcTorqueReference+0x1e>
 800988e:	bf00      	nop

08009890 <STC_GetMecSpeedRefUnitDefault>:
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  return ((MC_NULL == pHandle) ? 0 : pHandle->MecSpeedRefUnitDefault);
#else
  return (pHandle->MecSpeedRefUnitDefault);
#endif
}
 8009890:	f9b0 002c 	ldrsh.w	r0, [r0, #44]	@ 0x2c
 8009894:	4770      	bx	lr
 8009896:	bf00      	nop

08009898 <STC_GetDefaultIqdref>:
    IqdRefDefault.d = 0;
  }
  else
  {
#endif
    IqdRefDefault.q = pHandle->TorqueRefDefault;
 8009898:	f8d0 302e 	ldr.w	r3, [r0, #46]	@ 0x2e
    IqdRefDefault.d = pHandle->IdrefDefault;
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
  return (IqdRefDefault);
 800989c:	2200      	movs	r2, #0
 800989e:	b299      	uxth	r1, r3
 80098a0:	f361 020f 	bfi	r2, r1, #0, #16
 80098a4:	0c1b      	lsrs	r3, r3, #16
 80098a6:	f363 421f 	bfi	r2, r3, #16, #16
{
 80098aa:	b082      	sub	sp, #8
}
 80098ac:	4610      	mov	r0, r2
 80098ae:	b002      	add	sp, #8
 80098b0:	4770      	bx	lr
 80098b2:	bf00      	nop

080098b4 <STC_ForceSpeedReferenceToCurrentSpeed>:
  *
  * - Called during the CHARGE_BOOT_CAP, SWITCH_OVER and WAIT_STOP_MOTOR states of the MC state machine
  * into MediumFrequencyTask to initialize the speed reference.
  */
__weak void STC_ForceSpeedReferenceToCurrentSpeed(SpeednTorqCtrl_Handle_t *pHandle)
{
 80098b4:	b510      	push	{r4, lr}
 80098b6:	4604      	mov	r4, r0
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->SpeedRefUnitExt = ((int32_t)SPD_GetAvrgMecSpeedUnit(pHandle->SPD)) * (int32_t)65536;
 80098b8:	6940      	ldr	r0, [r0, #20]
 80098ba:	f7ff feff 	bl	80096bc <SPD_GetAvrgMecSpeedUnit>
 80098be:	0400      	lsls	r0, r0, #16
 80098c0:	6060      	str	r0, [r4, #4]
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
}
 80098c2:	bd10      	pop	{r4, pc}

080098c4 <STO_CR_CalcElAngle>:
  *         pInputs pointer to the observer inputs structure.
  * @retval int16_t rotor electrical angle (s16Degrees)
  */
//cstat !MISRAC2012-Rule-8.13
__weak int16_t STO_CR_CalcElAngle(STO_CR_Handle_t *pHandle, Observer_Inputs_t *pInputs)
{
 80098c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80098c8:	b085      	sub	sp, #20
    int16_t hRotor_Acceleration;
    int16_t hRotor_Angle;
    int16_t hValfa;
    int16_t hVbeta;

    int16_t hPrev_Rotor_Angle = pHandle->_Super.hElAngle;
 80098ca:	f9b0 2004 	ldrsh.w	r2, [r0, #4]
 80098ce:	9200      	str	r2, [sp, #0]
    int16_t hPrev_Rotor_Speed = pHandle->_Super.hElSpeedDpp;
    int16_t hMax_Instant_Accel = pHandle->MaxInstantElAcceleration;
 80098d0:	f9b0 2176 	ldrsh.w	r2, [r0, #374]	@ 0x176
 80098d4:	9201      	str	r2, [sp, #4]

    if (pHandle->wBemf_alfa_est > ((int32_t)pHandle->hF2 * INT16_MAX))
 80098d6:	f9b0 202e 	ldrsh.w	r2, [r0, #46]	@ 0x2e
 80098da:	6bc5      	ldr	r5, [r0, #60]	@ 0x3c
    int16_t hPrev_Rotor_Speed = pHandle->_Super.hElSpeedDpp;
 80098dc:	f9b0 b00e 	ldrsh.w	fp, [r0, #14]
    if (pHandle->wBemf_alfa_est > ((int32_t)pHandle->hF2 * INT16_MAX))
 80098e0:	ebc2 32c2 	rsb	r2, r2, r2, lsl #15
 80098e4:	4295      	cmp	r5, r2
{
 80098e6:	4603      	mov	r3, r0
    if (pHandle->wBemf_alfa_est > ((int32_t)pHandle->hF2 * INT16_MAX))
 80098e8:	f340 80f3 	ble.w	8009ad2 <STO_CR_CalcElAngle+0x20e>
    {
      pHandle->wBemf_alfa_est = INT16_MAX * (int32_t)(pHandle->hF2);
 80098ec:	63c2      	str	r2, [r0, #60]	@ 0x3c
 80098ee:	4615      	mov	r5, r2
    {
      /* Nothing to do */
    }
#ifndef FULL_MISRA_C_COMPLIANCY_STO_CORDIC
    //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
      hAux_Alfa = (int16_t)(pHandle->wBemf_alfa_est >> pHandle->F2LOG);
 80098f0:	f8b3 c17e 	ldrh.w	ip, [r3, #382]	@ 0x17e
#else
      hAux_Alfa = (int16_t)(pHandle->wBemf_alfa_est / pHandle->hF2);
#endif

    if (pHandle->wBemf_beta_est > (INT16_MAX * (int32_t)(pHandle->hF2)))
 80098f4:	6c1c      	ldr	r4, [r3, #64]	@ 0x40
      hAux_Alfa = (int16_t)(pHandle->wBemf_alfa_est >> pHandle->F2LOG);
 80098f6:	fa45 f70c 	asr.w	r7, r5, ip
    if (pHandle->wBemf_beta_est > (INT16_MAX * (int32_t)(pHandle->hF2)))
 80098fa:	42a2      	cmp	r2, r4
      hAux_Alfa = (int16_t)(pHandle->wBemf_alfa_est >> pHandle->F2LOG);
 80098fc:	b23f      	sxth	r7, r7
    if (pHandle->wBemf_beta_est > (INT16_MAX * (int32_t)(pHandle->hF2)))
 80098fe:	f2c0 80c5 	blt.w	8009a8c <STO_CR_CalcElAngle+0x1c8>
    {
      pHandle->wBemf_beta_est = INT16_MAX * (int32_t)(pHandle->hF2);
    }
    else if (pHandle->wBemf_beta_est <= (-INT16_MAX * (int32_t)(pHandle->hF2)))
 8009902:	4252      	negs	r2, r2
 8009904:	4294      	cmp	r4, r2
 8009906:	f340 80c1 	ble.w	8009a8c <STO_CR_CalcElAngle+0x1c8>
      hAux_Beta = (int16_t)(pHandle->wBemf_beta_est >> pHandle->F2LOG);
#else
      hAux_Beta = (int16_t)(pHandle->wBemf_beta_est / pHandle->hF2);
#endif

    if (pHandle->Ialfa_est > (INT16_MAX * (int32_t)(pHandle->hF1)))
 800990a:	f9b3 202c 	ldrsh.w	r2, [r3, #44]	@ 0x2c
 800990e:	f8d3 9034 	ldr.w	r9, [r3, #52]	@ 0x34
 8009912:	ebc2 32c2 	rsb	r2, r2, r2, lsl #15
      hAux_Beta = (int16_t)(pHandle->wBemf_beta_est >> pHandle->F2LOG);
 8009916:	fa44 fc0c 	asr.w	ip, r4, ip
    if (pHandle->Ialfa_est > (INT16_MAX * (int32_t)(pHandle->hF1)))
 800991a:	4591      	cmp	r9, r2
      hAux_Beta = (int16_t)(pHandle->wBemf_beta_est >> pHandle->F2LOG);
 800991c:	fa0f fc8c 	sxth.w	ip, ip
    if (pHandle->Ialfa_est > (INT16_MAX * (int32_t)(pHandle->hF1)))
 8009920:	f340 80dd 	ble.w	8009ade <STO_CR_CalcElAngle+0x21a>
    {
      pHandle->Ialfa_est = INT16_MAX * (int32_t)(pHandle->hF1);
 8009924:	635a      	str	r2, [r3, #52]	@ 0x34
 8009926:	4691      	mov	r9, r2
    else
    {
      /* Nothing to do */
    }

    if (pHandle->Ibeta_est > (INT16_MAX * (int32_t)(pHandle->hF1)))
 8009928:	f8d3 8038 	ldr.w	r8, [r3, #56]	@ 0x38
 800992c:	4542      	cmp	r2, r8
 800992e:	f2c0 80aa 	blt.w	8009a86 <STO_CR_CalcElAngle+0x1c2>
    {
      pHandle->Ibeta_est = INT16_MAX * (int32_t)(pHandle->hF1);
    }
    else if (pHandle->Ibeta_est <= (-INT16_MAX * (int32_t)(pHandle->hF1)))
 8009932:	4252      	negs	r2, r2
 8009934:	4590      	cmp	r8, r2
 8009936:	f340 80a6 	ble.w	8009a86 <STO_CR_CalcElAngle+0x1c2>
      /* Nothing to do */
    }

#ifndef FULL_MISRA_C_COMPLIANCY_STO_CORDIC
    //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
    hIalfa_err = (int16_t)(pHandle->Ialfa_est >> pHandle->F1LOG);
 800993a:	f8b3 017c 	ldrh.w	r0, [r3, #380]	@ 0x17c
    hIbeta_err = (int16_t)(pHandle->Ibeta_est >> pHandle->F1LOG);
#else
    hIbeta_err = (int16_t)(pHandle->Ibeta_est / pHandle->hF1);
#endif

    hIbeta_err = hIbeta_err - pInputs->Ialfa_beta.beta;
 800993e:	88ce      	ldrh	r6, [r1, #6]
    hAux = (int16_t)(pHandle->Ialfa_est >> pHandle->F1LOG);
#else
    hAux = (int16_t)(pHandle->Ialfa_est / pHandle->hF1);
#endif

    wAux = (int32_t)(pHandle->hC1) * hAux;
 8009940:	f9b3 2020 	ldrsh.w	r2, [r3, #32]
 8009944:	9202      	str	r2, [sp, #8]
    hIalfa_err = (int16_t)(pHandle->Ialfa_est >> pHandle->F1LOG);
 8009946:	fa49 f200 	asr.w	r2, r9, r0
    hIbeta_err = (int16_t)(pHandle->Ibeta_est >> pHandle->F1LOG);
 800994a:	fa48 f000 	asr.w	r0, r8, r0
    hIbeta_err = hIbeta_err - pInputs->Ialfa_beta.beta;
 800994e:	1b86      	subs	r6, r0, r6
    hIalfa_err = hIalfa_err - pInputs->Ialfa_beta.alpha;
 8009950:	f8b1 e004 	ldrh.w	lr, [r1, #4]
    hIbeta_err = hIbeta_err - pInputs->Ialfa_beta.beta;
 8009954:	9603      	str	r6, [sp, #12]
    wAux = (int32_t)(pHandle->hC1) * hAux;
 8009956:	9e02      	ldr	r6, [sp, #8]
    wAux = (int32_t)(pInputs->Vbus) * pInputs->Valfa_beta.alpha;
 8009958:	f8b1 a008 	ldrh.w	sl, [r1, #8]
    hIalfa_err = hIalfa_err - pInputs->Ialfa_beta.alpha;
 800995c:	eba2 0e0e 	sub.w	lr, r2, lr
    hAux = (int16_t)(pHandle->Ibeta_est >> pHandle->F1LOG);
#else
    hAux = (int16_t)(pHandle->Ibeta_est / pHandle->hF1);
#endif

    wAux = (int32_t)(pHandle->hC1) * hAux;
 8009960:	fb10 f006 	smulbb	r0, r0, r6
    wAux = (int32_t)(pHandle->hC1) * hAux;
 8009964:	fb12 f206 	smulbb	r2, r2, r6
    wIalfa_est_Next = pHandle->Ialfa_est - wAux;
 8009968:	eba9 0202 	sub.w	r2, r9, r2
    wIbeta_est_Next = pHandle->Ibeta_est - wAux;
 800996c:	eba8 0000 	sub.w	r0, r8, r0
    wAux = (int32_t)(pInputs->Vbus) * pInputs->Valfa_beta.alpha;
 8009970:	f9b1 9000 	ldrsh.w	r9, [r1]
    wAux = (int32_t)(pInputs->Vbus) * pInputs->Valfa_beta.beta;
 8009974:	f9b1 8002 	ldrsh.w	r8, [r1, #2]
    hIbeta_err = hIbeta_err - pInputs->Ialfa_beta.beta;
 8009978:	f9bd 600c 	ldrsh.w	r6, [sp, #12]
    wAux = (int32_t)(pHandle->hC2) * hIalfa_err;
 800997c:	f9b3 1022 	ldrsh.w	r1, [r3, #34]	@ 0x22
    {
      wDirection = -1;
    }

    /* Stores observed b-emfs */
    pHandle->hBemf_alfa_est = hAux_Alfa;
 8009980:	f8a3 7044 	strh.w	r7, [r3, #68]	@ 0x44
    wAux = (int32_t)(pInputs->Vbus) * pInputs->Valfa_beta.alpha;
 8009984:	fb0a f909 	mul.w	r9, sl, r9
    wAux = (int32_t)(pInputs->Vbus) * pInputs->Valfa_beta.beta;
 8009988:	fb0a f808 	mul.w	r8, sl, r8
    wAux = (int32_t)(pHandle->hC5) * hValfa;
 800998c:	f9b3 a028 	ldrsh.w	sl, [r3, #40]	@ 0x28
    pHandle->hBemf_beta_est = hAux_Beta;
 8009990:	f8a3 c046 	strh.w	ip, [r3, #70]	@ 0x46
    wIbeta_est_Next += wAux;
 8009994:	fb01 0006 	mla	r0, r1, r6, r0
    hVbeta = (int16_t)(wAux >> 16); //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 8009998:	ea4f 4828 	mov.w	r8, r8, asr #16
    wIbeta_est_Next += wAux;
 800999c:	fb0a 0008 	mla	r0, sl, r8, r0
    wAux = (int32_t)(pHandle->hC4) * hIalfa_err;
 80099a0:	f9b3 8026 	ldrsh.w	r8, [r3, #38]	@ 0x26
    hIalfa_err = hIalfa_err - pInputs->Ialfa_beta.alpha;
 80099a4:	fa0f fe8e 	sxth.w	lr, lr
    wIalfa_est_Next += wAux;
 80099a8:	fb01 220e 	mla	r2, r1, lr, r2
    hValfa = (int16_t)(wAux >> 16); //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 80099ac:	ea4f 4929 	mov.w	r9, r9, asr #16
    wAux = (int32_t) hAux_Beta >> pHandle->F3POW2;
 80099b0:	8e59      	ldrh	r1, [r3, #50]	@ 0x32
    wBemf_alfa_est_Next = pHandle->wBemf_alfa_est + wAux;
 80099b2:	fb0e 5e08 	mla	lr, lr, r8, r5
    wBemf_beta_est_Next = pHandle->wBemf_beta_est + wAux;
 80099b6:	fb08 4806 	mla	r8, r8, r6, r4
    wAux = (int32_t)(pHandle->hC3) * hAux_Alfa;
 80099ba:	f9b3 6024 	ldrsh.w	r6, [r3, #36]	@ 0x24
    wIalfa_est_Next += wAux;
 80099be:	fb0a 2209 	mla	r2, sl, r9, r2
    wAux = wAux * pHandle->hC6;
 80099c2:	f9b3 902a 	ldrsh.w	r9, [r3, #42]	@ 0x2a
    wIalfa_est_Next -= wAux;
 80099c6:	fb06 2217 	mls	r2, r6, r7, r2
    wIbeta_est_Next -= wAux;
 80099ca:	fb06 061c 	mls	r6, r6, ip, r0
    wAux = (int32_t) hAux_Beta >> pHandle->F3POW2;
 80099ce:	fa4c f001 	asr.w	r0, ip, r1
    wAux = wAux * pHandle->hC6;
 80099d2:	fb00 f009 	mul.w	r0, r0, r9
    wBemf_alfa_est_Next += wAux;
 80099d6:	fb00 ee0b 	mla	lr, r0, fp, lr
    if (pHandle->Orig_ElSpeedDpp >= 0)
 80099da:	f9b3 014e 	ldrsh.w	r0, [r3, #334]	@ 0x14e
  */
static inline int16_t MCM_PhaseComputation(int32_t wBemf_alfa_est, int32_t wBemf_beta_est)
{

  /* Configure and call to CORDIC */
  WRITE_REG(CORDIC->CSR,CORDIC_CONFIG_PHASE);
 80099de:	f8df c158 	ldr.w	ip, [pc, #344]	@ 8009b38 <STO_CR_CalcElAngle+0x274>
 80099e2:	2800      	cmp	r0, #0
    wAux = (int32_t) hAux_Alfa >> pHandle->F3POW2;
 80099e4:	fa47 f101 	asr.w	r1, r7, r1
    wAux = wAux * pHandle->hC6;
 80099e8:	bfb8      	it	lt
 80099ea:	4264      	neglt	r4, r4
 80099ec:	4f51      	ldr	r7, [pc, #324]	@ (8009b34 <STO_CR_CalcElAngle+0x270>)
 80099ee:	bfb8      	it	lt
 80099f0:	426d      	neglt	r5, r5

    /* Calls the CORDIC blockset */
    wAux_Alpha = pHandle->wBemf_alfa_est * wDirection;
    wAux_Beta = pHandle->wBemf_beta_est * wDirection;

    hRotor_Angle = MCM_PhaseComputation(wAux_Alpha, -wAux_Beta);
 80099f2:	f1c4 0400 	rsb	r4, r4, #0
 80099f6:	f8c7 c000 	str.w	ip, [r7]
  WRITE_REG(CORDICx->WDATA, InData);
 80099fa:	607d      	str	r5, [r7, #4]
 80099fc:	607c      	str	r4, [r7, #4]
  return (uint32_t)(READ_REG(CORDICx->RDATA));
 80099fe:	68bd      	ldr	r5, [r7, #8]
    wAux = wAux * pHandle->hC6;
 8009a00:	fb01 f109 	mul.w	r1, r1, r9

    hOrRotor_Speed = (int16_t)(hRotor_Angle - hPrev_Rotor_Angle);
 8009a04:	f8bd 9000 	ldrh.w	r9, [sp]
    wBemf_beta_est_Next -= wAux;
 8009a08:	fb01 811b 	mls	r1, r1, fp, r8
    hOrRotor_Speed = (int16_t)(hRotor_Angle - hPrev_Rotor_Angle);
 8009a0c:	ebc9 4715 	rsb	r7, r9, r5, lsr #16
      wDirection = -1;
 8009a10:	bfb4      	ite	lt
 8009a12:	f04f 30ff 	movlt.w	r0, #4294967295
      wDirection = 1;
 8009a16:	2001      	movge	r0, #1
    hRotor_Acceleration = hOrRotor_Speed - hPrev_Rotor_Speed;
 8009a18:	fa1f f88b 	uxth.w	r8, fp
 8009a1c:	eba7 0408 	sub.w	r4, r7, r8

    hRotor_Speed = hOrRotor_Speed;

    if (wDirection == 1)
 8009a20:	2801      	cmp	r0, #1
  LL_CORDIC_WriteData(CORDIC, (uint32_t)wBemf_beta_est);

  /* Read computed angle */
  uint32_t result;
  result = LL_CORDIC_ReadData(CORDIC) >> 16U;
  return ((int16_t)result);
 8009a22:	ea4f 4525 	mov.w	r5, r5, asr #16
    hOrRotor_Speed = (int16_t)(hRotor_Angle - hPrev_Rotor_Angle);
 8009a26:	b23f      	sxth	r7, r7
    hRotor_Acceleration = hOrRotor_Speed - hPrev_Rotor_Speed;
 8009a28:	b224      	sxth	r4, r4
    if (wDirection == 1)
 8009a2a:	d05e      	beq.n	8009aea <STO_CR_CalcElAngle+0x226>
        }
      }
    }
    else
    {
      if (hRotor_Speed > 0)
 8009a2c:	2f00      	cmp	r7, #0
 8009a2e:	dd30      	ble.n	8009a92 <STO_CR_CalcElAngle+0x1ce>
        }
      }
    }


    if (hRotor_Acceleration > hMax_Instant_Accel)
 8009a30:	9801      	ldr	r0, [sp, #4]
 8009a32:	42a0      	cmp	r0, r4
 8009a34:	da42      	bge.n	8009abc <STO_CR_CalcElAngle+0x1f8>
    {
      hOrRotor_Speed = hPrev_Rotor_Speed + hMax_Instant_Accel;
 8009a36:	4480      	add	r8, r0
 8009a38:	fa0f f788 	sxth.w	r7, r8
 8009a3c:	f04f 0c00 	mov.w	ip, #0
  * @param  pHandle: handler of the current instance of the STO CORDIC component
  * @retval none
  */
inline static void STO_CR_Store_Rotor_Speed(STO_CR_Handle_t *pHandle, int16_t hRotor_Speed, int16_t hOrRotor_Speed)
{
  uint8_t bBuffer_index = pHandle->Speed_Buffer_Index;
 8009a40:	f893 40c8 	ldrb.w	r4, [r3, #200]	@ 0xc8

  bBuffer_index++;
  if (bBuffer_index == pHandle->SpeedBufferSizeUnit)
 8009a44:	f893 016c 	ldrb.w	r0, [r3, #364]	@ 0x16c
  bBuffer_index++;
 8009a48:	3401      	adds	r4, #1
 8009a4a:	b2e4      	uxtb	r4, r4
  if (bBuffer_index == pHandle->SpeedBufferSizeUnit)
 8009a4c:	42a0      	cmp	r0, r4
 8009a4e:	bf0a      	itet	eq
 8009a50:	2500      	moveq	r5, #0
  else
  {
    /* Nothing too do */
  }

  pHandle->SpeedBufferOldestEl = pHandle->Speed_Buffer[bBuffer_index];
 8009a52:	4625      	movne	r5, r4
    bBuffer_index = 0U;
 8009a54:	462c      	moveq	r4, r5
  pHandle->SpeedBufferOldestEl = pHandle->Speed_Buffer[bBuffer_index];
 8009a56:	eb03 0545 	add.w	r5, r3, r5, lsl #1
}
 8009a5a:	9800      	ldr	r0, [sp, #0]
  pHandle->SpeedBufferOldestEl = pHandle->Speed_Buffer[bBuffer_index];
 8009a5c:	f9b5 8048 	ldrsh.w	r8, [r5, #72]	@ 0x48
 8009a60:	f8a3 8168 	strh.w	r8, [r3, #360]	@ 0x168
  pHandle->OrigSpeedBufferOldestEl = pHandle->Orig_Speed_Buffer[bBuffer_index];
 8009a64:	f9b5 80ce 	ldrsh.w	r8, [r5, #206]	@ 0xce
 8009a68:	f8a3 816a 	strh.w	r8, [r3, #362]	@ 0x16a

  pHandle->Speed_Buffer[bBuffer_index] = hRotor_Speed;
 8009a6c:	f8a5 c048 	strh.w	ip, [r5, #72]	@ 0x48
  pHandle->Orig_Speed_Buffer[bBuffer_index] = hOrRotor_Speed;
 8009a70:	f8a5 70ce 	strh.w	r7, [r5, #206]	@ 0xce
    pHandle->Ibeta_est = wIbeta_est_Next;
 8009a74:	e9c3 6e0e 	strd	r6, lr, [r3, #56]	@ 0x38
  pHandle->Speed_Buffer_Index = bBuffer_index;
 8009a78:	f883 40c8 	strb.w	r4, [r3, #200]	@ 0xc8
    pHandle->Ialfa_est = wIalfa_est_Next;
 8009a7c:	635a      	str	r2, [r3, #52]	@ 0x34
    pHandle->wBemf_beta_est = wBemf_beta_est_Next;
 8009a7e:	6419      	str	r1, [r3, #64]	@ 0x40
}
 8009a80:	b005      	add	sp, #20
 8009a82:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      pHandle->Ibeta_est = -INT16_MAX * (int32_t)(pHandle->hF1);
 8009a86:	639a      	str	r2, [r3, #56]	@ 0x38
 8009a88:	4690      	mov	r8, r2
 8009a8a:	e756      	b.n	800993a <STO_CR_CalcElAngle+0x76>
      pHandle->wBemf_beta_est = -INT16_MAX * (int32_t)(pHandle->hF2);
 8009a8c:	641a      	str	r2, [r3, #64]	@ 0x40
 8009a8e:	4614      	mov	r4, r2
 8009a90:	e73b      	b.n	800990a <STO_CR_CalcElAngle+0x46>
        if (hRotor_Acceleration < (-hMax_Instant_Accel))
 8009a92:	9801      	ldr	r0, [sp, #4]
 8009a94:	4240      	negs	r0, r0
 8009a96:	4284      	cmp	r4, r0
 8009a98:	da37      	bge.n	8009b0a <STO_CR_CalcElAngle+0x246>
          hRotor_Speed = hPrev_Rotor_Speed - hMax_Instant_Accel;
 8009a9a:	9801      	ldr	r0, [sp, #4]
 8009a9c:	b287      	uxth	r7, r0
 8009a9e:	eba8 0c07 	sub.w	ip, r8, r7
          pHandle->_Super.hElAngle = hPrev_Rotor_Angle + hRotor_Speed;
 8009aa2:	fa19 f98c 	uxtah	r9, r9, ip
 8009aa6:	fa0f f589 	sxth.w	r5, r9
    if (hRotor_Acceleration > hMax_Instant_Accel)
 8009aaa:	42a0      	cmp	r0, r4
          pHandle->_Super.hElAngle = hPrev_Rotor_Angle + hRotor_Speed;
 8009aac:	9500      	str	r5, [sp, #0]
 8009aae:	809d      	strh	r5, [r3, #4]
          hRotor_Speed = hPrev_Rotor_Speed - hMax_Instant_Accel;
 8009ab0:	fa0f fc8c 	sxth.w	ip, ip
    if (hRotor_Acceleration > hMax_Instant_Accel)
 8009ab4:	da3b      	bge.n	8009b2e <STO_CR_CalcElAngle+0x26a>
      hOrRotor_Speed = hPrev_Rotor_Speed + hMax_Instant_Accel;
 8009ab6:	4447      	add	r7, r8
 8009ab8:	b23f      	sxth	r7, r7
 8009aba:	e7c1      	b.n	8009a40 <STO_CR_CalcElAngle+0x17c>
 8009abc:	f04f 0c00 	mov.w	ip, #0
 8009ac0:	4605      	mov	r5, r0
    else if (hRotor_Acceleration < (-hMax_Instant_Accel))
 8009ac2:	4268      	negs	r0, r5
 8009ac4:	4284      	cmp	r4, r0
 8009ac6:	dabb      	bge.n	8009a40 <STO_CR_CalcElAngle+0x17c>
      hOrRotor_Speed = hPrev_Rotor_Speed - hMax_Instant_Accel;
 8009ac8:	eba8 0805 	sub.w	r8, r8, r5
 8009acc:	fa0f f788 	sxth.w	r7, r8
 8009ad0:	e7b6      	b.n	8009a40 <STO_CR_CalcElAngle+0x17c>
    else if (pHandle->wBemf_alfa_est <= (-INT16_MAX * (int32_t)(pHandle->hF2)))
 8009ad2:	4250      	negs	r0, r2
 8009ad4:	4285      	cmp	r5, r0
      pHandle->wBemf_alfa_est = -INT16_MAX * (int32_t)(pHandle->hF2);
 8009ad6:	bfdc      	itt	le
 8009ad8:	63d8      	strle	r0, [r3, #60]	@ 0x3c
 8009ada:	4605      	movle	r5, r0
 8009adc:	e708      	b.n	80098f0 <STO_CR_CalcElAngle+0x2c>
    else if (pHandle->Ialfa_est <= (-INT16_MAX * (int32_t)(pHandle->hF1)))
 8009ade:	4250      	negs	r0, r2
 8009ae0:	4581      	cmp	r9, r0
      pHandle->Ialfa_est = -INT16_MAX * (int32_t)(pHandle->hF1);
 8009ae2:	bfdc      	itt	le
 8009ae4:	6358      	strle	r0, [r3, #52]	@ 0x34
 8009ae6:	4681      	movle	r9, r0
 8009ae8:	e71e      	b.n	8009928 <STO_CR_CalcElAngle+0x64>
      if (hRotor_Speed < 0)
 8009aea:	2f00      	cmp	r7, #0
 8009aec:	dba0      	blt.n	8009a30 <STO_CR_CalcElAngle+0x16c>
        if (hRotor_Acceleration > hMax_Instant_Accel)
 8009aee:	9801      	ldr	r0, [sp, #4]
 8009af0:	42a0      	cmp	r0, r4
 8009af2:	da14      	bge.n	8009b1e <STO_CR_CalcElAngle+0x25a>
          hRotor_Speed = hPrev_Rotor_Speed + hMax_Instant_Accel;
 8009af4:	4480      	add	r8, r0
          pHandle->_Super.hElAngle = hPrev_Rotor_Angle + hRotor_Speed;
 8009af6:	fa19 f988 	uxtah	r9, r9, r8
 8009afa:	fa0f f089 	sxth.w	r0, r9
          hRotor_Speed = hPrev_Rotor_Speed + hMax_Instant_Accel;
 8009afe:	fa0f fc88 	sxth.w	ip, r8
          pHandle->_Super.hElAngle = hPrev_Rotor_Angle + hRotor_Speed;
 8009b02:	9000      	str	r0, [sp, #0]
 8009b04:	8098      	strh	r0, [r3, #4]
 8009b06:	4667      	mov	r7, ip
 8009b08:	e79a      	b.n	8009a40 <STO_CR_CalcElAngle+0x17c>
    if (hRotor_Acceleration > hMax_Instant_Accel)
 8009b0a:	9801      	ldr	r0, [sp, #4]
          pHandle->_Super.hElAngle = hRotor_Angle;
 8009b0c:	809d      	strh	r5, [r3, #4]
    if (hRotor_Acceleration > hMax_Instant_Accel)
 8009b0e:	42a0      	cmp	r0, r4
 8009b10:	da0a      	bge.n	8009b28 <STO_CR_CalcElAngle+0x264>
      hOrRotor_Speed = hPrev_Rotor_Speed + hMax_Instant_Accel;
 8009b12:	4480      	add	r8, r0
 8009b14:	46bc      	mov	ip, r7
 8009b16:	9500      	str	r5, [sp, #0]
 8009b18:	fa0f f788 	sxth.w	r7, r8
 8009b1c:	e790      	b.n	8009a40 <STO_CR_CalcElAngle+0x17c>
          pHandle->_Super.hElAngle = hRotor_Angle;
 8009b1e:	809d      	strh	r5, [r3, #4]
 8009b20:	9500      	str	r5, [sp, #0]
 8009b22:	46bc      	mov	ip, r7
 8009b24:	4605      	mov	r5, r0
 8009b26:	e7cc      	b.n	8009ac2 <STO_CR_CalcElAngle+0x1fe>
    if (hRotor_Acceleration > hMax_Instant_Accel)
 8009b28:	9500      	str	r5, [sp, #0]
 8009b2a:	46bc      	mov	ip, r7
 8009b2c:	e788      	b.n	8009a40 <STO_CR_CalcElAngle+0x17c>
 8009b2e:	4667      	mov	r7, ip
      hOrRotor_Speed = hPrev_Rotor_Speed - hMax_Instant_Accel;
 8009b30:	e786      	b.n	8009a40 <STO_CR_CalcElAngle+0x17c>
 8009b32:	bf00      	nop
 8009b34:	40020c00 	.word	0x40020c00
 8009b38:	00100062 	.word	0x00100062

08009b3c <STO_CR_CalcAvrgMecSpeedUnit>:
{
 8009b3c:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint8_t bSpeedBufferSizeUnit = pHandle->SpeedBufferSizeUnit;
 8009b3e:	f890 516c 	ldrb.w	r5, [r0, #364]	@ 0x16c
    for (i = 0U; i < bSpeedBufferSizeUnit; i++)
 8009b42:	2d00      	cmp	r5, #0
 8009b44:	f000 8094 	beq.w	8009c70 <STO_CR_CalcAvrgMecSpeedUnit+0x134>
 8009b48:	f100 0246 	add.w	r2, r0, #70	@ 0x46
 8009b4c:	eb02 0445 	add.w	r4, r2, r5, lsl #1
 8009b50:	4613      	mov	r3, r2
    int32_t wAvrSpeed_dpp = (int32_t)0;
 8009b52:	f04f 0c00 	mov.w	ip, #0
      wAvrSpeed_dpp += (int32_t)(pHandle->Speed_Buffer[i]);
 8009b56:	f933 ef02 	ldrsh.w	lr, [r3, #2]!
    for (i = 0U; i < bSpeedBufferSizeUnit; i++)
 8009b5a:	42a3      	cmp	r3, r4
      wAvrSpeed_dpp += (int32_t)(pHandle->Speed_Buffer[i]);
 8009b5c:	44f4      	add	ip, lr
    for (i = 0U; i < bSpeedBufferSizeUnit; i++)
 8009b5e:	d1fa      	bne.n	8009b56 <STO_CR_CalcAvrgMecSpeedUnit+0x1a>
      wAvrSpeed_dpp = wAvrSpeed_dpp / (int16_t)bSpeedBufferSizeUnit;
 8009b60:	fb9c fef5 	sdiv	lr, ip, r5
    int32_t wAvrQuadraticError = 0;
 8009b64:	f04f 0c00 	mov.w	ip, #0
      wError = (int32_t)(pHandle->Speed_Buffer[i]) - wAvrSpeed_dpp;
 8009b68:	f932 3f02 	ldrsh.w	r3, [r2, #2]!
 8009b6c:	eba3 030e 	sub.w	r3, r3, lr
    for (i = 0U; i < bSpeedBufferSizeUnit; i++)
 8009b70:	42a2      	cmp	r2, r4
      wAvrQuadraticError += wError;
 8009b72:	fb03 cc03 	mla	ip, r3, r3, ip
    for (i = 0U; i < bSpeedBufferSizeUnit; i++)
 8009b76:	d1f7      	bne.n	8009b68 <STO_CR_CalcAvrgMecSpeedUnit+0x2c>
    wAvrQuadraticError = wAvrQuadraticError / (int16_t)bSpeedBufferSizeUnit;
 8009b78:	fbbc f4f5 	udiv	r4, ip, r5
    wAvrSquareSpeed = wAvrSpeed_dpp * wAvrSpeed_dpp;
 8009b7c:	fb0e f30e 	mul.w	r3, lr, lr
    int64_t lAvrSquareSpeed = (int64_t)(wAvrSquareSpeed) * (int64_t)pHandle->VariancePercentage;
 8009b80:	17de      	asrs	r6, r3, #31
 8009b82:	f8b0 c16e 	ldrh.w	ip, [r0, #366]	@ 0x16e
    wAux = wAvrSpeed_dpp * (int32_t)(pHandle->_Super.hMeasurementFrequency);
 8009b86:	8b45      	ldrh	r5, [r0, #26]
    if (true == pHandle->EnableDualCheck) /*do algorithm if it's enabled*/
 8009b88:	f890 715c 	ldrb.w	r7, [r0, #348]	@ 0x15c
    int64_t lAvrSquareSpeed = (int64_t)(wAvrSquareSpeed) * (int64_t)pHandle->VariancePercentage;
 8009b8c:	fbac 2303 	umull	r2, r3, ip, r3
 8009b90:	fb0c 3306 	mla	r3, ip, r6, r3
    wAvrSquareSpeed = (int32_t)(lAvrSquareSpeed / (int64_t)128);
 8009b94:	09d2      	lsrs	r2, r2, #7
 8009b96:	ea42 6243 	orr.w	r2, r2, r3, lsl #25
    wAux = wAux * (int32_t) (pHandle->_Super.SpeedUnit);
 8009b9a:	7883      	ldrb	r3, [r0, #2]
    wAux = wAvrSpeed_dpp * (int32_t)(pHandle->_Super.hMeasurementFrequency);
 8009b9c:	fb0e f505 	mul.w	r5, lr, r5
    if (wAvrQuadraticError < wAvrSquareSpeed)
 8009ba0:	42a2      	cmp	r2, r4
    wAux = wAux * (int32_t) (pHandle->_Super.SpeedUnit);
 8009ba2:	fb05 f303 	mul.w	r3, r5, r3
    if (wAvrQuadraticError < wAvrSquareSpeed)
 8009ba6:	bfd8      	it	le
 8009ba8:	2600      	movle	r6, #0
    wAux = wAux / (int32_t)(pHandle->_Super.DPPConvFactor);
 8009baa:	69c5      	ldr	r5, [r0, #28]
 8009bac:	fb93 f3f5 	sdiv	r3, r3, r5
    if (wAvrQuadraticError < wAvrSquareSpeed)
 8009bb0:	bfc8      	it	gt
 8009bb2:	2601      	movgt	r6, #1
    wAux = wAux / (int16_t)(pHandle->_Super.bElToMecRatio);
 8009bb4:	7845      	ldrb	r5, [r0, #1]
 8009bb6:	fb93 f3f5 	sdiv	r3, r3, r5
    *pMecSpeedUnit = (int16_t)wAux;
 8009bba:	b21d      	sxth	r5, r3
 8009bbc:	800d      	strh	r5, [r1, #0]
    if (wAvrQuadraticError < wAvrSquareSpeed)
 8009bbe:	f880 60c9 	strb.w	r6, [r0, #201]	@ 0xc9
    pHandle->_Super.hAvrMecSpeedUnit = (int16_t)wAux;
 8009bc2:	8185      	strh	r5, [r0, #12]
    if (pHandle->IsAlgorithmConverged == false)
 8009bc4:	f890 60cc 	ldrb.w	r6, [r0, #204]	@ 0xcc
    if (true == pHandle->EnableDualCheck) /*do algorithm if it's enabled*/
 8009bc8:	b98f      	cbnz	r7, 8009bee <STO_CR_CalcAvrgMecSpeedUnit+0xb2>
    if (pHandle->IsAlgorithmConverged == false)
 8009bca:	b336      	cbz	r6, 8009c1a <STO_CR_CalcAvrgMecSpeedUnit+0xde>
      if ((pHandle->IsSpeedReliable == false) || (bIs_Bemf_Consistent == false))
 8009bcc:	42a2      	cmp	r2, r4
 8009bce:	dc21      	bgt.n	8009c14 <STO_CR_CalcAvrgMecSpeedUnit+0xd8>
        pHandle->ReliabilityCounter++;
 8009bd0:	f890 30cb 	ldrb.w	r3, [r0, #203]	@ 0xcb
        if (pHandle->ReliabilityCounter >= pHandle->_Super.bMaximumSpeedErrorsNumber)
 8009bd4:	78c2      	ldrb	r2, [r0, #3]
        pHandle->ReliabilityCounter++;
 8009bd6:	3301      	adds	r3, #1
 8009bd8:	b2db      	uxtb	r3, r3
        if (pHandle->ReliabilityCounter >= pHandle->_Super.bMaximumSpeedErrorsNumber)
 8009bda:	4293      	cmp	r3, r2
        pHandle->ReliabilityCounter++;
 8009bdc:	f880 30cb 	strb.w	r3, [r0, #203]	@ 0xcb
        if (pHandle->ReliabilityCounter >= pHandle->_Super.bMaximumSpeedErrorsNumber)
 8009be0:	d31b      	bcc.n	8009c1a <STO_CR_CalcAvrgMecSpeedUnit+0xde>
          pHandle->ReliabilityCounter = 0U;
 8009be2:	2300      	movs	r3, #0
 8009be4:	f880 30cb 	strb.w	r3, [r0, #203]	@ 0xcb
          pHandle->_Super.bSpeedErrorNumber = pHandle->_Super.bMaximumSpeedErrorsNumber;
 8009be8:	7002      	strb	r2, [r0, #0]
}
 8009bea:	4618      	mov	r0, r3
 8009bec:	bdf0      	pop	{r4, r5, r6, r7, pc}
      wAux = ((wAux < 0) ? (-wAux) : (wAux));  //cstat !MISRAC2012-Rule-14.3_b !RED-cond-never !RED-cmp-never
 8009bee:	2b00      	cmp	r3, #0
      if (wAux < (int32_t)(pHandle->MaxAppPositiveMecSpeedUnit))
 8009bf0:	f8b0 517a 	ldrh.w	r5, [r0, #378]	@ 0x17a
      wAux = ((wAux < 0) ? (-wAux) : (wAux));  //cstat !MISRAC2012-Rule-14.3_b !RED-cond-never !RED-cmp-never
 8009bf4:	bfb8      	it	lt
 8009bf6:	425b      	neglt	r3, r3
      if (wAux < (int32_t)(pHandle->MaxAppPositiveMecSpeedUnit))
 8009bf8:	429d      	cmp	r5, r3
 8009bfa:	dc12      	bgt.n	8009c22 <STO_CR_CalcAvrgMecSpeedUnit+0xe6>
    bool bIs_Bemf_Consistent = false;
 8009bfc:	2500      	movs	r5, #0
    int32_t wEstBemfSq = 0;
 8009bfe:	462b      	mov	r3, r5
    int32_t wObsBemfSq = 0;
 8009c00:	462f      	mov	r7, r5
      pHandle->Est_Bemf_Level = wEstBemfSq;
 8009c02:	e9c0 7355 	strd	r7, r3, [r0, #340]	@ 0x154
      pHandle->IsBemfConsistent = bIs_Bemf_Consistent;
 8009c06:	f880 5150 	strb.w	r5, [r0, #336]	@ 0x150
    if (pHandle->IsAlgorithmConverged == false)
 8009c0a:	b136      	cbz	r6, 8009c1a <STO_CR_CalcAvrgMecSpeedUnit+0xde>
      if ((pHandle->IsSpeedReliable == false) || (bIs_Bemf_Consistent == false))
 8009c0c:	42a2      	cmp	r2, r4
 8009c0e:	dddf      	ble.n	8009bd0 <STO_CR_CalcAvrgMecSpeedUnit+0x94>
 8009c10:	2d00      	cmp	r5, #0
 8009c12:	d0dd      	beq.n	8009bd0 <STO_CR_CalcAvrgMecSpeedUnit+0x94>
        pHandle->ReliabilityCounter = 0U;
 8009c14:	2300      	movs	r3, #0
 8009c16:	f880 30cb 	strb.w	r3, [r0, #203]	@ 0xcb
}
 8009c1a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
        bAux = SPD_IsMecSpeedReliable (&pHandle->_Super, pMecSpeedUnit);
 8009c1e:	f7ff bd51 	b.w	80096c4 <SPD_IsMecSpeedReliable>
        wObsBemf = (int32_t)(pHandle->hBemf_alfa_est);
 8009c22:	f9b0 5044 	ldrsh.w	r5, [r0, #68]	@ 0x44
        wObsBemf = (int32_t)(pHandle->hBemf_beta_est);
 8009c26:	f9b0 7046 	ldrsh.w	r7, [r0, #70]	@ 0x46
        wObsBemfSq = wObsBemf * wObsBemf;
 8009c2a:	fb05 fc05 	mul.w	ip, r5, r5
        wEstBemfSq = (wEstBemf * (int32_t)(pHandle->BemfConsistencyGain)) / 64;
 8009c2e:	f890 5179 	ldrb.w	r5, [r0, #377]	@ 0x179
        wObsBemfSq += wObsBemf * wObsBemf;
 8009c32:	fb07 c707 	mla	r7, r7, r7, ip
        wEstBemf = (wAux * 32767) / (int16_t)(pHandle->_Super.hMaxReliableMecSpeedUnit);
 8009c36:	ebc3 33c3 	rsb	r3, r3, r3, lsl #15
 8009c3a:	f9b0 c014 	ldrsh.w	ip, [r0, #20]
 8009c3e:	fb93 f3fc 	sdiv	r3, r3, ip
        wEstBemfSq = (wEstBemf * (int32_t)(pHandle->BemfConsistencyGain)) / 64;
 8009c42:	fb03 f505 	mul.w	r5, r3, r5
 8009c46:	2d00      	cmp	r5, #0
 8009c48:	bfb8      	it	lt
 8009c4a:	353f      	addlt	r5, #63	@ 0x3f
 8009c4c:	11ad      	asrs	r5, r5, #6
        wEstBemfSq *= wEstBemf;
 8009c4e:	fb05 f303 	mul.w	r3, r5, r3
        wEstBemfSqLo = wEstBemfSq - ((wEstBemfSq / 64) * (int32_t)(pHandle->BemfConsistencyCheck));
 8009c52:	2b00      	cmp	r3, #0
 8009c54:	461d      	mov	r5, r3
 8009c56:	f890 c178 	ldrb.w	ip, [r0, #376]	@ 0x178
 8009c5a:	bfb8      	it	lt
 8009c5c:	f103 053f 	addlt.w	r5, r3, #63	@ 0x3f
 8009c60:	11ad      	asrs	r5, r5, #6
 8009c62:	fb0c 3515 	mls	r5, ip, r5, r3
        if (wObsBemfSq > wEstBemfSqLo)
 8009c66:	42af      	cmp	r7, r5
 8009c68:	bfd4      	ite	le
 8009c6a:	2500      	movle	r5, #0
 8009c6c:	2501      	movgt	r5, #1
 8009c6e:	e7c8      	b.n	8009c02 <STO_CR_CalcAvrgMecSpeedUnit+0xc6>
    for (i = 0U; i < bSpeedBufferSizeUnit; i++)
 8009c70:	462c      	mov	r4, r5
 8009c72:	462b      	mov	r3, r5
 8009c74:	462e      	mov	r6, r5
    int32_t wAvrSpeed_dpp = (int32_t)0;
 8009c76:	46ae      	mov	lr, r5
 8009c78:	e783      	b.n	8009b82 <STO_CR_CalcAvrgMecSpeedUnit+0x46>
 8009c7a:	bf00      	nop

08009c7c <STO_CR_Clear>:
{
 8009c7c:	b570      	push	{r4, r5, r6, lr}
  * @retval none
  */
static void STO_CR_InitSpeedBuffer(STO_CR_Handle_t *pHandle)
{
  uint8_t b_i;
  uint8_t bSpeedBufferSizeUnit = pHandle->SpeedBufferSizeUnit;
 8009c7e:	f890 616c 	ldrb.w	r6, [r0, #364]	@ 0x16c
    pHandle->Ialfa_est = (int32_t)0;
 8009c82:	2500      	movs	r5, #0
    pHandle->Ibeta_est = (int32_t)0;
 8009c84:	e9c0 550d 	strd	r5, r5, [r0, #52]	@ 0x34
    pHandle->wBemf_beta_est = (int32_t)0;
 8009c88:	e9c0 550f 	strd	r5, r5, [r0, #60]	@ 0x3c
    pHandle->Est_Bemf_Level = (int32_t)0;
 8009c8c:	e9c0 5555 	strd	r5, r5, [r0, #340]	@ 0x154
    pHandle->DppOrigBufferSum = (int32_t)0;
 8009c90:	e9c0 5558 	strd	r5, r5, [r0, #352]	@ 0x160
{
 8009c94:	4604      	mov	r4, r0
    pHandle->_Super.hElAngle = (int16_t)0;
 8009c96:	8085      	strh	r5, [r0, #4]
    pHandle->_Super.hElSpeedDpp = (int16_t)0;
 8009c98:	81c5      	strh	r5, [r0, #14]
    pHandle->Orig_ElSpeedDpp = (int16_t)0;
 8009c9a:	f8a0 514e 	strh.w	r5, [r0, #334]	@ 0x14e
    pHandle->ConsistencyCounter = 0u;
 8009c9e:	f8a0 50ca 	strh.w	r5, [r0, #202]	@ 0xca
    pHandle->IsAlgorithmConverged = false;
 8009ca2:	f880 50cc 	strb.w	r5, [r0, #204]	@ 0xcc
    pHandle->IsBemfConsistent = false;
 8009ca6:	f880 5150 	strb.w	r5, [r0, #336]	@ 0x150
    pHandle->ForceConvergency = false;
 8009caa:	f8a0 5182 	strh.w	r5, [r0, #386]	@ 0x182

  /*init speed buffer*/
  for (b_i = 0U; b_i < bSpeedBufferSizeUnit; b_i++)
 8009cae:	b15e      	cbz	r6, 8009cc8 <STO_CR_Clear+0x4c>
  {
    pHandle->Speed_Buffer[b_i] = (int16_t)0;
 8009cb0:	0076      	lsls	r6, r6, #1
 8009cb2:	4632      	mov	r2, r6
 8009cb4:	4629      	mov	r1, r5
 8009cb6:	3048      	adds	r0, #72	@ 0x48
 8009cb8:	f000 fa14 	bl	800a0e4 <memset>
    pHandle->Orig_Speed_Buffer[b_i] = (int16_t)0;
 8009cbc:	4632      	mov	r2, r6
 8009cbe:	4629      	mov	r1, r5
 8009cc0:	f104 00ce 	add.w	r0, r4, #206	@ 0xce
 8009cc4:	f000 fa0e 	bl	800a0e4 <memset>
  }

  pHandle->Speed_Buffer_Index = 0u;
 8009cc8:	2300      	movs	r3, #0
 8009cca:	f884 30c8 	strb.w	r3, [r4, #200]	@ 0xc8
  pHandle->SpeedBufferOldestEl = (int16_t)0;
 8009cce:	f8c4 3168 	str.w	r3, [r4, #360]	@ 0x168
}
 8009cd2:	bd70      	pop	{r4, r5, r6, pc}

08009cd4 <STO_CR_Init>:
{
 8009cd4:	b510      	push	{r4, lr}
    pHandle->ConsistencyCounter = pHandle->StartUpConsistThreshold;
 8009cd6:	f890 1174 	ldrb.w	r1, [r0, #372]	@ 0x174
    htempk = (int16_t)(C6_COMP_CONST1 / (pHandle->hF2));
 8009cda:	4b17      	ldr	r3, [pc, #92]	@ (8009d38 <STO_CR_Init+0x64>)
 8009cdc:	f9b0 e02e 	ldrsh.w	lr, [r0, #46]	@ 0x2e
    pHandle->ConsistencyCounter = pHandle->StartUpConsistThreshold;
 8009ce0:	f880 10ca 	strb.w	r1, [r0, #202]	@ 0xca
    pHandle->EnableDualCheck = true;
 8009ce4:	2201      	movs	r2, #1
    pHandle->F3POW2 = 0u;
 8009ce6:	2100      	movs	r1, #0
    htempk = (int16_t)(C6_COMP_CONST1 / (pHandle->hF2));
 8009ce8:	fb93 f3fe 	sdiv	r3, r3, lr
 8009cec:	b21b      	sxth	r3, r3
{
 8009cee:	4604      	mov	r4, r0
    pHandle->EnableDualCheck = true;
 8009cf0:	f880 215c 	strb.w	r2, [r0, #348]	@ 0x15c
    pHandle->F3POW2 = 0u;
 8009cf4:	8641      	strh	r1, [r0, #50]	@ 0x32
    while (htempk != 0)
 8009cf6:	b1eb      	cbz	r3, 8009d34 <STO_CR_Init+0x60>
    wAux = (int32_t)1;
 8009cf8:	4611      	mov	r1, r2
      htempk /= (int16_t)2;
 8009cfa:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
    while (htempk != 0)
 8009cfe:	f102 0c01 	add.w	ip, r2, #1
 8009d02:	105b      	asrs	r3, r3, #1
 8009d04:	4610      	mov	r0, r2
      wAux *= (int32_t)2;
 8009d06:	ea4f 0141 	mov.w	r1, r1, lsl #1
    while (htempk != 0)
 8009d0a:	fa1f f28c 	uxth.w	r2, ip
 8009d0e:	d1f4      	bne.n	8009cfa <STO_CR_Init+0x26>
    pHandle->hF3 = (int16_t)wAux;
 8009d10:	b20a      	sxth	r2, r1
 8009d12:	8660      	strh	r0, [r4, #50]	@ 0x32
    wAux = (int32_t)(pHandle->hF2) * pHandle->hF3;
 8009d14:	fb0e f102 	mul.w	r1, lr, r2
    pHandle->hC6 = (int16_t)(wAux / C6_COMP_CONST2);
 8009d18:	4808      	ldr	r0, [pc, #32]	@ (8009d3c <STO_CR_Init+0x68>)
    pHandle->hF3 = (int16_t)wAux;
 8009d1a:	8622      	strh	r2, [r4, #48]	@ 0x30
    pHandle->hC6 = (int16_t)(wAux / C6_COMP_CONST2);
 8009d1c:	17cb      	asrs	r3, r1, #31
 8009d1e:	fb80 0101 	smull	r0, r1, r0, r1
 8009d22:	ebc3 2321 	rsb	r3, r3, r1, asr #8
 8009d26:	8563      	strh	r3, [r4, #42]	@ 0x2a
    STO_CR_Clear(pHandle);
 8009d28:	4620      	mov	r0, r4
 8009d2a:	f7ff ffa7 	bl	8009c7c <STO_CR_Clear>
    pHandle->_Super.hMecAccelUnitP = 0;
 8009d2e:	2300      	movs	r3, #0
 8009d30:	8263      	strh	r3, [r4, #18]
}
 8009d32:	bd10      	pop	{r4, pc}
 8009d34:	4671      	mov	r1, lr
 8009d36:	e7ef      	b.n	8009d18 <STO_CR_Init+0x44>
 8009d38:	000fea5e 	.word	0x000fea5e
 8009d3c:	06488dc5 	.word	0x06488dc5

08009d40 <STO_CR_IsObserverConverged>:
    int16_t hUpperThreshold;
    int16_t hLowerThreshold;
    int16_t lForcedMecSpeedUnit;


    if (pHandle->ForceConvergency2 == true)
 8009d40:	f890 2183 	ldrb.w	r2, [r0, #387]	@ 0x183
{
 8009d44:	4603      	mov	r3, r0
    if (pHandle->ForceConvergency2 == true)
 8009d46:	b10a      	cbz	r2, 8009d4c <STO_CR_IsObserverConverged+0xc>
    {
      lForcedMecSpeedUnit = pHandle->_Super.hAvrMecSpeedUnit;
 8009d48:	f9b0 100c 	ldrsh.w	r1, [r0, #12]
    else
    {
      lForcedMecSpeedUnit = hForcedMecSpeedUnit;
    }

    if (pHandle->ForceConvergency == true)
 8009d4c:	f893 0182 	ldrb.w	r0, [r3, #386]	@ 0x182
 8009d50:	b128      	cbz	r0, 8009d5e <STO_CR_IsObserverConverged+0x1e>
    {
      bAux = true;
      pHandle->IsAlgorithmConverged = true;
 8009d52:	2001      	movs	r0, #1
      pHandle->_Super.bSpeedErrorNumber = 0U;
 8009d54:	2200      	movs	r2, #0
      pHandle->IsAlgorithmConverged = true;
 8009d56:	f883 00cc 	strb.w	r0, [r3, #204]	@ 0xcc
      pHandle->_Super.bSpeedErrorNumber = 0U;
 8009d5a:	701a      	strb	r2, [r3, #0]
    }
#ifdef NULL_PTR_CHECK_STO_COR_SPD_POS_FDB
  }
#endif
  return (bAux);
}
 8009d5c:	4770      	bx	lr
      hEstimatedSpeedUnit = pHandle->_Super.hAvrMecSpeedUnit;
 8009d5e:	f9b3 200c 	ldrsh.w	r2, [r3, #12]
      wtemp = (int32_t)hEstimatedSpeedUnit * (int32_t)lForcedMecSpeedUnit;
 8009d62:	fb02 fc01 	mul.w	ip, r2, r1
      if (wtemp > 0)
 8009d66:	f1bc 0f00 	cmp.w	ip, #0
{
 8009d6a:	b530      	push	{r4, r5, lr}
      wtemp = (int32_t)hEstimatedSpeedUnit * (int32_t)lForcedMecSpeedUnit;
 8009d6c:	468e      	mov	lr, r1
      if (wtemp > 0)
 8009d6e:	dd37      	ble.n	8009de0 <STO_CR_IsObserverConverged+0xa0>
        if (hEstimatedSpeedUnit < 0)
 8009d70:	2a00      	cmp	r2, #0
          hEstimatedSpeedUnit = -hEstimatedSpeedUnit;
 8009d72:	bfbc      	itt	lt
 8009d74:	4252      	neglt	r2, r2
 8009d76:	b212      	sxthlt	r2, r2
        if (true == pHandle->IsSpeedReliable)
 8009d78:	f893 40c9 	ldrb.w	r4, [r3, #201]	@ 0xc9
        wAux = (int32_t) (lForcedMecSpeedUnit) * (int16_t)pHandle->SpeedValidationBand_H;
 8009d7c:	f893 c170 	ldrb.w	ip, [r3, #368]	@ 0x170
        if (lForcedMecSpeedUnit < 0)
 8009d80:	2900      	cmp	r1, #0
          lForcedMecSpeedUnit = -lForcedMecSpeedUnit;
 8009d82:	bfbc      	itt	lt
 8009d84:	4249      	neglt	r1, r1
        wAux = (int32_t) (lForcedMecSpeedUnit) * (int16_t)pHandle->SpeedValidationBand_H;
 8009d86:	fa0f fe81 	sxthlt.w	lr, r1
        wAux = (int32_t) (lForcedMecSpeedUnit) * (int16_t)pHandle->SpeedValidationBand_L;
 8009d8a:	f893 1171 	ldrb.w	r1, [r3, #369]	@ 0x171
        if (true == pHandle->IsSpeedReliable)
 8009d8e:	b344      	cbz	r4, 8009de2 <STO_CR_IsObserverConverged+0xa2>
          if ((uint16_t)hEstimatedSpeedUnit > pHandle->MinStartUpValidSpeed)
 8009d90:	f8b3 5172 	ldrh.w	r5, [r3, #370]	@ 0x172
 8009d94:	b294      	uxth	r4, r2
 8009d96:	42a5      	cmp	r5, r4
 8009d98:	d223      	bcs.n	8009de2 <STO_CR_IsObserverConverged+0xa2>
        wAux = (int32_t) (lForcedMecSpeedUnit) * (int16_t)pHandle->SpeedValidationBand_L;
 8009d9a:	fb0e f101 	mul.w	r1, lr, r1
        hLowerThreshold = (int16_t)(wAux / (int32_t)16);
 8009d9e:	2900      	cmp	r1, #0
 8009da0:	bfb8      	it	lt
 8009da2:	310f      	addlt	r1, #15
            if (hEstimatedSpeedUnit >= hLowerThreshold)
 8009da4:	f341 110f 	sbfx	r1, r1, #4, #16
 8009da8:	428a      	cmp	r2, r1
 8009daa:	db1a      	blt.n	8009de2 <STO_CR_IsObserverConverged+0xa2>
        wAux = (int32_t) (lForcedMecSpeedUnit) * (int16_t)pHandle->SpeedValidationBand_H;
 8009dac:	fb0e fc0c 	mul.w	ip, lr, ip
        hUpperThreshold = (int16_t)(wAux / (int32_t)16);
 8009db0:	f1bc 0f00 	cmp.w	ip, #0
 8009db4:	bfb8      	it	lt
 8009db6:	f10c 0c0f 	addlt.w	ip, ip, #15
              if (hEstimatedSpeedUnit <= hUpperThreshold)
 8009dba:	f34c 1c0f 	sbfx	ip, ip, #4, #16
 8009dbe:	4562      	cmp	r2, ip
 8009dc0:	dc0f      	bgt.n	8009de2 <STO_CR_IsObserverConverged+0xa2>
                pHandle->ConsistencyCounter++;
 8009dc2:	f893 20ca 	ldrb.w	r2, [r3, #202]	@ 0xca
                if (pHandle->ConsistencyCounter >= pHandle->StartUpConsistThreshold)
 8009dc6:	f893 1174 	ldrb.w	r1, [r3, #372]	@ 0x174
                pHandle->ConsistencyCounter++;
 8009dca:	3201      	adds	r2, #1
 8009dcc:	b2d2      	uxtb	r2, r2
                if (pHandle->ConsistencyCounter >= pHandle->StartUpConsistThreshold)
 8009dce:	4291      	cmp	r1, r2
                pHandle->ConsistencyCounter++;
 8009dd0:	f883 20ca 	strb.w	r2, [r3, #202]	@ 0xca
                if (pHandle->ConsistencyCounter >= pHandle->StartUpConsistThreshold)
 8009dd4:	d804      	bhi.n	8009de0 <STO_CR_IsObserverConverged+0xa0>
      pHandle->IsAlgorithmConverged = true;
 8009dd6:	2001      	movs	r0, #1
      pHandle->_Super.bSpeedErrorNumber = 0U;
 8009dd8:	2200      	movs	r2, #0
      pHandle->IsAlgorithmConverged = true;
 8009dda:	f883 00cc 	strb.w	r0, [r3, #204]	@ 0xcc
      pHandle->_Super.bSpeedErrorNumber = 0U;
 8009dde:	701a      	strb	r2, [r3, #0]
}
 8009de0:	bd30      	pop	{r4, r5, pc}
                pHandle->ConsistencyCounter = 0U;
 8009de2:	2200      	movs	r2, #0
 8009de4:	f883 20ca 	strb.w	r2, [r3, #202]	@ 0xca
}
 8009de8:	bd30      	pop	{r4, r5, pc}
 8009dea:	bf00      	nop

08009dec <STO_CR_GetEstimatedBemf>:
    Vaux.alpha = pHandle->hBemf_alfa_est;
    Vaux.beta = pHandle->hBemf_beta_est;
#ifdef NULL_PTR_CHECK_STO_COR_SPD_POS_FDB
  }
#endif
  return (Vaux);
 8009dec:	6c43      	ldr	r3, [r0, #68]	@ 0x44
 8009dee:	2200      	movs	r2, #0
 8009df0:	b299      	uxth	r1, r3
 8009df2:	f361 020f 	bfi	r2, r1, #0, #16
 8009df6:	0c1b      	lsrs	r3, r3, #16
 8009df8:	f363 421f 	bfi	r2, r3, #16, #16
{
 8009dfc:	b082      	sub	sp, #8
}
 8009dfe:	4610      	mov	r0, r2
 8009e00:	b002      	add	sp, #8
 8009e02:	4770      	bx	lr

08009e04 <STO_CR_GetEstimatedCurrent>:
  *         observer
  * @param  pHandle: handler of the current instance of the STO CORDIC component
  * @retval alphabeta_t State observer estimated stator current Ialpha-beta
  */
__weak alphabeta_t STO_CR_GetEstimatedCurrent(STO_CR_Handle_t *pHandle)
{
 8009e04:	4603      	mov	r3, r0
    Iaux.beta = (int16_t)(pHandle->Ibeta_est / (pHandle->hF1));
#endif
#ifdef NULL_PTR_CHECK_STO_COR_SPD_POS_FDB
  }
#endif
  return (Iaux);
 8009e06:	2000      	movs	r0, #0
    Iaux.alpha = (int16_t)(pHandle->Ialfa_est >> pHandle->F1LOG);
 8009e08:	f8b3 117c 	ldrh.w	r1, [r3, #380]	@ 0x17c
    Iaux.beta = (int16_t)(pHandle->Ibeta_est >> pHandle->F1LOG);
 8009e0c:	e9d3 230d 	ldrd	r2, r3, [r3, #52]	@ 0x34
    Iaux.alpha = (int16_t)(pHandle->Ialfa_est >> pHandle->F1LOG);
 8009e10:	410a      	asrs	r2, r1
  return (Iaux);
 8009e12:	410b      	asrs	r3, r1
 8009e14:	b292      	uxth	r2, r2
 8009e16:	f362 000f 	bfi	r0, r2, #0, #16
 8009e1a:	b29b      	uxth	r3, r3
{
 8009e1c:	b082      	sub	sp, #8
  return (Iaux);
 8009e1e:	f363 401f 	bfi	r0, r3, #16, #16
}
 8009e22:	b002      	add	sp, #8
 8009e24:	4770      	bx	lr
 8009e26:	bf00      	nop

08009e28 <STO_CR_GetObserverGains>:
    /* Nothing to do */
  }
  else
  {
#endif
    *phC2 = pHandle->hC2;
 8009e28:	f9b0 3022 	ldrsh.w	r3, [r0, #34]	@ 0x22
 8009e2c:	800b      	strh	r3, [r1, #0]
    *phC4 = pHandle->hC4;
 8009e2e:	f9b0 3026 	ldrsh.w	r3, [r0, #38]	@ 0x26
 8009e32:	8013      	strh	r3, [r2, #0]
#ifdef NULL_PTR_CHECK_STO_COR_SPD_POS_FDB
  }
#endif
}
 8009e34:	4770      	bx	lr
 8009e36:	bf00      	nop

08009e38 <STO_CR_SetObserverGains>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->hC2 = hhC1;
 8009e38:	8441      	strh	r1, [r0, #34]	@ 0x22
    pHandle->hC4 = hhC2;
 8009e3a:	84c2      	strh	r2, [r0, #38]	@ 0x26
#ifdef NULL_PTR_CHECK_STO_COR_SPD_POS_FDB
  }
#endif
}
 8009e3c:	4770      	bx	lr
 8009e3e:	bf00      	nop

08009e40 <STO_CR_CalcAvrgElSpeedDpp>:
    int32_t wSumOrig = pHandle->DppOrigBufferSum;
    int32_t wAvrSpeed_dpp;
    int16_t hSpeedBufferSizedpp = (int16_t)(pHandle->SpeedBufferSizedpp);
    int16_t hSpeedBufferSizeUnit = (int16_t)(pHandle->SpeedBufferSizeUnit);
    int16_t hBufferSizeDiff;
    int16_t hIndexNew = (int16_t)pHandle->Speed_Buffer_Index;
 8009e40:	f890 10c8 	ldrb.w	r1, [r0, #200]	@ 0xc8
    int16_t hIndexOld;
    int16_t hIndexOldTemp;

    hBufferSizeDiff = hSpeedBufferSizeUnit - hSpeedBufferSizedpp;
 8009e44:	f890 216d 	ldrb.w	r2, [r0, #365]	@ 0x16d
 8009e48:	eb00 0c41 	add.w	ip, r0, r1, lsl #1
{
 8009e4c:	b510      	push	{r4, lr}

    if (0 == hBufferSizeDiff)
    {
      wSum = wSum + pHandle->Speed_Buffer[hIndexNew] - pHandle->SpeedBufferOldestEl;
 8009e4e:	f9bc 3048 	ldrsh.w	r3, [ip, #72]	@ 0x48
 8009e52:	f8d0 4160 	ldr.w	r4, [r0, #352]	@ 0x160
    int16_t hSpeedBufferSizeUnit = (int16_t)(pHandle->SpeedBufferSizeUnit);
 8009e56:	f890 e16c 	ldrb.w	lr, [r0, #364]	@ 0x16c
      wSumOrig = wSumOrig + pHandle->Orig_Speed_Buffer[hIndexNew] - pHandle->OrigSpeedBufferOldestEl;
 8009e5a:	f9bc c0ce 	ldrsh.w	ip, [ip, #206]	@ 0xce
    hBufferSizeDiff = hSpeedBufferSizeUnit - hSpeedBufferSizedpp;
 8009e5e:	ebae 0202 	sub.w	r2, lr, r2
      wSum = wSum + pHandle->Speed_Buffer[hIndexNew] - pHandle->SpeedBufferOldestEl;
 8009e62:	4423      	add	r3, r4
      wSumOrig = wSumOrig + pHandle->Orig_Speed_Buffer[hIndexNew] - pHandle->OrigSpeedBufferOldestEl;
 8009e64:	f8d0 4164 	ldr.w	r4, [r0, #356]	@ 0x164
    hBufferSizeDiff = hSpeedBufferSizeUnit - hSpeedBufferSizedpp;
 8009e68:	b292      	uxth	r2, r2
      wSumOrig = wSumOrig + pHandle->Orig_Speed_Buffer[hIndexNew] - pHandle->OrigSpeedBufferOldestEl;
 8009e6a:	44a4      	add	ip, r4
    if (0 == hBufferSizeDiff)
 8009e6c:	b99a      	cbnz	r2, 8009e96 <STO_CR_CalcAvrgElSpeedDpp+0x56>
      wSum = wSum + pHandle->Speed_Buffer[hIndexNew] - pHandle->SpeedBufferOldestEl;
 8009e6e:	f9b0 1168 	ldrsh.w	r1, [r0, #360]	@ 0x168
      wSumOrig = wSumOrig + pHandle->Orig_Speed_Buffer[hIndexNew] - pHandle->OrigSpeedBufferOldestEl;
 8009e72:	f9b0 216a 	ldrsh.w	r2, [r0, #362]	@ 0x16a
      wSum = wSum + pHandle->Speed_Buffer[hIndexNew] - pHandle->SpeedBufferOldestEl;
 8009e76:	1a5b      	subs	r3, r3, r1
      wSumOrig = wSumOrig + pHandle->Orig_Speed_Buffer[hIndexNew] - pHandle->OrigSpeedBufferOldestEl;
 8009e78:	ebac 0202 	sub.w	r2, ip, r2
      wSumOrig = wSumOrig + pHandle->Orig_Speed_Buffer[hIndexNew] - pHandle->Orig_Speed_Buffer[hIndexOld];
    }

#ifndef FULL_MISRA_C_COMPLIANCY_STO_CORDIC
    //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
    wAvrSpeed_dpp = (int32_t)(wSum >> pHandle->SpeedBufferSizedppLOG);
 8009e7c:	f8b0 1180 	ldrh.w	r1, [r0, #384]	@ 0x180
    }
#endif

    pHandle->Orig_ElSpeedDpp = (int16_t)wAvrSpeed_dpp;

    pHandle->DppBufferSum = wSum;
 8009e80:	f8c0 3160 	str.w	r3, [r0, #352]	@ 0x160
    wAvrSpeed_dpp = (int32_t)(wSum >> pHandle->SpeedBufferSizedppLOG);
 8009e84:	410b      	asrs	r3, r1
    wAvrSpeed_dpp = (int32_t)(wSumOrig >> pHandle->SpeedBufferSizedppLOG);
 8009e86:	fa42 f101 	asr.w	r1, r2, r1
    pHandle->_Super.hElSpeedDpp = (int16_t)wAvrSpeed_dpp;
 8009e8a:	81c3      	strh	r3, [r0, #14]
    pHandle->Orig_ElSpeedDpp = (int16_t)wAvrSpeed_dpp;
 8009e8c:	f8a0 114e 	strh.w	r1, [r0, #334]	@ 0x14e

    pHandle->DppOrigBufferSum = wSumOrig;
 8009e90:	f8c0 2164 	str.w	r2, [r0, #356]	@ 0x164
#ifdef NULL_PTR_CHECK_STO_COR_SPD_POS_FDB
  }
#endif
}
 8009e94:	bd10      	pop	{r4, pc}
      hIndexOldTemp = hIndexNew + hBufferSizeDiff;
 8009e96:	4411      	add	r1, r2
 8009e98:	b20a      	sxth	r2, r1
      if (hIndexOldTemp >= hSpeedBufferSizeUnit)
 8009e9a:	4596      	cmp	lr, r2
      hIndexOldTemp = hIndexNew + hBufferSizeDiff;
 8009e9c:	b289      	uxth	r1, r1
        hIndexOld = hIndexOldTemp - hSpeedBufferSizeUnit;
 8009e9e:	bfdc      	itt	le
 8009ea0:	eba1 010e 	suble.w	r1, r1, lr
 8009ea4:	b20a      	sxthle	r2, r1
      wSum = wSum + pHandle->Speed_Buffer[hIndexNew] - pHandle->Speed_Buffer[hIndexOld];
 8009ea6:	eb00 0242 	add.w	r2, r0, r2, lsl #1
 8009eaa:	f9b2 1048 	ldrsh.w	r1, [r2, #72]	@ 0x48
      wSumOrig = wSumOrig + pHandle->Orig_Speed_Buffer[hIndexNew] - pHandle->Orig_Speed_Buffer[hIndexOld];
 8009eae:	f9b2 20ce 	ldrsh.w	r2, [r2, #206]	@ 0xce
      wSum = wSum + pHandle->Speed_Buffer[hIndexNew] - pHandle->Speed_Buffer[hIndexOld];
 8009eb2:	1a5b      	subs	r3, r3, r1
      wSumOrig = wSumOrig + pHandle->Orig_Speed_Buffer[hIndexNew] - pHandle->Orig_Speed_Buffer[hIndexOld];
 8009eb4:	ebac 0202 	sub.w	r2, ip, r2
 8009eb8:	e7e0      	b.n	8009e7c <STO_CR_CalcAvrgElSpeedDpp+0x3c>
 8009eba:	bf00      	nop

08009ebc <STO_CR_IsSpeedReliable>:
  }
  else
  {
#endif
    const  STO_CR_Handle_t *pHdl = (STO_CR_Handle_t *)pHandle->_Super; //cstat !MISRAC2012-Rule-11.3
    returnbool = pHdl->IsSpeedReliable;
 8009ebc:	6803      	ldr	r3, [r0, #0]
#ifdef NULL_PTR_CHECK_STO_COR_SPD_POS_FDB
  }
#endif
  return (returnbool);
}
 8009ebe:	f893 00c9 	ldrb.w	r0, [r3, #201]	@ 0xc9
 8009ec2:	4770      	bx	lr

08009ec4 <STO_CR_ForceConvergency1>:
  else
  {
#endif
    STO_CR_Handle_t *pHdl = (STO_CR_Handle_t *)pHandle->_Super; //cstat !MISRAC2012-Rule-11.3
  
    pHdl->ForceConvergency = true;
 8009ec4:	6803      	ldr	r3, [r0, #0]
 8009ec6:	2201      	movs	r2, #1
 8009ec8:	f883 2182 	strb.w	r2, [r3, #386]	@ 0x182
#ifdef NULL_PTR_CHECK_STO_COR_SPD_POS_FDB
  }
#endif
}
 8009ecc:	4770      	bx	lr
 8009ece:	bf00      	nop

08009ed0 <STO_CR_ForceConvergency2>:
  else
  {
#endif
    STO_CR_Handle_t *pHdl = (STO_CR_Handle_t *)pHandle->_Super; //cstat !MISRAC2012-Rule-11.3
  
    pHdl->ForceConvergency2 = true;
 8009ed0:	6803      	ldr	r3, [r0, #0]
 8009ed2:	2201      	movs	r2, #1
 8009ed4:	f883 2183 	strb.w	r2, [r3, #387]	@ 0x183
#ifdef NULL_PTR_CHECK_STO_COR_SPD_POS_FDB
  }
#endif
}
 8009ed8:	4770      	bx	lr
 8009eda:	bf00      	nop

08009edc <VSS_Clear>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->_Super.bSpeedErrorNumber = 0U;
 8009edc:	2300      	movs	r3, #0
    pHandle->hRemainingStep = 0U;
    pHandle->hElAngleAccu = 0;

    pHandle->bTransitionStarted = false;
    pHandle->bTransitionEnded = false;
    pHandle->hTransitionRemainingSteps = pHandle->hTransitionSteps;
 8009ede:	8ec2      	ldrh	r2, [r0, #54]	@ 0x36
    pHandle->_Super.bSpeedErrorNumber = 0U;
 8009ee0:	7003      	strb	r3, [r0, #0]
    pHandle->wElSpeedDpp32 = 0;
 8009ee2:	e9c0 3308 	strd	r3, r3, [r0, #32]
    pHandle->_Super.hElAngle = 0;
 8009ee6:	6043      	str	r3, [r0, #4]
    pHandle->_Super.hAvrMecSpeedUnit = 0;
 8009ee8:	60c3      	str	r3, [r0, #12]
    pHandle->_Super.hMecAccelUnitP = 0;
 8009eea:	8243      	strh	r3, [r0, #18]
    pHandle->hRemainingStep = 0U;
 8009eec:	8503      	strh	r3, [r0, #40]	@ 0x28
    pHandle->bTransitionStarted = false;
 8009eee:	8583      	strh	r3, [r0, #44]	@ 0x2c
    pHandle->hTransitionRemainingSteps = pHandle->hTransitionSteps;
 8009ef0:	85c2      	strh	r2, [r0, #46]	@ 0x2e
    pHandle->hElAngleAccu = 0;
 8009ef2:	6303      	str	r3, [r0, #48]	@ 0x30

    pHandle->bCopyObserver = false;
#ifdef NULL_PTR_CHECK_VIR_SPD_SEN
  }
#endif
}
 8009ef4:	4770      	bx	lr
 8009ef6:	bf00      	nop

08009ef8 <VSS_Init>:
{
 8009ef8:	b508      	push	{r3, lr}
  VSS_Clear(pHandle);
 8009efa:	f7ff ffef 	bl	8009edc <VSS_Clear>
}
 8009efe:	bd08      	pop	{r3, pc}

08009f00 <VSS_CalcElAngle>:
    int16_t hAngleDiff;
    int32_t wAux;
    int16_t hAngleCorr;
    int16_t hSignCorr = 1;

    if (true == pHandle->bCopyObserver)
 8009f00:	f890 2033 	ldrb.w	r2, [r0, #51]	@ 0x33
{
 8009f04:	4603      	mov	r3, r0
    if (true == pHandle->bCopyObserver)
 8009f06:	b11a      	cbz	r2, 8009f10 <VSS_CalcElAngle+0x10>
    {
      hRetAngle = *(int16_t *)pInputVars_str;
 8009f08:	f9b1 0000 	ldrsh.w	r0, [r1]
      {
        hRetAngle = pHandle->hElAngleAccu;
      }
    }

    pHandle->_Super.hElAngle = hRetAngle;
 8009f0c:	8098      	strh	r0, [r3, #4]
#ifdef NULL_PTR_CHECK_VIR_SPD_SEN
  }
#endif
  return (hRetAngle);
}
 8009f0e:	4770      	bx	lr
{
 8009f10:	b530      	push	{r4, r5, lr}
      pHandle->hElAngleAccu += pHandle->_Super.hElSpeedDpp;
 8009f12:	f9b0 c00e 	ldrsh.w	ip, [r0, #14]
 8009f16:	8e00      	ldrh	r0, [r0, #48]	@ 0x30
      pHandle->_Super.hMecAngle += (pHandle->_Super.hElSpeedDpp / (int16_t)pHandle->_Super.bElToMecRatio);
 8009f18:	88dd      	ldrh	r5, [r3, #6]
      if (true == pHandle->bTransitionStarted)
 8009f1a:	f893 402c 	ldrb.w	r4, [r3, #44]	@ 0x2c
      pHandle->_Super.hMecAngle += (pHandle->_Super.hElSpeedDpp / (int16_t)pHandle->_Super.bElToMecRatio);
 8009f1e:	785a      	ldrb	r2, [r3, #1]
 8009f20:	fb9c f2f2 	sdiv	r2, ip, r2
      pHandle->hElAngleAccu += pHandle->_Super.hElSpeedDpp;
 8009f24:	4460      	add	r0, ip
 8009f26:	fa1f fe80 	uxth.w	lr, r0
      pHandle->_Super.hMecAngle += (pHandle->_Super.hElSpeedDpp / (int16_t)pHandle->_Super.bElToMecRatio);
 8009f2a:	442a      	add	r2, r5
      pHandle->hElAngleAccu += pHandle->_Super.hElSpeedDpp;
 8009f2c:	b200      	sxth	r0, r0
 8009f2e:	8618      	strh	r0, [r3, #48]	@ 0x30
      pHandle->_Super.hMecAngle += (pHandle->_Super.hElSpeedDpp / (int16_t)pHandle->_Super.bElToMecRatio);
 8009f30:	80da      	strh	r2, [r3, #6]
      if (true == pHandle->bTransitionStarted)
 8009f32:	b1fc      	cbz	r4, 8009f74 <VSS_CalcElAngle+0x74>
        if (0 == pHandle->hTransitionRemainingSteps)
 8009f34:	f9b3 202e 	ldrsh.w	r2, [r3, #46]	@ 0x2e
 8009f38:	b1f2      	cbz	r2, 8009f78 <VSS_CalcElAngle+0x78>
          pHandle->hTransitionRemainingSteps--;
 8009f3a:	3a01      	subs	r2, #1
 8009f3c:	b212      	sxth	r2, r2
 8009f3e:	85da      	strh	r2, [r3, #46]	@ 0x2e
          if (pHandle->_Super.hElSpeedDpp >= 0)
 8009f40:	f1bc 0f00 	cmp.w	ip, #0
            hAngleDiff = *(int16_t *)pInputVars_str - pHandle->hElAngleAccu;
 8009f44:	8809      	ldrh	r1, [r1, #0]
          if (pHandle->_Super.hElSpeedDpp >= 0)
 8009f46:	db26      	blt.n	8009f96 <VSS_CalcElAngle+0x96>
            hAngleDiff = *(int16_t *)pInputVars_str - pHandle->hElAngleAccu;
 8009f48:	eba1 0e0e 	sub.w	lr, r1, lr
 8009f4c:	fa0f fe8e 	sxth.w	lr, lr
 8009f50:	2501      	movs	r5, #1
          hAngleCorr = (int16_t)(wAux / pHandle->hTransitionSteps);
 8009f52:	f9b3 4036 	ldrsh.w	r4, [r3, #54]	@ 0x36
          wAux = (int32_t)hAngleDiff * pHandle->hTransitionRemainingSteps;
 8009f56:	fb0e f202 	mul.w	r2, lr, r2
          if (hAngleDiff >= 0)
 8009f5a:	f1be 0f00 	cmp.w	lr, #0
          hAngleCorr = (int16_t)(wAux / pHandle->hTransitionSteps);
 8009f5e:	fb92 f2f4 	sdiv	r2, r2, r4
          hAngleCorr *= hSignCorr;
 8009f62:	fb12 f205 	smulbb	r2, r2, r5
 8009f66:	b292      	uxth	r2, r2
          if (hAngleDiff >= 0)
 8009f68:	db0e      	blt.n	8009f88 <VSS_CalcElAngle+0x88>
            pHandle->bTransitionLocked = true;
 8009f6a:	2001      	movs	r0, #1
            hRetAngle = *(int16_t *)pInputVars_str - hAngleCorr;
 8009f6c:	1a8a      	subs	r2, r1, r2
            pHandle->bTransitionLocked = true;
 8009f6e:	f883 0032 	strb.w	r0, [r3, #50]	@ 0x32
            hRetAngle = *(int16_t *)pInputVars_str - hAngleCorr;
 8009f72:	b210      	sxth	r0, r2
    pHandle->_Super.hElAngle = hRetAngle;
 8009f74:	8098      	strh	r0, [r3, #4]
}
 8009f76:	bd30      	pop	{r4, r5, pc}
          hRetAngle = *(int16_t *)pInputVars_str;
 8009f78:	f9b1 0000 	ldrsh.w	r0, [r1]
          pHandle->_Super.bSpeedErrorNumber = 0U;
 8009f7c:	701a      	strb	r2, [r3, #0]
          pHandle->bTransitionEnded = true;
 8009f7e:	2401      	movs	r4, #1
 8009f80:	f883 402d 	strb.w	r4, [r3, #45]	@ 0x2d
    pHandle->_Super.hElAngle = hRetAngle;
 8009f84:	8098      	strh	r0, [r3, #4]
}
 8009f86:	bd30      	pop	{r4, r5, pc}
            if (false == pHandle->bTransitionLocked)
 8009f88:	f893 4032 	ldrb.w	r4, [r3, #50]	@ 0x32
 8009f8c:	2c00      	cmp	r4, #0
 8009f8e:	d0f1      	beq.n	8009f74 <VSS_CalcElAngle+0x74>
              hRetAngle = *(int16_t *)pInputVars_str + hAngleCorr;
 8009f90:	440a      	add	r2, r1
 8009f92:	b210      	sxth	r0, r2
 8009f94:	e7ee      	b.n	8009f74 <VSS_CalcElAngle+0x74>
            hAngleDiff = pHandle->hElAngleAccu - *(int16_t *)pInputVars_str;
 8009f96:	ebae 0e01 	sub.w	lr, lr, r1
 8009f9a:	fa0f fe8e 	sxth.w	lr, lr
 8009f9e:	f64f 75ff 	movw	r5, #65535	@ 0xffff
 8009fa2:	e7d6      	b.n	8009f52 <VSS_CalcElAngle+0x52>

08009fa4 <VSS_CalcAvrgMecSpeedUnit>:
    SpeedSensorReliability = false;
  }
  else
  {
#endif
    if (pHandle->hRemainingStep > 1u)
 8009fa4:	8d02      	ldrh	r2, [r0, #40]	@ 0x28
 8009fa6:	2a01      	cmp	r2, #1
{
 8009fa8:	4603      	mov	r3, r0
    if (pHandle->hRemainingStep > 1u)
 8009faa:	d922      	bls.n	8009ff2 <VSS_CalcAvrgMecSpeedUnit+0x4e>
{
 8009fac:	b410      	push	{r4}
    {
      pHandle->wElSpeedDpp32 += pHandle->wElAccDppP32;
 8009fae:	6a40      	ldr	r0, [r0, #36]	@ 0x24
 8009fb0:	6a1c      	ldr	r4, [r3, #32]
      pHandle->_Super.hElSpeedDpp = (int16_t)(pHandle->wElSpeedDpp32 / 65536);
#endif

      /* Convert dpp into MecUnit */
      *hMecSpeedUnit = (int16_t)((((int32_t)pHandle->_Super.hElSpeedDpp)
                               * ((int32_t )pHandle->_Super.hMeasurementFrequency) * SPEED_UNIT)
 8009fb2:	8b5a      	ldrh	r2, [r3, #26]
      pHandle->wElSpeedDpp32 += pHandle->wElAccDppP32;
 8009fb4:	4420      	add	r0, r4
      pHandle->_Super.hElSpeedDpp = (int16_t)(pHandle->wElSpeedDpp32 >> 16);
 8009fb6:	ea4f 4c20 	mov.w	ip, r0, asr #16
                               / (((int32_t)pHandle->_Super.DPPConvFactor) * ((int32_t)pHandle->_Super.bElToMecRatio)));
 8009fba:	69dc      	ldr	r4, [r3, #28]
      pHandle->wElSpeedDpp32 += pHandle->wElAccDppP32;
 8009fbc:	6258      	str	r0, [r3, #36]	@ 0x24
                               * ((int32_t )pHandle->_Super.hMeasurementFrequency) * SPEED_UNIT)
 8009fbe:	fb0c f202 	mul.w	r2, ip, r2
                               / (((int32_t)pHandle->_Super.DPPConvFactor) * ((int32_t)pHandle->_Super.bElToMecRatio)));
 8009fc2:	7858      	ldrb	r0, [r3, #1]
      pHandle->_Super.hElSpeedDpp = (int16_t)(pHandle->wElSpeedDpp32 >> 16);
 8009fc4:	f8a3 c00e 	strh.w	ip, [r3, #14]
                               * ((int32_t )pHandle->_Super.hMeasurementFrequency) * SPEED_UNIT)
 8009fc8:	eb02 0282 	add.w	r2, r2, r2, lsl #2
                               / (((int32_t)pHandle->_Super.DPPConvFactor) * ((int32_t)pHandle->_Super.bElToMecRatio)));
 8009fcc:	fb04 f000 	mul.w	r0, r4, r0
                               * ((int32_t )pHandle->_Super.hMeasurementFrequency) * SPEED_UNIT)
 8009fd0:	0052      	lsls	r2, r2, #1
                               / (((int32_t)pHandle->_Super.DPPConvFactor) * ((int32_t)pHandle->_Super.bElToMecRatio)));
 8009fd2:	fb92 f2f0 	sdiv	r2, r2, r0
      *hMecSpeedUnit = (int16_t)((((int32_t)pHandle->_Super.hElSpeedDpp)
 8009fd6:	b212      	sxth	r2, r2
 8009fd8:	800a      	strh	r2, [r1, #0]
      pHandle->_Super.hAvrMecSpeedUnit = *hMecSpeedUnit;
      pHandle->hRemainingStep--;
 8009fda:	8d18      	ldrh	r0, [r3, #40]	@ 0x28
      pHandle->_Super.hAvrMecSpeedUnit = *hMecSpeedUnit;
 8009fdc:	819a      	strh	r2, [r3, #12]
      pHandle->hRemainingStep--;
 8009fde:	1e42      	subs	r2, r0, #1
    else
    {
      *hMecSpeedUnit = pHandle->_Super.hAvrMecSpeedUnit;
    }
    /* If the transition is not done yet, we already know that speed is not reliable */
    if (false == pHandle->bTransitionEnded)
 8009fe0:	f893 002d 	ldrb.w	r0, [r3, #45]	@ 0x2d
      pHandle->hRemainingStep--;
 8009fe4:	851a      	strh	r2, [r3, #40]	@ 0x28
    if (false == pHandle->bTransitionEnded)
 8009fe6:	b970      	cbnz	r0, 800a006 <VSS_CalcAvrgMecSpeedUnit+0x62>
    {
      pHandle->_Super.bSpeedErrorNumber = pHandle->_Super.bMaximumSpeedErrorsNumber;
 8009fe8:	78da      	ldrb	r2, [r3, #3]
 8009fea:	701a      	strb	r2, [r3, #0]
    }
#ifdef NULL_PTR_CHECK_VIR_SPD_SEN
  }
#endif
  return (SpeedSensorReliability);
}
 8009fec:	f85d 4b04 	ldr.w	r4, [sp], #4
 8009ff0:	4770      	bx	lr
    else if (1U == pHandle->hRemainingStep)
 8009ff2:	d00d      	beq.n	800a010 <VSS_CalcAvrgMecSpeedUnit+0x6c>
      *hMecSpeedUnit = pHandle->_Super.hAvrMecSpeedUnit;
 8009ff4:	f9b0 200c 	ldrsh.w	r2, [r0, #12]
    if (false == pHandle->bTransitionEnded)
 8009ff8:	f893 002d 	ldrb.w	r0, [r3, #45]	@ 0x2d
      *hMecSpeedUnit = pHandle->_Super.hAvrMecSpeedUnit;
 8009ffc:	800a      	strh	r2, [r1, #0]
    if (false == pHandle->bTransitionEnded)
 8009ffe:	bb00      	cbnz	r0, 800a042 <VSS_CalcAvrgMecSpeedUnit+0x9e>
      pHandle->_Super.bSpeedErrorNumber = pHandle->_Super.bMaximumSpeedErrorsNumber;
 800a000:	78da      	ldrb	r2, [r3, #3]
 800a002:	701a      	strb	r2, [r3, #0]
}
 800a004:	4770      	bx	lr
 800a006:	f85d 4b04 	ldr.w	r4, [sp], #4
      SpeedSensorReliability = SPD_IsMecSpeedReliable(&pHandle->_Super, hMecSpeedUnit);
 800a00a:	4618      	mov	r0, r3
 800a00c:	f7ff bb5a 	b.w	80096c4 <SPD_IsMecSpeedReliable>
      *hMecSpeedUnit = pHandle->hFinalMecSpeedUnit;
 800a010:	f9b0 c02a 	ldrsh.w	ip, [r0, #42]	@ 0x2a
 800a014:	f8a1 c000 	strh.w	ip, [r1]
                                          / (((int32_t)SPEED_UNIT) * ((int32_t)pHandle->_Super.hMeasurementFrequency)));
 800a018:	8b42      	ldrh	r2, [r0, #26]
      pHandle->_Super.hElSpeedDpp = (int16_t)((((int32_t)*hMecSpeedUnit) * ((int32_t)pHandle->_Super.DPPConvFactor))
 800a01a:	69c0      	ldr	r0, [r0, #28]
      pHandle->_Super.hAvrMecSpeedUnit = *hMecSpeedUnit;
 800a01c:	f8a3 c00c 	strh.w	ip, [r3, #12]
                                          / (((int32_t)SPEED_UNIT) * ((int32_t)pHandle->_Super.hMeasurementFrequency)));
 800a020:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 800a024:	0052      	lsls	r2, r2, #1
      pHandle->_Super.hElSpeedDpp = (int16_t)((((int32_t)*hMecSpeedUnit) * ((int32_t)pHandle->_Super.DPPConvFactor))
 800a026:	fb00 f00c 	mul.w	r0, r0, ip
                                          / (((int32_t)SPEED_UNIT) * ((int32_t)pHandle->_Super.hMeasurementFrequency)));
 800a02a:	fb90 f0f2 	sdiv	r0, r0, r2
      pHandle->_Super.hElSpeedDpp *= ((int16_t)pHandle->_Super.bElToMecRatio);
 800a02e:	785a      	ldrb	r2, [r3, #1]
 800a030:	fb12 f200 	smulbb	r2, r2, r0
      pHandle->hRemainingStep = 0U;
 800a034:	2000      	movs	r0, #0
 800a036:	8518      	strh	r0, [r3, #40]	@ 0x28
    if (false == pHandle->bTransitionEnded)
 800a038:	f893 002d 	ldrb.w	r0, [r3, #45]	@ 0x2d
      pHandle->_Super.hElSpeedDpp *= ((int16_t)pHandle->_Super.bElToMecRatio);
 800a03c:	81da      	strh	r2, [r3, #14]
    if (false == pHandle->bTransitionEnded)
 800a03e:	2800      	cmp	r0, #0
 800a040:	d0de      	beq.n	800a000 <VSS_CalcAvrgMecSpeedUnit+0x5c>
      SpeedSensorReliability = SPD_IsMecSpeedReliable(&pHandle->_Super, hMecSpeedUnit);
 800a042:	4618      	mov	r0, r3
 800a044:	f7ff bb3e 	b.w	80096c4 <SPD_IsMecSpeedReliable>

0800a048 <VSS_SetMecAcceleration>:
    int32_t wMecAccDppP32;
    uint16_t hNbrStep;
    int16_t hCurrentMecSpeedDpp;
    int16_t hFinalMecSpeedDpp;

    if (false == pHandle->bTransitionStarted)
 800a048:	f890 302c 	ldrb.w	r3, [r0, #44]	@ 0x2c
 800a04c:	b9a3      	cbnz	r3, 800a078 <VSS_SetMecAcceleration+0x30>
        pHandle->_Super.hAvrMecSpeedUnit = hFinalMecSpeedUnit;

        pHandle->_Super.hElSpeedDpp = (int16_t)((((int32_t)hFinalMecSpeedUnit)
                                               * ((int32_t)pHandle->_Super.DPPConvFactor))
                                              / (((int32_t)SPEED_UNIT)
                                               * ((int32_t)pHandle->_Super.hMeasurementFrequency)));
 800a04e:	8b43      	ldrh	r3, [r0, #26]
{
 800a050:	b510      	push	{r4, lr}
                                               * ((int32_t)pHandle->_Super.DPPConvFactor))
 800a052:	69c4      	ldr	r4, [r0, #28]

        pHandle->_Super.hElSpeedDpp *= ((int16_t)pHandle->_Super.bElToMecRatio);
 800a054:	f890 e001 	ldrb.w	lr, [r0, #1]
                                               * ((int32_t)pHandle->_Super.hMeasurementFrequency)));
 800a058:	eb03 0383 	add.w	r3, r3, r3, lsl #2
                                               * ((int32_t)pHandle->_Super.DPPConvFactor))
 800a05c:	fb04 fc01 	mul.w	ip, r4, r1
                                               * ((int32_t)pHandle->_Super.hMeasurementFrequency)));
 800a060:	005b      	lsls	r3, r3, #1
                                              / (((int32_t)SPEED_UNIT)
 800a062:	fb9c fcf3 	sdiv	ip, ip, r3
      if (0U == hDurationms)
 800a066:	b942      	cbnz	r2, 800a07a <VSS_SetMecAcceleration+0x32>
        pHandle->_Super.hElSpeedDpp *= ((int16_t)pHandle->_Super.bElToMecRatio);
 800a068:	fb1c fc0e 	smulbb	ip, ip, lr
        pHandle->_Super.hAvrMecSpeedUnit = hFinalMecSpeedUnit;
 800a06c:	8181      	strh	r1, [r0, #12]
        pHandle->_Super.hElSpeedDpp *= ((int16_t)pHandle->_Super.bElToMecRatio);
 800a06e:	f8a0 c00e 	strh.w	ip, [r0, #14]

        pHandle->hRemainingStep = 0U;
 800a072:	8502      	strh	r2, [r0, #40]	@ 0x28

        pHandle->hFinalMecSpeedUnit = hFinalMecSpeedUnit;
 800a074:	8541      	strh	r1, [r0, #42]	@ 0x2a
      /* Nothing to do */
    }
#ifdef NULL_PTR_CHECK_VIR_SPD_SEN
  }
#endif
}
 800a076:	bd10      	pop	{r4, pc}
 800a078:	4770      	bx	lr
        hNbrStep = (uint16_t)((((uint32_t)hDurationms) * ((uint32_t)pHandle->hSpeedSamplingFreqHz)) / 1000U);
 800a07a:	8e83      	ldrh	r3, [r0, #52]	@ 0x34
 800a07c:	fb02 f303 	mul.w	r3, r2, r3
 800a080:	4a0e      	ldr	r2, [pc, #56]	@ (800a0bc <VSS_SetMecAcceleration+0x74>)
 800a082:	fba2 2303 	umull	r2, r3, r2, r3
 800a086:	f3c3 138f 	ubfx	r3, r3, #6, #16
        hNbrStep++;
 800a08a:	3301      	adds	r3, #1
 800a08c:	b29b      	uxth	r3, r3
        hCurrentMecSpeedDpp = pHandle->_Super.hElSpeedDpp / ((int16_t)pHandle->_Super.bElToMecRatio);
 800a08e:	f9b0 200e 	ldrsh.w	r2, [r0, #14]
        pHandle->hRemainingStep = hNbrStep;
 800a092:	8503      	strh	r3, [r0, #40]	@ 0x28
        if (0U == hNbrStep)
 800a094:	b91b      	cbnz	r3, 800a09e <VSS_SetMecAcceleration+0x56>
        pHandle->wElSpeedDpp32 = ((int32_t)pHandle->_Super.hElSpeedDpp) * ((int32_t)65536);
 800a096:	0412      	lsls	r2, r2, #16
        pHandle->hFinalMecSpeedUnit = hFinalMecSpeedUnit;
 800a098:	8541      	strh	r1, [r0, #42]	@ 0x2a
        pHandle->wElSpeedDpp32 = ((int32_t)pHandle->_Super.hElSpeedDpp) * ((int32_t)65536);
 800a09a:	6242      	str	r2, [r0, #36]	@ 0x24
}
 800a09c:	bd10      	pop	{r4, pc}
        hCurrentMecSpeedDpp = pHandle->_Super.hElSpeedDpp / ((int16_t)pHandle->_Super.bElToMecRatio);
 800a09e:	fb92 f4fe 	sdiv	r4, r2, lr
          wMecAccDppP32 = ((((int32_t)hFinalMecSpeedDpp) - ((int32_t)hCurrentMecSpeedDpp))
 800a0a2:	ebac 0c04 	sub.w	ip, ip, r4
                         * ((int32_t)65536)) / ((int32_t )hNbrStep);
 800a0a6:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
        pHandle->wElSpeedDpp32 = ((int32_t)pHandle->_Super.hElSpeedDpp) * ((int32_t)65536);
 800a0aa:	0412      	lsls	r2, r2, #16
          wMecAccDppP32 = ((((int32_t)hFinalMecSpeedDpp) - ((int32_t)hCurrentMecSpeedDpp))
 800a0ac:	fb9c f3f3 	sdiv	r3, ip, r3
          pHandle->wElAccDppP32 = wMecAccDppP32 * ((int16_t)pHandle->_Super.bElToMecRatio);
 800a0b0:	fb0e f303 	mul.w	r3, lr, r3
 800a0b4:	6203      	str	r3, [r0, #32]
        pHandle->hFinalMecSpeedUnit = hFinalMecSpeedUnit;
 800a0b6:	8541      	strh	r1, [r0, #42]	@ 0x2a
        pHandle->wElSpeedDpp32 = ((int32_t)pHandle->_Super.hElSpeedDpp) * ((int32_t)65536);
 800a0b8:	6242      	str	r2, [r0, #36]	@ 0x24
    }
 800a0ba:	e7ef      	b.n	800a09c <VSS_SetMecAcceleration+0x54>
 800a0bc:	10624dd3 	.word	0x10624dd3

0800a0c0 <VSS_SetStartTransition>:
    /* nothing to do */
  }
  else
  {
#endif
    if (true == bCommand)
 800a0c0:	b151      	cbz	r1, 800a0d8 <VSS_SetStartTransition+0x18>
    {
      pHandle->bTransitionStarted = true;

      if (0 == pHandle->hTransitionSteps)
 800a0c2:	f9b0 3036 	ldrsh.w	r3, [r0, #54]	@ 0x36
      pHandle->bTransitionStarted = true;
 800a0c6:	2201      	movs	r2, #1
 800a0c8:	f880 202c 	strb.w	r2, [r0, #44]	@ 0x2c
      if (0 == pHandle->hTransitionSteps)
 800a0cc:	b923      	cbnz	r3, 800a0d8 <VSS_SetStartTransition+0x18>
      {
        pHandle->bTransitionEnded = true;
 800a0ce:	f880 202d 	strb.w	r2, [r0, #45]	@ 0x2d
        pHandle->_Super.bSpeedErrorNumber = 0U;
 800a0d2:	7003      	strb	r3, [r0, #0]
        bAux = false;
 800a0d4:	4618      	mov	r0, r3
    }
#ifdef NULL_PTR_CHECK_VIR_SPD_SEN
  }
#endif
  return (bAux);
}
 800a0d6:	4770      	bx	lr
  bool bAux = true;
 800a0d8:	2001      	movs	r0, #1
 800a0da:	4770      	bx	lr

0800a0dc <VSS_TransitionEnded>:
#ifdef NULL_PTR_CHECK_VIR_SPD_SEN
  return ((MC_NULL == pHandle) ? false : pHandle->bTransitionEnded);
#else
  return (pHandle->bTransitionEnded);
#endif
}
 800a0dc:	f890 002d 	ldrb.w	r0, [r0, #45]	@ 0x2d
 800a0e0:	4770      	bx	lr
 800a0e2:	bf00      	nop

0800a0e4 <memset>:
 800a0e4:	4402      	add	r2, r0
 800a0e6:	4603      	mov	r3, r0
 800a0e8:	4293      	cmp	r3, r2
 800a0ea:	d100      	bne.n	800a0ee <memset+0xa>
 800a0ec:	4770      	bx	lr
 800a0ee:	f803 1b01 	strb.w	r1, [r3], #1
 800a0f2:	e7f9      	b.n	800a0e8 <memset+0x4>

0800a0f4 <__libc_init_array>:
 800a0f4:	b570      	push	{r4, r5, r6, lr}
 800a0f6:	4d0d      	ldr	r5, [pc, #52]	@ (800a12c <__libc_init_array+0x38>)
 800a0f8:	4c0d      	ldr	r4, [pc, #52]	@ (800a130 <__libc_init_array+0x3c>)
 800a0fa:	1b64      	subs	r4, r4, r5
 800a0fc:	10a4      	asrs	r4, r4, #2
 800a0fe:	2600      	movs	r6, #0
 800a100:	42a6      	cmp	r6, r4
 800a102:	d109      	bne.n	800a118 <__libc_init_array+0x24>
 800a104:	4d0b      	ldr	r5, [pc, #44]	@ (800a134 <__libc_init_array+0x40>)
 800a106:	4c0c      	ldr	r4, [pc, #48]	@ (800a138 <__libc_init_array+0x44>)
 800a108:	f000 f826 	bl	800a158 <_init>
 800a10c:	1b64      	subs	r4, r4, r5
 800a10e:	10a4      	asrs	r4, r4, #2
 800a110:	2600      	movs	r6, #0
 800a112:	42a6      	cmp	r6, r4
 800a114:	d105      	bne.n	800a122 <__libc_init_array+0x2e>
 800a116:	bd70      	pop	{r4, r5, r6, pc}
 800a118:	f855 3b04 	ldr.w	r3, [r5], #4
 800a11c:	4798      	blx	r3
 800a11e:	3601      	adds	r6, #1
 800a120:	e7ee      	b.n	800a100 <__libc_init_array+0xc>
 800a122:	f855 3b04 	ldr.w	r3, [r5], #4
 800a126:	4798      	blx	r3
 800a128:	3601      	adds	r6, #1
 800a12a:	e7f2      	b.n	800a112 <__libc_init_array+0x1e>
 800a12c:	0800a530 	.word	0x0800a530
 800a130:	0800a530 	.word	0x0800a530
 800a134:	0800a530 	.word	0x0800a530
 800a138:	0800a534 	.word	0x0800a534

0800a13c <memcpy>:
 800a13c:	440a      	add	r2, r1
 800a13e:	4291      	cmp	r1, r2
 800a140:	f100 33ff 	add.w	r3, r0, #4294967295
 800a144:	d100      	bne.n	800a148 <memcpy+0xc>
 800a146:	4770      	bx	lr
 800a148:	b510      	push	{r4, lr}
 800a14a:	f811 4b01 	ldrb.w	r4, [r1], #1
 800a14e:	f803 4f01 	strb.w	r4, [r3, #1]!
 800a152:	4291      	cmp	r1, r2
 800a154:	d1f9      	bne.n	800a14a <memcpy+0xe>
 800a156:	bd10      	pop	{r4, pc}

0800a158 <_init>:
 800a158:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a15a:	bf00      	nop
 800a15c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800a15e:	bc08      	pop	{r3}
 800a160:	469e      	mov	lr, r3
 800a162:	4770      	bx	lr

0800a164 <_fini>:
 800a164:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a166:	bf00      	nop
 800a168:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800a16a:	bc08      	pop	{r3}
 800a16c:	469e      	mov	lr, r3
 800a16e:	4770      	bx	lr
