
3Ph BLDC FOC Quadrature Encoder.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001d8  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000a14c  080001e0  080001e0  000011e0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000003b8  0800a32c  0800a32c  0000b32c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0800a6e4  0800a6e4  0000c484  2**0
                  CONTENTS
  4 .ARM          00000008  0800a6e4  0800a6e4  0000b6e4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  0800a6ec  0800a6ec  0000c484  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0800a6ec  0800a6ec  0000b6ec  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  0800a6f0  0800a6f0  0000b6f0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000484  20000000  0800a6f4  0000c000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          000022a4  20000484  0800ab78  0000c484  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  20002728  0800ab78  0000c728  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  0000c484  2**0
                  CONTENTS, READONLY
 12 .debug_line   00052347  00000000  00000000  0000c4b4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_line_str 00000088  00000000  00000000  0005e7fb  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_info   00054260  00000000  00000000  0005e883  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_abbrev 0000abca  00000000  00000000  000b2ae3  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_aranges 00002600  00000000  00000000  000bd6b0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_str    0010cc58  00000000  00000000  000bfcb0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_rnglists 00003c99  00000000  00000000  001cc908  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_loclists 0001f2da  00000000  00000000  001d05a1  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_macro  0000d451  00000000  00000000  001ef87b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .comment      00000043  00000000  00000000  001fcccc  2**0
                  CONTENTS, READONLY
 22 .debug_frame  00006524  00000000  00000000  001fcd10  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080001e0 <__do_global_dtors_aux>:
 80001e0:	b510      	push	{r4, lr}
 80001e2:	4c05      	ldr	r4, [pc, #20]	@ (80001f8 <__do_global_dtors_aux+0x18>)
 80001e4:	7823      	ldrb	r3, [r4, #0]
 80001e6:	b933      	cbnz	r3, 80001f6 <__do_global_dtors_aux+0x16>
 80001e8:	4b04      	ldr	r3, [pc, #16]	@ (80001fc <__do_global_dtors_aux+0x1c>)
 80001ea:	b113      	cbz	r3, 80001f2 <__do_global_dtors_aux+0x12>
 80001ec:	4804      	ldr	r0, [pc, #16]	@ (8000200 <__do_global_dtors_aux+0x20>)
 80001ee:	f3af 8000 	nop.w
 80001f2:	2301      	movs	r3, #1
 80001f4:	7023      	strb	r3, [r4, #0]
 80001f6:	bd10      	pop	{r4, pc}
 80001f8:	20000484 	.word	0x20000484
 80001fc:	00000000 	.word	0x00000000
 8000200:	0800a314 	.word	0x0800a314

08000204 <frame_dummy>:
 8000204:	b508      	push	{r3, lr}
 8000206:	4b03      	ldr	r3, [pc, #12]	@ (8000214 <frame_dummy+0x10>)
 8000208:	b11b      	cbz	r3, 8000212 <frame_dummy+0xe>
 800020a:	4903      	ldr	r1, [pc, #12]	@ (8000218 <frame_dummy+0x14>)
 800020c:	4803      	ldr	r0, [pc, #12]	@ (800021c <frame_dummy+0x18>)
 800020e:	f3af 8000 	nop.w
 8000212:	bd08      	pop	{r3, pc}
 8000214:	00000000 	.word	0x00000000
 8000218:	20000488 	.word	0x20000488
 800021c:	0800a314 	.word	0x0800a314

08000220 <__aeabi_uldivmod>:
 8000220:	b953      	cbnz	r3, 8000238 <__aeabi_uldivmod+0x18>
 8000222:	b94a      	cbnz	r2, 8000238 <__aeabi_uldivmod+0x18>
 8000224:	2900      	cmp	r1, #0
 8000226:	bf08      	it	eq
 8000228:	2800      	cmpeq	r0, #0
 800022a:	bf1c      	itt	ne
 800022c:	f04f 31ff 	movne.w	r1, #4294967295
 8000230:	f04f 30ff 	movne.w	r0, #4294967295
 8000234:	f000 b96a 	b.w	800050c <__aeabi_idiv0>
 8000238:	f1ad 0c08 	sub.w	ip, sp, #8
 800023c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000240:	f000 f806 	bl	8000250 <__udivmoddi4>
 8000244:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000248:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800024c:	b004      	add	sp, #16
 800024e:	4770      	bx	lr

08000250 <__udivmoddi4>:
 8000250:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000254:	9d08      	ldr	r5, [sp, #32]
 8000256:	460c      	mov	r4, r1
 8000258:	2b00      	cmp	r3, #0
 800025a:	d14e      	bne.n	80002fa <__udivmoddi4+0xaa>
 800025c:	4694      	mov	ip, r2
 800025e:	458c      	cmp	ip, r1
 8000260:	4686      	mov	lr, r0
 8000262:	fab2 f282 	clz	r2, r2
 8000266:	d962      	bls.n	800032e <__udivmoddi4+0xde>
 8000268:	b14a      	cbz	r2, 800027e <__udivmoddi4+0x2e>
 800026a:	f1c2 0320 	rsb	r3, r2, #32
 800026e:	4091      	lsls	r1, r2
 8000270:	fa20 f303 	lsr.w	r3, r0, r3
 8000274:	fa0c fc02 	lsl.w	ip, ip, r2
 8000278:	4319      	orrs	r1, r3
 800027a:	fa00 fe02 	lsl.w	lr, r0, r2
 800027e:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8000282:	fa1f f68c 	uxth.w	r6, ip
 8000286:	fbb1 f4f7 	udiv	r4, r1, r7
 800028a:	ea4f 431e 	mov.w	r3, lr, lsr #16
 800028e:	fb07 1114 	mls	r1, r7, r4, r1
 8000292:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000296:	fb04 f106 	mul.w	r1, r4, r6
 800029a:	4299      	cmp	r1, r3
 800029c:	d90a      	bls.n	80002b4 <__udivmoddi4+0x64>
 800029e:	eb1c 0303 	adds.w	r3, ip, r3
 80002a2:	f104 30ff 	add.w	r0, r4, #4294967295
 80002a6:	f080 8112 	bcs.w	80004ce <__udivmoddi4+0x27e>
 80002aa:	4299      	cmp	r1, r3
 80002ac:	f240 810f 	bls.w	80004ce <__udivmoddi4+0x27e>
 80002b0:	3c02      	subs	r4, #2
 80002b2:	4463      	add	r3, ip
 80002b4:	1a59      	subs	r1, r3, r1
 80002b6:	fa1f f38e 	uxth.w	r3, lr
 80002ba:	fbb1 f0f7 	udiv	r0, r1, r7
 80002be:	fb07 1110 	mls	r1, r7, r0, r1
 80002c2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 80002c6:	fb00 f606 	mul.w	r6, r0, r6
 80002ca:	429e      	cmp	r6, r3
 80002cc:	d90a      	bls.n	80002e4 <__udivmoddi4+0x94>
 80002ce:	eb1c 0303 	adds.w	r3, ip, r3
 80002d2:	f100 31ff 	add.w	r1, r0, #4294967295
 80002d6:	f080 80fc 	bcs.w	80004d2 <__udivmoddi4+0x282>
 80002da:	429e      	cmp	r6, r3
 80002dc:	f240 80f9 	bls.w	80004d2 <__udivmoddi4+0x282>
 80002e0:	4463      	add	r3, ip
 80002e2:	3802      	subs	r0, #2
 80002e4:	1b9b      	subs	r3, r3, r6
 80002e6:	ea40 4004 	orr.w	r0, r0, r4, lsl #16
 80002ea:	2100      	movs	r1, #0
 80002ec:	b11d      	cbz	r5, 80002f6 <__udivmoddi4+0xa6>
 80002ee:	40d3      	lsrs	r3, r2
 80002f0:	2200      	movs	r2, #0
 80002f2:	e9c5 3200 	strd	r3, r2, [r5]
 80002f6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80002fa:	428b      	cmp	r3, r1
 80002fc:	d905      	bls.n	800030a <__udivmoddi4+0xba>
 80002fe:	b10d      	cbz	r5, 8000304 <__udivmoddi4+0xb4>
 8000300:	e9c5 0100 	strd	r0, r1, [r5]
 8000304:	2100      	movs	r1, #0
 8000306:	4608      	mov	r0, r1
 8000308:	e7f5      	b.n	80002f6 <__udivmoddi4+0xa6>
 800030a:	fab3 f183 	clz	r1, r3
 800030e:	2900      	cmp	r1, #0
 8000310:	d146      	bne.n	80003a0 <__udivmoddi4+0x150>
 8000312:	42a3      	cmp	r3, r4
 8000314:	d302      	bcc.n	800031c <__udivmoddi4+0xcc>
 8000316:	4290      	cmp	r0, r2
 8000318:	f0c0 80f0 	bcc.w	80004fc <__udivmoddi4+0x2ac>
 800031c:	1a86      	subs	r6, r0, r2
 800031e:	eb64 0303 	sbc.w	r3, r4, r3
 8000322:	2001      	movs	r0, #1
 8000324:	2d00      	cmp	r5, #0
 8000326:	d0e6      	beq.n	80002f6 <__udivmoddi4+0xa6>
 8000328:	e9c5 6300 	strd	r6, r3, [r5]
 800032c:	e7e3      	b.n	80002f6 <__udivmoddi4+0xa6>
 800032e:	2a00      	cmp	r2, #0
 8000330:	f040 8090 	bne.w	8000454 <__udivmoddi4+0x204>
 8000334:	eba1 040c 	sub.w	r4, r1, ip
 8000338:	ea4f 481c 	mov.w	r8, ip, lsr #16
 800033c:	fa1f f78c 	uxth.w	r7, ip
 8000340:	2101      	movs	r1, #1
 8000342:	fbb4 f6f8 	udiv	r6, r4, r8
 8000346:	ea4f 431e 	mov.w	r3, lr, lsr #16
 800034a:	fb08 4416 	mls	r4, r8, r6, r4
 800034e:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 8000352:	fb07 f006 	mul.w	r0, r7, r6
 8000356:	4298      	cmp	r0, r3
 8000358:	d908      	bls.n	800036c <__udivmoddi4+0x11c>
 800035a:	eb1c 0303 	adds.w	r3, ip, r3
 800035e:	f106 34ff 	add.w	r4, r6, #4294967295
 8000362:	d202      	bcs.n	800036a <__udivmoddi4+0x11a>
 8000364:	4298      	cmp	r0, r3
 8000366:	f200 80cd 	bhi.w	8000504 <__udivmoddi4+0x2b4>
 800036a:	4626      	mov	r6, r4
 800036c:	1a1c      	subs	r4, r3, r0
 800036e:	fa1f f38e 	uxth.w	r3, lr
 8000372:	fbb4 f0f8 	udiv	r0, r4, r8
 8000376:	fb08 4410 	mls	r4, r8, r0, r4
 800037a:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 800037e:	fb00 f707 	mul.w	r7, r0, r7
 8000382:	429f      	cmp	r7, r3
 8000384:	d908      	bls.n	8000398 <__udivmoddi4+0x148>
 8000386:	eb1c 0303 	adds.w	r3, ip, r3
 800038a:	f100 34ff 	add.w	r4, r0, #4294967295
 800038e:	d202      	bcs.n	8000396 <__udivmoddi4+0x146>
 8000390:	429f      	cmp	r7, r3
 8000392:	f200 80b0 	bhi.w	80004f6 <__udivmoddi4+0x2a6>
 8000396:	4620      	mov	r0, r4
 8000398:	1bdb      	subs	r3, r3, r7
 800039a:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 800039e:	e7a5      	b.n	80002ec <__udivmoddi4+0x9c>
 80003a0:	f1c1 0620 	rsb	r6, r1, #32
 80003a4:	408b      	lsls	r3, r1
 80003a6:	fa22 f706 	lsr.w	r7, r2, r6
 80003aa:	431f      	orrs	r7, r3
 80003ac:	fa20 fc06 	lsr.w	ip, r0, r6
 80003b0:	fa04 f301 	lsl.w	r3, r4, r1
 80003b4:	ea43 030c 	orr.w	r3, r3, ip
 80003b8:	40f4      	lsrs	r4, r6
 80003ba:	fa00 f801 	lsl.w	r8, r0, r1
 80003be:	0c38      	lsrs	r0, r7, #16
 80003c0:	ea4f 4913 	mov.w	r9, r3, lsr #16
 80003c4:	fbb4 fef0 	udiv	lr, r4, r0
 80003c8:	fa1f fc87 	uxth.w	ip, r7
 80003cc:	fb00 441e 	mls	r4, r0, lr, r4
 80003d0:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
 80003d4:	fb0e f90c 	mul.w	r9, lr, ip
 80003d8:	45a1      	cmp	r9, r4
 80003da:	fa02 f201 	lsl.w	r2, r2, r1
 80003de:	d90a      	bls.n	80003f6 <__udivmoddi4+0x1a6>
 80003e0:	193c      	adds	r4, r7, r4
 80003e2:	f10e 3aff 	add.w	sl, lr, #4294967295
 80003e6:	f080 8084 	bcs.w	80004f2 <__udivmoddi4+0x2a2>
 80003ea:	45a1      	cmp	r9, r4
 80003ec:	f240 8081 	bls.w	80004f2 <__udivmoddi4+0x2a2>
 80003f0:	f1ae 0e02 	sub.w	lr, lr, #2
 80003f4:	443c      	add	r4, r7
 80003f6:	eba4 0409 	sub.w	r4, r4, r9
 80003fa:	fa1f f983 	uxth.w	r9, r3
 80003fe:	fbb4 f3f0 	udiv	r3, r4, r0
 8000402:	fb00 4413 	mls	r4, r0, r3, r4
 8000406:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
 800040a:	fb03 fc0c 	mul.w	ip, r3, ip
 800040e:	45a4      	cmp	ip, r4
 8000410:	d907      	bls.n	8000422 <__udivmoddi4+0x1d2>
 8000412:	193c      	adds	r4, r7, r4
 8000414:	f103 30ff 	add.w	r0, r3, #4294967295
 8000418:	d267      	bcs.n	80004ea <__udivmoddi4+0x29a>
 800041a:	45a4      	cmp	ip, r4
 800041c:	d965      	bls.n	80004ea <__udivmoddi4+0x29a>
 800041e:	3b02      	subs	r3, #2
 8000420:	443c      	add	r4, r7
 8000422:	ea43 400e 	orr.w	r0, r3, lr, lsl #16
 8000426:	fba0 9302 	umull	r9, r3, r0, r2
 800042a:	eba4 040c 	sub.w	r4, r4, ip
 800042e:	429c      	cmp	r4, r3
 8000430:	46ce      	mov	lr, r9
 8000432:	469c      	mov	ip, r3
 8000434:	d351      	bcc.n	80004da <__udivmoddi4+0x28a>
 8000436:	d04e      	beq.n	80004d6 <__udivmoddi4+0x286>
 8000438:	b155      	cbz	r5, 8000450 <__udivmoddi4+0x200>
 800043a:	ebb8 030e 	subs.w	r3, r8, lr
 800043e:	eb64 040c 	sbc.w	r4, r4, ip
 8000442:	fa04 f606 	lsl.w	r6, r4, r6
 8000446:	40cb      	lsrs	r3, r1
 8000448:	431e      	orrs	r6, r3
 800044a:	40cc      	lsrs	r4, r1
 800044c:	e9c5 6400 	strd	r6, r4, [r5]
 8000450:	2100      	movs	r1, #0
 8000452:	e750      	b.n	80002f6 <__udivmoddi4+0xa6>
 8000454:	f1c2 0320 	rsb	r3, r2, #32
 8000458:	fa20 f103 	lsr.w	r1, r0, r3
 800045c:	fa0c fc02 	lsl.w	ip, ip, r2
 8000460:	fa24 f303 	lsr.w	r3, r4, r3
 8000464:	4094      	lsls	r4, r2
 8000466:	430c      	orrs	r4, r1
 8000468:	ea4f 481c 	mov.w	r8, ip, lsr #16
 800046c:	fa00 fe02 	lsl.w	lr, r0, r2
 8000470:	fa1f f78c 	uxth.w	r7, ip
 8000474:	fbb3 f0f8 	udiv	r0, r3, r8
 8000478:	fb08 3110 	mls	r1, r8, r0, r3
 800047c:	0c23      	lsrs	r3, r4, #16
 800047e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000482:	fb00 f107 	mul.w	r1, r0, r7
 8000486:	4299      	cmp	r1, r3
 8000488:	d908      	bls.n	800049c <__udivmoddi4+0x24c>
 800048a:	eb1c 0303 	adds.w	r3, ip, r3
 800048e:	f100 36ff 	add.w	r6, r0, #4294967295
 8000492:	d22c      	bcs.n	80004ee <__udivmoddi4+0x29e>
 8000494:	4299      	cmp	r1, r3
 8000496:	d92a      	bls.n	80004ee <__udivmoddi4+0x29e>
 8000498:	3802      	subs	r0, #2
 800049a:	4463      	add	r3, ip
 800049c:	1a5b      	subs	r3, r3, r1
 800049e:	b2a4      	uxth	r4, r4
 80004a0:	fbb3 f1f8 	udiv	r1, r3, r8
 80004a4:	fb08 3311 	mls	r3, r8, r1, r3
 80004a8:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 80004ac:	fb01 f307 	mul.w	r3, r1, r7
 80004b0:	42a3      	cmp	r3, r4
 80004b2:	d908      	bls.n	80004c6 <__udivmoddi4+0x276>
 80004b4:	eb1c 0404 	adds.w	r4, ip, r4
 80004b8:	f101 36ff 	add.w	r6, r1, #4294967295
 80004bc:	d213      	bcs.n	80004e6 <__udivmoddi4+0x296>
 80004be:	42a3      	cmp	r3, r4
 80004c0:	d911      	bls.n	80004e6 <__udivmoddi4+0x296>
 80004c2:	3902      	subs	r1, #2
 80004c4:	4464      	add	r4, ip
 80004c6:	1ae4      	subs	r4, r4, r3
 80004c8:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 80004cc:	e739      	b.n	8000342 <__udivmoddi4+0xf2>
 80004ce:	4604      	mov	r4, r0
 80004d0:	e6f0      	b.n	80002b4 <__udivmoddi4+0x64>
 80004d2:	4608      	mov	r0, r1
 80004d4:	e706      	b.n	80002e4 <__udivmoddi4+0x94>
 80004d6:	45c8      	cmp	r8, r9
 80004d8:	d2ae      	bcs.n	8000438 <__udivmoddi4+0x1e8>
 80004da:	ebb9 0e02 	subs.w	lr, r9, r2
 80004de:	eb63 0c07 	sbc.w	ip, r3, r7
 80004e2:	3801      	subs	r0, #1
 80004e4:	e7a8      	b.n	8000438 <__udivmoddi4+0x1e8>
 80004e6:	4631      	mov	r1, r6
 80004e8:	e7ed      	b.n	80004c6 <__udivmoddi4+0x276>
 80004ea:	4603      	mov	r3, r0
 80004ec:	e799      	b.n	8000422 <__udivmoddi4+0x1d2>
 80004ee:	4630      	mov	r0, r6
 80004f0:	e7d4      	b.n	800049c <__udivmoddi4+0x24c>
 80004f2:	46d6      	mov	lr, sl
 80004f4:	e77f      	b.n	80003f6 <__udivmoddi4+0x1a6>
 80004f6:	4463      	add	r3, ip
 80004f8:	3802      	subs	r0, #2
 80004fa:	e74d      	b.n	8000398 <__udivmoddi4+0x148>
 80004fc:	4606      	mov	r6, r0
 80004fe:	4623      	mov	r3, r4
 8000500:	4608      	mov	r0, r1
 8000502:	e70f      	b.n	8000324 <__udivmoddi4+0xd4>
 8000504:	3e02      	subs	r6, #2
 8000506:	4463      	add	r3, ip
 8000508:	e730      	b.n	800036c <__udivmoddi4+0x11c>
 800050a:	bf00      	nop

0800050c <__aeabi_idiv0>:
 800050c:	4770      	bx	lr
 800050e:	bf00      	nop

08000510 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8000510:	480d      	ldr	r0, [pc, #52]	@ (8000548 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8000512:	4685      	mov	sp, r0
  
/* Call the clock system initialization function.*/
    bl  SystemInit
 8000514:	f003 fe8c 	bl	8004230 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8000518:	480c      	ldr	r0, [pc, #48]	@ (800054c <LoopForever+0x6>)
  ldr r1, =_edata
 800051a:	490d      	ldr	r1, [pc, #52]	@ (8000550 <LoopForever+0xa>)
  ldr r2, =_sidata
 800051c:	4a0d      	ldr	r2, [pc, #52]	@ (8000554 <LoopForever+0xe>)
  movs r3, #0
 800051e:	2300      	movs	r3, #0
  b	LoopCopyDataInit
 8000520:	e002      	b.n	8000528 <LoopCopyDataInit>

08000522 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8000522:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8000524:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8000526:	3304      	adds	r3, #4

08000528 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8000528:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 800052a:	428c      	cmp	r4, r1
  bcc CopyDataInit
 800052c:	d3f9      	bcc.n	8000522 <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 800052e:	4a0a      	ldr	r2, [pc, #40]	@ (8000558 <LoopForever+0x12>)
  ldr r4, =_ebss
 8000530:	4c0a      	ldr	r4, [pc, #40]	@ (800055c <LoopForever+0x16>)
  movs r3, #0
 8000532:	2300      	movs	r3, #0
  b LoopFillZerobss
 8000534:	e001      	b.n	800053a <LoopFillZerobss>

08000536 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8000536:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8000538:	3204      	adds	r2, #4

0800053a <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 800053a:	42a2      	cmp	r2, r4
  bcc FillZerobss
 800053c:	d3fb      	bcc.n	8000536 <FillZerobss>
/* Call static constructors */
    bl __libc_init_array
 800053e:	f009 feb7 	bl	800a2b0 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 8000542:	f000 fba9 	bl	8000c98 <main>

08000546 <LoopForever>:

LoopForever:
    b LoopForever
 8000546:	e7fe      	b.n	8000546 <LoopForever>
  ldr   r0, =_estack
 8000548:	20008000 	.word	0x20008000
  ldr r0, =_sdata
 800054c:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8000550:	20000484 	.word	0x20000484
  ldr r2, =_sidata
 8000554:	0800a6f4 	.word	0x0800a6f4
  ldr r2, =_sbss
 8000558:	20000484 	.word	0x20000484
  ldr r4, =_ebss
 800055c:	20002728 	.word	0x20002728

08000560 <BusFault_Handler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 8000560:	e7fe      	b.n	8000560 <BusFault_Handler>
	...

08000564 <ASPEP_start>:
  * @brief  Starts ASPEP communication by configuring UART.
  *
  * @param  *pHandle Handler of the current instance of the ASPEP component
  */
void ASPEP_start(ASPEP_Handle_t *pHandle)
{
 8000564:	b570      	push	{r4, r5, r6, lr}
 8000566:	4604      	mov	r4, r0
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->fASPEP_HWInit(pHandle->ASPEPIp);
 8000568:	6940      	ldr	r0, [r0, #20]
 800056a:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
 800056c:	4798      	blx	r3
    pHandle->ASPEP_State = ASPEP_IDLE;
 800056e:	2300      	movs	r3, #0
    pHandle->ASPEP_TL_State = WAITING_PACKET;
    pHandle->syncPacketCount = 0; /* Sync packet counter is reset only at startup*/
    /* Configure UART to receive first packet*/
    pHandle->fASPEP_cfg_recept(pHandle->ASPEPIp, pHandle->rxHeader, ASPEP_HEADER_SIZE);
 8000570:	6d65      	ldr	r5, [r4, #84]	@ 0x54
    pHandle->ASPEP_State = ASPEP_IDLE;
 8000572:	f8a4 3064 	strh.w	r3, [r4, #100]	@ 0x64
    pHandle->syncPacketCount = 0; /* Sync packet counter is reset only at startup*/
 8000576:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
    pHandle->fASPEP_cfg_recept(pHandle->ASPEPIp, pHandle->rxHeader, ASPEP_HEADER_SIZE);
 800057a:	6960      	ldr	r0, [r4, #20]
 800057c:	f104 011c 	add.w	r1, r4, #28
 8000580:	462b      	mov	r3, r5
 8000582:	2204      	movs	r2, #4
#ifdef NULL_PTR_CHECK_ASP
  }
#endif
}
 8000584:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    pHandle->fASPEP_cfg_recept(pHandle->ASPEPIp, pHandle->rxHeader, ASPEP_HEADER_SIZE);
 8000588:	4718      	bx	r3
 800058a:	bf00      	nop

0800058c <ASPEP_sendBeacon>:
  *
  * @param  *pHandle Handler of the current instance of the ASPEP component
  * @param  *capabilities Matched capabilities between controller and performer
  */
void ASPEP_sendBeacon(ASPEP_Handle_t *pHandle, ASPEP_Capabilities_def *capabilities)
{
 800058c:	b410      	push	{r4}
  {
#endif
    uint32_t *packet = (uint32_t *)pHandle->ctrlBuffer.buffer; //cstat !MISRAC2012-Rule-11.3
    *packet = (BEACON
             | (((uint32_t)capabilities->version) << 4U)
             | (((uint32_t)capabilities->DATA_CRC) << 7U)
 800058e:	780b      	ldrb	r3, [r1, #0]
             | (((uint32_t)capabilities->version) << 4U)
 8000590:	790a      	ldrb	r2, [r1, #4]
             | (((uint32_t)capabilities->RX_maxSize) << 8U)
             | (((uint32_t)capabilities->TXS_maxSize) << 14U)
 8000592:	f891 c002 	ldrb.w	ip, [r1, #2]
  crc = CRC4_Lookup8[crc ^ (uint8_t)(header         & 0xffU)];
 8000596:	4c1e      	ldr	r4, [pc, #120]	@ (8000610 <ASPEP_sendBeacon+0x84>)
             | (((uint32_t)capabilities->DATA_CRC) << 7U)
 8000598:	01db      	lsls	r3, r3, #7
 800059a:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
             | (((uint32_t)capabilities->RX_maxSize) << 8U)
 800059e:	784a      	ldrb	r2, [r1, #1]
 80005a0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
             | (((uint32_t)capabilities->TXA_maxSize) << 21U));
 80005a4:	78ca      	ldrb	r2, [r1, #3]
             | (((uint32_t)capabilities->TXS_maxSize) << 14U)
 80005a6:	ea43 338c 	orr.w	r3, r3, ip, lsl #14
             | (((uint32_t)capabilities->TXA_maxSize) << 21U));
 80005aa:	ea43 5342 	orr.w	r3, r3, r2, lsl #21
  crc = CRC4_Lookup8[crc ^ (uint8_t)(header         & 0xffU)];
 80005ae:	b2da      	uxtb	r2, r3
 80005b0:	f042 0205 	orr.w	r2, r2, #5
  header &= 0x0fffffffU;
 80005b4:	f023 4170 	bic.w	r1, r3, #4026531840	@ 0xf0000000
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 80005b8:	5ca2      	ldrb	r2, [r4, r2]
 80005ba:	ea82 2211 	eor.w	r2, r2, r1, lsr #8
 80005be:	b2d2      	uxtb	r2, r2
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 80005c0:	5ca2      	ldrb	r2, [r4, r2]
 80005c2:	ea82 4211 	eor.w	r2, r2, r1, lsr #16
 80005c6:	b2d2      	uxtb	r2, r2
  crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 80005c8:	5ca2      	ldrb	r2, [r4, r2]
 80005ca:	4c12      	ldr	r4, [pc, #72]	@ (8000614 <ASPEP_sendBeacon+0x88>)
 80005cc:	ea82 6211 	eor.w	r2, r2, r1, lsr #24
  *headerPtr |= (uint32_t)crc << 28;
 80005d0:	5ca2      	ldrb	r2, [r4, r2]
 80005d2:	ea43 7302 	orr.w	r3, r3, r2, lsl #28
 80005d6:	f043 0305 	orr.w	r3, r3, #5
 80005da:	6203      	str	r3, [r0, #32]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80005dc:	b672      	cpsid	i
  {
#endif
    /* Insert CRC header in the packet to send */
    ASPEP_ComputeHeaderCRC((uint32_t *)txBuffer); //cstat !MISRAC2012-Rule-11.5
    __disable_irq(); /*TODO: Disable High frequency task is enough */
    if (NULL == pHandle->lockBuffer) /* Communication Ip free to send data*/
 80005de:	6c83      	ldr	r3, [r0, #72]	@ 0x48
 80005e0:	b14b      	cbz	r3, 80005f6 <ASPEP_sendBeacon+0x6a>
  __ASM volatile ("cpsie i" : : : "memory");
 80005e2:	b662      	cpsie	i
          pHandle->syncBuffer.length = bufferLength;
        }
      }
      else if(ASPEP_CTRL == dataType)
      {
        if (pHandle->ctrlBuffer.state != available)
 80005e4:	f890 3024 	ldrb.w	r3, [r0, #36]	@ 0x24
 80005e8:	b913      	cbnz	r3, 80005f0 <ASPEP_sendBeacon+0x64>
        {
          result = ASPEP_BUFFER_ERROR;
        }
        else
        {
          pHandle->ctrlBuffer.state = pending;
 80005ea:	2302      	movs	r3, #2
 80005ec:	f880 3024 	strb.w	r3, [r0, #36]	@ 0x24
}
 80005f0:	f85d 4b04 	ldr.w	r4, [sp], #4
 80005f4:	4770      	bx	lr
    (void)ASPEP_TXframeProcess(pHandle, ASPEP_CTRL, &pHandle->ctrlBuffer, ASPEP_CTRL_SIZE);
 80005f6:	f100 0120 	add.w	r1, r0, #32
        pHandle->ctrlBuffer.state = readLock;
 80005fa:	2303      	movs	r3, #3
 80005fc:	f880 3024 	strb.w	r3, [r0, #36]	@ 0x24
        pHandle->lockBuffer = (void *)&pHandle->ctrlBuffer;
 8000600:	6481      	str	r1, [r0, #72]	@ 0x48
 8000602:	b662      	cpsie	i
      pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, txBuffer, bufferLength);
 8000604:	2204      	movs	r2, #4
 8000606:	6d83      	ldr	r3, [r0, #88]	@ 0x58
}
 8000608:	f85d 4b04 	ldr.w	r4, [sp], #4
      pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, txBuffer, bufferLength);
 800060c:	6940      	ldr	r0, [r0, #20]
 800060e:	4718      	bx	r3
 8000610:	0800a364 	.word	0x0800a364
 8000614:	0800a354 	.word	0x0800a354

08000618 <ASPEP_sendPing>:
{
 8000618:	b430      	push	{r4, r5}
                   | (uint32_t)((uint32_t)cBit << 5U)
 800061a:	014b      	lsls	r3, r1, #5
    uint8_t Nbit = pHandle->syncPacketCount & 0x1U; /* Keep only LSB */
 800061c:	f890 c060 	ldrb.w	ip, [r0, #96]	@ 0x60
    uint8_t ipID = pHandle->liid & 0xFU;
 8000620:	f890 4063 	ldrb.w	r4, [r0, #99]	@ 0x63
  crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 8000624:	4d1d      	ldr	r5, [pc, #116]	@ (800069c <ASPEP_sendPing+0x84>)
                   | (uint32_t)((uint32_t)cBit << 5U)
 8000626:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
                   | (uint32_t)(((uint32_t) packetNumber) << 12U);
 800062a:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
                   | (uint32_t)((uint32_t)Nbit << 6U)
 800062e:	f00c 0101 	and.w	r1, ip, #1
                   | (uint32_t)(((uint32_t) packetNumber) << 12U);
 8000632:	ea43 1381 	orr.w	r3, r3, r1, lsl #6
 8000636:	ea43 13c1 	orr.w	r3, r3, r1, lsl #7
                   | (uint32_t)((uint32_t)ipID << 8U)
 800063a:	f004 040f 	and.w	r4, r4, #15
                   | (uint32_t)(((uint32_t) packetNumber) << 12U);
 800063e:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
  crc = CRC4_Lookup8[crc ^ (uint8_t)(header         & 0xffU)];
 8000642:	b2da      	uxtb	r2, r3
 8000644:	4c16      	ldr	r4, [pc, #88]	@ (80006a0 <ASPEP_sendPing+0x88>)
 8000646:	f042 0206 	orr.w	r2, r2, #6
                   | (uint32_t)(((uint32_t) packetNumber) << 12U);
 800064a:	f043 0106 	orr.w	r1, r3, #6
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 800064e:	5ca2      	ldrb	r2, [r4, r2]
 8000650:	ea82 2213 	eor.w	r2, r2, r3, lsr #8
 8000654:	b2d2      	uxtb	r2, r2
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 8000656:	5ca2      	ldrb	r2, [r4, r2]
 8000658:	ea82 4213 	eor.w	r2, r2, r3, lsr #16
 800065c:	b2d2      	uxtb	r2, r2
  crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 800065e:	5ca2      	ldrb	r2, [r4, r2]
 8000660:	ea82 6313 	eor.w	r3, r2, r3, lsr #24
  *headerPtr |= (uint32_t)crc << 28;
 8000664:	5ceb      	ldrb	r3, [r5, r3]
 8000666:	ea41 7303 	orr.w	r3, r1, r3, lsl #28
 800066a:	6203      	str	r3, [r0, #32]
  __ASM volatile ("cpsid i" : : : "memory");
 800066c:	b672      	cpsid	i
    if (NULL == pHandle->lockBuffer) /* Communication Ip free to send data*/
 800066e:	6c83      	ldr	r3, [r0, #72]	@ 0x48
 8000670:	b143      	cbz	r3, 8000684 <ASPEP_sendPing+0x6c>
  __ASM volatile ("cpsie i" : : : "memory");
 8000672:	b662      	cpsie	i
        if (pHandle->ctrlBuffer.state != available)
 8000674:	f890 3024 	ldrb.w	r3, [r0, #36]	@ 0x24
 8000678:	b913      	cbnz	r3, 8000680 <ASPEP_sendPing+0x68>
          pHandle->ctrlBuffer.state = pending;
 800067a:	2302      	movs	r3, #2
 800067c:	f880 3024 	strb.w	r3, [r0, #36]	@ 0x24
}
 8000680:	bc30      	pop	{r4, r5}
 8000682:	4770      	bx	lr
    (void)ASPEP_TXframeProcess(pHandle, ASPEP_CTRL, &pHandle->ctrlBuffer, ASPEP_CTRL_SIZE);
 8000684:	f100 0120 	add.w	r1, r0, #32
        pHandle->ctrlBuffer.state = readLock;
 8000688:	2303      	movs	r3, #3
 800068a:	f880 3024 	strb.w	r3, [r0, #36]	@ 0x24
        pHandle->lockBuffer = (void *)&pHandle->ctrlBuffer;
 800068e:	6481      	str	r1, [r0, #72]	@ 0x48
 8000690:	b662      	cpsie	i
      pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, txBuffer, bufferLength);
 8000692:	2204      	movs	r2, #4
 8000694:	6d83      	ldr	r3, [r0, #88]	@ 0x58
 8000696:	6940      	ldr	r0, [r0, #20]
}
 8000698:	bc30      	pop	{r4, r5}
      pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, txBuffer, bufferLength);
 800069a:	4718      	bx	r3
 800069c:	0800a354 	.word	0x0800a354
 80006a0:	0800a364 	.word	0x0800a364

080006a4 <ASPEP_getBuffer>:
    if (MCTL_SYNC == syncAsync)
 80006a4:	2a0a      	cmp	r2, #10
 80006a6:	d009      	beq.n	80006bc <ASPEP_getBuffer+0x18>
      if ((pHandle->asyncBufferA.state > writeLock) && (pHandle->asyncBufferB.state > writeLock))
 80006a8:	f890 3036 	ldrb.w	r3, [r0, #54]	@ 0x36
 80006ac:	2b01      	cmp	r3, #1
 80006ae:	d91d      	bls.n	80006ec <ASPEP_getBuffer+0x48>
 80006b0:	f890 303e 	ldrb.w	r3, [r0, #62]	@ 0x3e
 80006b4:	2b01      	cmp	r3, #1
 80006b6:	d90d      	bls.n	80006d4 <ASPEP_getBuffer+0x30>
        result = false;
 80006b8:	2000      	movs	r0, #0
}
 80006ba:	4770      	bx	lr
      if (pHandle->syncBuffer.state <= writeLock) /* Possible values are free or writeLock*/
 80006bc:	f890 302e 	ldrb.w	r3, [r0, #46]	@ 0x2e
 80006c0:	2b01      	cmp	r3, #1
 80006c2:	d8f9      	bhi.n	80006b8 <ASPEP_getBuffer+0x14>
        *buffer = &pHandle->syncBuffer.buffer[ASPEP_HEADER_SIZE];
 80006c4:	6a83      	ldr	r3, [r0, #40]	@ 0x28
        pHandle->syncBuffer.state = writeLock;
 80006c6:	2201      	movs	r2, #1
        *buffer = &pHandle->syncBuffer.buffer[ASPEP_HEADER_SIZE];
 80006c8:	3304      	adds	r3, #4
 80006ca:	600b      	str	r3, [r1, #0]
        pHandle->syncBuffer.state = writeLock;
 80006cc:	f880 202e 	strb.w	r2, [r0, #46]	@ 0x2e
  bool result = true;
 80006d0:	2001      	movs	r0, #1
 80006d2:	4770      	bx	lr
          *buffer = &pHandle->asyncBufferB.buffer[ASPEP_HEADER_SIZE];
 80006d4:	6b83      	ldr	r3, [r0, #56]	@ 0x38
          pHandle->asyncBufferB.state = writeLock;
 80006d6:	f04f 0c01 	mov.w	ip, #1
          pHandle->lastRequestedAsyncBuff = &pHandle->asyncBufferB;
 80006da:	f100 0238 	add.w	r2, r0, #56	@ 0x38
          *buffer = &pHandle->asyncBufferB.buffer[ASPEP_HEADER_SIZE];
 80006de:	3304      	adds	r3, #4
          pHandle->asyncBufferB.state = writeLock;
 80006e0:	f880 c03e 	strb.w	ip, [r0, #62]	@ 0x3e
          pHandle->lastRequestedAsyncBuff = &pHandle->asyncBufferB;
 80006e4:	6402      	str	r2, [r0, #64]	@ 0x40
          *buffer = &pHandle->asyncBufferB.buffer[ASPEP_HEADER_SIZE];
 80006e6:	600b      	str	r3, [r1, #0]
  bool result = true;
 80006e8:	2001      	movs	r0, #1
 80006ea:	4770      	bx	lr
          *buffer = &pHandle->asyncBufferA.buffer[ASPEP_HEADER_SIZE];
 80006ec:	6b03      	ldr	r3, [r0, #48]	@ 0x30
          pHandle->asyncBufferA.state = writeLock;
 80006ee:	f04f 0c01 	mov.w	ip, #1
          pHandle->lastRequestedAsyncBuff = &pHandle->asyncBufferA;
 80006f2:	f100 0230 	add.w	r2, r0, #48	@ 0x30
          *buffer = &pHandle->asyncBufferA.buffer[ASPEP_HEADER_SIZE];
 80006f6:	3304      	adds	r3, #4
          pHandle->asyncBufferA.state = writeLock;
 80006f8:	f880 c036 	strb.w	ip, [r0, #54]	@ 0x36
          pHandle->lastRequestedAsyncBuff = &pHandle->asyncBufferA;
 80006fc:	6402      	str	r2, [r0, #64]	@ 0x40
          *buffer = &pHandle->asyncBufferA.buffer[ASPEP_HEADER_SIZE];
 80006fe:	600b      	str	r3, [r1, #0]
 8000700:	e7f2      	b.n	80006e8 <ASPEP_getBuffer+0x44>
 8000702:	bf00      	nop

08000704 <ASPEP_sendPacket>:
{
 8000704:	4684      	mov	ip, r0
    if (ASPEP_CONNECTED == pHandle-> ASPEP_State)
 8000706:	f890 0064 	ldrb.w	r0, [r0, #100]	@ 0x64
 800070a:	2802      	cmp	r0, #2
 800070c:	d001      	beq.n	8000712 <ASPEP_sendPacket+0xe>
      result = ASPEP_NOT_CONNECTED;
 800070e:	2002      	movs	r0, #2
 8000710:	4770      	bx	lr
      tmpHeader = ((uint32_t)((uint32_t)txDataLengthTemp << (uint32_t)4) | (uint32_t)syncAsync);
 8000712:	ea43 1002 	orr.w	r0, r3, r2, lsl #4
      *header = tmpHeader;
 8000716:	f841 0c04 	str.w	r0, [r1, #-4]
      if (1U == pHandle->Capabilities.DATA_CRC)
 800071a:	f89c 006c 	ldrb.w	r0, [ip, #108]	@ 0x6c
 800071e:	2801      	cmp	r0, #1
 8000720:	d104      	bne.n	800072c <ASPEP_sendPacket+0x28>
        packet[txDataLengthTemp] = (uint8_t)0xCA; /* Dummy CRC */
 8000722:	f64f 60ca 	movw	r0, #65226	@ 0xfeca
 8000726:	5288      	strh	r0, [r1, r2]
        txDataLengthTemp += (uint16_t)ASPEP_DATACRC_SIZE;
 8000728:	3202      	adds	r2, #2
 800072a:	b292      	uxth	r2, r2
      if (MCTL_SYNC == syncAsync)
 800072c:	2b0a      	cmp	r3, #10
 800072e:	d105      	bne.n	800073c <ASPEP_sendPacket+0x38>
        if (pSupHandle->MCP_PacketAvailable)
 8000730:	f89c 0010 	ldrb.w	r0, [ip, #16]
 8000734:	b348      	cbz	r0, 800078a <ASPEP_sendPacket+0x86>
          pSupHandle->MCP_PacketAvailable = false; /* CMD from controller is processed*/
 8000736:	2000      	movs	r0, #0
 8000738:	f88c 0010 	strb.w	r0, [ip, #16]
  uint32_t header = *headerPtr;
 800073c:	f851 0c04 	ldr.w	r0, [r1, #-4]
{
 8000740:	b570      	push	{r4, r5, r6, lr}
  crc = CRC4_Lookup8[crc ^ (uint8_t)(header         & 0xffU)];
 8000742:	4d34      	ldr	r5, [pc, #208]	@ (8000814 <ASPEP_sendPacket+0x110>)
 8000744:	b2c4      	uxtb	r4, r0
        result = ASPEP_TXframeProcess(pHandle, syncAsync, header, txDataLengthTemp + (uint16_t)ASPEP_HEADER_SIZE);
 8000746:	3204      	adds	r2, #4
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 8000748:	5d2e      	ldrb	r6, [r5, r4]
 800074a:	f3c0 2407 	ubfx	r4, r0, #8, #8
 800074e:	4074      	eors	r4, r6
      header--; /* Header ues 4*8 bits on top of txBuffer*/
 8000750:	f1a1 0e04 	sub.w	lr, r1, #4
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 8000754:	5d2e      	ldrb	r6, [r5, r4]
 8000756:	f3c0 4407 	ubfx	r4, r0, #16, #8
 800075a:	4074      	eors	r4, r6
        result = ASPEP_TXframeProcess(pHandle, syncAsync, header, txDataLengthTemp + (uint16_t)ASPEP_HEADER_SIZE);
 800075c:	b292      	uxth	r2, r2
  crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 800075e:	5d2c      	ldrb	r4, [r5, r4]
 8000760:	f3c0 6503 	ubfx	r5, r0, #24, #4
 8000764:	406c      	eors	r4, r5
 8000766:	4d2c      	ldr	r5, [pc, #176]	@ (8000818 <ASPEP_sendPacket+0x114>)
  *headerPtr |= (uint32_t)crc << 28;
 8000768:	5d2c      	ldrb	r4, [r5, r4]
 800076a:	ea40 7004 	orr.w	r0, r0, r4, lsl #28
 800076e:	f841 0c04 	str.w	r0, [r1, #-4]
  __ASM volatile ("cpsid i" : : : "memory");
 8000772:	b672      	cpsid	i
    if (NULL == pHandle->lockBuffer) /* Communication Ip free to send data*/
 8000774:	f8dc 1048 	ldr.w	r1, [ip, #72]	@ 0x48
 8000778:	b1b9      	cbz	r1, 80007aa <ASPEP_sendPacket+0xa6>
  __ASM volatile ("cpsie i" : : : "memory");
 800077a:	b662      	cpsie	i
      if (MCTL_ASYNC == dataType)
 800077c:	2b09      	cmp	r3, #9
 800077e:	d006      	beq.n	800078e <ASPEP_sendPacket+0x8a>
      else if (MCTL_SYNC == dataType)
 8000780:	2b0a      	cmp	r3, #10
 8000782:	d02a      	beq.n	80007da <ASPEP_sendPacket+0xd6>
      else if(ASPEP_CTRL == dataType)
 8000784:	b37b      	cbz	r3, 80007e6 <ASPEP_sendPacket+0xe2>
  uint8_t result = ASPEP_OK;
 8000786:	2000      	movs	r0, #0
}
 8000788:	bd70      	pop	{r4, r5, r6, pc}
          result = MCTL_SYNC_NOT_EXPECTED;
 800078a:	2001      	movs	r0, #1
}
 800078c:	4770      	bx	lr
        if (txBuffer != (uint8_t *)pHandle->lastRequestedAsyncBuff->buffer)
 800078e:	f8dc 3040 	ldr.w	r3, [ip, #64]	@ 0x40
 8000792:	6819      	ldr	r1, [r3, #0]
  uint8_t result = ASPEP_OK;
 8000794:	458e      	cmp	lr, r1
 8000796:	bf14      	ite	ne
 8000798:	2003      	movne	r0, #3
 800079a:	2000      	moveq	r0, #0
        if (NULL == pHandle->asyncNextBuffer)
 800079c:	f8dc 1044 	ldr.w	r1, [ip, #68]	@ 0x44
 80007a0:	b3a1      	cbz	r1, 800080c <ASPEP_sendPacket+0x108>
        pHandle->lastRequestedAsyncBuff->state = pending;
 80007a2:	2102      	movs	r1, #2
 80007a4:	7199      	strb	r1, [r3, #6]
        pHandle->lastRequestedAsyncBuff->length = bufferLength;
 80007a6:	809a      	strh	r2, [r3, #4]
}
 80007a8:	bd70      	pop	{r4, r5, r6, pc}
      if (MCTL_ASYNC == dataType)
 80007aa:	2b09      	cmp	r3, #9
 80007ac:	d029      	beq.n	8000802 <ASPEP_sendPacket+0xfe>
      else if (MCTL_SYNC == dataType)
 80007ae:	2b0a      	cmp	r3, #10
        pHandle->syncBuffer.state = readLock;
 80007b0:	f04f 0303 	mov.w	r3, #3
 80007b4:	bf0b      	itete	eq
 80007b6:	f88c 302e 	strbeq.w	r3, [ip, #46]	@ 0x2e
        pHandle->ctrlBuffer.state = readLock;
 80007ba:	f88c 3024 	strbne.w	r3, [ip, #36]	@ 0x24
        pHandle->lockBuffer = (void *)&pHandle->syncBuffer;
 80007be:	f10c 0328 	addeq.w	r3, ip, #40	@ 0x28
        pHandle->lockBuffer = (void *)&pHandle->ctrlBuffer;
 80007c2:	f10c 0320 	addne.w	r3, ip, #32
        pHandle->lockBuffer = (void *)pHandle->lastRequestedAsyncBuff;
 80007c6:	f8cc 3048 	str.w	r3, [ip, #72]	@ 0x48
 80007ca:	b662      	cpsie	i
      pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, txBuffer, bufferLength);
 80007cc:	f8dc 3058 	ldr.w	r3, [ip, #88]	@ 0x58
 80007d0:	f8dc 0014 	ldr.w	r0, [ip, #20]
 80007d4:	4671      	mov	r1, lr
 80007d6:	4798      	blx	r3
 80007d8:	e7d5      	b.n	8000786 <ASPEP_sendPacket+0x82>
        if (pHandle -> syncBuffer.state != writeLock)
 80007da:	f89c 302e 	ldrb.w	r3, [ip, #46]	@ 0x2e
 80007de:	2b01      	cmp	r3, #1
 80007e0:	d009      	beq.n	80007f6 <ASPEP_sendPacket+0xf2>
          result = ASPEP_BUFFER_ERROR;
 80007e2:	2003      	movs	r0, #3
}
 80007e4:	bd70      	pop	{r4, r5, r6, pc}
        if (pHandle->ctrlBuffer.state != available)
 80007e6:	f89c 3024 	ldrb.w	r3, [ip, #36]	@ 0x24
 80007ea:	2b00      	cmp	r3, #0
 80007ec:	d1f9      	bne.n	80007e2 <ASPEP_sendPacket+0xde>
          pHandle->ctrlBuffer.state = pending;
 80007ee:	2302      	movs	r3, #2
 80007f0:	f88c 3024 	strb.w	r3, [ip, #36]	@ 0x24
 80007f4:	e7c7      	b.n	8000786 <ASPEP_sendPacket+0x82>
          pHandle->syncBuffer.state = pending;
 80007f6:	2302      	movs	r3, #2
 80007f8:	f88c 302e 	strb.w	r3, [ip, #46]	@ 0x2e
          pHandle->syncBuffer.length = bufferLength;
 80007fc:	f8ac 202c 	strh.w	r2, [ip, #44]	@ 0x2c
 8000800:	e7c1      	b.n	8000786 <ASPEP_sendPacket+0x82>
        pHandle->lastRequestedAsyncBuff->state = readLock;
 8000802:	f8dc 3040 	ldr.w	r3, [ip, #64]	@ 0x40
 8000806:	2103      	movs	r1, #3
 8000808:	7199      	strb	r1, [r3, #6]
        pHandle->lockBuffer = (void *)pHandle->lastRequestedAsyncBuff;
 800080a:	e7dc      	b.n	80007c6 <ASPEP_sendPacket+0xc2>
          pHandle->asyncNextBuffer = pHandle->lastRequestedAsyncBuff;
 800080c:	f8cc 3044 	str.w	r3, [ip, #68]	@ 0x44
 8000810:	e7c7      	b.n	80007a2 <ASPEP_sendPacket+0x9e>
 8000812:	bf00      	nop
 8000814:	0800a364 	.word	0x0800a364
 8000818:	0800a354 	.word	0x0800a354

0800081c <ASPEP_HWDataTransmittedIT>:
  * Therefore, there is no need to protect this ISR against another higher priority ISR (HF Task).
  *
  * @param  *pHandle Handler of the current instance of the ASPEP component
  */
void ASPEP_HWDataTransmittedIT(ASPEP_Handle_t *pHandle)
{
 800081c:	b510      	push	{r4, lr}
  }
  else
  {
#endif
    /* First free previous readLock buffer */
    if (pHandle->ctrlBuffer.state == readLock)
 800081e:	f890 3024 	ldrb.w	r3, [r0, #36]	@ 0x24
 8000822:	2b03      	cmp	r3, #3
{
 8000824:	4604      	mov	r4, r0
    if (pHandle->ctrlBuffer.state == readLock)
 8000826:	d013      	beq.n	8000850 <ASPEP_HWDataTransmittedIT+0x34>
      pHandle->ctrlBuffer.state = available;
    }
    else /* if previous buffer was not ASPEP_CTRL, then the buffer locked is a MCTL_Buff_t */
    {
      MCTL_Buff_t *tempBuff = (MCTL_Buff_t *)pHandle->lockBuffer; //cstat !MISRAC2012-Rule-11.5
      tempBuff->state = available;
 8000828:	6c82      	ldr	r2, [r0, #72]	@ 0x48
 800082a:	2100      	movs	r1, #0
 800082c:	7191      	strb	r1, [r2, #6]
    }
    if (pHandle->syncBuffer.state == pending)
 800082e:	f890 202e 	ldrb.w	r2, [r0, #46]	@ 0x2e
 8000832:	2a02      	cmp	r2, #2
 8000834:	d013      	beq.n	800085e <ASPEP_HWDataTransmittedIT+0x42>
      pHandle->lockBuffer = (void *)&pHandle->syncBuffer;
      pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, pHandle->syncBuffer.buffer, pHandle->syncBuffer.length);
      pHandle->syncBuffer.state = readLock;
    }
    /* Second prepare transfer of pending buffer */
    else if (pHandle->ctrlBuffer.state == pending)
 8000836:	2b02      	cmp	r3, #2
 8000838:	d11d      	bne.n	8000876 <ASPEP_HWDataTransmittedIT+0x5a>
    {
      pHandle->lockBuffer = (void *)(&pHandle ->ctrlBuffer);
 800083a:	f100 0120 	add.w	r1, r0, #32
      pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, pHandle->ctrlBuffer.buffer, ASPEP_CTRL_SIZE);
 800083e:	6d83      	ldr	r3, [r0, #88]	@ 0x58
      pHandle->lockBuffer = (void *)(&pHandle ->ctrlBuffer);
 8000840:	6481      	str	r1, [r0, #72]	@ 0x48
      pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, pHandle->ctrlBuffer.buffer, ASPEP_CTRL_SIZE);
 8000842:	2204      	movs	r2, #4
 8000844:	6940      	ldr	r0, [r0, #20]
 8000846:	4798      	blx	r3
      pHandle->ctrlBuffer.state = readLock;
 8000848:	2303      	movs	r3, #3
 800084a:	f884 3024 	strb.w	r3, [r4, #36]	@ 0x24
      __enable_irq();
    }
#ifdef NULL_PTR_CHECK_ASP
  }
#endif
}
 800084e:	bd10      	pop	{r4, pc}
    if (pHandle->syncBuffer.state == pending)
 8000850:	f890 302e 	ldrb.w	r3, [r0, #46]	@ 0x2e
      pHandle->ctrlBuffer.state = available;
 8000854:	2200      	movs	r2, #0
    if (pHandle->syncBuffer.state == pending)
 8000856:	2b02      	cmp	r3, #2
      pHandle->ctrlBuffer.state = available;
 8000858:	f880 2024 	strb.w	r2, [r0, #36]	@ 0x24
    if (pHandle->syncBuffer.state == pending)
 800085c:	d10b      	bne.n	8000876 <ASPEP_HWDataTransmittedIT+0x5a>
      pHandle->lockBuffer = (void *)&pHandle->syncBuffer;
 800085e:	f104 0028 	add.w	r0, r4, #40	@ 0x28
      pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, pHandle->syncBuffer.buffer, pHandle->syncBuffer.length);
 8000862:	6da3      	ldr	r3, [r4, #88]	@ 0x58
      pHandle->lockBuffer = (void *)&pHandle->syncBuffer;
 8000864:	64a0      	str	r0, [r4, #72]	@ 0x48
      pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, pHandle->syncBuffer.buffer, pHandle->syncBuffer.length);
 8000866:	8da2      	ldrh	r2, [r4, #44]	@ 0x2c
 8000868:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 800086a:	6960      	ldr	r0, [r4, #20]
 800086c:	4798      	blx	r3
      pHandle->syncBuffer.state = readLock;
 800086e:	2303      	movs	r3, #3
 8000870:	f884 302e 	strb.w	r3, [r4, #46]	@ 0x2e
}
 8000874:	bd10      	pop	{r4, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 8000876:	b672      	cpsid	i
      if (pHandle->asyncNextBuffer != NULL)
 8000878:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 800087a:	b1cb      	cbz	r3, 80008b0 <ASPEP_HWDataTransmittedIT+0x94>
        pHandle->asyncNextBuffer->state = readLock;
 800087c:	2203      	movs	r2, #3
        pHandle->lockBuffer = (void *)pHandle->asyncNextBuffer;
 800087e:	64a3      	str	r3, [r4, #72]	@ 0x48
        pHandle->asyncNextBuffer->state = readLock;
 8000880:	719a      	strb	r2, [r3, #6]
        pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, pHandle->asyncNextBuffer->buffer, pHandle->asyncNextBuffer->length);
 8000882:	6819      	ldr	r1, [r3, #0]
 8000884:	889a      	ldrh	r2, [r3, #4]
 8000886:	6960      	ldr	r0, [r4, #20]
 8000888:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 800088a:	4798      	blx	r3
        if ((pHandle->asyncBufferA.state == pending) || (pHandle->asyncBufferB.state == pending))
 800088c:	f894 3036 	ldrb.w	r3, [r4, #54]	@ 0x36
 8000890:	2b02      	cmp	r3, #2
 8000892:	d007      	beq.n	80008a4 <ASPEP_HWDataTransmittedIT+0x88>
 8000894:	f894 303e 	ldrb.w	r3, [r4, #62]	@ 0x3e
 8000898:	2b02      	cmp	r3, #2
 800089a:	d003      	beq.n	80008a4 <ASPEP_HWDataTransmittedIT+0x88>
          pHandle->asyncNextBuffer = NULL;
 800089c:	2300      	movs	r3, #0
 800089e:	6463      	str	r3, [r4, #68]	@ 0x44
  __ASM volatile ("cpsie i" : : : "memory");
 80008a0:	b662      	cpsie	i
}
 80008a2:	bd10      	pop	{r4, pc}
          uint32_t temp = (uint32_t)&pHandle->asyncBufferA + (uint32_t)&pHandle->asyncBufferB
 80008a4:	6c62      	ldr	r2, [r4, #68]	@ 0x44
 80008a6:	0063      	lsls	r3, r4, #1
 80008a8:	3368      	adds	r3, #104	@ 0x68
 80008aa:	1a9b      	subs	r3, r3, r2
          pHandle->asyncNextBuffer = (MCTL_Buff_t *) temp; //cstat !MISRAC2012-Rule-11.4
 80008ac:	6463      	str	r3, [r4, #68]	@ 0x44
        {
 80008ae:	e7f7      	b.n	80008a0 <ASPEP_HWDataTransmittedIT+0x84>
        pHandle->lockBuffer = NULL;
 80008b0:	64a3      	str	r3, [r4, #72]	@ 0x48
 80008b2:	e7f5      	b.n	80008a0 <ASPEP_HWDataTransmittedIT+0x84>

080008b4 <ASPEP_RXframeProcess>:
    uint16_t packetNumber;
#if VALID_CRC_DATA
    bool validCRCData = true;
#endif
    *packetLength = 0;
    if (pHandle->NewPacketAvailable)
 80008b4:	f890 3061 	ldrb.w	r3, [r0, #97]	@ 0x61
    uint32_t packetHeader = *((uint32_t *)pHandle->rxHeader); //cstat !MISRAC2012-Rule-11.3
 80008b8:	69c2      	ldr	r2, [r0, #28]
    *packetLength = 0;
 80008ba:	f04f 0c00 	mov.w	ip, #0
{
 80008be:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80008c2:	4604      	mov	r4, r0
    *packetLength = 0;
 80008c4:	f8a1 c000 	strh.w	ip, [r1]
    if (pHandle->NewPacketAvailable)
 80008c8:	b1cb      	cbz	r3, 80008fe <ASPEP_RXframeProcess+0x4a>
    {
      pHandle->NewPacketAvailable = false; /* Consumes new packet*/
      switch (pHandle->ASPEP_State)
 80008ca:	f890 3064 	ldrb.w	r3, [r0, #100]	@ 0x64
      pHandle->NewPacketAvailable = false; /* Consumes new packet*/
 80008ce:	f880 c061 	strb.w	ip, [r0, #97]	@ 0x61
      switch (pHandle->ASPEP_State)
 80008d2:	2b01      	cmp	r3, #1
 80008d4:	d055      	beq.n	8000982 <ASPEP_RXframeProcess+0xce>
 80008d6:	2b02      	cmp	r3, #2
 80008d8:	d018      	beq.n	800090c <ASPEP_RXframeProcess+0x58>
 80008da:	b933      	cbnz	r3, 80008ea <ASPEP_RXframeProcess+0x36>
      {
        case ASPEP_IDLE:
        {
          if (BEACON == pHandle->rxPacketType)
 80008dc:	6e81      	ldr	r1, [r0, #104]	@ 0x68
 80008de:	2905      	cmp	r1, #5
 80008e0:	f000 80e3 	beq.w	8000aaa <ASPEP_RXframeProcess+0x1f6>
              /* Nothing to do, controller has to send back new beacon with matching capabilities */
            }
            /* Beacon Packet must be answered*/
            ASPEP_sendBeacon(pHandle, &pHandle->Capabilities);
          }
          else if (PING == pHandle->rxPacketType)
 80008e4:	2906      	cmp	r1, #6
 80008e6:	f000 8129 	beq.w	8000b3c <ASPEP_RXframeProcess+0x288>
  uint8_t *result = NULL; //cstat !MISRAC2012-Rule-8.13
 80008ea:	2500      	movs	r5, #0

        default:
          break;
      }
      /* The valid received packet is now safely consumes, we are ready to receive a new packet */
      pHandle->fASPEP_cfg_recept(pHandle->ASPEPIp, pHandle->rxHeader, ASPEP_HEADER_SIZE);
 80008ec:	6960      	ldr	r0, [r4, #20]
 80008ee:	6d63      	ldr	r3, [r4, #84]	@ 0x54
 80008f0:	2204      	movs	r2, #4
 80008f2:	f104 011c 	add.w	r1, r4, #28
 80008f6:	4798      	blx	r3
    }
#ifdef NULL_PTR_CHECK_ASP
  }
#endif
  return (result);
}
 80008f8:	4628      	mov	r0, r5
 80008fa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    else if (pHandle->badPacketFlag > ASPEP_OK)
 80008fe:	f890 3062 	ldrb.w	r3, [r0, #98]	@ 0x62
 8000902:	b9bb      	cbnz	r3, 8000934 <ASPEP_RXframeProcess+0x80>
  uint8_t *result = NULL; //cstat !MISRAC2012-Rule-8.13
 8000904:	2500      	movs	r5, #0
}
 8000906:	4628      	mov	r0, r5
 8000908:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
          if (BEACON == pHandle->rxPacketType)
 800090c:	6e83      	ldr	r3, [r0, #104]	@ 0x68
 800090e:	2b05      	cmp	r3, #5
 8000910:	d045      	beq.n	800099e <ASPEP_RXframeProcess+0xea>
          else if (PING == pHandle->rxPacketType)
 8000912:	2b06      	cmp	r3, #6
 8000914:	f000 8118 	beq.w	8000b48 <ASPEP_RXframeProcess+0x294>
          else if (DATA_PACKET == pHandle->rxPacketType)
 8000918:	2b09      	cmp	r3, #9
 800091a:	d1e6      	bne.n	80008ea <ASPEP_RXframeProcess+0x36>
              pHandle->syncPacketCount++; /* this counter is incremented at each valid data packet received from controller */
 800091c:	f890 3060 	ldrb.w	r3, [r0, #96]	@ 0x60
              *packetLength = pHandle->rxLengthASPEP;
 8000920:	f8b0 205c 	ldrh.w	r2, [r0, #92]	@ 0x5c
              result = pHandle->rxBuffer;
 8000924:	69a5      	ldr	r5, [r4, #24]
              pHandle->syncPacketCount++; /* this counter is incremented at each valid data packet received from controller */
 8000926:	3301      	adds	r3, #1
              pSupHandle->MCP_PacketAvailable = true; /* Will be consumed in ASPEP_sendPacket */
 8000928:	2001      	movs	r0, #1
              pHandle->syncPacketCount++; /* this counter is incremented at each valid data packet received from controller */
 800092a:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
              pSupHandle->MCP_PacketAvailable = true; /* Will be consumed in ASPEP_sendPacket */
 800092e:	7420      	strb	r0, [r4, #16]
              *packetLength = pHandle->rxLengthASPEP;
 8000930:	800a      	strh	r2, [r1, #0]
              result = pHandle->rxBuffer;
 8000932:	e7db      	b.n	80008ec <ASPEP_RXframeProcess+0x38>
  *packet = NACK | (uint32_t)(((uint32_t) errorInfo) << 8U) | (uint32_t)(((uint32_t) errorInfo) << 16U);
 8000934:	eb03 2303 	add.w	r3, r3, r3, lsl #8
 8000938:	021b      	lsls	r3, r3, #8
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 800093a:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800093e:	488b      	ldr	r0, [pc, #556]	@ (8000b6c <ASPEP_RXframeProcess+0x2b8>)
  crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 8000940:	4d8b      	ldr	r5, [pc, #556]	@ (8000b70 <ASPEP_RXframeProcess+0x2bc>)
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 8000942:	f082 0209 	eor.w	r2, r2, #9
  *packet = NACK | (uint32_t)(((uint32_t) errorInfo) << 8U) | (uint32_t)(((uint32_t) errorInfo) << 16U);
 8000946:	f043 010f 	orr.w	r1, r3, #15
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 800094a:	5c82      	ldrb	r2, [r0, r2]
 800094c:	ea82 4313 	eor.w	r3, r2, r3, lsr #16
 8000950:	b2db      	uxtb	r3, r3
  crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 8000952:	5cc3      	ldrb	r3, [r0, r3]
  *headerPtr |= (uint32_t)crc << 28;
 8000954:	5ceb      	ldrb	r3, [r5, r3]
 8000956:	ea41 7303 	orr.w	r3, r1, r3, lsl #28
 800095a:	6223      	str	r3, [r4, #32]
  __ASM volatile ("cpsid i" : : : "memory");
 800095c:	b672      	cpsid	i
    if (NULL == pHandle->lockBuffer) /* Communication Ip free to send data*/
 800095e:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 8000960:	2b00      	cmp	r3, #0
 8000962:	f000 80f7 	beq.w	8000b54 <ASPEP_RXframeProcess+0x2a0>
  __ASM volatile ("cpsie i" : : : "memory");
 8000966:	b662      	cpsie	i
        if (pHandle->ctrlBuffer.state != available)
 8000968:	f894 3024 	ldrb.w	r3, [r4, #36]	@ 0x24
 800096c:	b913      	cbnz	r3, 8000974 <ASPEP_RXframeProcess+0xc0>
          pHandle->ctrlBuffer.state = pending;
 800096e:	2302      	movs	r3, #2
 8000970:	f884 3024 	strb.w	r3, [r4, #36]	@ 0x24
      pHandle->badPacketFlag = ASPEP_OK;
 8000974:	2200      	movs	r2, #0
      pHandle->fASPEP_HWSync(pHandle->ASPEPIp);
 8000976:	6d23      	ldr	r3, [r4, #80]	@ 0x50
 8000978:	6960      	ldr	r0, [r4, #20]
      pHandle->badPacketFlag = ASPEP_OK;
 800097a:	f884 2062 	strb.w	r2, [r4, #98]	@ 0x62
      pHandle->fASPEP_HWSync(pHandle->ASPEPIp);
 800097e:	4798      	blx	r3
 8000980:	e7c0      	b.n	8000904 <ASPEP_RXframeProcess+0x50>
          if (BEACON == pHandle->rxPacketType)
 8000982:	6e81      	ldr	r1, [r0, #104]	@ 0x68
 8000984:	2905      	cmp	r1, #5
 8000986:	d04f      	beq.n	8000a28 <ASPEP_RXframeProcess+0x174>
          else if (PING == pHandle->rxPacketType)
 8000988:	2906      	cmp	r1, #6
 800098a:	d1ae      	bne.n	80008ea <ASPEP_RXframeProcess+0x36>
            ASPEP_sendPing(pHandle, ASPEP_PING_CFG, packetNumber);
 800098c:	4619      	mov	r1, r3
 800098e:	f3c2 320f 	ubfx	r2, r2, #12, #16
 8000992:	f7ff fe41 	bl	8000618 <ASPEP_sendPing>
            pHandle->ASPEP_State = ASPEP_CONNECTED;
 8000996:	2302      	movs	r3, #2
 8000998:	f884 3064 	strb.w	r3, [r4, #100]	@ 0x64
 800099c:	e7a5      	b.n	80008ea <ASPEP_RXframeProcess+0x36>
  MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 800099e:	f894 e01d 	ldrb.w	lr, [r4, #29]
  pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_maxSize);
 80009a2:	f894 506d 	ldrb.w	r5, [r4, #109]	@ 0x6d
  MasterCapabilities.DATA_CRC = pHandle->rxHeader[0] >> 7U ;                     /*Bit 7 */
 80009a6:	7f00      	ldrb	r0, [r0, #28]
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80009a8:	f894 606c 	ldrb.w	r6, [r4, #108]	@ 0x6c
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 80009ac:	f894 706e 	ldrb.w	r7, [r4, #110]	@ 0x6e
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 80009b0:	f894 906f 	ldrb.w	r9, [r4, #111]	@ 0x6f
  MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 80009b4:	f00e 0e3f 	and.w	lr, lr, #63	@ 0x3f
  MasterCapabilities.DATA_CRC = pHandle->rxHeader[0] >> 7U ;                     /*Bit 7 */
 80009b8:	09c0      	lsrs	r0, r0, #7
  pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_maxSize);
 80009ba:	4575      	cmp	r5, lr
 80009bc:	bf28      	it	cs
 80009be:	4675      	movcs	r5, lr
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80009c0:	42b0      	cmp	r0, r6
 80009c2:	4601      	mov	r1, r0
  MasterCapabilities.TXS_maxSize = (uint8_t)((packetHeader&0x01FC000U)  >> 14); /*Bits 14 to 20 */
 80009c4:	f3c2 3886 	ubfx	r8, r2, #14, #7
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80009c8:	bf28      	it	cs
 80009ca:	4631      	movcs	r1, r6
 80009cc:	4663      	mov	r3, ip
 80009ce:	f361 0307 	bfi	r3, r1, #0, #8
  MasterCapabilities.TXA_maxSize = (uint8_t)((packetHeader&0xFE00000U) >> 21);  /*Bits 21 to 27  */
 80009d2:	f3c2 5a46 	ubfx	sl, r2, #21, #7
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 80009d6:	45b8      	cmp	r8, r7
 80009d8:	4641      	mov	r1, r8
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80009da:	f365 230f 	bfi	r3, r5, #8, #8
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 80009de:	bf28      	it	cs
 80009e0:	4639      	movcs	r1, r7
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 80009e2:	45ca      	cmp	sl, r9
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80009e4:	f361 4317 	bfi	r3, r1, #16, #8
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 80009e8:	4651      	mov	r1, sl
 80009ea:	bf28      	it	cs
 80009ec:	4649      	movcs	r1, r9
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80009ee:	f361 631f 	bfi	r3, r1, #24, #8
  if ((MasterCapabilities.DATA_CRC != pHandle->Capabilities.DATA_CRC)
 80009f2:	42b0      	cmp	r0, r6
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80009f4:	66e3      	str	r3, [r4, #108]	@ 0x6c
  if ((MasterCapabilities.DATA_CRC != pHandle->Capabilities.DATA_CRC)
 80009f6:	f104 016c 	add.w	r1, r4, #108	@ 0x6c
 80009fa:	d80f      	bhi.n	8000a1c <ASPEP_RXframeProcess+0x168>
   || (MasterCapabilities.RX_maxSize > pHandle->Capabilities.RX_maxSize)
 80009fc:	45ae      	cmp	lr, r5
 80009fe:	d80d      	bhi.n	8000a1c <ASPEP_RXframeProcess+0x168>
   || (pHandle->Capabilities.TXS_maxSize != MasterCapabilities.TXS_maxSize )
 8000a00:	45b8      	cmp	r8, r7
 8000a02:	d80b      	bhi.n	8000a1c <ASPEP_RXframeProcess+0x168>
   || (pHandle->Capabilities.TXA_maxSize != MasterCapabilities.TXA_maxSize )
 8000a04:	45ca      	cmp	sl, r9
 8000a06:	d809      	bhi.n	8000a1c <ASPEP_RXframeProcess+0x168>
   || (MasterCapabilities.version != pHandle->Capabilities.version) )
 8000a08:	f894 c070 	ldrb.w	ip, [r4, #112]	@ 0x70
 8000a0c:	f3c2 1202 	ubfx	r2, r2, #4, #3
 8000a10:	ebac 0c02 	sub.w	ip, ip, r2
 8000a14:	fabc fc8c 	clz	ip, ip
 8000a18:	ea4f 1c5c 	mov.w	ip, ip, lsr #5
 8000a1c:	f884 c064 	strb.w	ip, [r4, #100]	@ 0x64
            ASPEP_sendBeacon(pHandle, &pHandle->Capabilities);
 8000a20:	4620      	mov	r0, r4
 8000a22:	f7ff fdb3 	bl	800058c <ASPEP_sendBeacon>
 8000a26:	e760      	b.n	80008ea <ASPEP_RXframeProcess+0x36>
  MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 8000a28:	7f45      	ldrb	r5, [r0, #29]
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8000a2a:	f890 606c 	ldrb.w	r6, [r0, #108]	@ 0x6c
  MasterCapabilities.DATA_CRC = pHandle->rxHeader[0] >> 7U ;                     /*Bit 7 */
 8000a2e:	7f01      	ldrb	r1, [r0, #28]
  pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_maxSize);
 8000a30:	f890 006d 	ldrb.w	r0, [r0, #109]	@ 0x6d
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 8000a34:	f894 706e 	ldrb.w	r7, [r4, #110]	@ 0x6e
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 8000a38:	f894 e06f 	ldrb.w	lr, [r4, #111]	@ 0x6f
  MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 8000a3c:	f005 053f 	and.w	r5, r5, #63	@ 0x3f
  MasterCapabilities.DATA_CRC = pHandle->rxHeader[0] >> 7U ;                     /*Bit 7 */
 8000a40:	09c9      	lsrs	r1, r1, #7
  pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_maxSize);
 8000a42:	42a8      	cmp	r0, r5
 8000a44:	bf28      	it	cs
 8000a46:	4628      	movcs	r0, r5
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8000a48:	42b1      	cmp	r1, r6
 8000a4a:	4663      	mov	r3, ip
 8000a4c:	468c      	mov	ip, r1
 8000a4e:	bf28      	it	cs
 8000a50:	46b4      	movcs	ip, r6
 8000a52:	f36c 0307 	bfi	r3, ip, #0, #8
  MasterCapabilities.TXS_maxSize = (uint8_t)((packetHeader&0x01FC000U)  >> 14); /*Bits 14 to 20 */
 8000a56:	f3c2 3c86 	ubfx	ip, r2, #14, #7
  MasterCapabilities.TXA_maxSize = (uint8_t)((packetHeader&0xFE00000U) >> 21);  /*Bits 21 to 27  */
 8000a5a:	f3c2 5846 	ubfx	r8, r2, #21, #7
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 8000a5e:	45bc      	cmp	ip, r7
 8000a60:	46e1      	mov	r9, ip
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8000a62:	f360 230f 	bfi	r3, r0, #8, #8
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 8000a66:	bf28      	it	cs
 8000a68:	46b9      	movcs	r9, r7
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 8000a6a:	45f0      	cmp	r8, lr
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8000a6c:	f369 4317 	bfi	r3, r9, #16, #8
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 8000a70:	46c1      	mov	r9, r8
 8000a72:	bf28      	it	cs
 8000a74:	46f1      	movcs	r9, lr
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8000a76:	f369 631f 	bfi	r3, r9, #24, #8
  if ((MasterCapabilities.DATA_CRC != pHandle->Capabilities.DATA_CRC)
 8000a7a:	42b1      	cmp	r1, r6
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8000a7c:	66e3      	str	r3, [r4, #108]	@ 0x6c
  if ((MasterCapabilities.DATA_CRC != pHandle->Capabilities.DATA_CRC)
 8000a7e:	d80b      	bhi.n	8000a98 <ASPEP_RXframeProcess+0x1e4>
   || (MasterCapabilities.RX_maxSize > pHandle->Capabilities.RX_maxSize)
 8000a80:	4285      	cmp	r5, r0
 8000a82:	d809      	bhi.n	8000a98 <ASPEP_RXframeProcess+0x1e4>
   || (pHandle->Capabilities.TXS_maxSize != MasterCapabilities.TXS_maxSize )
 8000a84:	45bc      	cmp	ip, r7
 8000a86:	d807      	bhi.n	8000a98 <ASPEP_RXframeProcess+0x1e4>
   || (pHandle->Capabilities.TXA_maxSize != MasterCapabilities.TXA_maxSize )
 8000a88:	45f0      	cmp	r8, lr
 8000a8a:	d805      	bhi.n	8000a98 <ASPEP_RXframeProcess+0x1e4>
   || (MasterCapabilities.version != pHandle->Capabilities.version) )
 8000a8c:	f894 3070 	ldrb.w	r3, [r4, #112]	@ 0x70
 8000a90:	f3c2 1202 	ubfx	r2, r2, #4, #3
 8000a94:	4293      	cmp	r3, r2
 8000a96:	d002      	beq.n	8000a9e <ASPEP_RXframeProcess+0x1ea>
              pHandle->ASPEP_State = ASPEP_IDLE;
 8000a98:	2300      	movs	r3, #0
 8000a9a:	f884 3064 	strb.w	r3, [r4, #100]	@ 0x64
            ASPEP_sendBeacon(pHandle, &pHandle->Capabilities);
 8000a9e:	f104 016c 	add.w	r1, r4, #108	@ 0x6c
 8000aa2:	4620      	mov	r0, r4
 8000aa4:	f7ff fd72 	bl	800058c <ASPEP_sendBeacon>
 8000aa8:	e71f      	b.n	80008ea <ASPEP_RXframeProcess+0x36>
  MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 8000aaa:	f890 c01d 	ldrb.w	ip, [r0, #29]
  pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_maxSize);
 8000aae:	f890 106d 	ldrb.w	r1, [r0, #109]	@ 0x6d
  MasterCapabilities.DATA_CRC = pHandle->rxHeader[0] >> 7U ;                     /*Bit 7 */
 8000ab2:	7f05      	ldrb	r5, [r0, #28]
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8000ab4:	f890 606c 	ldrb.w	r6, [r0, #108]	@ 0x6c
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 8000ab8:	f890 706e 	ldrb.w	r7, [r0, #110]	@ 0x6e
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 8000abc:	f894 906f 	ldrb.w	r9, [r4, #111]	@ 0x6f
  MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 8000ac0:	f00c 0c3f 	and.w	ip, ip, #63	@ 0x3f
  MasterCapabilities.DATA_CRC = pHandle->rxHeader[0] >> 7U ;                     /*Bit 7 */
 8000ac4:	09ed      	lsrs	r5, r5, #7
  pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_maxSize);
 8000ac6:	4561      	cmp	r1, ip
 8000ac8:	bf28      	it	cs
 8000aca:	4661      	movcs	r1, ip
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8000acc:	42b5      	cmp	r5, r6
 8000ace:	4628      	mov	r0, r5
  MasterCapabilities.TXS_maxSize = (uint8_t)((packetHeader&0x01FC000U)  >> 14); /*Bits 14 to 20 */
 8000ad0:	f3c2 3886 	ubfx	r8, r2, #14, #7
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8000ad4:	bf28      	it	cs
 8000ad6:	4630      	movcs	r0, r6
 8000ad8:	f360 0307 	bfi	r3, r0, #0, #8
  MasterCapabilities.TXA_maxSize = (uint8_t)((packetHeader&0xFE00000U) >> 21);  /*Bits 21 to 27  */
 8000adc:	f3c2 5a46 	ubfx	sl, r2, #21, #7
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 8000ae0:	45b8      	cmp	r8, r7
 8000ae2:	4640      	mov	r0, r8
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8000ae4:	f361 230f 	bfi	r3, r1, #8, #8
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 8000ae8:	bf28      	it	cs
 8000aea:	4638      	movcs	r0, r7
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 8000aec:	45ca      	cmp	sl, r9
 8000aee:	46d6      	mov	lr, sl
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8000af0:	f360 4317 	bfi	r3, r0, #16, #8
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 8000af4:	bf28      	it	cs
 8000af6:	46ce      	movcs	lr, r9
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8000af8:	f36e 631f 	bfi	r3, lr, #24, #8
  if ((MasterCapabilities.DATA_CRC != pHandle->Capabilities.DATA_CRC)
 8000afc:	42b5      	cmp	r5, r6
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8000afe:	66e3      	str	r3, [r4, #108]	@ 0x6c
  if ((MasterCapabilities.DATA_CRC != pHandle->Capabilities.DATA_CRC)
 8000b00:	d8cd      	bhi.n	8000a9e <ASPEP_RXframeProcess+0x1ea>
   || (MasterCapabilities.RX_maxSize > pHandle->Capabilities.RX_maxSize)
 8000b02:	458c      	cmp	ip, r1
 8000b04:	d8cb      	bhi.n	8000a9e <ASPEP_RXframeProcess+0x1ea>
   || (pHandle->Capabilities.TXS_maxSize != MasterCapabilities.TXS_maxSize )
 8000b06:	45b8      	cmp	r8, r7
 8000b08:	d8c9      	bhi.n	8000a9e <ASPEP_RXframeProcess+0x1ea>
   || (pHandle->Capabilities.TXA_maxSize != MasterCapabilities.TXA_maxSize )
 8000b0a:	45ca      	cmp	sl, r9
 8000b0c:	d8c7      	bhi.n	8000a9e <ASPEP_RXframeProcess+0x1ea>
   || (MasterCapabilities.version != pHandle->Capabilities.version) )
 8000b0e:	f894 3070 	ldrb.w	r3, [r4, #112]	@ 0x70
 8000b12:	f3c2 1202 	ubfx	r2, r2, #4, #3
 8000b16:	4293      	cmp	r3, r2
 8000b18:	d1c1      	bne.n	8000a9e <ASPEP_RXframeProcess+0x1ea>
              pHandle->maxRXPayload = (pHandle->Capabilities.RX_maxSize + (uint16_t)1U) * (uint16_t)32U;
 8000b1a:	1c4b      	adds	r3, r1, #1
              pSupHandle->txSyncMaxPayload = (pHandle->Capabilities.TXS_maxSize + (uint16_t)1U) * (uint16_t)32U;
 8000b1c:	1c42      	adds	r2, r0, #1
 8000b1e:	b2d2      	uxtb	r2, r2
              pHandle->maxRXPayload = (pHandle->Capabilities.RX_maxSize + (uint16_t)1U) * (uint16_t)32U;
 8000b20:	b2db      	uxtb	r3, r3
              pSupHandle->txSyncMaxPayload = (pHandle->Capabilities.TXS_maxSize + (uint16_t)1U) * (uint16_t)32U;
 8000b22:	0152      	lsls	r2, r2, #5
              pSupHandle->txAsyncMaxPayload = (pHandle->Capabilities.TXA_maxSize) * (uint16_t)64U;
 8000b24:	ea4f 1e8e 	mov.w	lr, lr, lsl #6
              pHandle->maxRXPayload = (pHandle->Capabilities.RX_maxSize + (uint16_t)1U) * (uint16_t)32U;
 8000b28:	015b      	lsls	r3, r3, #5
              pHandle->ASPEP_State = ASPEP_CONFIGURED;
 8000b2a:	2101      	movs	r1, #1
              pSupHandle->txSyncMaxPayload = (pHandle->Capabilities.TXS_maxSize + (uint16_t)1U) * (uint16_t)32U;
 8000b2c:	81a2      	strh	r2, [r4, #12]
              pSupHandle->txAsyncMaxPayload = (pHandle->Capabilities.TXA_maxSize) * (uint16_t)64U;
 8000b2e:	f8a4 e00e 	strh.w	lr, [r4, #14]
              pHandle->maxRXPayload = (pHandle->Capabilities.RX_maxSize + (uint16_t)1U) * (uint16_t)32U;
 8000b32:	f8a4 305e 	strh.w	r3, [r4, #94]	@ 0x5e
              pHandle->ASPEP_State = ASPEP_CONFIGURED;
 8000b36:	f884 1064 	strb.w	r1, [r4, #100]	@ 0x64
 8000b3a:	e7b0      	b.n	8000a9e <ASPEP_RXframeProcess+0x1ea>
            ASPEP_sendPing(pHandle, ASPEP_PING_RESET, packetNumber);
 8000b3c:	f3c2 320f 	ubfx	r2, r2, #12, #16
 8000b40:	4619      	mov	r1, r3
 8000b42:	f7ff fd69 	bl	8000618 <ASPEP_sendPing>
 8000b46:	e6d0      	b.n	80008ea <ASPEP_RXframeProcess+0x36>
            ASPEP_sendPing(pHandle, ASPEP_PING_CFG, packetNumber);
 8000b48:	f3c2 320f 	ubfx	r2, r2, #12, #16
 8000b4c:	2101      	movs	r1, #1
 8000b4e:	f7ff fd63 	bl	8000618 <ASPEP_sendPing>
 8000b52:	e6ca      	b.n	80008ea <ASPEP_RXframeProcess+0x36>
  (void)ASPEP_TXframeProcess(pHandle, ASPEP_CTRL, &pHandle->ctrlBuffer, ASPEP_CTRL_SIZE);
 8000b54:	f104 0120 	add.w	r1, r4, #32
        pHandle->ctrlBuffer.state = readLock;
 8000b58:	2303      	movs	r3, #3
 8000b5a:	f884 3024 	strb.w	r3, [r4, #36]	@ 0x24
        pHandle->lockBuffer = (void *)&pHandle->ctrlBuffer;
 8000b5e:	64a1      	str	r1, [r4, #72]	@ 0x48
 8000b60:	b662      	cpsie	i
      pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, txBuffer, bufferLength);
 8000b62:	2204      	movs	r2, #4
 8000b64:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 8000b66:	6960      	ldr	r0, [r4, #20]
 8000b68:	4798      	blx	r3
 8000b6a:	e703      	b.n	8000974 <ASPEP_RXframeProcess+0xc0>
 8000b6c:	0800a364 	.word	0x0800a364
 8000b70:	0800a354 	.word	0x0800a354

08000b74 <ASPEP_HWReset>:
  * @brief  Resets DMA after debugger has stopped the MCU.
  *
  * @param  *pHandle Handler of the current instance of the ASPEP component
  */
void ASPEP_HWReset(ASPEP_Handle_t *pHandle)
{
 8000b74:	4601      	mov	r1, r0
  {
#endif
    /* We must reset the RX state machine to be sure to not be in Waiting packet state */
    /* Otherwise the arrival of a new packet will trigger a NewPacketAvailable despite */
    /* the fact that bytes have been lost because of overrun (debugger paused for instance) */
    pHandle->ASPEP_TL_State = WAITING_PACKET;
 8000b76:	2200      	movs	r2, #0
 8000b78:	f880 2065 	strb.w	r2, [r0, #101]	@ 0x65
    pHandle->fASPEP_cfg_recept(pHandle->ASPEPIp, pHandle->rxHeader, ASPEP_HEADER_SIZE);
 8000b7c:	6d43      	ldr	r3, [r0, #84]	@ 0x54
 8000b7e:	6940      	ldr	r0, [r0, #20]
 8000b80:	2204      	movs	r2, #4
 8000b82:	311c      	adds	r1, #28
 8000b84:	4718      	bx	r3
 8000b86:	bf00      	nop

08000b88 <DAC_Init>:
/**
  * @brief  Hardware and software initialization of the DAC object.
  * @param  pHandle pointer on related component instance.
  */
__weak void DAC_Init(DAC_Handle_t *pHandle)
{
 8000b88:	b508      	push	{r3, lr}
 8000b8a:	4601      	mov	r1, r0
  else
  {
#endif
    /* Enable DAC Channel1 */
    /* By default send Ia motor 1 */
    (void)RI_GetPtrReg((MC_REG_I_A + 0x1U), (void *)&pHandle->ptrDataCh[DAC_CH1]); //cstat !MISRAC2012-Rule-11.5
 8000b8c:	f240 70d1 	movw	r0, #2001	@ 0x7d1
 8000b90:	f002 fc86 	bl	80034a0 <RI_GetPtrReg>
  *             Refer to device datasheet for channels availability.
  * @retval None
  */
__STATIC_INLINE void LL_DAC_Enable(DAC_TypeDef *DACx, uint32_t DAC_Channel)
{
  SET_BIT(DACx->CR,
 8000b94:	4a02      	ldr	r2, [pc, #8]	@ (8000ba0 <DAC_Init+0x18>)
 8000b96:	6813      	ldr	r3, [r2, #0]
 8000b98:	f043 0301 	orr.w	r3, r3, #1
 8000b9c:	6013      	str	r3, [r2, #0]
    LL_DAC_Enable(DAC1, LL_DAC_CHANNEL_1);
#ifdef NULL_PTR_CHECK_DAC_UI
  }
  #endif

}
 8000b9e:	bd08      	pop	{r3, pc}
 8000ba0:	50000800 	.word	0x50000800

08000ba4 <DAC_Exec>:
__STATIC_INLINE void LL_DAC_ConvertData12LeftAligned(DAC_TypeDef *DACx, uint32_t DAC_Channel, uint32_t Data)
{
  __IO uint32_t *preg = __DAC_PTR_REG_OFFSET(DACx->DHR12R1, (DAC_Channel >> DAC_REG_DHR12LX_REGOFFSET_BITOFFSET_POS)
                                             & DAC_REG_DHR_REGOFFSET_MASK_POSBIT0);

  MODIFY_REG(*preg, DAC_DHR12L1_DACC1DHR, Data);
 8000ba4:	f04f 4ca0 	mov.w	ip, #1342177280	@ 0x50000000
  }
  else
  {
#endif
    uint32_t temp1;
    temp1 = DACOFF + (uint32_t)*((uint16_t*) pHandle->ptrDataCh[DAC_CH1]); //cstat !MISRAC2012-Rule-11.3
 8000ba8:	6803      	ldr	r3, [r0, #0]
 8000baa:	f8dc 280c 	ldr.w	r2, [ip, #2060]	@ 0x80c
 8000bae:	881b      	ldrh	r3, [r3, #0]
  SET_BIT(DACx->SWTRIGR,
 8000bb0:	4907      	ldr	r1, [pc, #28]	@ (8000bd0 <DAC_Exec+0x2c>)
  MODIFY_REG(*preg, DAC_DHR12L1_DACC1DHR, Data);
 8000bb2:	f422 427f 	bic.w	r2, r2, #65280	@ 0xff00
 8000bb6:	f503 4300 	add.w	r3, r3, #32768	@ 0x8000
 8000bba:	f022 02f0 	bic.w	r2, r2, #240	@ 0xf0
 8000bbe:	4313      	orrs	r3, r2
 8000bc0:	f8cc 380c 	str.w	r3, [ip, #2060]	@ 0x80c
  SET_BIT(DACx->SWTRIGR,
 8000bc4:	684b      	ldr	r3, [r1, #4]
 8000bc6:	f043 0301 	orr.w	r3, r3, #1
 8000bca:	604b      	str	r3, [r1, #4]
    LL_DAC_ConvertData12LeftAligned(DAC1, LL_DAC_CHANNEL_1, temp1);
    LL_DAC_TrigSWConversion(DAC1, LL_DAC_CHANNEL_1);
#ifdef NULL_PTR_CHECK_DAC_UI
  }
#endif
}
 8000bcc:	4770      	bx	lr
 8000bce:	bf00      	nop
 8000bd0:	50000800 	.word	0x50000800

08000bd4 <DAC_SetChannelConfig>:
  * @param  regID the variables to be provided in out through the selected
  *         channel. It must be one of the exported UI register Ex.
  *         MC_PROTOCOL_REG_I_A.
  */
__weak void DAC_SetChannelConfig(DAC_Handle_t *pHandle, DAC_Channel_t bChannel, uint16_t regID)
{
 8000bd4:	4603      	mov	r3, r0
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->dataCh[bChannel] = regID;
 8000bd6:	f101 0c04 	add.w	ip, r1, #4
{
 8000bda:	4610      	mov	r0, r2
    pHandle->dataCh[bChannel] = regID;
 8000bdc:	f823 201c 	strh.w	r2, [r3, ip, lsl #1]
    (void)RI_GetPtrReg(regID, (void *)&pHandle->ptrDataCh[bChannel]); //cstat !MISRAC2012-Rule-11.5
 8000be0:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8000be4:	f002 bc5c 	b.w	80034a0 <RI_GetPtrReg>

08000be8 <DAC_GetChannelConfig>:
uint16_t DAC_GetChannelConfig(DAC_Handle_t *pHandle, DAC_Channel_t bChannel)
{
#ifdef NULL_PTR_CHECK_DAC_UI
  return ((NULL == pHandle) ? 0U : pHandle->dataCh[bChannel]);
#else
  return (pHandle->dataCh[bChannel]);
 8000be8:	3104      	adds	r1, #4
#endif
}
 8000bea:	f830 0011 	ldrh.w	r0, [r0, r1, lsl #1]
 8000bee:	4770      	bx	lr

08000bf0 <MC_StartMotor1>:
  *
  * @retval returns true if the command is successfully executed, false otherwise.
  */
__weak bool MC_StartMotor1(void)
{
  return (MCI_StartMotor(pMCI[M1]));
 8000bf0:	4b01      	ldr	r3, [pc, #4]	@ (8000bf8 <MC_StartMotor1+0x8>)
 8000bf2:	6818      	ldr	r0, [r3, #0]
 8000bf4:	f000 bb84 	b.w	8001300 <MCI_StartMotor>
 8000bf8:	20001924 	.word	0x20001924

08000bfc <MC_StopMotor1>:
  *
  * @retval returns true if the command is successfully executed, false otherwise.
  */
__weak bool MC_StopMotor1(void)
{
  return (MCI_StopMotor(pMCI[M1]));
 8000bfc:	4b01      	ldr	r3, [pc, #4]	@ (8000c04 <MC_StopMotor1+0x8>)
 8000bfe:	6818      	ldr	r0, [r3, #0]
 8000c00:	f000 bb96 	b.w	8001330 <MCI_StopMotor>
 8000c04:	20001924 	.word	0x20001924

08000c08 <MC_ProgramPositionCommandMotor1>:
  * @param  fDuration Duration of the movement expressed in seconds.
  *         It is possible to set 0 to perform an instantaneous angular change (follow mode).
  */
__weak void MC_ProgramPositionCommandMotor1(float_t fTargetPosition, float_t fDuration)
{
  MCI_ExecPositionCommand(pMCI[M1], fTargetPosition, fDuration);
 8000c08:	4b01      	ldr	r3, [pc, #4]	@ (8000c10 <MC_ProgramPositionCommandMotor1+0x8>)
 8000c0a:	6818      	ldr	r0, [r3, #0]
 8000c0c:	f000 baee 	b.w	80011ec <MCI_ExecPositionCommand>
 8000c10:	20001924 	.word	0x20001924

08000c14 <MC_GetSTMStateMotor1>:
/**
 * @brief returns the current state of Motor 1 state machine
 */
__weak MCI_State_t MC_GetSTMStateMotor1(void)
{
  return (MCI_GetSTMState(pMCI[M1]));
 8000c14:	4b01      	ldr	r3, [pc, #4]	@ (8000c1c <MC_GetSTMStateMotor1+0x8>)
 8000c16:	6818      	ldr	r0, [r3, #0]
 8000c18:	f000 bb66 	b.w	80012e8 <MCI_GetSTMState>
 8000c1c:	20001924 	.word	0x20001924

08000c20 <MC_ProfilerCommand>:
 * @brief Not implemented MC_Profiler function.
 *  */ //cstat !MISRAC2012-Rule-2.7 !RED-unused-param  !MISRAC2012-Rule-2.7  !MISRAC2012-Rule-8.13
__weak uint8_t MC_ProfilerCommand(uint16_t rxLength, uint8_t *rxBuffer, int16_t txSyncFreeSpace, uint16_t *txLength, uint8_t *txBuffer)
{
  return (MCP_CMD_UNKNOWN);
}
 8000c20:	2002      	movs	r0, #2
 8000c22:	4770      	bx	lr

08000c24 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8000c24:	b510      	push	{r4, lr}
 8000c26:	b094      	sub	sp, #80	@ 0x50
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8000c28:	2238      	movs	r2, #56	@ 0x38
 8000c2a:	2100      	movs	r1, #0
 8000c2c:	a806      	add	r0, sp, #24
 8000c2e:	f009 fb37 	bl	800a2a0 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8000c32:	2000      	movs	r0, #0
 8000c34:	e9cd 0001 	strd	r0, r0, [sp, #4]
 8000c38:	e9cd 0003 	strd	r0, r0, [sp, #12]
 8000c3c:	9005      	str	r0, [sp, #20]

  /** Configure the main internal regulator output voltage
  */
  HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1_BOOST);
 8000c3e:	f004 fd2b 	bl	8005698 <HAL_PWREx_ControlVoltageScaling>

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8000c42:	2001      	movs	r0, #1
 8000c44:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = RCC_PLLM_DIV6;
 8000c48:	2206      	movs	r2, #6
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8000c4a:	e9cd 0106 	strd	r0, r1, [sp, #24]
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8000c4e:	2302      	movs	r3, #2
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8000c50:	2403      	movs	r4, #3
  RCC_OscInitStruct.PLL.PLLM = RCC_PLLM_DIV6;
 8000c52:	920f      	str	r2, [sp, #60]	@ 0x3c
  RCC_OscInitStruct.PLL.PLLN = 85;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV8;
 8000c54:	2155      	movs	r1, #85	@ 0x55
 8000c56:	2208      	movs	r2, #8
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000c58:	a806      	add	r0, sp, #24
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8000c5a:	e9cd 340d 	strd	r3, r4, [sp, #52]	@ 0x34
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV8;
 8000c5e:	e9cd 1210 	strd	r1, r2, [sp, #64]	@ 0x40
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
 8000c62:	e9cd 3312 	strd	r3, r3, [sp, #72]	@ 0x48
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000c66:	f004 fd91 	bl	800578c <HAL_RCC_OscConfig>
 8000c6a:	b108      	cbz	r0, 8000c70 <SystemClock_Config+0x4c>
  __ASM volatile ("cpsid i" : : : "memory");
 8000c6c:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 8000c6e:	e7fe      	b.n	8000c6e <SystemClock_Config+0x4a>
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 8000c70:	2104      	movs	r1, #4
 8000c72:	4603      	mov	r3, r0
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8000c74:	220f      	movs	r2, #15
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 8000c76:	eb0d 0001 	add.w	r0, sp, r1
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8000c7a:	e9cd 2401 	strd	r2, r4, [sp, #4]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8000c7e:	e9cd 3303 	strd	r3, r3, [sp, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8000c82:	9305      	str	r3, [sp, #20]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 8000c84:	f005 f800 	bl	8005c88 <HAL_RCC_ClockConfig>
 8000c88:	b108      	cbz	r0, 8000c8e <SystemClock_Config+0x6a>
 8000c8a:	b672      	cpsid	i
  while (1)
 8000c8c:	e7fe      	b.n	8000c8c <SystemClock_Config+0x68>
  HAL_RCC_EnableCSS();
 8000c8e:	f005 f94b 	bl	8005f28 <HAL_RCC_EnableCSS>
}
 8000c92:	b014      	add	sp, #80	@ 0x50
 8000c94:	bd10      	pop	{r4, pc}
 8000c96:	bf00      	nop

08000c98 <main>:
{
 8000c98:	b580      	push	{r7, lr}
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000c9a:	2400      	movs	r4, #0
{
 8000c9c:	b0a4      	sub	sp, #144	@ 0x90
  HAL_Init();
 8000c9e:	f003 fad1 	bl	8004244 <HAL_Init>
  SystemClock_Config();
 8000ca2:	f7ff ffbf 	bl	8000c24 <SystemClock_Config>
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000ca6:	e9cd 4417 	strd	r4, r4, [sp, #92]	@ 0x5c
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8000caa:	4da6      	ldr	r5, [pc, #664]	@ (8000f44 <main+0x2ac>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000cac:	9419      	str	r4, [sp, #100]	@ 0x64
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8000cae:	6ceb      	ldr	r3, [r5, #76]	@ 0x4c
  HAL_GPIO_Init(Start_Stop_GPIO_Port, &GPIO_InitStruct);
 8000cb0:	48a5      	ldr	r0, [pc, #660]	@ (8000f48 <main+0x2b0>)
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8000cb2:	f043 0304 	orr.w	r3, r3, #4
 8000cb6:	64eb      	str	r3, [r5, #76]	@ 0x4c
 8000cb8:	6ceb      	ldr	r3, [r5, #76]	@ 0x4c
 8000cba:	f003 0304 	and.w	r3, r3, #4
 8000cbe:	9303      	str	r3, [sp, #12]
 8000cc0:	9b03      	ldr	r3, [sp, #12]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8000cc2:	6ceb      	ldr	r3, [r5, #76]	@ 0x4c
 8000cc4:	f043 0320 	orr.w	r3, r3, #32
 8000cc8:	64eb      	str	r3, [r5, #76]	@ 0x4c
 8000cca:	6ceb      	ldr	r3, [r5, #76]	@ 0x4c
 8000ccc:	f003 0320 	and.w	r3, r3, #32
 8000cd0:	9304      	str	r3, [sp, #16]
 8000cd2:	9b04      	ldr	r3, [sp, #16]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8000cd4:	6ceb      	ldr	r3, [r5, #76]	@ 0x4c
 8000cd6:	f043 0301 	orr.w	r3, r3, #1
 8000cda:	64eb      	str	r3, [r5, #76]	@ 0x4c
 8000cdc:	6ceb      	ldr	r3, [r5, #76]	@ 0x4c
 8000cde:	f003 0301 	and.w	r3, r3, #1
 8000ce2:	9305      	str	r3, [sp, #20]
 8000ce4:	9b05      	ldr	r3, [sp, #20]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8000ce6:	6ceb      	ldr	r3, [r5, #76]	@ 0x4c
 8000ce8:	f043 0302 	orr.w	r3, r3, #2
 8000cec:	64eb      	str	r3, [r5, #76]	@ 0x4c
 8000cee:	6ceb      	ldr	r3, [r5, #76]	@ 0x4c
 8000cf0:	f003 0302 	and.w	r3, r3, #2
 8000cf4:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Pin = Start_Stop_Pin;
 8000cf6:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
  HAL_GPIO_Init(Start_Stop_GPIO_Port, &GPIO_InitStruct);
 8000cfa:	a915      	add	r1, sp, #84	@ 0x54
  GPIO_InitStruct.Pin = Start_Stop_Pin;
 8000cfc:	9315      	str	r3, [sp, #84]	@ 0x54
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 8000cfe:	f44f 1304 	mov.w	r3, #2162688	@ 0x210000
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8000d02:	9a06      	ldr	r2, [sp, #24]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 8000d04:	9316      	str	r3, [sp, #88]	@ 0x58
  HAL_GPIO_Init(Start_Stop_GPIO_Port, &GPIO_InitStruct);
 8000d06:	f004 fbbf 	bl	8005488 <HAL_GPIO_Init>
  __HAL_RCC_DMAMUX1_CLK_ENABLE();
 8000d0a:	6cab      	ldr	r3, [r5, #72]	@ 0x48
 8000d0c:	f043 0304 	orr.w	r3, r3, #4
 8000d10:	64ab      	str	r3, [r5, #72]	@ 0x48
 8000d12:	6cab      	ldr	r3, [r5, #72]	@ 0x48
 8000d14:	f003 0304 	and.w	r3, r3, #4
 8000d18:	9301      	str	r3, [sp, #4]
 8000d1a:	9b01      	ldr	r3, [sp, #4]
  __HAL_RCC_DMA1_CLK_ENABLE();
 8000d1c:	6cab      	ldr	r3, [r5, #72]	@ 0x48
 8000d1e:	f043 0301 	orr.w	r3, r3, #1
 8000d22:	64ab      	str	r3, [r5, #72]	@ 0x48
 8000d24:	6cab      	ldr	r3, [r5, #72]	@ 0x48
  hadc1.Instance = ADC1;
 8000d26:	4d89      	ldr	r5, [pc, #548]	@ (8000f4c <main+0x2b4>)
  ADC_MultiModeTypeDef multimode = {0};
 8000d28:	940a      	str	r4, [sp, #40]	@ 0x28
  __HAL_RCC_DMA1_CLK_ENABLE();
 8000d2a:	f003 0301 	and.w	r3, r3, #1
  ADC_InjectionConfTypeDef sConfigInjected = {0};
 8000d2e:	4621      	mov	r1, r4
  __HAL_RCC_DMA1_CLK_ENABLE();
 8000d30:	9302      	str	r3, [sp, #8]
  ADC_InjectionConfTypeDef sConfigInjected = {0};
 8000d32:	223c      	movs	r2, #60	@ 0x3c
 8000d34:	a815      	add	r0, sp, #84	@ 0x54
  __HAL_RCC_DMA1_CLK_ENABLE();
 8000d36:	9b02      	ldr	r3, [sp, #8]
  ADC_MultiModeTypeDef multimode = {0};
 8000d38:	e9cd 440b 	strd	r4, r4, [sp, #44]	@ 0x2c
  ADC_InjectionConfTypeDef sConfigInjected = {0};
 8000d3c:	f009 fab0 	bl	800a2a0 <memset>
  ADC_ChannelConfTypeDef sConfig = {0};
 8000d40:	4621      	mov	r1, r4
 8000d42:	2220      	movs	r2, #32
 8000d44:	a80d      	add	r0, sp, #52	@ 0x34
 8000d46:	f009 faab 	bl	800a2a0 <memset>
  hadc1.Instance = ADC1;
 8000d4a:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
 8000d4e:	e9c5 4401 	strd	r4, r4, [r5, #4]
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 8000d52:	e9c5 440b 	strd	r4, r4, [r5, #44]	@ 0x2c
  hadc1.Init.GainCompensation = 0;
 8000d56:	612c      	str	r4, [r5, #16]
  hadc1.Init.LowPowerAutoWait = DISABLE;
 8000d58:	83ac      	strh	r4, [r5, #28]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
 8000d5a:	f885 4024 	strb.w	r4, [r5, #36]	@ 0x24
  hadc1.Init.DMAContinuousRequests = DISABLE;
 8000d5e:	f885 4038 	strb.w	r4, [r5, #56]	@ 0x38
  hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 8000d62:	63ec      	str	r4, [r5, #60]	@ 0x3c
  hadc1.Init.OversamplingMode = DISABLE;
 8000d64:	f885 4040 	strb.w	r4, [r5, #64]	@ 0x40
  hadc1.Instance = ADC1;
 8000d68:	602b      	str	r3, [r5, #0]
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8000d6a:	2701      	movs	r7, #1
  hadc1.Init.DataAlign = ADC_DATAALIGN_LEFT;
 8000d6c:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8000d70:	2604      	movs	r6, #4
  hadc1.Init.NbrOfConversion = 2;
 8000d72:	2402      	movs	r4, #2
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 8000d74:	4628      	mov	r0, r5
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8000d76:	e9c5 7605 	strd	r7, r6, [r5, #20]
  hadc1.Init.DataAlign = ADC_DATAALIGN_LEFT;
 8000d7a:	60eb      	str	r3, [r5, #12]
  hadc1.Init.NbrOfConversion = 2;
 8000d7c:	622c      	str	r4, [r5, #32]
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 8000d7e:	f003 fa8b 	bl	8004298 <HAL_ADC_Init>
 8000d82:	b108      	cbz	r0, 8000d88 <main+0xf0>
 8000d84:	b672      	cpsid	i
  while (1)
 8000d86:	e7fe      	b.n	8000d86 <main+0xee>
  multimode.Mode = ADC_MODE_INDEPENDENT;
 8000d88:	900a      	str	r0, [sp, #40]	@ 0x28
  if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
 8000d8a:	a90a      	add	r1, sp, #40	@ 0x28
 8000d8c:	4628      	mov	r0, r5
 8000d8e:	f004 f8af 	bl	8004ef0 <HAL_ADCEx_MultiModeConfigChannel>
 8000d92:	b108      	cbz	r0, 8000d98 <main+0x100>
 8000d94:	b672      	cpsid	i
  while (1)
 8000d96:	e7fe      	b.n	8000d96 <main+0xfe>
  sConfigInjected.InjectedRank = ADC_INJECTED_RANK_1;
 8000d98:	f8df 81d4 	ldr.w	r8, [pc, #468]	@ 8000f70 <main+0x2d8>
  sConfigInjected.InjectedDiscontinuousConvMode = DISABLE;
 8000d9c:	f8ad 0078 	strh.w	r0, [sp, #120]	@ 0x78
  sConfigInjected.ExternalTrigInjecConv = ADC_EXTERNALTRIGINJEC_T1_TRGO;
 8000da0:	2380      	movs	r3, #128	@ 0x80
  sConfigInjected.ExternalTrigInjecConvEdge = ADC_EXTERNALTRIGINJECCONV_EDGE_RISING;
 8000da2:	e9cd 331f 	strd	r3, r3, [sp, #124]	@ 0x7c
  sConfigInjected.InjectedRank = ADC_INJECTED_RANK_1;
 8000da6:	2309      	movs	r3, #9
 8000da8:	e9cd 8315 	strd	r8, r3, [sp, #84]	@ 0x54
  sConfigInjected.InjectedOffset = 0;
 8000dac:	e9cd 6019 	strd	r6, r0, [sp, #100]	@ 0x64
  sConfigInjected.QueueInjectedContext = DISABLE;
 8000db0:	f88d 007a 	strb.w	r0, [sp, #122]	@ 0x7a
  sConfigInjected.InjecOversamplingMode = DISABLE;
 8000db4:	f88d 0084 	strb.w	r0, [sp, #132]	@ 0x84
  sConfigInjected.InjectedSingleDiff = ADC_SINGLE_ENDED;
 8000db8:	f04f 087f 	mov.w	r8, #127	@ 0x7f
  sConfigInjected.InjectedNbrOfConversion = 3;
 8000dbc:	2303      	movs	r3, #3
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
 8000dbe:	a915      	add	r1, sp, #84	@ 0x54
 8000dc0:	4628      	mov	r0, r5
  sConfigInjected.InjectedSamplingTime = ADC_SAMPLETIME_6CYCLES_5;
 8000dc2:	9717      	str	r7, [sp, #92]	@ 0x5c
  sConfigInjected.InjectedSingleDiff = ADC_SINGLE_ENDED;
 8000dc4:	f8cd 8060 	str.w	r8, [sp, #96]	@ 0x60
  sConfigInjected.InjectedNbrOfConversion = 3;
 8000dc8:	931d      	str	r3, [sp, #116]	@ 0x74
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
 8000dca:	f003 fdb1 	bl	8004930 <HAL_ADCEx_InjectedConfigChannel>
 8000dce:	b108      	cbz	r0, 8000dd4 <main+0x13c>
 8000dd0:	b672      	cpsid	i
  while (1)
 8000dd2:	e7fe      	b.n	8000dd2 <main+0x13a>
  sConfigInjected.InjectedRank = ADC_INJECTED_RANK_2;
 8000dd4:	f8df e19c 	ldr.w	lr, [pc, #412]	@ 8000f74 <main+0x2dc>
 8000dd8:	f240 130f 	movw	r3, #271	@ 0x10f
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
 8000ddc:	a915      	add	r1, sp, #84	@ 0x54
 8000dde:	4628      	mov	r0, r5
  sConfigInjected.InjectedRank = ADC_INJECTED_RANK_2;
 8000de0:	e9cd e315 	strd	lr, r3, [sp, #84]	@ 0x54
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
 8000de4:	f003 fda4 	bl	8004930 <HAL_ADCEx_InjectedConfigChannel>
 8000de8:	b108      	cbz	r0, 8000dee <main+0x156>
 8000dea:	b672      	cpsid	i
  while (1)
 8000dec:	e7fe      	b.n	8000dec <main+0x154>
  sConfigInjected.InjectedRank = ADC_INJECTED_RANK_3;
 8000dee:	f8df c188 	ldr.w	ip, [pc, #392]	@ 8000f78 <main+0x2e0>
 8000df2:	f240 2315 	movw	r3, #533	@ 0x215
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
 8000df6:	a915      	add	r1, sp, #84	@ 0x54
 8000df8:	4628      	mov	r0, r5
  sConfigInjected.InjectedRank = ADC_INJECTED_RANK_3;
 8000dfa:	e9cd c315 	strd	ip, r3, [sp, #84]	@ 0x54
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
 8000dfe:	f003 fd97 	bl	8004930 <HAL_ADCEx_InjectedConfigChannel>
 8000e02:	b108      	cbz	r0, 8000e08 <main+0x170>
 8000e04:	b672      	cpsid	i
  while (1)
 8000e06:	e7fe      	b.n	8000e06 <main+0x16e>
  sConfig.SamplingTime = ADC_SAMPLETIME_47CYCLES_5;
 8000e08:	960f      	str	r6, [sp, #60]	@ 0x3c
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
 8000e0a:	9611      	str	r6, [sp, #68]	@ 0x44
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8000e0c:	4e50      	ldr	r6, [pc, #320]	@ (8000f50 <main+0x2b8>)
  sConfig.Offset = 0;
 8000e0e:	9012      	str	r0, [sp, #72]	@ 0x48
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8000e10:	2306      	movs	r3, #6
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8000e12:	a90d      	add	r1, sp, #52	@ 0x34
 8000e14:	4628      	mov	r0, r5
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8000e16:	e9cd 630d 	strd	r6, r3, [sp, #52]	@ 0x34
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
 8000e1a:	f8cd 8040 	str.w	r8, [sp, #64]	@ 0x40
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8000e1e:	f003 fb35 	bl	800448c <HAL_ADC_ConfigChannel>
 8000e22:	b108      	cbz	r0, 8000e28 <main+0x190>
 8000e24:	b672      	cpsid	i
  while (1)
 8000e26:	e7fe      	b.n	8000e26 <main+0x18e>
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8000e28:	4628      	mov	r0, r5
  sConfig.Rank = ADC_REGULAR_RANK_2;
 8000e2a:	4d4a      	ldr	r5, [pc, #296]	@ (8000f54 <main+0x2bc>)
 8000e2c:	230c      	movs	r3, #12
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8000e2e:	a90d      	add	r1, sp, #52	@ 0x34
  sConfig.Rank = ADC_REGULAR_RANK_2;
 8000e30:	e9cd 530d 	strd	r5, r3, [sp, #52]	@ 0x34
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8000e34:	f003 fb2a 	bl	800448c <HAL_ADC_ConfigChannel>
 8000e38:	b108      	cbz	r0, 8000e3e <main+0x1a6>
 8000e3a:	b672      	cpsid	i
  while (1)
 8000e3c:	e7fe      	b.n	8000e3c <main+0x1a4>
  hcordic.Instance = CORDIC;
 8000e3e:	4846      	ldr	r0, [pc, #280]	@ (8000f58 <main+0x2c0>)
 8000e40:	4b46      	ldr	r3, [pc, #280]	@ (8000f5c <main+0x2c4>)
 8000e42:	6003      	str	r3, [r0, #0]
  if (HAL_CORDIC_Init(&hcordic) != HAL_OK)
 8000e44:	f004 f8ba 	bl	8004fbc <HAL_CORDIC_Init>
 8000e48:	4601      	mov	r1, r0
 8000e4a:	b108      	cbz	r0, 8000e50 <main+0x1b8>
 8000e4c:	b672      	cpsid	i
  while (1)
 8000e4e:	e7fe      	b.n	8000e4e <main+0x1b6>
  hdac1.Instance = DAC1;
 8000e50:	4d43      	ldr	r5, [pc, #268]	@ (8000f60 <main+0x2c8>)
  DAC_ChannelConfTypeDef sConfig = {0};
 8000e52:	2230      	movs	r2, #48	@ 0x30
 8000e54:	a815      	add	r0, sp, #84	@ 0x54
 8000e56:	f009 fa23 	bl	800a2a0 <memset>
  hdac1.Instance = DAC1;
 8000e5a:	4b42      	ldr	r3, [pc, #264]	@ (8000f64 <main+0x2cc>)
 8000e5c:	602b      	str	r3, [r5, #0]
  if (HAL_DAC_Init(&hdac1) != HAL_OK)
 8000e5e:	4628      	mov	r0, r5
 8000e60:	f004 f93c 	bl	80050dc <HAL_DAC_Init>
 8000e64:	4602      	mov	r2, r0
 8000e66:	b108      	cbz	r0, 8000e6c <main+0x1d4>
 8000e68:	b672      	cpsid	i
  while (1)
 8000e6a:	e7fe      	b.n	8000e6a <main+0x1d2>
  if (HAL_DAC_ConfigChannel(&hdac1, &sConfig, DAC_CHANNEL_1) != HAL_OK)
 8000e6c:	4628      	mov	r0, r5
 8000e6e:	a915      	add	r1, sp, #84	@ 0x54
  sConfig.DAC_Trigger = DAC_TRIGGER_SOFTWARE;
 8000e70:	e9cd 2417 	strd	r2, r4, [sp, #92]	@ 0x5c
  sConfig.DAC_Trigger2 = DAC_TRIGGER_NONE;
 8000e74:	e9cd 2419 	strd	r2, r4, [sp, #100]	@ 0x64
  sConfig.DAC_ConnectOnChipPeripheral = DAC_CHIPCONNECT_EXTERNAL;
 8000e78:	971b      	str	r7, [sp, #108]	@ 0x6c
  sConfig.DAC_HighFrequency = DAC_HIGH_FREQUENCY_INTERFACE_MODE_AUTOMATIC;
 8000e7a:	9415      	str	r4, [sp, #84]	@ 0x54
  sConfig.DAC_DMADoubleDataMode = DISABLE;
 8000e7c:	f8ad 2058 	strh.w	r2, [sp, #88]	@ 0x58
  sConfig.DAC_UserTrimming = DAC_TRIMMING_FACTORY;
 8000e80:	921c      	str	r2, [sp, #112]	@ 0x70
  if (HAL_DAC_ConfigChannel(&hdac1, &sConfig, DAC_CHANNEL_1) != HAL_OK)
 8000e82:	f004 f975 	bl	8005170 <HAL_DAC_ConfigChannel>
 8000e86:	b108      	cbz	r0, 8000e8c <main+0x1f4>
 8000e88:	b672      	cpsid	i
  while (1)
 8000e8a:	e7fe      	b.n	8000e8a <main+0x1f2>
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8000e8c:	2500      	movs	r5, #0
  htim1.Instance = TIM1;
 8000e8e:	4c36      	ldr	r4, [pc, #216]	@ (8000f68 <main+0x2d0>)
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8000e90:	9507      	str	r5, [sp, #28]
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};
 8000e92:	4629      	mov	r1, r5
 8000e94:	2234      	movs	r2, #52	@ 0x34
 8000e96:	a815      	add	r0, sp, #84	@ 0x54
  TIMEx_BreakInputConfigTypeDef sBreakInputConfig = {0};
 8000e98:	e9cd 550a 	strd	r5, r5, [sp, #40]	@ 0x28
  TIM_OC_InitTypeDef sConfigOC = {0};
 8000e9c:	e9cd 550c 	strd	r5, r5, [sp, #48]	@ 0x30
 8000ea0:	e9cd 550e 	strd	r5, r5, [sp, #56]	@ 0x38
 8000ea4:	e9cd 5510 	strd	r5, r5, [sp, #64]	@ 0x40
 8000ea8:	e9cd 5512 	strd	r5, r5, [sp, #72]	@ 0x48
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8000eac:	e9cd 5508 	strd	r5, r5, [sp, #32]
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};
 8000eb0:	f009 f9f6 	bl	800a2a0 <memset>
  htim1.Instance = TIM1;
 8000eb4:	4b2d      	ldr	r3, [pc, #180]	@ (8000f6c <main+0x2d4>)
 8000eb6:	6023      	str	r3, [r4, #0]
  htim1.Init.Period = ((PWM_PERIOD_CYCLES) / 2);
 8000eb8:	2120      	movs	r1, #32
 8000eba:	f44f 53a6 	mov.w	r3, #5312	@ 0x14c0
 8000ebe:	e9c4 1302 	strd	r1, r3, [r4, #8]
  htim1.Init.RepetitionCounter = (REP_COUNTER);
 8000ec2:	2601      	movs	r6, #1
 8000ec4:	f44f 7380 	mov.w	r3, #256	@ 0x100
  if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
 8000ec8:	4620      	mov	r0, r4
  htim1.Init.RepetitionCounter = (REP_COUNTER);
 8000eca:	e9c4 3604 	strd	r3, r6, [r4, #16]
  htim1.Init.Prescaler = ((TIM_CLOCK_DIVIDER) - 1);
 8000ece:	6065      	str	r5, [r4, #4]
  htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8000ed0:	61a5      	str	r5, [r4, #24]
  if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
 8000ed2:	f005 faf7 	bl	80064c4 <HAL_TIM_PWM_Init>
 8000ed6:	b108      	cbz	r0, 8000edc <main+0x244>
 8000ed8:	b672      	cpsid	i
  while (1)
 8000eda:	e7fe      	b.n	8000eda <main+0x242>
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8000edc:	e9cd 0008 	strd	r0, r0, [sp, #32]
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_OC4REF;
 8000ee0:	2570      	movs	r5, #112	@ 0x70
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 8000ee2:	a907      	add	r1, sp, #28
 8000ee4:	4620      	mov	r0, r4
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_OC4REF;
 8000ee6:	9507      	str	r5, [sp, #28]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 8000ee8:	f005 fe20 	bl	8006b2c <HAL_TIMEx_MasterConfigSynchronization>
 8000eec:	b108      	cbz	r0, 8000ef2 <main+0x25a>
 8000eee:	b672      	cpsid	i
  while (1)
 8000ef0:	e7fe      	b.n	8000ef0 <main+0x258>
  if (HAL_TIMEx_ConfigBreakInput(&htim1, TIM_BREAKINPUT_BRK, &sBreakInputConfig) != HAL_OK)
 8000ef2:	aa0a      	add	r2, sp, #40	@ 0x28
 8000ef4:	4631      	mov	r1, r6
 8000ef6:	4620      	mov	r0, r4
  sBreakInputConfig.Enable = TIM_BREAKINPUTSOURCE_ENABLE;
 8000ef8:	e9cd 660a 	strd	r6, r6, [sp, #40]	@ 0x28
  sBreakInputConfig.Polarity = TIM_BREAKINPUTSOURCE_POLARITY_LOW;
 8000efc:	960c      	str	r6, [sp, #48]	@ 0x30
  if (HAL_TIMEx_ConfigBreakInput(&htim1, TIM_BREAKINPUT_BRK, &sBreakInputConfig) != HAL_OK)
 8000efe:	f005 feb5 	bl	8006c6c <HAL_TIMEx_ConfigBreakInput>
 8000f02:	4602      	mov	r2, r0
 8000f04:	b108      	cbz	r0, 8000f0a <main+0x272>
 8000f06:	b672      	cpsid	i
  while (1)
 8000f08:	e7fe      	b.n	8000f08 <main+0x270>
  sConfigOC.Pulse = ((PWM_PERIOD_CYCLES) / 4);
 8000f0a:	f44f 6326 	mov.w	r3, #2656	@ 0xa60
 8000f0e:	f04f 0860 	mov.w	r8, #96	@ 0x60
  sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
 8000f12:	e9cd 0011 	strd	r0, r0, [sp, #68]	@ 0x44
  sConfigOC.Pulse = ((PWM_PERIOD_CYCLES) / 4);
 8000f16:	e9cd 830d 	strd	r8, r3, [sp, #52]	@ 0x34
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8000f1a:	900f      	str	r0, [sp, #60]	@ 0x3c
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_LOW;
 8000f1c:	2708      	movs	r7, #8
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_SET;
 8000f1e:	f44f 7300 	mov.w	r3, #512	@ 0x200
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8000f22:	a90d      	add	r1, sp, #52	@ 0x34
 8000f24:	4620      	mov	r0, r4
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_LOW;
 8000f26:	9710      	str	r7, [sp, #64]	@ 0x40
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_SET;
 8000f28:	9313      	str	r3, [sp, #76]	@ 0x4c
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8000f2a:	f005 fd19 	bl	8006960 <HAL_TIM_PWM_ConfigChannel>
 8000f2e:	b108      	cbz	r0, 8000f34 <main+0x29c>
 8000f30:	b672      	cpsid	i
  while (1)
 8000f32:	e7fe      	b.n	8000f32 <main+0x29a>
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 8000f34:	2204      	movs	r2, #4
 8000f36:	a90d      	add	r1, sp, #52	@ 0x34
 8000f38:	4620      	mov	r0, r4
 8000f3a:	f005 fd11 	bl	8006960 <HAL_TIM_PWM_ConfigChannel>
 8000f3e:	b1e8      	cbz	r0, 8000f7c <main+0x2e4>
 8000f40:	b672      	cpsid	i
  while (1)
 8000f42:	e7fe      	b.n	8000f42 <main+0x2aa>
 8000f44:	40021000 	.word	0x40021000
 8000f48:	48000800 	.word	0x48000800
 8000f4c:	200006e4 	.word	0x200006e4
 8000f50:	08600004 	.word	0x08600004
 8000f54:	21800100 	.word	0x21800100
 8000f58:	200006bc 	.word	0x200006bc
 8000f5c:	40020c00 	.word	0x40020c00
 8000f60:	200006a8 	.word	0x200006a8
 8000f64:	50000800 	.word	0x50000800
 8000f68:	2000065c 	.word	0x2000065c
 8000f6c:	40012c00 	.word	0x40012c00
 8000f70:	04300002 	.word	0x04300002
 8000f74:	1d500080 	.word	0x1d500080
 8000f78:	19200040 	.word	0x19200040
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
 8000f7c:	463a      	mov	r2, r7
 8000f7e:	a90d      	add	r1, sp, #52	@ 0x34
 8000f80:	4620      	mov	r0, r4
 8000f82:	f005 fced 	bl	8006960 <HAL_TIM_PWM_ConfigChannel>
 8000f86:	b108      	cbz	r0, 8000f8c <main+0x2f4>
 8000f88:	b672      	cpsid	i
  while (1)
 8000f8a:	e7fe      	b.n	8000f8a <main+0x2f2>
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
 8000f8c:	9010      	str	r0, [sp, #64]	@ 0x40
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
 8000f8e:	9013      	str	r0, [sp, #76]	@ 0x4c
  sConfigOC.Pulse = (((PWM_PERIOD_CYCLES) / 2) - (HTMIN));
 8000f90:	f241 43bf 	movw	r3, #5311	@ 0x14bf
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
 8000f94:	220c      	movs	r2, #12
 8000f96:	a90d      	add	r1, sp, #52	@ 0x34
 8000f98:	4620      	mov	r0, r4
  sConfigOC.OCMode = TIM_OCMODE_PWM2;
 8000f9a:	950d      	str	r5, [sp, #52]	@ 0x34
  sConfigOC.Pulse = (((PWM_PERIOD_CYCLES) / 2) - (HTMIN));
 8000f9c:	930e      	str	r3, [sp, #56]	@ 0x38
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
 8000f9e:	f005 fcdf 	bl	8006960 <HAL_TIM_PWM_ConfigChannel>
 8000fa2:	b108      	cbz	r0, 8000fa8 <main+0x310>
 8000fa4:	b672      	cpsid	i
  while (1)
 8000fa6:	e7fe      	b.n	8000fa6 <main+0x30e>
  sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_ENABLE;
 8000fa8:	f44f 6500 	mov.w	r5, #2048	@ 0x800
 8000fac:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8000fb0:	e9cd 5315 	strd	r5, r3, [sp, #84]	@ 0x54
  sBreakDeadTimeConfig.BreakState = TIM_BREAK_ENABLE;
 8000fb4:	f04f 0c48 	mov.w	ip, #72	@ 0x48
 8000fb8:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8000fbc:	e9cd c318 	strd	ip, r3, [sp, #96]	@ 0x60
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 8000fc0:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
  sBreakDeadTimeConfig.Break2State = TIM_BREAK2_DISABLE;
 8000fc4:	e9cd 001c 	strd	r0, r0, [sp, #112]	@ 0x70
  sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
 8000fc8:	e9cd 0020 	strd	r0, r0, [sp, #128]	@ 0x80
  sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
 8000fcc:	9017      	str	r0, [sp, #92]	@ 0x5c
  sBreakDeadTimeConfig.BreakFilter = 3;
 8000fce:	2703      	movs	r7, #3
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 8000fd0:	931a      	str	r3, [sp, #104]	@ 0x68
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 8000fd2:	a915      	add	r1, sp, #84	@ 0x54
  sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;
 8000fd4:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 8000fd8:	4620      	mov	r0, r4
  sBreakDeadTimeConfig.BreakFilter = 3;
 8000fda:	971b      	str	r7, [sp, #108]	@ 0x6c
  sBreakDeadTimeConfig.Break2Filter = 3;
 8000fdc:	971f      	str	r7, [sp, #124]	@ 0x7c
  sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;
 8000fde:	931e      	str	r3, [sp, #120]	@ 0x78
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 8000fe0:	f005 fdf6 	bl	8006bd0 <HAL_TIMEx_ConfigBreakDeadTime>
 8000fe4:	4605      	mov	r5, r0
 8000fe6:	b108      	cbz	r0, 8000fec <main+0x354>
 8000fe8:	b672      	cpsid	i
  while (1)
 8000fea:	e7fe      	b.n	8000fea <main+0x352>
  HAL_TIM_MspPostInit(&htim1);
 8000fec:	4620      	mov	r0, r4
 8000fee:	f002 ff3f 	bl	8003e70 <HAL_TIM_MspPostInit>
  htim2.Instance = TIM2;
 8000ff2:	4c5d      	ldr	r4, [pc, #372]	@ (8001168 <main+0x4d0>)
  sConfig.EncoderMode = TIM_ENCODERMODE_TI12;
 8000ff4:	9715      	str	r7, [sp, #84]	@ 0x54
  sConfig.IC1Filter = M1_ENC_IC_FILTER;
 8000ff6:	230c      	movs	r3, #12
 8000ff8:	9319      	str	r3, [sp, #100]	@ 0x64
  sConfig.IC2Filter = M1_ENC_IC_FILTER;
 8000ffa:	931d      	str	r3, [sp, #116]	@ 0x74
  htim2.Instance = TIM2;
 8000ffc:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8001000:	6023      	str	r3, [r4, #0]
  if (HAL_TIM_Encoder_Init(&htim2, &sConfig) != HAL_OK)
 8001002:	a915      	add	r1, sp, #84	@ 0x54
  htim2.Init.Period = M1_PULSE_NBR;
 8001004:	f641 73ff 	movw	r3, #8191	@ 0x1fff
  if (HAL_TIM_Encoder_Init(&htim2, &sConfig) != HAL_OK)
 8001008:	4620      	mov	r0, r4
  htim2.Init.Period = M1_PULSE_NBR;
 800100a:	60e3      	str	r3, [r4, #12]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 800100c:	e9cd 550d 	strd	r5, r5, [sp, #52]	@ 0x34
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 8001010:	e9c4 5501 	strd	r5, r5, [r4, #4]
  TIM_Encoder_InitTypeDef sConfig = {0};
 8001014:	9516      	str	r5, [sp, #88]	@ 0x58
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8001016:	950f      	str	r5, [sp, #60]	@ 0x3c
  sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
 8001018:	9617      	str	r6, [sp, #92]	@ 0x5c
  sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
 800101a:	961b      	str	r6, [sp, #108]	@ 0x6c
  TIM_Encoder_InitTypeDef sConfig = {0};
 800101c:	9518      	str	r5, [sp, #96]	@ 0x60
 800101e:	951a      	str	r5, [sp, #104]	@ 0x68
 8001020:	951c      	str	r5, [sp, #112]	@ 0x70
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8001022:	6125      	str	r5, [r4, #16]
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8001024:	61a5      	str	r5, [r4, #24]
  if (HAL_TIM_Encoder_Init(&htim2, &sConfig) != HAL_OK)
 8001026:	f005 facb 	bl	80065c0 <HAL_TIM_Encoder_Init>
 800102a:	4603      	mov	r3, r0
 800102c:	b108      	cbz	r0, 8001032 <main+0x39a>
 800102e:	b672      	cpsid	i
  while (1)
 8001030:	e7fe      	b.n	8001030 <main+0x398>
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 8001032:	a90d      	add	r1, sp, #52	@ 0x34
 8001034:	4620      	mov	r0, r4
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8001036:	930d      	str	r3, [sp, #52]	@ 0x34
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8001038:	930f      	str	r3, [sp, #60]	@ 0x3c
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 800103a:	f005 fd77 	bl	8006b2c <HAL_TIMEx_MasterConfigSynchronization>
 800103e:	b108      	cbz	r0, 8001044 <main+0x3ac>
 8001040:	b672      	cpsid	i
  while (1)
 8001042:	e7fe      	b.n	8001042 <main+0x3aa>
  huart2.Instance = USART2;
 8001044:	4c49      	ldr	r4, [pc, #292]	@ (800116c <main+0x4d4>)
  huart2.Init.BaudRate = 115200;
 8001046:	494a      	ldr	r1, [pc, #296]	@ (8001170 <main+0x4d8>)
 8001048:	f44f 32e1 	mov.w	r2, #115200	@ 0x1c200
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 800104c:	2300      	movs	r3, #0
  huart2.Init.BaudRate = 115200;
 800104e:	e9c4 1200 	strd	r1, r2, [r4]
  if (HAL_UART_Init(&huart2) != HAL_OK)
 8001052:	4620      	mov	r0, r4
  huart2.Init.Mode = UART_MODE_TX_RX;
 8001054:	220c      	movs	r2, #12
  huart2.Init.StopBits = UART_STOPBITS_1;
 8001056:	e9c4 3302 	strd	r3, r3, [r4, #8]
  huart2.Init.Mode = UART_MODE_TX_RX;
 800105a:	e9c4 3204 	strd	r3, r2, [r4, #16]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 800105e:	e9c4 3306 	strd	r3, r3, [r4, #24]
  huart2.Init.ClockPrescaler = UART_PRESCALER_DIV1;
 8001062:	e9c4 3308 	strd	r3, r3, [r4, #32]
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8001066:	62a3      	str	r3, [r4, #40]	@ 0x28
  if (HAL_UART_Init(&huart2) != HAL_OK)
 8001068:	f006 f934 	bl	80072d4 <HAL_UART_Init>
 800106c:	4601      	mov	r1, r0
 800106e:	b108      	cbz	r0, 8001074 <main+0x3dc>
 8001070:	b672      	cpsid	i
  while (1)
 8001072:	e7fe      	b.n	8001072 <main+0x3da>
  if (HAL_UARTEx_SetTxFifoThreshold(&huart2, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 8001074:	4620      	mov	r0, r4
 8001076:	f006 f97f 	bl	8007378 <HAL_UARTEx_SetTxFifoThreshold>
 800107a:	4601      	mov	r1, r0
 800107c:	b108      	cbz	r0, 8001082 <main+0x3ea>
 800107e:	b672      	cpsid	i
  while (1)
 8001080:	e7fe      	b.n	8001080 <main+0x3e8>
  if (HAL_UARTEx_SetRxFifoThreshold(&huart2, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 8001082:	4620      	mov	r0, r4
 8001084:	f006 f9ba 	bl	80073fc <HAL_UARTEx_SetRxFifoThreshold>
 8001088:	b108      	cbz	r0, 800108e <main+0x3f6>
 800108a:	b672      	cpsid	i
  while (1)
 800108c:	e7fe      	b.n	800108c <main+0x3f4>
  if (HAL_UARTEx_DisableFifoMode(&huart2) != HAL_OK)
 800108e:	4620      	mov	r0, r4
 8001090:	f006 f954 	bl	800733c <HAL_UARTEx_DisableFifoMode>
 8001094:	4605      	mov	r5, r0
 8001096:	b108      	cbz	r0, 800109c <main+0x404>
 8001098:	b672      	cpsid	i
  while (1)
 800109a:	e7fe      	b.n	800109a <main+0x402>
  MX_MotorControl_Init();
 800109c:	f001 f8ae 	bl	80021fc <MX_MotorControl_Init>
  HAL_NVIC_SetPriority(USART2_IRQn, 8, 0);
 80010a0:	462a      	mov	r2, r5
 80010a2:	2108      	movs	r1, #8
 80010a4:	2026      	movs	r0, #38	@ 0x26
 80010a6:	f003 ffb5 	bl	8005014 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(USART2_IRQn);
 80010aa:	2026      	movs	r0, #38	@ 0x26
 80010ac:	f003 ffee 	bl	800508c <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 8, 0);
 80010b0:	462a      	mov	r2, r5
 80010b2:	2108      	movs	r1, #8
 80010b4:	200b      	movs	r0, #11
 80010b6:	f003 ffad 	bl	8005014 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
 80010ba:	200b      	movs	r0, #11
 80010bc:	f003 ffe6 	bl	800508c <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(TIM1_BRK_TIM15_IRQn, 9, 0);
 80010c0:	462a      	mov	r2, r5
 80010c2:	2109      	movs	r1, #9
 80010c4:	2018      	movs	r0, #24
 80010c6:	f003 ffa5 	bl	8005014 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(TIM1_BRK_TIM15_IRQn);
 80010ca:	2018      	movs	r0, #24
 80010cc:	f003 ffde 	bl	800508c <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(TIM1_UP_TIM16_IRQn, 5, 0);
 80010d0:	462a      	mov	r2, r5
 80010d2:	2105      	movs	r1, #5
 80010d4:	2019      	movs	r0, #25
 80010d6:	f003 ff9d 	bl	8005014 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(TIM1_UP_TIM16_IRQn);
 80010da:	2019      	movs	r0, #25
 80010dc:	f003 ffd6 	bl	800508c <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(ADC1_2_IRQn, 7, 0);
 80010e0:	462a      	mov	r2, r5
 80010e2:	2107      	movs	r1, #7
 80010e4:	2012      	movs	r0, #18
 80010e6:	f003 ff95 	bl	8005014 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(ADC1_2_IRQn);
 80010ea:	2012      	movs	r0, #18
 80010ec:	f003 ffce 	bl	800508c <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(TIM2_IRQn, 8, 0);
 80010f0:	462a      	mov	r2, r5
 80010f2:	2108      	movs	r1, #8
 80010f4:	201c      	movs	r0, #28
 80010f6:	f003 ff8d 	bl	8005014 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(TIM2_IRQn);
 80010fa:	201c      	movs	r0, #28
 80010fc:	f003 ffc6 	bl	800508c <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(EXTI15_10_IRQn, 8, 0);
 8001100:	462a      	mov	r2, r5
 8001102:	2108      	movs	r1, #8
 8001104:	2028      	movs	r0, #40	@ 0x28
 8001106:	f003 ff85 	bl	8005014 <HAL_NVIC_SetPriority>
  targetPosition = degreesToRadians(90.0f);  // Set target position to 90 degrees
 800110a:	4f1a      	ldr	r7, [pc, #104]	@ (8001174 <main+0x4dc>)
  osThreadDef(mediumFrequency, startMediumFrequencyTask, osPriorityNormal, 0, 128);
 800110c:	4c1a      	ldr	r4, [pc, #104]	@ (8001178 <main+0x4e0>)
  HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
 800110e:	2028      	movs	r0, #40	@ 0x28
 8001110:	f003 ffbc 	bl	800508c <HAL_NVIC_EnableIRQ>
  targetPosition = degreesToRadians(90.0f);  // Set target position to 90 degrees
 8001114:	4b19      	ldr	r3, [pc, #100]	@ (800117c <main+0x4e4>)
 8001116:	603b      	str	r3, [r7, #0]
  startMotor = true;
 8001118:	4b19      	ldr	r3, [pc, #100]	@ (8001180 <main+0x4e8>)
 800111a:	2201      	movs	r2, #1
 800111c:	701a      	strb	r2, [r3, #0]
  osThreadDef(mediumFrequency, startMediumFrequencyTask, osPriorityNormal, 0, 128);
 800111e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8001120:	ae0d      	add	r6, sp, #52	@ 0x34
 8001122:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8001124:	f854 3b04 	ldr.w	r3, [r4], #4
 8001128:	6033      	str	r3, [r6, #0]
  mediumFrequencyHandle = osThreadCreate(osThread(mediumFrequency), NULL);
 800112a:	4629      	mov	r1, r5
 800112c:	a80d      	add	r0, sp, #52	@ 0x34
 800112e:	f006 f9ad 	bl	800748c <osThreadCreate>
 8001132:	4b14      	ldr	r3, [pc, #80]	@ (8001184 <main+0x4ec>)
 8001134:	6018      	str	r0, [r3, #0]
  osThreadDef(safety, StartSafetyTask, osPriorityAboveNormal, 0, 128);
 8001136:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8001138:	ae15      	add	r6, sp, #84	@ 0x54
 800113a:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 800113c:	6823      	ldr	r3, [r4, #0]
 800113e:	6033      	str	r3, [r6, #0]
  safetyHandle = osThreadCreate(osThread(safety), NULL);
 8001140:	4629      	mov	r1, r5
 8001142:	a815      	add	r0, sp, #84	@ 0x54
 8001144:	f006 f9a2 	bl	800748c <osThreadCreate>
 8001148:	4b0f      	ldr	r3, [pc, #60]	@ (8001188 <main+0x4f0>)
 800114a:	6018      	str	r0, [r3, #0]
  MC_StartMotor1();
 800114c:	f7ff fd50 	bl	8000bf0 <MC_StartMotor1>
  MC_ProgramPositionCommandMotor1(targetPosition, 0); // Immediate movement
 8001150:	eddf 0a0e 	vldr	s1, [pc, #56]	@ 800118c <main+0x4f4>
 8001154:	ed97 0a00 	vldr	s0, [r7]
 8001158:	f7ff fd56 	bl	8000c08 <MC_ProgramPositionCommandMotor1>
  MC_StopMotor1();
 800115c:	f7ff fd4e 	bl	8000bfc <MC_StopMotor1>
  osKernelStart();
 8001160:	f006 f98e 	bl	8007480 <osKernelStart>
  while (1)
 8001164:	e7fe      	b.n	8001164 <main+0x4cc>
 8001166:	bf00      	nop
 8001168:	20000610 	.word	0x20000610
 800116c:	2000057c 	.word	0x2000057c
 8001170:	40004400 	.word	0x40004400
 8001174:	200004b0 	.word	0x200004b0
 8001178:	0800a32c 	.word	0x0800a32c
 800117c:	3fc90fdb 	.word	0x3fc90fdb
 8001180:	200004ac 	.word	0x200004ac
 8001184:	200004b8 	.word	0x200004b8
 8001188:	200004b4 	.word	0x200004b4
 800118c:	00000000 	.word	0x00000000

08001190 <HAL_TIM_PeriodElapsedCallback>:
  if (htim->Instance == TIM6) {
 8001190:	4b03      	ldr	r3, [pc, #12]	@ (80011a0 <HAL_TIM_PeriodElapsedCallback+0x10>)
 8001192:	6802      	ldr	r2, [r0, #0]
 8001194:	429a      	cmp	r2, r3
 8001196:	d000      	beq.n	800119a <HAL_TIM_PeriodElapsedCallback+0xa>
}
 8001198:	4770      	bx	lr
    HAL_IncTick();
 800119a:	f003 b86b 	b.w	8004274 <HAL_IncTick>
 800119e:	bf00      	nop
 80011a0:	40001000 	.word	0x40001000

080011a4 <Error_Handler>:
 80011a4:	b672      	cpsid	i
  while (1)
 80011a6:	e7fe      	b.n	80011a6 <Error_Handler+0x2>

080011a8 <MC_APP_BootHook>:
   */

/* USER CODE BEGIN BootHook */

/* USER CODE END BootHook */
}
 80011a8:	4770      	bx	lr
 80011aa:	bf00      	nop

080011ac <MC_APP_PostMediumFrequencyHook_M1>:
 * @brief Hook function called right after the Medium Frequency Task for Motor 1.
 *
 *
 *
 */
__weak void MC_APP_PostMediumFrequencyHook_M1(void)
 80011ac:	4770      	bx	lr
 80011ae:	bf00      	nop

080011b0 <MCI_ExecSpeedRamp>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->lastCommand = MCI_CMD_EXECSPEEDRAMP;
 80011b0:	f04f 0c01 	mov.w	ip, #1
    pHandle->hFinalSpeed = hFinalSpeed;
    pHandle->hDurationms = hDurationms;
    pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 80011b4:	f240 3301 	movw	r3, #769	@ 0x301
    pHandle->lastCommand = MCI_CMD_EXECSPEEDRAMP;
 80011b8:	f880 c010 	strb.w	ip, [r0, #16]
    pHandle->hFinalSpeed = hFinalSpeed;
 80011bc:	8241      	strh	r1, [r0, #18]
    pHandle->hDurationms = hDurationms;
 80011be:	8402      	strh	r2, [r0, #32]
    pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 80011c0:	8503      	strh	r3, [r0, #40]	@ 0x28
    pHandle->LastModalitySetByUser = MCM_SPEED_MODE;

#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
}
 80011c2:	4770      	bx	lr

080011c4 <MCI_ExecTorqueRamp>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->lastCommand = MCI_CMD_EXECTORQUERAMP;
 80011c4:	f04f 0c02 	mov.w	ip, #2
    pHandle->hFinalTorque = hFinalTorque;
    pHandle->hDurationms = hDurationms;
    pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 80011c8:	f240 4301 	movw	r3, #1025	@ 0x401
    pHandle->lastCommand = MCI_CMD_EXECTORQUERAMP;
 80011cc:	f880 c010 	strb.w	ip, [r0, #16]
    pHandle->hFinalTorque = hFinalTorque;
 80011d0:	8281      	strh	r1, [r0, #20]
    pHandle->hDurationms = hDurationms;
 80011d2:	8402      	strh	r2, [r0, #32]
    pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 80011d4:	8503      	strh	r3, [r0, #40]	@ 0x28
    pHandle->LastModalitySetByUser = MCM_TORQUE_MODE;
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
}
 80011d6:	4770      	bx	lr

080011d8 <MCI_SetCurrentReferences>:
  * function.

  @sa MCI_SetCurrentReferences_F
  */
__weak void MCI_SetCurrentReferences(MCI_Handle_t *pHandle, qd_t Iqdref)
{
 80011d8:	b082      	sub	sp, #8
  }
  else
  {
#endif

    pHandle->lastCommand = MCI_CMD_SETCURRENTREFERENCES;
 80011da:	2203      	movs	r2, #3
    pHandle->Iqdref.q = Iqdref.q;
    pHandle->Iqdref.d = Iqdref.d;
    pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 80011dc:	f240 4301 	movw	r3, #1025	@ 0x401
    pHandle->lastCommand = MCI_CMD_SETCURRENTREFERENCES;
 80011e0:	7402      	strb	r2, [r0, #16]
    pHandle->Iqdref.q = Iqdref.q;
 80011e2:	f8c0 1016 	str.w	r1, [r0, #22]
    pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 80011e6:	8503      	strh	r3, [r0, #40]	@ 0x28
    pHandle->LastModalitySetByUser = MCM_TORQUE_MODE;
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
}
 80011e8:	b002      	add	sp, #8
 80011ea:	4770      	bx	lr

080011ec <MCI_ExecPositionCommand>:
  *
  * Users can check the status of the command by calling the MCI_IsCommandAcknowledged()
  * function.
  */
__weak void MCI_ExecPositionCommand(MCI_Handle_t *pHandle, float_t FinalPosition, float_t Duration)
{
 80011ec:	b510      	push	{r4, lr}
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->pFOCVars->bDriveInput = INTERNAL;
 80011ee:	6843      	ldr	r3, [r0, #4]
 80011f0:	2200      	movs	r2, #0
{
 80011f2:	ed2d 8b02 	vpush	{d8}
    pHandle->pFOCVars->bDriveInput = INTERNAL;
 80011f6:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
static inline SpeednPosFdbk_Handle_t *STC_GetSpeedSensor(SpeednTorqCtrl_Handle_t *pHandle)
{
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  return ((MC_NULL ==  pHandle) ? MC_NULL : pHandle->SPD);
#else
  return (pHandle->SPD);
 80011fa:	6803      	ldr	r3, [r0, #0]
{
 80011fc:	b082      	sub	sp, #8
 80011fe:	4604      	mov	r4, r0
    float_t currentPositionRad = (float_t)(SPD_GetMecAngle(STC_GetSpeedSensor(pHandle->pSTC))) / RADTOS16;
 8001200:	6958      	ldr	r0, [r3, #20]
{
 8001202:	eeb0 8a60 	vmov.f32	s16, s1
 8001206:	eef0 8a40 	vmov.f32	s17, s0
    float_t currentPositionRad = (float_t)(SPD_GetMecAngle(STC_GetSpeedSensor(pHandle->pSTC))) / RADTOS16;
 800120a:	f008 fc89 	bl	8009b20 <SPD_GetMecAngle>
    if (Duration > 0)
 800120e:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8001212:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    float_t currentPositionRad = (float_t)(SPD_GetMecAngle(STC_GetSpeedSensor(pHandle->pSTC))) / RADTOS16;
 8001216:	9001      	str	r0, [sp, #4]
    if (Duration > 0)
 8001218:	dd15      	ble.n	8001246 <MCI_ExecPositionCommand+0x5a>
    float_t currentPositionRad = (float_t)(SPD_GetMecAngle(STC_GetSpeedSensor(pHandle->pSTC))) / RADTOS16;
 800121a:	ee07 0a90 	vmov	s15, r0
 800121e:	ed9f 7a0d 	vldr	s14, [pc, #52]	@ 8001254 <MCI_ExecPositionCommand+0x68>
    {
      TC_MoveCommand(pHandle->pPosCtrl, currentPositionRad, FinalPosition - currentPositionRad, Duration);
 8001222:	68e0      	ldr	r0, [r4, #12]
    float_t currentPositionRad = (float_t)(SPD_GetMecAngle(STC_GetSpeedSensor(pHandle->pSTC))) / RADTOS16;
 8001224:	eef8 7ae7 	vcvt.f32.s32	s15, s15
      TC_MoveCommand(pHandle->pPosCtrl, currentPositionRad, FinalPosition - currentPositionRad, Duration);
 8001228:	eeb0 1a48 	vmov.f32	s2, s16
    float_t currentPositionRad = (float_t)(SPD_GetMecAngle(STC_GetSpeedSensor(pHandle->pSTC))) / RADTOS16;
 800122c:	ee27 0a87 	vmul.f32	s0, s15, s14
      TC_MoveCommand(pHandle->pPosCtrl, currentPositionRad, FinalPosition - currentPositionRad, Duration);
 8001230:	ee78 0ac0 	vsub.f32	s1, s17, s0
 8001234:	f008 fdaa 	bl	8009d8c <TC_MoveCommand>
    else
    {
      TC_FollowCommand(pHandle->pPosCtrl, FinalPosition);
    }

    pHandle->LastModalitySetByUser = MCM_TORQUE_MODE;
 8001238:	2304      	movs	r3, #4
 800123a:	f884 3029 	strb.w	r3, [r4, #41]	@ 0x29
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
}
 800123e:	b002      	add	sp, #8
 8001240:	ecbd 8b02 	vpop	{d8}
 8001244:	bd10      	pop	{r4, pc}
      TC_FollowCommand(pHandle->pPosCtrl, FinalPosition);
 8001246:	68e0      	ldr	r0, [r4, #12]
 8001248:	eeb0 0a68 	vmov.f32	s0, s17
 800124c:	f008 fe10 	bl	8009e70 <TC_FollowCommand>
 8001250:	e7f2      	b.n	8001238 <MCI_ExecPositionCommand+0x4c>
 8001252:	bf00      	nop
 8001254:	38c90fdb 	.word	0x38c90fdb

08001258 <MCI_FaultProcessing>:
  }
  else
  {
#endif
    /* Set current errors */
    pHandle->CurrentFaults = (pHandle->CurrentFaults | hSetErrors ) & (~hResetErrors);
 8001258:	8c83      	ldrh	r3, [r0, #36]	@ 0x24
    pHandle->PastFaults |= hSetErrors;
 800125a:	f8b0 c026 	ldrh.w	ip, [r0, #38]	@ 0x26
    pHandle->CurrentFaults = (pHandle->CurrentFaults | hSetErrors ) & (~hResetErrors);
 800125e:	430b      	orrs	r3, r1
 8001260:	ea23 0302 	bic.w	r3, r3, r2
    pHandle->PastFaults |= hSetErrors;
 8001264:	ea41 010c 	orr.w	r1, r1, ip
    pHandle->CurrentFaults = (pHandle->CurrentFaults | hSetErrors ) & (~hResetErrors);
 8001268:	8483      	strh	r3, [r0, #36]	@ 0x24
    pHandle->PastFaults |= hSetErrors;
 800126a:	84c1      	strh	r1, [r0, #38]	@ 0x26
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
}
 800126c:	4770      	bx	lr
 800126e:	bf00      	nop

08001270 <MCI_ExecBufferedCommands>:
    /* Nothing to do */
  }
  else
  {
#endif
    if ( pHandle->CommandState == MCI_COMMAND_NOT_ALREADY_EXECUTED )
 8001270:	f890 3028 	ldrb.w	r3, [r0, #40]	@ 0x28
 8001274:	2b01      	cmp	r3, #1
 8001276:	d000      	beq.n	800127a <MCI_ExecBufferedCommands+0xa>
 8001278:	4770      	bx	lr
{
 800127a:	b510      	push	{r4, lr}
    {
      bool commandHasBeenExecuted = false;
      switch (pHandle->lastCommand)
 800127c:	7c02      	ldrb	r2, [r0, #16]
 800127e:	2a02      	cmp	r2, #2
 8001280:	4604      	mov	r4, r0
 8001282:	d007      	beq.n	8001294 <MCI_ExecBufferedCommands+0x24>
 8001284:	2a03      	cmp	r2, #3
 8001286:	d028      	beq.n	80012da <MCI_ExecBufferedCommands+0x6a>
 8001288:	2a01      	cmp	r2, #1
 800128a:	d017      	beq.n	80012bc <MCI_ExecBufferedCommands+0x4c>
      {
        pHandle->CommandState = MCI_COMMAND_EXECUTED_SUCCESSFULLY;
      }
      else
      {
        pHandle->CommandState = MCI_COMMAND_EXECUTED_UNSUCCESSFULLY;
 800128c:	2303      	movs	r3, #3
 800128e:	f884 3028 	strb.w	r3, [r4, #40]	@ 0x28
      }
    }
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
}
 8001292:	bd10      	pop	{r4, pc}
          pHandle->pFOCVars->bDriveInput = INTERNAL;
 8001294:	6843      	ldr	r3, [r0, #4]
 8001296:	2200      	movs	r2, #0
 8001298:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
          STC_SetControlMode(pHandle->pSTC, MCM_TORQUE_MODE);
 800129c:	6800      	ldr	r0, [r0, #0]
 800129e:	2104      	movs	r1, #4
 80012a0:	f008 fca8 	bl	8009bf4 <STC_SetControlMode>
          commandHasBeenExecuted = STC_ExecRamp(pHandle->pSTC, pHandle->hFinalTorque, pHandle->hDurationms);
 80012a4:	8c22      	ldrh	r2, [r4, #32]
 80012a6:	f9b4 1014 	ldrsh.w	r1, [r4, #20]
 80012aa:	6820      	ldr	r0, [r4, #0]
 80012ac:	f008 fca6 	bl	8009bfc <STC_ExecRamp>
      if (commandHasBeenExecuted)
 80012b0:	2800      	cmp	r0, #0
 80012b2:	d0eb      	beq.n	800128c <MCI_ExecBufferedCommands+0x1c>
        pHandle->CommandState = MCI_COMMAND_EXECUTED_SUCCESSFULLY;
 80012b4:	2302      	movs	r3, #2
 80012b6:	f884 3028 	strb.w	r3, [r4, #40]	@ 0x28
}
 80012ba:	bd10      	pop	{r4, pc}
          pHandle->pFOCVars->bDriveInput = INTERNAL;
 80012bc:	6843      	ldr	r3, [r0, #4]
 80012be:	2200      	movs	r2, #0
 80012c0:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
          STC_SetControlMode(pHandle->pSTC, MCM_SPEED_MODE);
 80012c4:	6800      	ldr	r0, [r0, #0]
 80012c6:	2103      	movs	r1, #3
 80012c8:	f008 fc94 	bl	8009bf4 <STC_SetControlMode>
          commandHasBeenExecuted = STC_ExecRamp(pHandle->pSTC, pHandle->hFinalSpeed, pHandle->hDurationms);
 80012cc:	8c22      	ldrh	r2, [r4, #32]
 80012ce:	f9b4 1012 	ldrsh.w	r1, [r4, #18]
 80012d2:	6820      	ldr	r0, [r4, #0]
 80012d4:	f008 fc92 	bl	8009bfc <STC_ExecRamp>
          break;
 80012d8:	e7ea      	b.n	80012b0 <MCI_ExecBufferedCommands+0x40>
          pHandle->pFOCVars->bDriveInput = EXTERNAL;
 80012da:	6842      	ldr	r2, [r0, #4]
 80012dc:	f882 3024 	strb.w	r3, [r2, #36]	@ 0x24
          pHandle->pFOCVars->Iqdref = pHandle->Iqdref;
 80012e0:	f8d0 3016 	ldr.w	r3, [r0, #22]
 80012e4:	6113      	str	r3, [r2, #16]
      if (commandHasBeenExecuted)
 80012e6:	e7e5      	b.n	80012b4 <MCI_ExecBufferedCommands+0x44>

080012e8 <MCI_GetSTMState>:
#ifdef NULL_PTR_CHECK_MC_INT
  return ((MC_NULL == pHandle) ? FAULT_NOW : pHandle->State);
#else
  return (pHandle->State);
#endif
}
 80012e8:	f890 0023 	ldrb.w	r0, [r0, #35]	@ 0x23
 80012ec:	4770      	bx	lr
 80012ee:	bf00      	nop

080012f0 <MCI_GetCurrentPosition>:
__weak float_t MCI_GetCurrentPosition(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
{
#ifdef NULL_PTR_CHECK_MC_INT
  return ((MC_NULL == pHandle) ? 0 : TC_GetCurrentPosition(pHandle->pPosCtrl));
#else
  return (TC_GetCurrentPosition(pHandle->pPosCtrl));
 80012f0:	68c0      	ldr	r0, [r0, #12]
 80012f2:	f008 bf67 	b.w	800a1c4 <TC_GetCurrentPosition>
 80012f6:	bf00      	nop

080012f8 <MCI_GetOccurredFaults>:
#ifdef NULL_PTR_CHECK_MC_INT
  return ((MC_NULL == pHandle) ? MC_SW_ERROR : (uint16_t)pHandle->PastFaults);
#else
  return ((uint16_t)pHandle->PastFaults);
#endif
}
 80012f8:	8cc0      	ldrh	r0, [r0, #38]	@ 0x26
 80012fa:	4770      	bx	lr

080012fc <MCI_GetCurrentFaults>:
#ifdef NULL_PTR_CHECK_MC_INT
  return ((MC_NULL == pHandle) ? MC_SW_ERROR : (uint16_t)pHandle->CurrentFaults);
#else
  return ((uint16_t)pHandle->CurrentFaults);
#endif
}
 80012fc:	8c80      	ldrh	r0, [r0, #36]	@ 0x24
 80012fe:	4770      	bx	lr

08001300 <MCI_StartMotor>:
{
 8001300:	b510      	push	{r4, lr}
 8001302:	4604      	mov	r4, r0
    if ((IDLE == MCI_GetSTMState(pHandle)) &&
 8001304:	f7ff fff0 	bl	80012e8 <MCI_GetSTMState>
 8001308:	b108      	cbz	r0, 800130e <MCI_StartMotor+0xe>
  bool retVal = false;
 800130a:	2000      	movs	r0, #0
}
 800130c:	bd10      	pop	{r4, pc}
        (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 800130e:	4620      	mov	r0, r4
 8001310:	f7ff fff2 	bl	80012f8 <MCI_GetOccurredFaults>
    if ((IDLE == MCI_GetSTMState(pHandle)) &&
 8001314:	2800      	cmp	r0, #0
 8001316:	d1f8      	bne.n	800130a <MCI_StartMotor+0xa>
        (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)))
 8001318:	4620      	mov	r0, r4
 800131a:	f7ff ffef 	bl	80012fc <MCI_GetCurrentFaults>
        (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 800131e:	2800      	cmp	r0, #0
 8001320:	d1f3      	bne.n	800130a <MCI_StartMotor+0xa>
      pHandle->DirectCommand = MCI_START;
 8001322:	2001      	movs	r0, #1
 8001324:	f884 0022 	strb.w	r0, [r4, #34]	@ 0x22
      pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 8001328:	f884 0028 	strb.w	r0, [r4, #40]	@ 0x28
}
 800132c:	bd10      	pop	{r4, pc}
 800132e:	bf00      	nop

08001330 <MCI_StopMotor>:
{
 8001330:	b538      	push	{r3, r4, r5, lr}
 8001332:	4605      	mov	r5, r0
    State = MCI_GetSTMState(pHandle);
 8001334:	f7ff ffd8 	bl	80012e8 <MCI_GetSTMState>
    if ((IDLE == State) || (ICLWAIT == State))
 8001338:	4604      	mov	r4, r0
 800133a:	b118      	cbz	r0, 8001344 <MCI_StopMotor+0x14>
 800133c:	f1b0 040c 	subs.w	r4, r0, #12
 8001340:	bf18      	it	ne
 8001342:	2401      	movne	r4, #1
    if ((MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 8001344:	4628      	mov	r0, r5
 8001346:	f7ff ffd7 	bl	80012f8 <MCI_GetOccurredFaults>
 800134a:	b110      	cbz	r0, 8001352 <MCI_StopMotor+0x22>
  bool retVal = false;
 800134c:	2400      	movs	r4, #0
}
 800134e:	4620      	mov	r0, r4
 8001350:	bd38      	pop	{r3, r4, r5, pc}
        (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)) &&
 8001352:	4628      	mov	r0, r5
 8001354:	f7ff ffd2 	bl	80012fc <MCI_GetCurrentFaults>
    if ((MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 8001358:	2800      	cmp	r0, #0
 800135a:	d1f7      	bne.n	800134c <MCI_StopMotor+0x1c>
        (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)) &&
 800135c:	2c00      	cmp	r4, #0
 800135e:	d0f5      	beq.n	800134c <MCI_StopMotor+0x1c>
      pHandle->DirectCommand = MCI_STOP;
 8001360:	2305      	movs	r3, #5
 8001362:	f885 3022 	strb.w	r3, [r5, #34]	@ 0x22
      retVal = true;
 8001366:	e7f2      	b.n	800134e <MCI_StopMotor+0x1e>

08001368 <MCI_FaultAcknowledged>:
{
 8001368:	b510      	push	{r4, lr}
 800136a:	4604      	mov	r4, r0
    if ((FAULT_OVER == MCI_GetSTMState(pHandle)) && (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)))
 800136c:	f7ff ffbc 	bl	80012e8 <MCI_GetSTMState>
 8001370:	280b      	cmp	r0, #11
 8001372:	d001      	beq.n	8001378 <MCI_FaultAcknowledged+0x10>
  bool reVal = false;
 8001374:	2000      	movs	r0, #0
}
 8001376:	bd10      	pop	{r4, pc}
    if ((FAULT_OVER == MCI_GetSTMState(pHandle)) && (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)))
 8001378:	4620      	mov	r0, r4
 800137a:	f7ff ffbf 	bl	80012fc <MCI_GetCurrentFaults>
 800137e:	2800      	cmp	r0, #0
 8001380:	d1f8      	bne.n	8001374 <MCI_FaultAcknowledged+0xc>
      pHandle->DirectCommand = MCI_ACK_FAULTS;
 8001382:	2302      	movs	r3, #2
 8001384:	f884 3022 	strb.w	r3, [r4, #34]	@ 0x22
      pHandle->PastFaults = MC_NO_FAULTS;
 8001388:	84e0      	strh	r0, [r4, #38]	@ 0x26
      reVal = true;
 800138a:	2001      	movs	r0, #1
}
 800138c:	bd10      	pop	{r4, pc}
 800138e:	bf00      	nop

08001390 <MCI_GetFaultState>:
    LocalFaultState = MC_SW_ERROR | (MC_SW_ERROR << 16);
  }
  else
  {
#endif
    LocalFaultState = (uint32_t)(pHandle->PastFaults);
 8001390:	8cc3      	ldrh	r3, [r0, #38]	@ 0x26
    LocalFaultState |= (uint32_t)(pHandle->CurrentFaults) << 16;
 8001392:	8c80      	ldrh	r0, [r0, #36]	@ 0x24
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
  return (LocalFaultState);
}
 8001394:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 8001398:	4770      	bx	lr
 800139a:	bf00      	nop

0800139c <MCI_GetControlMode>:
#ifdef NULL_PTR_CHECK_MC_INT
  return ((MC_NULL == pHandle) ? MCM_TORQUE_MODE : pHandle->LastModalitySetByUser);
#else
  return (pHandle->LastModalitySetByUser);
#endif
}
 800139c:	f890 0029 	ldrb.w	r0, [r0, #41]	@ 0x29
 80013a0:	4770      	bx	lr
 80013a2:	bf00      	nop

080013a4 <MCI_GetLastRampFinalSpeed>:
  }
  return (retVal);
#else
  return (pHandle->hFinalSpeed);
#endif
}
 80013a4:	f9b0 0012 	ldrsh.w	r0, [r0, #18]
 80013a8:	4770      	bx	lr
 80013aa:	bf00      	nop

080013ac <MCI_GetLastRampFinalTorque>:
  }
  return (retVal);
#else
  return (pHandle->hFinalTorque);
#endif
}
 80013ac:	f9b0 0014 	ldrsh.w	r0, [r0, #20]
 80013b0:	4770      	bx	lr
 80013b2:	bf00      	nop

080013b4 <MCI_GetLastRampFinalDuration>:
  }
  return (retVal);
#else
  return (pHandle->hDurationms);
#endif
}
 80013b4:	8c00      	ldrh	r0, [r0, #32]
 80013b6:	4770      	bx	lr

080013b8 <MCI_StopRamp>:
    /* Nothing to do */
  }
  else
  {
#endif
    STC_StopRamp(pHandle->pSTC);
 80013b8:	6803      	ldr	r3, [r0, #0]
    pHandle->RampRemainingStep = 0U;
 80013ba:	2200      	movs	r2, #0
 80013bc:	60da      	str	r2, [r3, #12]
    pHandle->IncDecAmount = 0;
 80013be:	619a      	str	r2, [r3, #24]
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
}
 80013c0:	4770      	bx	lr
 80013c2:	bf00      	nop

080013c4 <MCI_GetAvrgMecSpeedUnit>:
  return (pHandle->SPD);
 80013c4:	6803      	ldr	r3, [r0, #0]
  }
  else
  {
#endif
    SpeednPosFdbk_Handle_t * SpeedSensor = STC_GetSpeedSensor(pHandle->pSTC);
    temp_speed = SPD_GetAvrgMecSpeedUnit(SpeedSensor);
 80013c6:	6958      	ldr	r0, [r3, #20]
 80013c8:	f008 bbac 	b.w	8009b24 <SPD_GetAvrgMecSpeedUnit>

080013cc <MCI_GetMecSpeedRefUnit>:
__weak int16_t MCI_GetMecSpeedRefUnit(MCI_Handle_t *pHandle)
{
#ifdef NULL_PTR_CHECK_MC_INT
  return ((MC_NULL == pHandle) ? 0 : STC_GetMecSpeedRefUnit(pHandle->pSTC));
#else
  return (STC_GetMecSpeedRefUnit(pHandle->pSTC));
 80013cc:	6800      	ldr	r0, [r0, #0]
 80013ce:	f008 bc0d 	b.w	8009bec <STC_GetMecSpeedRefUnit>
 80013d2:	bf00      	nop

080013d4 <MCI_GetIab>:
  {
    tempVal = pHandle->pFOCVars->Iab;
  }
  return (tempVal);
#else
  return (pHandle->pFOCVars->Iab);
 80013d4:	6842      	ldr	r2, [r0, #4]
 80013d6:	6810      	ldr	r0, [r2, #0]
 80013d8:	2300      	movs	r3, #0
 80013da:	b282      	uxth	r2, r0
 80013dc:	f362 030f 	bfi	r3, r2, #0, #16
 80013e0:	0c00      	lsrs	r0, r0, #16
 80013e2:	f360 431f 	bfi	r3, r0, #16, #16
{
 80013e6:	b082      	sub	sp, #8
#endif
}
 80013e8:	4618      	mov	r0, r3
 80013ea:	b002      	add	sp, #8
 80013ec:	4770      	bx	lr
 80013ee:	bf00      	nop

080013f0 <MCI_GetIalphabeta>:
  {
    tempVal = pHandle->pFOCVars->Ialphabeta;
  }
  return (tempVal);
#else
  return (pHandle->pFOCVars->Ialphabeta);
 80013f0:	6842      	ldr	r2, [r0, #4]
 80013f2:	6850      	ldr	r0, [r2, #4]
 80013f4:	2300      	movs	r3, #0
 80013f6:	b282      	uxth	r2, r0
 80013f8:	f362 030f 	bfi	r3, r2, #0, #16
 80013fc:	0c00      	lsrs	r0, r0, #16
 80013fe:	f360 431f 	bfi	r3, r0, #16, #16
{
 8001402:	b082      	sub	sp, #8
#endif
}
 8001404:	4618      	mov	r0, r3
 8001406:	b002      	add	sp, #8
 8001408:	4770      	bx	lr
 800140a:	bf00      	nop

0800140c <MCI_GetIqd>:
  {
    tempVal = pHandle->pFOCVars->Iqd;
  }
  return (tempVal);
#else
  return (pHandle->pFOCVars->Iqd);
 800140c:	6842      	ldr	r2, [r0, #4]
 800140e:	68d0      	ldr	r0, [r2, #12]
 8001410:	2300      	movs	r3, #0
 8001412:	b282      	uxth	r2, r0
 8001414:	f362 030f 	bfi	r3, r2, #0, #16
 8001418:	0c00      	lsrs	r0, r0, #16
 800141a:	f360 431f 	bfi	r3, r0, #16, #16
{
 800141e:	b082      	sub	sp, #8
#endif
}
 8001420:	4618      	mov	r0, r3
 8001422:	b002      	add	sp, #8
 8001424:	4770      	bx	lr
 8001426:	bf00      	nop

08001428 <MCI_GetIqdref>:
  {
    tempVal = pHandle->pFOCVars->Iqdref;
  }
  return (tempVal);
#else
  return (pHandle->pFOCVars->Iqdref);
 8001428:	6842      	ldr	r2, [r0, #4]
 800142a:	6910      	ldr	r0, [r2, #16]
 800142c:	2300      	movs	r3, #0
 800142e:	b282      	uxth	r2, r0
 8001430:	f362 030f 	bfi	r3, r2, #0, #16
 8001434:	0c00      	lsrs	r0, r0, #16
 8001436:	f360 431f 	bfi	r3, r0, #16, #16
{
 800143a:	b082      	sub	sp, #8
#endif
}
 800143c:	4618      	mov	r0, r3
 800143e:	b002      	add	sp, #8
 8001440:	4770      	bx	lr
 8001442:	bf00      	nop

08001444 <MCI_GetVqd>:
  {
    tempVal = pHandle->pFOCVars->Vqd;
  }
  return (tempVal);
#else
  return (pHandle->pFOCVars->Vqd);
 8001444:	6842      	ldr	r2, [r0, #4]
 8001446:	f8d2 0016 	ldr.w	r0, [r2, #22]
 800144a:	2300      	movs	r3, #0
 800144c:	b282      	uxth	r2, r0
 800144e:	f362 030f 	bfi	r3, r2, #0, #16
 8001452:	0c00      	lsrs	r0, r0, #16
 8001454:	f360 431f 	bfi	r3, r0, #16, #16
{
 8001458:	b082      	sub	sp, #8
#endif
}
 800145a:	4618      	mov	r0, r3
 800145c:	b002      	add	sp, #8
 800145e:	4770      	bx	lr

08001460 <MCI_GetValphabeta>:
  {
    tempVal = pHandle->pFOCVars->Valphabeta;
  }
  return (tempVal);
#else
  return (pHandle->pFOCVars->Valphabeta);
 8001460:	6842      	ldr	r2, [r0, #4]
 8001462:	f8d2 001a 	ldr.w	r0, [r2, #26]
 8001466:	2300      	movs	r3, #0
 8001468:	b282      	uxth	r2, r0
 800146a:	f362 030f 	bfi	r3, r2, #0, #16
 800146e:	0c00      	lsrs	r0, r0, #16
 8001470:	f360 431f 	bfi	r3, r0, #16, #16
{
 8001474:	b082      	sub	sp, #8
#endif
}
 8001476:	4618      	mov	r0, r3
 8001478:	b002      	add	sp, #8
 800147a:	4770      	bx	lr

0800147c <MCI_GetTeref>:
__weak int16_t MCI_GetTeref(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
{
#ifdef NULL_PTR_CHECK_MC_INT
  return ((MC_NULL == pHandle) ? 0 : pHandle->pFOCVars->hTeref);
#else
  return (pHandle->pFOCVars->hTeref);
 800147c:	6843      	ldr	r3, [r0, #4]
#endif
}
 800147e:	f9b3 001e 	ldrsh.w	r0, [r3, #30]
 8001482:	4770      	bx	lr

08001484 <MCI_Clear_Iqdref>:
/**
  * @brief  It re-initializes Iqdref variables with their default values.
  * @param  pHandle Pointer on the component instance to work on.
  */
__weak void MCI_Clear_Iqdref(MCI_Handle_t *pHandle)
{
 8001484:	b510      	push	{r4, lr}
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->pFOCVars->Iqdref = STC_GetDefaultIqdref(pHandle->pSTC);
 8001486:	e9d0 0400 	ldrd	r0, r4, [r0]
 800148a:	f008 fc39 	bl	8009d00 <STC_GetDefaultIqdref>
 800148e:	f3c0 430f 	ubfx	r3, r0, #16, #16
 8001492:	8220      	strh	r0, [r4, #16]
 8001494:	8263      	strh	r3, [r4, #18]
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
}
 8001496:	bd10      	pop	{r4, pc}

08001498 <MCM_Clarke>:
  *                       beta = -(2*b+a)/sqrt(3)
  * @param  Input: stator values a and b in ab_t format.
  * @retval Stator values alpha and beta in alphabeta_t format.
  */
__weak alphabeta_t MCM_Clarke(ab_t Input)
{
 8001498:	f3c0 430f 	ubfx	r3, r0, #16, #16
  /* qIalpha = qIas*/
  Output.alpha = Input.a;

  a_divSQRT3_tmp = divSQRT_3 * ((int32_t)Input.a);

  b_divSQRT3_tmp = divSQRT_3 * ((int32_t)Input.b);
 800149c:	f644 11e6 	movw	r1, #18918	@ 0x49e6
#ifndef FULL_MISRA_C_COMPLIANCY_MC_MATH
  /* WARNING: the below instruction is not MISRA compliant, user should verify
    that Cortex-M3 assembly instruction ASR (arithmetic shift right) is used by
    the compiler to perform the shift (instead of LSR logical shift right) */
  //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
  wbeta_tmp = (-(a_divSQRT3_tmp) - (b_divSQRT3_tmp) - (b_divSQRT3_tmp)) >> 15;
 80014a0:	f24b 621a 	movw	r2, #46618	@ 0xb61a
  b_divSQRT3_tmp = divSQRT_3 * ((int32_t)Input.b);
 80014a4:	fb13 f301 	smulbb	r3, r3, r1
  wbeta_tmp = (-(a_divSQRT3_tmp) - (b_divSQRT3_tmp) - (b_divSQRT3_tmp)) >> 15;
 80014a8:	fb10 f202 	smulbb	r2, r0, r2
 80014ac:	eba2 0243 	sub.w	r2, r2, r3, lsl #1
#else
  wbeta_tmp = (-(a_divSQRT3_tmp) - (b_divSQRT3_tmp) - (b_divSQRT3_tmp)) / 32768;
#endif

  /* Check saturation of Ibeta */
  if (wbeta_tmp > INT16_MAX)
 80014b0:	f1b2 4f80 	cmp.w	r2, #1073741824	@ 0x40000000
{
 80014b4:	b084      	sub	sp, #16
 80014b6:	b203      	sxth	r3, r0
  if (wbeta_tmp > INT16_MAX)
 80014b8:	da05      	bge.n	80014c6 <MCM_Clarke+0x2e>
 80014ba:	13d1      	asrs	r1, r2, #15
  {
    hbeta_tmp = INT16_MAX;
  }
  else if (wbeta_tmp < (-32768))
 80014bc:	f511 4f00 	cmn.w	r1, #32768	@ 0x8000
 80014c0:	da0c      	bge.n	80014dc <MCM_Clarke+0x44>
 80014c2:	4a09      	ldr	r2, [pc, #36]	@ (80014e8 <MCM_Clarke+0x50>)
 80014c4:	e001      	b.n	80014ca <MCM_Clarke+0x32>
 80014c6:	f647 72ff 	movw	r2, #32767	@ 0x7fff
  else
  {
    /* Nothing to do */
  }

  return (Output);
 80014ca:	b29b      	uxth	r3, r3
 80014cc:	2000      	movs	r0, #0
 80014ce:	f363 000f 	bfi	r0, r3, #0, #16
 80014d2:	b293      	uxth	r3, r2
 80014d4:	f363 401f 	bfi	r0, r3, #16, #16
}
 80014d8:	b004      	add	sp, #16
 80014da:	4770      	bx	lr
    hbeta_tmp = ((int16_t)wbeta_tmp);
 80014dc:	4802      	ldr	r0, [pc, #8]	@ (80014e8 <MCM_Clarke+0x50>)
 80014de:	b20a      	sxth	r2, r1
 80014e0:	4282      	cmp	r2, r0
 80014e2:	bfb8      	it	lt
 80014e4:	4602      	movlt	r2, r0
 80014e6:	e7f0      	b.n	80014ca <MCM_Clarke+0x32>
 80014e8:	ffff8001 	.word	0xffff8001

080014ec <MCM_Trig_Functions>:
  } CosSin;
  //cstat +MISRAC2012-Rule-19.2
  /* Configure CORDIC */
  /* Misra  violation Rule 11.4 A�Conversion�should�not�be�performed�between�a�
   * pointer�to�object and an integer type */
  WRITE_REG(CORDIC->CSR, CORDIC_CONFIG_COSINE);
 80014ec:	4b09      	ldr	r3, [pc, #36]	@ (8001514 <MCM_Trig_Functions+0x28>)
  /* Misra  violation Rule�11.4 A�Conversion�should�not�be�performed�between�a
   * pointer�to�object and an integer type */
  LL_CORDIC_WriteData(CORDIC, ((uint32_t)0x7FFF0000) + ((uint32_t)hAngle));
 80014ee:	f100 40ff 	add.w	r0, r0, #2139095040	@ 0x7f800000
  WRITE_REG(CORDIC->CSR, CORDIC_CONFIG_COSINE);
 80014f2:	f04f 1260 	mov.w	r2, #6291552	@ 0x600060
  LL_CORDIC_WriteData(CORDIC, ((uint32_t)0x7FFF0000) + ((uint32_t)hAngle));
 80014f6:	f500 00fe 	add.w	r0, r0, #8323072	@ 0x7f0000
  WRITE_REG(CORDIC->CSR, CORDIC_CONFIG_COSINE);
 80014fa:	601a      	str	r2, [r3, #0]
  * @param  InData 0 .. 0xFFFFFFFF : 32-bit value to be provided as input data for CORDIC processing.
  * @retval None
  */
__STATIC_INLINE void LL_CORDIC_WriteData(CORDIC_TypeDef *CORDICx, uint32_t InData)
{
  WRITE_REG(CORDICx->WDATA, InData);
 80014fc:	6058      	str	r0, [r3, #4]
  * @param  CORDICx CORDIC Instance
  * @retval 32-bit output data of CORDIC processing.
  */
__STATIC_INLINE uint32_t LL_CORDIC_ReadData(const CORDIC_TypeDef *CORDICx)
{
  return (uint32_t)(READ_REG(CORDICx->RDATA));
 80014fe:	689b      	ldr	r3, [r3, #8]
  /* Read angle */
  /* Misra  violation Rule�11.4 A�Conversion�should�not�be�performed between�a
   * pointer�to object and an integer type */
  CosSin.CordicRdata = LL_CORDIC_ReadData(CORDIC);
  return (CosSin.Components); //cstat !UNION-type-punning
 8001500:	2000      	movs	r0, #0
 8001502:	b29a      	uxth	r2, r3
 8001504:	f362 000f 	bfi	r0, r2, #0, #16
 8001508:	0c1b      	lsrs	r3, r3, #16
{
 800150a:	b082      	sub	sp, #8
  return (CosSin.Components); //cstat !UNION-type-punning
 800150c:	f363 401f 	bfi	r0, r3, #16, #16
}
 8001510:	b002      	add	sp, #8
 8001512:	4770      	bx	lr
 8001514:	40020c00 	.word	0x40020c00

08001518 <MCM_Park>:
{
 8001518:	b530      	push	{r4, r5, lr}
 800151a:	4605      	mov	r5, r0
 800151c:	4604      	mov	r4, r0
 800151e:	b085      	sub	sp, #20
  Local_Vector_Components = MCM_Trig_Functions(Theta);
 8001520:	4608      	mov	r0, r1
 8001522:	f7ff ffe3 	bl	80014ec <MCM_Trig_Functions>
 8001526:	b22d      	sxth	r5, r5
 8001528:	b201      	sxth	r1, r0
 800152a:	1424      	asrs	r4, r4, #16
 800152c:	1400      	asrs	r0, r0, #16
  q_tmp_1 = Input.alpha * ((int32_t )Local_Vector_Components.hCos);
 800152e:	fb05 f301 	mul.w	r3, r5, r1
  wqd_tmp = (q_tmp_1 - q_tmp_2) >> 15; //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 8001532:	fb04 3310 	mls	r3, r4, r0, r3
  if (wqd_tmp > INT16_MAX)
 8001536:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 800153a:	da05      	bge.n	8001548 <MCM_Park+0x30>
 800153c:	13da      	asrs	r2, r3, #15
  else if (wqd_tmp < (-32768))
 800153e:	f512 4f00 	cmn.w	r2, #32768	@ 0x8000
 8001542:	da22      	bge.n	800158a <MCM_Park+0x72>
 8001544:	4a14      	ldr	r2, [pc, #80]	@ (8001598 <MCM_Park+0x80>)
 8001546:	e001      	b.n	800154c <MCM_Park+0x34>
 8001548:	f647 72ff 	movw	r2, #32767	@ 0x7fff
  d_tmp_2 = Input.beta * ((int32_t )Local_Vector_Components.hCos);
 800154c:	fb01 f404 	mul.w	r4, r1, r4
  wqd_tmp = (d_tmp_1 + d_tmp_2) >> 15; //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 8001550:	fb05 4400 	mla	r4, r5, r0, r4
  if (wqd_tmp > INT16_MAX)
 8001554:	f1b4 4f80 	cmp.w	r4, #1073741824	@ 0x40000000
  wqd_tmp = (d_tmp_1 + d_tmp_2) >> 15; //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 8001558:	ea4f 33e4 	mov.w	r3, r4, asr #15
  if (wqd_tmp > INT16_MAX)
 800155c:	da04      	bge.n	8001568 <MCM_Park+0x50>
  else if (wqd_tmp < (-32768))
 800155e:	f513 4f00 	cmn.w	r3, #32768	@ 0x8000
 8001562:	da0c      	bge.n	800157e <MCM_Park+0x66>
 8001564:	4b0c      	ldr	r3, [pc, #48]	@ (8001598 <MCM_Park+0x80>)
 8001566:	e001      	b.n	800156c <MCM_Park+0x54>
 8001568:	f647 73ff 	movw	r3, #32767	@ 0x7fff
  return (Output);
 800156c:	b292      	uxth	r2, r2
 800156e:	2000      	movs	r0, #0
 8001570:	f362 000f 	bfi	r0, r2, #0, #16
 8001574:	b29b      	uxth	r3, r3
 8001576:	f363 401f 	bfi	r0, r3, #16, #16
}
 800157a:	b005      	add	sp, #20
 800157c:	bd30      	pop	{r4, r5, pc}
    hqd_tmp = ((int16_t)wqd_tmp);
 800157e:	4906      	ldr	r1, [pc, #24]	@ (8001598 <MCM_Park+0x80>)
 8001580:	b21b      	sxth	r3, r3
 8001582:	428b      	cmp	r3, r1
 8001584:	bfb8      	it	lt
 8001586:	460b      	movlt	r3, r1
 8001588:	e7f0      	b.n	800156c <MCM_Park+0x54>
    hqd_tmp = ((int16_t)wqd_tmp);
 800158a:	4b03      	ldr	r3, [pc, #12]	@ (8001598 <MCM_Park+0x80>)
 800158c:	b212      	sxth	r2, r2
 800158e:	429a      	cmp	r2, r3
 8001590:	bfb8      	it	lt
 8001592:	461a      	movlt	r2, r3
 8001594:	e7da      	b.n	800154c <MCM_Park+0x34>
 8001596:	bf00      	nop
 8001598:	ffff8001 	.word	0xffff8001

0800159c <MCM_Rev_Park>:
{
 800159c:	b530      	push	{r4, r5, lr}
 800159e:	4605      	mov	r5, r0
 80015a0:	b085      	sub	sp, #20
 80015a2:	4604      	mov	r4, r0
  Local_Vector_Components = MCM_Trig_Functions(Theta);
 80015a4:	4608      	mov	r0, r1
 80015a6:	f7ff ffa1 	bl	80014ec <MCM_Trig_Functions>
 80015aa:	1424      	asrs	r4, r4, #16
 80015ac:	1402      	asrs	r2, r0, #16
 80015ae:	b22d      	sxth	r5, r5
 80015b0:	b200      	sxth	r0, r0
  alpha_tmp2 = Input.d * ((int32_t)Local_Vector_Components.hSin);
 80015b2:	fb04 f302 	mul.w	r3, r4, r2
  Output.alpha = (int16_t)(((alpha_tmp1) + (alpha_tmp2)) >> 15);
 80015b6:	fb05 3300 	mla	r3, r5, r0, r3
  beta_tmp2 = Input.d * ((int32_t)Local_Vector_Components.hCos);
 80015ba:	fb00 f404 	mul.w	r4, r0, r4
  Output.beta = (int16_t)((beta_tmp2 - beta_tmp1) >> 15);
 80015be:	fb05 4412 	mls	r4, r5, r2, r4
  return (Output);
 80015c2:	f3c3 33cf 	ubfx	r3, r3, #15, #16
 80015c6:	2000      	movs	r0, #0
 80015c8:	f363 000f 	bfi	r0, r3, #0, #16
 80015cc:	f3c4 34cf 	ubfx	r4, r4, #15, #16
 80015d0:	f364 401f 	bfi	r0, r4, #16, #16
}
 80015d4:	b005      	add	sp, #20
 80015d6:	bd30      	pop	{r4, r5, pc}

080015d8 <MCM_Sqrt>:
  */
__weak int32_t MCM_Sqrt(int32_t wInput)
{
  int32_t wtemprootnew;

  if (wInput > 0)
 80015d8:	2800      	cmp	r0, #0
 80015da:	dd09      	ble.n	80015f0 <MCM_Sqrt+0x18>
 80015dc:	b672      	cpsid	i
  {
    uint32_t retVal;
    /* Disable Irq as sqrt is used in MF and HF task */
    __disable_irq();
    /* Configure CORDIC */
    WRITE_REG(CORDIC->CSR, CORDIC_CONFIG_SQRT);
 80015de:	4b05      	ldr	r3, [pc, #20]	@ (80015f4 <MCM_Sqrt+0x1c>)
 80015e0:	f240 1269 	movw	r2, #361	@ 0x169
 80015e4:	601a      	str	r2, [r3, #0]
  WRITE_REG(CORDICx->WDATA, InData);
 80015e6:	6058      	str	r0, [r3, #4]
  return (uint32_t)(READ_REG(CORDICx->RDATA));
 80015e8:	6898      	ldr	r0, [r3, #8]
    LL_CORDIC_WriteData(CORDIC, ((uint32_t)wInput));
    /* Read sqrt and return */
#ifndef FULL_MISRA_C_COMPLIANCY_MC_MATH
    retVal = (LL_CORDIC_ReadData(CORDIC)) >> 15; //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 80015ea:	0bc0      	lsrs	r0, r0, #15
  __ASM volatile ("cpsie i" : : : "memory");
 80015ec:	b662      	cpsie	i
}
 80015ee:	4770      	bx	lr
    __enable_irq();

  }
  else
  {
    wtemprootnew = (int32_t)0;
 80015f0:	2000      	movs	r0, #0
  }

  return (wtemprootnew);
}
 80015f2:	4770      	bx	lr
 80015f4:	40020c00 	.word	0x40020c00

080015f8 <MCboot>:
{
  /* USER CODE BEGIN MCboot 0 */

  /* USER CODE END MCboot 0 */

  if (MC_NULL == pMCIList)
 80015f8:	b328      	cbz	r0, 8001646 <MCboot+0x4e>
{
 80015fa:	b538      	push	{r3, r4, r5, lr}
    /* Nothing to do */
  }
  else
  {

    bMCBootCompleted = (uint8_t )0;
 80015fc:	4d12      	ldr	r5, [pc, #72]	@ (8001648 <MCboot+0x50>)
 80015fe:	2300      	movs	r3, #0
 8001600:	702b      	strb	r3, [r5, #0]
 8001602:	4604      	mov	r4, r0

    /*************************************************/
    /*    FOC initialization         */
    /*************************************************/
    FOC_Init();
 8001604:	f000 fa12 	bl	8001a2c <FOC_Init>

    ASPEP_start(&aspepOverUartA);
 8001608:	4810      	ldr	r0, [pc, #64]	@ (800164c <MCboot+0x54>)
 800160a:	f7fe ffab 	bl	8000564 <ASPEP_start>
    /* USER CODE END MCboot 1 */

    /******************************************************/
    /*   PID component initialization: speed regulation   */
    /******************************************************/
    PID_HandleInit(&PIDSpeedHandle_M1);
 800160e:	4810      	ldr	r0, [pc, #64]	@ (8001650 <MCboot+0x58>)
 8001610:	f007 fa2c 	bl	8008a6c <PID_HandleInit>

    /****************************************************/
    /*   Virtual speed sensor component initialization  */
    /****************************************************/
    VSS_Init(&VirtualSpeedSensorM1);
 8001614:	480f      	ldr	r0, [pc, #60]	@ (8001654 <MCboot+0x5c>)
 8001616:	f008 fe03 	bl	800a220 <VSS_Init>

    /********************************************************/
    /*   Bus voltage sensor component initialization        */
    /********************************************************/
    (void)RCM_RegisterRegConv(&VbusRegConv_M1);
 800161a:	480f      	ldr	r0, [pc, #60]	@ (8001658 <MCboot+0x60>)
 800161c:	f001 ffc6 	bl	80035ac <RCM_RegisterRegConv>
    RVBS_Init(&BusVoltageSensor_M1);
 8001620:	480e      	ldr	r0, [pc, #56]	@ (800165c <MCboot+0x64>)
 8001622:	f008 fa1b 	bl	8009a5c <RVBS_Init>

    /*******************************************************/
    /*   Temperature measurement component initialization  */
    /*******************************************************/
    (void)RCM_RegisterRegConv(&TempRegConv_M1);
 8001626:	480e      	ldr	r0, [pc, #56]	@ (8001660 <MCboot+0x68>)
 8001628:	f001 ffc0 	bl	80035ac <RCM_RegisterRegConv>
    NTC_Init(&TempSensor_M1);
 800162c:	480d      	ldr	r0, [pc, #52]	@ (8001664 <MCboot+0x6c>)
 800162e:	f007 f9e1 	bl	80089f4 <NTC_Init>

    pMCIList[M1] = &Mci[M1];
 8001632:	4b0d      	ldr	r3, [pc, #52]	@ (8001668 <MCboot+0x70>)
 8001634:	6023      	str	r3, [r4, #0]

    DAC_Init(&DAC_Handle);
 8001636:	480d      	ldr	r0, [pc, #52]	@ (800166c <MCboot+0x74>)
 8001638:	f7ff faa6 	bl	8000b88 <DAC_Init>

    /* Applicative hook in MCBoot() */
    MC_APP_BootHook();
 800163c:	f7ff fdb4 	bl	80011a8 <MC_APP_BootHook>

    /* USER CODE BEGIN MCboot 2 */

    /* USER CODE END MCboot 2 */

    bMCBootCompleted = 1U;
 8001640:	2301      	movs	r3, #1
 8001642:	702b      	strb	r3, [r5, #0]
  }
}
 8001644:	bd38      	pop	{r3, r4, r5, pc}
 8001646:	4770      	bx	lr
 8001648:	20000790 	.word	0x20000790
 800164c:	200003ec 	.word	0x200003ec
 8001650:	20000228 	.word	0x20000228
 8001654:	200002bc 	.word	0x200002bc
 8001658:	20000280 	.word	0x20000280
 800165c:	20000264 	.word	0x20000264
 8001660:	200002ac 	.word	0x200002ac
 8001664:	20000290 	.word	0x20000290
 8001668:	20000000 	.word	0x20000000
 800166c:	200004a0 	.word	0x200004a0

08001670 <MC_RunMotorControlTasks>:
 * - Power Factor Correction Task (if enabled).
 * - User Interface task.
 */
__weak void MC_RunMotorControlTasks(void)
{
  if (0U == bMCBootCompleted)
 8001670:	4b1d      	ldr	r3, [pc, #116]	@ (80016e8 <MC_RunMotorControlTasks+0x78>)
 8001672:	781b      	ldrb	r3, [r3, #0]
 8001674:	b1bb      	cbz	r3, 80016a6 <MC_RunMotorControlTasks+0x36>
{
 8001676:	b570      	push	{r4, r5, r6, lr}
    /* ** Medium Frequency Tasks ** */
/* USER CODE BEGIN MC_Scheduler 0 */

/* USER CODE END MC_Scheduler 0 */

    if(hMFTaskCounterM1 > 0u)
 8001678:	4c1c      	ldr	r4, [pc, #112]	@ (80016ec <MC_RunMotorControlTasks+0x7c>)
 800167a:	8823      	ldrh	r3, [r4, #0]
 800167c:	b1a3      	cbz	r3, 80016a8 <MC_RunMotorControlTasks+0x38>
    {
      hMFTaskCounterM1--;
 800167e:	3b01      	subs	r3, #1
 8001680:	b29b      	uxth	r3, r3

      /* USER CODE END MC_Scheduler 1 */

      hMFTaskCounterM1 = (uint16_t)MF_TASK_OCCURENCE_TICKS;
    }
    if(hBootCapDelayCounterM1 > 0U)
 8001682:	4a1b      	ldr	r2, [pc, #108]	@ (80016f0 <MC_RunMotorControlTasks+0x80>)
      hMFTaskCounterM1--;
 8001684:	8023      	strh	r3, [r4, #0]
    if(hBootCapDelayCounterM1 > 0U)
 8001686:	8813      	ldrh	r3, [r2, #0]
 8001688:	b29b      	uxth	r3, r3
 800168a:	b11b      	cbz	r3, 8001694 <MC_RunMotorControlTasks+0x24>
    {
      hBootCapDelayCounterM1--;
 800168c:	8813      	ldrh	r3, [r2, #0]
 800168e:	3b01      	subs	r3, #1
 8001690:	b29b      	uxth	r3, r3
 8001692:	8013      	strh	r3, [r2, #0]
    }
    else
    {
      /* Nothing to do */
    }
    if(hStopPermanencyCounterM1 > 0U)
 8001694:	4a17      	ldr	r2, [pc, #92]	@ (80016f4 <MC_RunMotorControlTasks+0x84>)
 8001696:	8813      	ldrh	r3, [r2, #0]
 8001698:	b29b      	uxth	r3, r3
 800169a:	b11b      	cbz	r3, 80016a4 <MC_RunMotorControlTasks+0x34>
    {
      hStopPermanencyCounterM1--;
 800169c:	8813      	ldrh	r3, [r2, #0]
 800169e:	3b01      	subs	r3, #1
 80016a0:	b29b      	uxth	r3, r3
 80016a2:	8013      	strh	r3, [r2, #0]

  /* USER CODE BEGIN MC_Scheduler 2 */

  /* USER CODE END MC_Scheduler 2 */
  }
}
 80016a4:	bd70      	pop	{r4, r5, r6, pc}
 80016a6:	4770      	bx	lr
      MCP_Over_UartA.rxBuffer = MCP_Over_UartA.pTransportLayer->fRXPacketProcess(MCP_Over_UartA.pTransportLayer,
 80016a8:	4d13      	ldr	r5, [pc, #76]	@ (80016f8 <MC_RunMotorControlTasks+0x88>)
      TSK_MediumFrequencyTaskM1();
 80016aa:	f000 fa67 	bl	8001b7c <TSK_MediumFrequencyTaskM1>
      MC_APP_PostMediumFrequencyHook_M1();
 80016ae:	f7ff fd7d 	bl	80011ac <MC_APP_PostMediumFrequencyHook_M1>
      MCP_Over_UartA.rxBuffer = MCP_Over_UartA.pTransportLayer->fRXPacketProcess(MCP_Over_UartA.pTransportLayer,
 80016b2:	4629      	mov	r1, r5
 80016b4:	f851 0b0c 	ldr.w	r0, [r1], #12
 80016b8:	6883      	ldr	r3, [r0, #8]
 80016ba:	4798      	blx	r3
 80016bc:	6068      	str	r0, [r5, #4]
      if ( 0U == MCP_Over_UartA.rxBuffer)
 80016be:	b130      	cbz	r0, 80016ce <MC_RunMotorControlTasks+0x5e>
        if (0U == MCP_Over_UartA.pTransportLayer->fGetBuffer(MCP_Over_UartA.pTransportLayer,
 80016c0:	4629      	mov	r1, r5
 80016c2:	220a      	movs	r2, #10
 80016c4:	f851 0b08 	ldr.w	r0, [r1], #8
 80016c8:	6803      	ldr	r3, [r0, #0]
 80016ca:	4798      	blx	r3
 80016cc:	b908      	cbnz	r0, 80016d2 <MC_RunMotorControlTasks+0x62>
{
 80016ce:	2301      	movs	r3, #1
 80016d0:	e7d7      	b.n	8001682 <MC_RunMotorControlTasks+0x12>
          MCP_ReceivedPacket(&MCP_Over_UartA);
 80016d2:	4628      	mov	r0, r5
 80016d4:	f000 fcd6 	bl	8002084 <MCP_ReceivedPacket>
          MCP_Over_UartA.pTransportLayer->fSendPacket(MCP_Over_UartA.pTransportLayer, MCP_Over_UartA.txBuffer,
 80016d8:	6828      	ldr	r0, [r5, #0]
 80016da:	89ea      	ldrh	r2, [r5, #14]
 80016dc:	6846      	ldr	r6, [r0, #4]
 80016de:	68a9      	ldr	r1, [r5, #8]
 80016e0:	230a      	movs	r3, #10
 80016e2:	47b0      	blx	r6
 80016e4:	e7f3      	b.n	80016ce <MC_RunMotorControlTasks+0x5e>
 80016e6:	bf00      	nop
 80016e8:	20000790 	.word	0x20000790
 80016ec:	20000796 	.word	0x20000796
 80016f0:	20000794 	.word	0x20000794
 80016f4:	20000792 	.word	0x20000792
 80016f8:	200003dc 	.word	0x200003dc

080016fc <TSK_SetChargeBootCapDelayM1>:
  * @param  hTickCount number of ticks to be counted.
  * @retval void
  */
__weak void TSK_SetChargeBootCapDelayM1(uint16_t hTickCount)
{
   hBootCapDelayCounterM1 = hTickCount;
 80016fc:	4b01      	ldr	r3, [pc, #4]	@ (8001704 <TSK_SetChargeBootCapDelayM1+0x8>)
 80016fe:	8018      	strh	r0, [r3, #0]
}
 8001700:	4770      	bx	lr
 8001702:	bf00      	nop
 8001704:	20000794 	.word	0x20000794

08001708 <TSK_ChargeBootCapDelayHasElapsedM1>:
  * @retval bool true if time has elapsed, false otherwise.
  */
__weak bool TSK_ChargeBootCapDelayHasElapsedM1(void)
{
  bool retVal = false;
  if (((uint16_t)0) == hBootCapDelayCounterM1)
 8001708:	4b03      	ldr	r3, [pc, #12]	@ (8001718 <TSK_ChargeBootCapDelayHasElapsedM1+0x10>)
 800170a:	8818      	ldrh	r0, [r3, #0]
 800170c:	b280      	uxth	r0, r0
  {
    retVal = true;
  }
  return (retVal);
}
 800170e:	fab0 f080 	clz	r0, r0
 8001712:	0940      	lsrs	r0, r0, #5
 8001714:	4770      	bx	lr
 8001716:	bf00      	nop
 8001718:	20000794 	.word	0x20000794

0800171c <TSK_SetStopPermanencyTimeM1>:
  * @param  hTickCount number of ticks to be counted.
  * @retval void
  */
__weak void TSK_SetStopPermanencyTimeM1(uint16_t hTickCount)
{
  hStopPermanencyCounterM1 = hTickCount;
 800171c:	4b01      	ldr	r3, [pc, #4]	@ (8001724 <TSK_SetStopPermanencyTimeM1+0x8>)
 800171e:	8018      	strh	r0, [r3, #0]
}
 8001720:	4770      	bx	lr
 8001722:	bf00      	nop
 8001724:	20000792 	.word	0x20000792

08001728 <TSK_StopPermanencyTimeHasElapsedM1>:
  * @retval bool true if time is elapsed, false otherwise.
  */
__weak bool TSK_StopPermanencyTimeHasElapsedM1(void)
{
  bool retVal = false;
  if (((uint16_t)0) == hStopPermanencyCounterM1)
 8001728:	4b03      	ldr	r3, [pc, #12]	@ (8001738 <TSK_StopPermanencyTimeHasElapsedM1+0x10>)
 800172a:	8818      	ldrh	r0, [r3, #0]
 800172c:	b280      	uxth	r0, r0
  {
    retVal = true;
  }
  return (retVal);
}
 800172e:	fab0 f080 	clz	r0, r0
 8001732:	0940      	lsrs	r0, r0, #5
 8001734:	4770      	bx	lr
 8001736:	bf00      	nop
 8001738:	20000792 	.word	0x20000792

0800173c <TSK_HighFrequencyTask>:
  * subsystem (see the state machine(s)).
  *
  * @retval Number of the  motor instance which FOC loop was executed.
  */
__weak uint8_t TSK_HighFrequencyTask(void)
{
 800173c:	b508      	push	{r3, lr}
  uint8_t bMotorNbr;
  bMotorNbr = 0;
  /* USER CODE BEGIN HighFrequencyTask 0 */

  /* USER CODE END HighFrequencyTask 0 */
  FOC_HighFrequencyTask(bMotorNbr);
 800173e:	2000      	movs	r0, #0
 8001740:	f000 fb7c 	bl	8001e3c <FOC_HighFrequencyTask>
  DAC_Exec(&DAC_Handle);
 8001744:	4808      	ldr	r0, [pc, #32]	@ (8001768 <TSK_HighFrequencyTask+0x2c>)
 8001746:	f7ff fa2d 	bl	8000ba4 <DAC_Exec>

  /* USER CODE BEGIN HighFrequencyTask 1 */

  /* USER CODE END HighFrequencyTask 1 */

  GLOBAL_TIMESTAMP++;
 800174a:	4a08      	ldr	r2, [pc, #32]	@ (800176c <TSK_HighFrequencyTask+0x30>)
  if (0U == MCPA_UART_A.Mark)
 800174c:	4808      	ldr	r0, [pc, #32]	@ (8001770 <TSK_HighFrequencyTask+0x34>)
  GLOBAL_TIMESTAMP++;
 800174e:	6813      	ldr	r3, [r2, #0]
  if (0U == MCPA_UART_A.Mark)
 8001750:	f890 1029 	ldrb.w	r1, [r0, #41]	@ 0x29
  GLOBAL_TIMESTAMP++;
 8001754:	3301      	adds	r3, #1
 8001756:	6013      	str	r3, [r2, #0]
  if (0U == MCPA_UART_A.Mark)
 8001758:	b909      	cbnz	r1, 800175e <TSK_HighFrequencyTask+0x22>
    MCPA_dataLog (&MCPA_UART_A);
  }

  return (bMotorNbr);

}
 800175a:	2000      	movs	r0, #0
 800175c:	bd08      	pop	{r3, pc}
    MCPA_dataLog (&MCPA_UART_A);
 800175e:	f006 ffcb 	bl	80086f8 <MCPA_dataLog>
}
 8001762:	2000      	movs	r0, #0
 8001764:	bd08      	pop	{r3, pc}
 8001766:	bf00      	nop
 8001768:	200004a0 	.word	0x200004a0
 800176c:	20002724 	.word	0x20002724
 8001770:	200003b0 	.word	0x200003b0

08001774 <TSK_SafetyTask_PWMOFF>:
  * @brief  Safety task implementation if  MC.M1_ON_OVER_VOLTAGE == TURN_OFF_PWM.
  * @param  bMotor Motor reference number defined
  *         \link Motors_reference_number here \endlink.
  */
__weak void TSK_SafetyTask_PWMOFF(uint8_t bMotor)
{
 8001774:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /* USER CODE END TSK_SafetyTask_PWMOFF 0 */
  uint16_t CodeReturn = MC_NO_ERROR;
  uint8_t lbmotor = M1;
  const uint16_t errMask[NBR_OF_MOTORS] = {VBUS_TEMP_ERR_MASK};
  /* Check for fault if FW protection is activated. It returns MC_OVER_TEMP or MC_NO_ERROR */
  if (M1 == bMotor)
 8001776:	4604      	mov	r4, r0
 8001778:	b340      	cbz	r0, 80017cc <TSK_SafetyTask_PWMOFF+0x58>
  {
    /* Nothing to do */
  }

/* Due to warning array subscript 1 is above array bounds of PWMC_Handle_t *[1] [-Warray-bounds] */
   CodeReturn |= PWMC_IsFaultOccurred(pwmcHandle[lbmotor]);     /* check for fault. It return MC_OVER_CURR or MC_NO_FAULTS
 800177a:	4e25      	ldr	r6, [pc, #148]	@ (8001810 <TSK_SafetyTask_PWMOFF+0x9c>)
 800177c:	6830      	ldr	r0, [r6, #0]
 800177e:	f000 ff55 	bl	800262c <PWMC_IsFaultOccurred>
 8001782:	4601      	mov	r1, r0
  }
  else
  {
    /* Nothing to do */
  }
  MCI_FaultProcessing(&Mci[bMotor], CodeReturn, ~CodeReturn); /* Process faults */
 8001784:	4d23      	ldr	r5, [pc, #140]	@ (8001814 <TSK_SafetyTask_PWMOFF+0xa0>)
 8001786:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 800178a:	eb04 0343 	add.w	r3, r4, r3, lsl #1
 800178e:	eb05 0583 	add.w	r5, r5, r3, lsl #2
 8001792:	43ca      	mvns	r2, r1
 8001794:	4628      	mov	r0, r5
 8001796:	b292      	uxth	r2, r2
 8001798:	f7ff fd5e 	bl	8001258 <MCI_FaultProcessing>

  if (MCI_GetFaultState(&Mci[bMotor]) != (uint32_t)MC_NO_FAULTS)
 800179c:	4628      	mov	r0, r5
 800179e:	f7ff fdf7 	bl	8001390 <MCI_GetFaultState>
 80017a2:	b190      	cbz	r0, 80017ca <TSK_SafetyTask_PWMOFF+0x56>
  {
    /* Reset Encoder state */
    if (pEAC[bMotor] != MC_NULL)
 80017a4:	4b1c      	ldr	r3, [pc, #112]	@ (8001818 <TSK_SafetyTask_PWMOFF+0xa4>)
 80017a6:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 80017aa:	b10b      	cbz	r3, 80017b0 <TSK_SafetyTask_PWMOFF+0x3c>
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->EncRestart = restart;
 80017ac:	2200      	movs	r2, #0
 80017ae:	73da      	strb	r2, [r3, #15]
    }
    else
    {
      /* Nothing to do */
    }
    PWMC_SwitchOffPWM(pwmcHandle[bMotor]);
 80017b0:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
 80017b4:	f000 feee 	bl	8002594 <PWMC_SwitchOffPWM>
    if (MCPA_UART_A.Mark != 0U)
 80017b8:	4818      	ldr	r0, [pc, #96]	@ (800181c <TSK_SafetyTask_PWMOFF+0xa8>)
 80017ba:	f890 3029 	ldrb.w	r3, [r0, #41]	@ 0x29
 80017be:	bb03      	cbnz	r3, 8001802 <TSK_SafetyTask_PWMOFF+0x8e>
    }
    else
    {
      /* Nothing to do */
    }
    FOC_Clear(bMotor);
 80017c0:	4620      	mov	r0, r4
    /* No errors */
  }
  /* USER CODE BEGIN TSK_SafetyTask_PWMOFF 3 */

  /* USER CODE END TSK_SafetyTask_PWMOFF 3 */
}
 80017c2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    FOC_Clear(bMotor);
 80017c6:	f000 b8f7 	b.w	80019b8 <FOC_Clear>
}
 80017ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    uint16_t rawValueM1 = RCM_ExecRegularConv(&TempRegConv_M1);
 80017cc:	4814      	ldr	r0, [pc, #80]	@ (8001820 <TSK_SafetyTask_PWMOFF+0xac>)
   CodeReturn |= PWMC_IsFaultOccurred(pwmcHandle[lbmotor]);     /* check for fault. It return MC_OVER_CURR or MC_NO_FAULTS
 80017ce:	4e10      	ldr	r6, [pc, #64]	@ (8001810 <TSK_SafetyTask_PWMOFF+0x9c>)
    uint16_t rawValueM1 = RCM_ExecRegularConv(&TempRegConv_M1);
 80017d0:	f001 ffe8 	bl	80037a4 <RCM_ExecRegularConv>
 80017d4:	4601      	mov	r1, r0
    CodeReturn |= errMask[bMotor] & NTC_CalcAvTemp(&TempSensor_M1, rawValueM1);
 80017d6:	4813      	ldr	r0, [pc, #76]	@ (8001824 <TSK_SafetyTask_PWMOFF+0xb0>)
 80017d8:	f007 f91e 	bl	8008a18 <NTC_CalcAvTemp>
 80017dc:	4607      	mov	r7, r0
   CodeReturn |= PWMC_IsFaultOccurred(pwmcHandle[lbmotor]);     /* check for fault. It return MC_OVER_CURR or MC_NO_FAULTS
 80017de:	6830      	ldr	r0, [r6, #0]
 80017e0:	f000 ff24 	bl	800262c <PWMC_IsFaultOccurred>
 80017e4:	4605      	mov	r5, r0
    uint16_t rawValueM1 =  RCM_ExecRegularConv(&VbusRegConv_M1);
 80017e6:	4810      	ldr	r0, [pc, #64]	@ (8001828 <TSK_SafetyTask_PWMOFF+0xb4>)
 80017e8:	f001 ffdc 	bl	80037a4 <RCM_ExecRegularConv>
 80017ec:	4601      	mov	r1, r0
    CodeReturn |= errMask[bMotor] & RVBS_CalcAvVbus(&BusVoltageSensor_M1, rawValueM1);
 80017ee:	480f      	ldr	r0, [pc, #60]	@ (800182c <TSK_SafetyTask_PWMOFF+0xb8>)
 80017f0:	f008 f960 	bl	8009ab4 <RVBS_CalcAvVbus>
 80017f4:	4307      	orrs	r7, r0
 80017f6:	f007 070e 	and.w	r7, r7, #14
 80017fa:	ea45 0107 	orr.w	r1, r5, r7
 80017fe:	b289      	uxth	r1, r1
 8001800:	e7c0      	b.n	8001784 <TSK_SafetyTask_PWMOFF+0x10>
      MCPA_flushDataLog (&MCPA_UART_A);
 8001802:	f007 f839 	bl	8008878 <MCPA_flushDataLog>
    FOC_Clear(bMotor);
 8001806:	4620      	mov	r0, r4
}
 8001808:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    FOC_Clear(bMotor);
 800180c:	f000 b8d4 	b.w	80019b8 <FOC_Clear>
 8001810:	2000077c 	.word	0x2000077c
 8001814:	20000000 	.word	0x20000000
 8001818:	20000780 	.word	0x20000780
 800181c:	200003b0 	.word	0x200003b0
 8001820:	200002ac 	.word	0x200002ac
 8001824:	20000290 	.word	0x20000290
 8001828:	20000280 	.word	0x20000280
 800182c:	20000264 	.word	0x20000264

08001830 <TSK_SafetyTask>:
{
 8001830:	b508      	push	{r3, lr}
  if (1U == bMCBootCompleted)
 8001832:	4b06      	ldr	r3, [pc, #24]	@ (800184c <TSK_SafetyTask+0x1c>)
 8001834:	781b      	ldrb	r3, [r3, #0]
 8001836:	2b01      	cmp	r3, #1
 8001838:	d000      	beq.n	800183c <TSK_SafetyTask+0xc>
}
 800183a:	bd08      	pop	{r3, pc}
    TSK_SafetyTask_PWMOFF(M1);
 800183c:	2000      	movs	r0, #0
 800183e:	f7ff ff99 	bl	8001774 <TSK_SafetyTask_PWMOFF>
}
 8001842:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCM_ExecUserConv();
 8001846:	f002 b875 	b.w	8003934 <RCM_ExecUserConv>
 800184a:	bf00      	nop
 800184c:	20000790 	.word	0x20000790

08001850 <TSK_HardwareFaultTask>:
  *
  *  This function is to be executed when a general hardware failure has been detected
  * by the microcontroller and is used to put the system in safety condition.
  */
__weak void TSK_HardwareFaultTask(void)
{
 8001850:	b508      	push	{r3, lr}
  /* USER CODE BEGIN TSK_HardwareFaultTask 0 */

  /* USER CODE END TSK_HardwareFaultTask 0 */
   FOC_Clear(M1);
 8001852:	2000      	movs	r0, #0
 8001854:	f000 f8b0 	bl	80019b8 <FOC_Clear>
  MCI_FaultProcessing(&Mci[M1], MC_SW_ERROR, 0);

  /* USER CODE BEGIN TSK_HardwareFaultTask 1 */

  /* USER CODE END TSK_HardwareFaultTask 1 */
}
 8001858:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  MCI_FaultProcessing(&Mci[M1], MC_SW_ERROR, 0);
 800185c:	4802      	ldr	r0, [pc, #8]	@ (8001868 <TSK_HardwareFaultTask+0x18>)
 800185e:	2200      	movs	r2, #0
 8001860:	2180      	movs	r1, #128	@ 0x80
 8001862:	f7ff bcf9 	b.w	8001258 <MCI_FaultProcessing>
 8001866:	bf00      	nop
 8001868:	20000000 	.word	0x20000000

0800186c <startMediumFrequencyTask>:

/* startMediumFrequencyTask function */
void startMediumFrequencyTask(void const * argument)
{
 800186c:	b508      	push	{r3, lr}
  /* USER CODE BEGIN MF task 1 */
  /* Infinite loop */
  for(;;)
  {
    /* Delay of 500us */
    vTaskDelay(1);
 800186e:	2001      	movs	r0, #1
 8001870:	f006 fbee 	bl	8008050 <vTaskDelay>
    MC_RunMotorControlTasks();
 8001874:	f7ff fefc 	bl	8001670 <MC_RunMotorControlTasks>
  for(;;)
 8001878:	e7f9      	b.n	800186e <startMediumFrequencyTask+0x2>
 800187a:	bf00      	nop

0800187c <StartSafetyTask>:
  /* USER CODE END MF task 1 */
}

/* startSafetyTask function */
void StartSafetyTask(void const * argument)
{
 800187c:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SF task 1 */
  /* Infinite loop */
  for(;;)
  {
    /* Delay of 500us */
    vTaskDelay(1);
 800187e:	2001      	movs	r0, #1
 8001880:	f006 fbe6 	bl	8008050 <vTaskDelay>
    TSK_SafetyTask();
 8001884:	f7ff ffd4 	bl	8001830 <TSK_SafetyTask>
  for(;;)
 8001888:	e7f9      	b.n	800187e <StartSafetyTask+0x2>
 800188a:	bf00      	nop

0800188c <UI_HandleStartStopButton_cb>:
  }
  /* USER CODE END SF task 1 */
}

__weak void UI_HandleStartStopButton_cb (void)
{
 800188c:	b508      	push	{r3, lr}
/* USER CODE BEGIN START_STOP_BTN */
  if (IDLE == MC_GetSTMStateMotor1())
 800188e:	f7ff f9c1 	bl	8000c14 <MC_GetSTMStateMotor1>
 8001892:	b918      	cbnz	r0, 800189c <UI_HandleStartStopButton_cb+0x10>
  else
  {
    (void)MC_StopMotor1();
  }
/* USER CODE END START_STOP_BTN */
}
 8001894:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    (void)MC_StartMotor1();
 8001898:	f7ff b9aa 	b.w	8000bf0 <MC_StartMotor1>
}
 800189c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    (void)MC_StopMotor1();
 80018a0:	f7ff b9ac 	b.w	8000bfc <MC_StopMotor1>

080018a4 <mc_lock_pins>:

 /**
  * @brief  Locks GPIO pins used for Motor Control to prevent accidental reconfiguration.
  */
__weak void mc_lock_pins (void)
{
 80018a4:	b4f0      	push	{r4, r5, r6, r7}
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
{
  __IO uint32_t temp;
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80018a6:	f04f 4390 	mov.w	r3, #1207959552	@ 0x48000000
 80018aa:	f44f 32c0 	mov.w	r2, #98304	@ 0x18000
  WRITE_REG(GPIOx->LCKR, PinMask);
 80018ae:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80018b2:	61da      	str	r2, [r3, #28]
 80018b4:	b08e      	sub	sp, #56	@ 0x38
  WRITE_REG(GPIOx->LCKR, PinMask);
 80018b6:	61d9      	str	r1, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80018b8:	61da      	str	r2, [r3, #28]
  /* Read LCKR register. This read is mandatory to complete key lock sequence */
  temp = READ_REG(GPIOx->LCKR);
 80018ba:	69d9      	ldr	r1, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80018bc:	4a36      	ldr	r2, [pc, #216]	@ (8001998 <mc_lock_pins+0xf4>)
  temp = READ_REG(GPIOx->LCKR);
 80018be:	910d      	str	r1, [sp, #52]	@ 0x34
  WRITE_REG(GPIOx->LCKR, PinMask);
 80018c0:	2008      	movs	r0, #8
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80018c2:	4936      	ldr	r1, [pc, #216]	@ (800199c <mc_lock_pins+0xf8>)
  (void) temp;
 80018c4:	9c0d      	ldr	r4, [sp, #52]	@ 0x34
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80018c6:	61d1      	str	r1, [r2, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 80018c8:	61d0      	str	r0, [r2, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80018ca:	61d1      	str	r1, [r2, #28]
  temp = READ_REG(GPIOx->LCKR);
 80018cc:	69d1      	ldr	r1, [r2, #28]
 80018ce:	910c      	str	r1, [sp, #48]	@ 0x30
  WRITE_REG(GPIOx->LCKR, PinMask);
 80018d0:	f44f 7080 	mov.w	r0, #256	@ 0x100
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80018d4:	4932      	ldr	r1, [pc, #200]	@ (80019a0 <mc_lock_pins+0xfc>)
  (void) temp;
 80018d6:	9c0c      	ldr	r4, [sp, #48]	@ 0x30
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80018d8:	61d9      	str	r1, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 80018da:	61d8      	str	r0, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80018dc:	61d9      	str	r1, [r3, #28]
  temp = READ_REG(GPIOx->LCKR);
 80018de:	69d9      	ldr	r1, [r3, #28]
 80018e0:	910b      	str	r1, [sp, #44]	@ 0x2c
  WRITE_REG(GPIOx->LCKR, PinMask);
 80018e2:	f44f 7000 	mov.w	r0, #512	@ 0x200
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80018e6:	f44f 3181 	mov.w	r1, #66048	@ 0x10200
  (void) temp;
 80018ea:	9c0b      	ldr	r4, [sp, #44]	@ 0x2c
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80018ec:	61d9      	str	r1, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 80018ee:	61d8      	str	r0, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80018f0:	61d9      	str	r1, [r3, #28]
  temp = READ_REG(GPIOx->LCKR);
 80018f2:	69d9      	ldr	r1, [r3, #28]
 80018f4:	910a      	str	r1, [sp, #40]	@ 0x28
  WRITE_REG(GPIOx->LCKR, PinMask);
 80018f6:	2040      	movs	r0, #64	@ 0x40
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80018f8:	492a      	ldr	r1, [pc, #168]	@ (80019a4 <mc_lock_pins+0x100>)
  (void) temp;
 80018fa:	9c0a      	ldr	r4, [sp, #40]	@ 0x28
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80018fc:	61d9      	str	r1, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 80018fe:	61d8      	str	r0, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8001900:	61d9      	str	r1, [r3, #28]
  temp = READ_REG(GPIOx->LCKR);
 8001902:	69d8      	ldr	r0, [r3, #28]
 8001904:	9009      	str	r0, [sp, #36]	@ 0x24
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8001906:	f04f 1101 	mov.w	r1, #65537	@ 0x10001
  WRITE_REG(GPIOx->LCKR, PinMask);
 800190a:	2401      	movs	r4, #1
  (void) temp;
 800190c:	9809      	ldr	r0, [sp, #36]	@ 0x24
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 800190e:	61d1      	str	r1, [r2, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 8001910:	61d4      	str	r4, [r2, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8001912:	61d1      	str	r1, [r2, #28]
  temp = READ_REG(GPIOx->LCKR);
 8001914:	69d0      	ldr	r0, [r2, #28]
 8001916:	9008      	str	r0, [sp, #32]
  (void) temp;
 8001918:	9d08      	ldr	r5, [sp, #32]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 800191a:	f44f 3082 	mov.w	r0, #66560	@ 0x10400
  WRITE_REG(GPIOx->LCKR, PinMask);
 800191e:	f44f 6580 	mov.w	r5, #1024	@ 0x400
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8001922:	61d8      	str	r0, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 8001924:	61dd      	str	r5, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8001926:	61d8      	str	r0, [r3, #28]
  temp = READ_REG(GPIOx->LCKR);
 8001928:	69d8      	ldr	r0, [r3, #28]
 800192a:	9007      	str	r0, [sp, #28]
  (void) temp;
 800192c:	9d07      	ldr	r5, [sp, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 800192e:	481e      	ldr	r0, [pc, #120]	@ (80019a8 <mc_lock_pins+0x104>)
 8001930:	61d0      	str	r0, [r2, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 8001932:	2502      	movs	r5, #2
 8001934:	61d5      	str	r5, [r2, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8001936:	61d0      	str	r0, [r2, #28]
  temp = READ_REG(GPIOx->LCKR);
 8001938:	69d2      	ldr	r2, [r2, #28]
 800193a:	9206      	str	r2, [sp, #24]
  (void) temp;
 800193c:	9a06      	ldr	r2, [sp, #24]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 800193e:	4a1b      	ldr	r2, [pc, #108]	@ (80019ac <mc_lock_pins+0x108>)
 8001940:	61da      	str	r2, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 8001942:	2680      	movs	r6, #128	@ 0x80
 8001944:	61de      	str	r6, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8001946:	61da      	str	r2, [r3, #28]
  temp = READ_REG(GPIOx->LCKR);
 8001948:	69da      	ldr	r2, [r3, #28]
 800194a:	9205      	str	r2, [sp, #20]
  (void) temp;
 800194c:	9a05      	ldr	r2, [sp, #20]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 800194e:	4a18      	ldr	r2, [pc, #96]	@ (80019b0 <mc_lock_pins+0x10c>)
 8001950:	4e18      	ldr	r6, [pc, #96]	@ (80019b4 <mc_lock_pins+0x110>)
 8001952:	61d6      	str	r6, [r2, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 8001954:	2704      	movs	r7, #4
 8001956:	61d7      	str	r7, [r2, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8001958:	61d6      	str	r6, [r2, #28]
  temp = READ_REG(GPIOx->LCKR);
 800195a:	69d6      	ldr	r6, [r2, #28]
 800195c:	9604      	str	r6, [sp, #16]
  (void) temp;
 800195e:	9e04      	ldr	r6, [sp, #16]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8001960:	61d0      	str	r0, [r2, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 8001962:	61d5      	str	r5, [r2, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8001964:	61d0      	str	r0, [r2, #28]
  temp = READ_REG(GPIOx->LCKR);
 8001966:	69d6      	ldr	r6, [r2, #28]
 8001968:	9603      	str	r6, [sp, #12]
  (void) temp;
 800196a:	9e03      	ldr	r6, [sp, #12]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 800196c:	61d1      	str	r1, [r2, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 800196e:	61d4      	str	r4, [r2, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8001970:	61d1      	str	r1, [r2, #28]
  temp = READ_REG(GPIOx->LCKR);
 8001972:	69d2      	ldr	r2, [r2, #28]
 8001974:	9202      	str	r2, [sp, #8]
  (void) temp;
 8001976:	9a02      	ldr	r2, [sp, #8]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8001978:	61d8      	str	r0, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 800197a:	61dd      	str	r5, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 800197c:	61d8      	str	r0, [r3, #28]
  temp = READ_REG(GPIOx->LCKR);
 800197e:	69da      	ldr	r2, [r3, #28]
 8001980:	9201      	str	r2, [sp, #4]
  (void) temp;
 8001982:	9a01      	ldr	r2, [sp, #4]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8001984:	61d9      	str	r1, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 8001986:	61dc      	str	r4, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8001988:	61d9      	str	r1, [r3, #28]
  temp = READ_REG(GPIOx->LCKR);
 800198a:	69db      	ldr	r3, [r3, #28]
 800198c:	9300      	str	r3, [sp, #0]
  (void) temp;
 800198e:	9b00      	ldr	r3, [sp, #0]
LL_GPIO_LockPin(M1_TEMPERATURE_GPIO_Port, M1_TEMPERATURE_Pin);
LL_GPIO_LockPin(M1_CURR_AMPL_V_GPIO_Port, M1_CURR_AMPL_V_Pin);
LL_GPIO_LockPin(M1_CURR_AMPL_W_GPIO_Port, M1_CURR_AMPL_W_Pin);
LL_GPIO_LockPin(M1_BUS_VOLTAGE_GPIO_Port, M1_BUS_VOLTAGE_Pin);
LL_GPIO_LockPin(M1_CURR_AMPL_U_GPIO_Port, M1_CURR_AMPL_U_Pin);
}
 8001990:	b00e      	add	sp, #56	@ 0x38
 8001992:	bcf0      	pop	{r4, r5, r6, r7}
 8001994:	4770      	bx	lr
 8001996:	bf00      	nop
 8001998:	48000400 	.word	0x48000400
 800199c:	00010008 	.word	0x00010008
 80019a0:	00010100 	.word	0x00010100
 80019a4:	00010040 	.word	0x00010040
 80019a8:	00010002 	.word	0x00010002
 80019ac:	00010080 	.word	0x00010080
 80019b0:	48000800 	.word	0x48000800
 80019b4:	00010004 	.word	0x00010004

080019b8 <FOC_Clear>:
  *         controller. It must be called before each motor restart.
  *         It does not clear speed sensor.
  * @param  bMotor related motor it can be M1 or M2.
  */
__weak void FOC_Clear(uint8_t bMotor)
{
 80019b8:	b538      	push	{r3, r4, r5, lr}
 80019ba:	2326      	movs	r3, #38	@ 0x26
 80019bc:	4916      	ldr	r1, [pc, #88]	@ (8001a18 <FOC_Clear+0x60>)
 80019be:	fb00 f303 	mul.w	r3, r0, r3

  ab_t NULL_ab = {((int16_t)0), ((int16_t)0)};
  qd_t NULL_qd = {((int16_t)0), ((int16_t)0)};
  alphabeta_t NULL_alphabeta = {((int16_t)0), ((int16_t)0)};

  FOCVars[bMotor].Iab = NULL_ab;
 80019c2:	2400      	movs	r4, #0
 80019c4:	50cc      	str	r4, [r1, r3]
{
 80019c6:	4605      	mov	r5, r0
 80019c8:	f103 0208 	add.w	r2, r3, #8
 80019cc:	1858      	adds	r0, r3, r1
 80019ce:	3310      	adds	r3, #16
 80019d0:	440a      	add	r2, r1
 80019d2:	440b      	add	r3, r1
  FOCVars[bMotor].hTeref = (int16_t)0;
  FOCVars[bMotor].Vqd = NULL_qd;
  FOCVars[bMotor].Valphabeta = NULL_alphabeta;
  FOCVars[bMotor].hElAngle = (int16_t)0;

  PID_SetIntegralTerm(pPIDIq[bMotor], ((int32_t)0));
 80019d4:	4911      	ldr	r1, [pc, #68]	@ (8001a1c <FOC_Clear+0x64>)
  FOCVars[bMotor].Iab = NULL_ab;
 80019d6:	6044      	str	r4, [r0, #4]
  PID_SetIntegralTerm(pPIDIq[bMotor], ((int32_t)0));
 80019d8:	f851 0025 	ldr.w	r0, [r1, r5, lsl #2]
  FOCVars[bMotor].Iqd = NULL_qd;
 80019dc:	6054      	str	r4, [r2, #4]
 80019de:	6094      	str	r4, [r2, #8]
  PID_SetIntegralTerm(pPIDIq[bMotor], ((int32_t)0));
 80019e0:	4621      	mov	r1, r4
  FOCVars[bMotor].Vqd = NULL_qd;
 80019e2:	f8c3 4006 	str.w	r4, [r3, #6]
 80019e6:	f8c3 400a 	str.w	r4, [r3, #10]
 80019ea:	f8c3 400e 	str.w	r4, [r3, #14]
  PID_SetIntegralTerm(pPIDIq[bMotor], ((int32_t)0));
 80019ee:	f007 f851 	bl	8008a94 <PID_SetIntegralTerm>
  PID_SetIntegralTerm(pPIDId[bMotor], ((int32_t)0));
 80019f2:	4b0b      	ldr	r3, [pc, #44]	@ (8001a20 <FOC_Clear+0x68>)
 80019f4:	4621      	mov	r1, r4
 80019f6:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
 80019fa:	f007 f84b 	bl	8008a94 <PID_SetIntegralTerm>

  STC_Clear(pSTC[bMotor]);
 80019fe:	4b09      	ldr	r3, [pc, #36]	@ (8001a24 <FOC_Clear+0x6c>)
 8001a00:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
 8001a04:	f008 f8ea 	bl	8009bdc <STC_Clear>

  PWMC_SwitchOffPWM(pwmcHandle[bMotor]);
 8001a08:	4b07      	ldr	r3, [pc, #28]	@ (8001a28 <FOC_Clear+0x70>)
 8001a0a:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]

  /* USER CODE BEGIN FOC_Clear 1 */

  /* USER CODE END FOC_Clear 1 */
}
 8001a0e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  PWMC_SwitchOffPWM(pwmcHandle[bMotor]);
 8001a12:	f000 bdbf 	b.w	8002594 <PWMC_SwitchOffPWM>
 8001a16:	bf00      	nop
 8001a18:	20000754 	.word	0x20000754
 8001a1c:	20000038 	.word	0x20000038
 8001a20:	20000034 	.word	0x20000034
 8001a24:	2000003c 	.word	0x2000003c
 8001a28:	2000077c 	.word	0x2000077c

08001a2c <FOC_Init>:
{
 8001a2c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    pwmcHandle[M1] = &PWM_Handle_M1._Super;
 8001a30:	4b2d      	ldr	r3, [pc, #180]	@ (8001ae8 <FOC_Init+0xbc>)
    PID_HandleInit(&PIDSpeedHandle_M1);
 8001a32:	4e2e      	ldr	r6, [pc, #184]	@ (8001aec <FOC_Init+0xc0>)
    ENC_Init (&ENCODER_M1);
 8001a34:	4c2e      	ldr	r4, [pc, #184]	@ (8001af0 <FOC_Init+0xc4>)
    pwmcHandle[M1] = &PWM_Handle_M1._Super;
 8001a36:	482f      	ldr	r0, [pc, #188]	@ (8001af4 <FOC_Init+0xc8>)
    EAC_Init(&EncAlignCtrlM1,pSTC[M1],&VirtualSpeedSensorM1,&ENCODER_M1);
 8001a38:	4d2f      	ldr	r5, [pc, #188]	@ (8001af8 <FOC_Init+0xcc>)
    pwmcHandle[M1] = &PWM_Handle_M1._Super;
 8001a3a:	6018      	str	r0, [r3, #0]
{
 8001a3c:	b082      	sub	sp, #8
    R3_1_Init(&PWM_Handle_M1);
 8001a3e:	f007 fbb1 	bl	80091a4 <R3_1_Init>
    EAC_Init(&EncAlignCtrlM1,pSTC[M1],&VirtualSpeedSensorM1,&ENCODER_M1);
 8001a42:	f8df 80ec 	ldr.w	r8, [pc, #236]	@ 8001b30 <FOC_Init+0x104>
    PID_HandleInit(&PID_PosParamsM1);
 8001a46:	4f2d      	ldr	r7, [pc, #180]	@ (8001afc <FOC_Init+0xd0>)
    startTimers();
 8001a48:	f000 fbf0 	bl	800222c <startTimers>
    PID_HandleInit(&PIDSpeedHandle_M1);
 8001a4c:	4630      	mov	r0, r6
 8001a4e:	f007 f80d 	bl	8008a6c <PID_HandleInit>
    ENC_Init (&ENCODER_M1);
 8001a52:	4620      	mov	r0, r4
 8001a54:	f006 fcf2 	bl	800843c <ENC_Init>
    EAC_Init(&EncAlignCtrlM1,pSTC[M1],&VirtualSpeedSensorM1,&ENCODER_M1);
 8001a58:	6829      	ldr	r1, [r5, #0]
 8001a5a:	4a29      	ldr	r2, [pc, #164]	@ (8001b00 <FOC_Init+0xd4>)
 8001a5c:	4623      	mov	r3, r4
 8001a5e:	4640      	mov	r0, r8
 8001a60:	f006 fc9e 	bl	80083a0 <EAC_Init>
    pEAC[M1] = &EncAlignCtrlM1;
 8001a64:	4b27      	ldr	r3, [pc, #156]	@ (8001b04 <FOC_Init+0xd8>)
    PID_HandleInit(&PID_PosParamsM1);
 8001a66:	4638      	mov	r0, r7
    pEAC[M1] = &EncAlignCtrlM1;
 8001a68:	f8c3 8000 	str.w	r8, [r3]
    PID_HandleInit(&PID_PosParamsM1);
 8001a6c:	f006 fffe 	bl	8008a6c <PID_HandleInit>
    TC_Init(&PosCtrlM1, &PID_PosParamsM1, &SpeednTorqCtrlM1, &ENCODER_M1);
 8001a70:	4623      	mov	r3, r4
 8001a72:	4639      	mov	r1, r7
 8001a74:	4824      	ldr	r0, [pc, #144]	@ (8001b08 <FOC_Init+0xdc>)
 8001a76:	4a25      	ldr	r2, [pc, #148]	@ (8001b0c <FOC_Init+0xe0>)
 8001a78:	f008 f958 	bl	8009d2c <TC_Init>
    STC_Init(pSTC[M1],&PIDSpeedHandle_M1, &ENCODER_M1._Super);
 8001a7c:	4631      	mov	r1, r6
 8001a7e:	4622      	mov	r2, r4
 8001a80:	6828      	ldr	r0, [r5, #0]
    pMPM[M1]->pFOCVars = &FOCVars[M1];
 8001a82:	4c23      	ldr	r4, [pc, #140]	@ (8001b10 <FOC_Init+0xe4>)
    STC_Init(pSTC[M1],&PIDSpeedHandle_M1, &ENCODER_M1._Super);
 8001a84:	f008 f892 	bl	8009bac <STC_Init>
    PID_HandleInit(&PIDIqHandle_M1);
 8001a88:	4822      	ldr	r0, [pc, #136]	@ (8001b14 <FOC_Init+0xe8>)
 8001a8a:	f006 ffef 	bl	8008a6c <PID_HandleInit>
    PID_HandleInit(&PIDIdHandle_M1);
 8001a8e:	4822      	ldr	r0, [pc, #136]	@ (8001b18 <FOC_Init+0xec>)
 8001a90:	f006 ffec 	bl	8008a6c <PID_HandleInit>
    pMPM[M1]->pVBS = &(BusVoltageSensor_M1._Super);
 8001a94:	4b21      	ldr	r3, [pc, #132]	@ (8001b1c <FOC_Init+0xf0>)
 8001a96:	4a22      	ldr	r2, [pc, #136]	@ (8001b20 <FOC_Init+0xf4>)
 8001a98:	681b      	ldr	r3, [r3, #0]
    pREMNG[M1] = &RampExtMngrHFParamsM1;
 8001a9a:	4822      	ldr	r0, [pc, #136]	@ (8001b24 <FOC_Init+0xf8>)
    pMPM[M1]->pVBS = &(BusVoltageSensor_M1._Super);
 8001a9c:	60da      	str	r2, [r3, #12]
    pREMNG[M1] = &RampExtMngrHFParamsM1;
 8001a9e:	4a22      	ldr	r2, [pc, #136]	@ (8001b28 <FOC_Init+0xfc>)
    pMPM[M1]->pFOCVars = &FOCVars[M1];
 8001aa0:	609c      	str	r4, [r3, #8]
    pREMNG[M1] = &RampExtMngrHFParamsM1;
 8001aa2:	6010      	str	r0, [r2, #0]
    REMNG_Init(pREMNG[M1]);
 8001aa4:	f008 f834 	bl	8009b10 <REMNG_Init>
    FOC_Clear(M1);
 8001aa8:	2000      	movs	r0, #0
 8001aaa:	f7ff ff85 	bl	80019b8 <FOC_Clear>
    FOCVars[M1].bDriveInput = EXTERNAL;
 8001aae:	2301      	movs	r3, #1
    FOCVars[M1].Iqdref = STC_GetDefaultIqdref(pSTC[M1]);
 8001ab0:	6828      	ldr	r0, [r5, #0]
    FOCVars[M1].bDriveInput = EXTERNAL;
 8001ab2:	f884 3024 	strb.w	r3, [r4, #36]	@ 0x24
    FOCVars[M1].Iqdref = STC_GetDefaultIqdref(pSTC[M1]);
 8001ab6:	f008 f923 	bl	8009d00 <STC_GetDefaultIqdref>
 8001aba:	f3c0 420f 	ubfx	r2, r0, #16, #16
 8001abe:	4603      	mov	r3, r0
    FOCVars[M1].UserIdref = STC_GetDefaultIqdref(pSTC[M1]).d;
 8001ac0:	6828      	ldr	r0, [r5, #0]
    FOCVars[M1].Iqdref = STC_GetDefaultIqdref(pSTC[M1]);
 8001ac2:	8262      	strh	r2, [r4, #18]
 8001ac4:	8223      	strh	r3, [r4, #16]
    FOCVars[M1].UserIdref = STC_GetDefaultIqdref(pSTC[M1]).d;
 8001ac6:	f008 f91b 	bl	8009d00 <STC_GetDefaultIqdref>
 8001aca:	f3c0 430f 	ubfx	r3, r0, #16, #16
    MCI_ExecSpeedRamp(&Mci[M1],
 8001ace:	6828      	ldr	r0, [r5, #0]
    FOCVars[M1].UserIdref = STC_GetDefaultIqdref(pSTC[M1]).d;
 8001ad0:	82a3      	strh	r3, [r4, #20]
    MCI_ExecSpeedRamp(&Mci[M1],
 8001ad2:	f008 f911 	bl	8009cf8 <STC_GetMecSpeedRefUnitDefault>
 8001ad6:	4601      	mov	r1, r0
 8001ad8:	4814      	ldr	r0, [pc, #80]	@ (8001b2c <FOC_Init+0x100>)
 8001ada:	2200      	movs	r2, #0
}
 8001adc:	b002      	add	sp, #8
 8001ade:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    MCI_ExecSpeedRamp(&Mci[M1],
 8001ae2:	f7ff bb65 	b.w	80011b0 <MCI_ExecSpeedRamp>
 8001ae6:	bf00      	nop
 8001ae8:	2000077c 	.word	0x2000077c
 8001aec:	20000228 	.word	0x20000228
 8001af0:	20000310 	.word	0x20000310
 8001af4:	2000005c 	.word	0x2000005c
 8001af8:	2000003c 	.word	0x2000003c
 8001afc:	200001a4 	.word	0x200001a4
 8001b00:	200002bc 	.word	0x200002bc
 8001b04:	20000780 	.word	0x20000780
 8001b08:	20000134 	.word	0x20000134
 8001b0c:	20000100 	.word	0x20000100
 8001b10:	20000754 	.word	0x20000754
 8001b14:	200001fc 	.word	0x200001fc
 8001b18:	200001d0 	.word	0x200001d0
 8001b1c:	20000030 	.word	0x20000030
 8001b20:	20000264 	.word	0x20000264
 8001b24:	20000044 	.word	0x20000044
 8001b28:	20000750 	.word	0x20000750
 8001b2c:	20000000 	.word	0x20000000
 8001b30:	200002f4 	.word	0x200002f4

08001b34 <FOC_InitAdditionalMethods>:
    {
  /* USER CODE BEGIN FOC_InitAdditionalMethods 0 */

  /* USER CODE END FOC_InitAdditionalMethods 0 */
    }
}
 8001b34:	4770      	bx	lr
 8001b36:	bf00      	nop

08001b38 <FOC_CalcCurrRef>:
  *         MTPA algorithm(s). It must be called with the periodicity specified
  *         in oTSC parameters.
  * @param  bMotor related motor it can be M1 or M2.
  */
__weak void FOC_CalcCurrRef(uint8_t bMotor)
{
 8001b38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001b3a:	4606      	mov	r6, r0
  __ASM volatile ("cpsid i" : : : "memory");
 8001b3c:	b672      	cpsid	i

  /* Enter critical section */
  /* Disable interrupts to avoid any interruption during Iqd reference latching */
  /* to avoid MF task writing them while HF task reading them */
  __disable_irq();
  IqdTmp = FOCVars[bMotor].Iqdref;
 8001b3e:	4d0d      	ldr	r5, [pc, #52]	@ (8001b74 <FOC_CalcCurrRef+0x3c>)
 8001b40:	2426      	movs	r4, #38	@ 0x26
 8001b42:	fb04 5400 	mla	r4, r4, r0, r5
 8001b46:	f9b4 0010 	ldrsh.w	r0, [r4, #16]
 8001b4a:	f9b4 7012 	ldrsh.w	r7, [r4, #18]
  __ASM volatile ("cpsie i" : : : "memory");
 8001b4e:	b662      	cpsie	i
  __enable_irq();

  /* USER CODE BEGIN FOC_CalcCurrRef 0 */

  /* USER CODE END FOC_CalcCurrRef 0 */
  if (INTERNAL == FOCVars[bMotor].bDriveInput)
 8001b50:	f894 3024 	ldrb.w	r3, [r4, #36]	@ 0x24
 8001b54:	b13b      	cbz	r3, 8001b66 <FOC_CalcCurrRef+0x2e>
  __ASM volatile ("cpsid i" : : : "memory");
 8001b56:	b672      	cpsid	i
  }

  /* Enter critical section */
  /* Disable interrupts to avoid any interruption during Iqd reference restoring */
  __disable_irq();
  FOCVars[bMotor].Iqdref = IqdTmp;
 8001b58:	2326      	movs	r3, #38	@ 0x26
 8001b5a:	fb03 5506 	mla	r5, r3, r6, r5
 8001b5e:	8228      	strh	r0, [r5, #16]
 8001b60:	826f      	strh	r7, [r5, #18]
  __ASM volatile ("cpsie i" : : : "memory");
 8001b62:	b662      	cpsie	i
  /* Exit critical section */
  __enable_irq();
  /* USER CODE BEGIN FOC_CalcCurrRef 1 */

  /* USER CODE END FOC_CalcCurrRef 1 */
}
 8001b64:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    FOCVars[bMotor].hTeref = STC_CalcTorqueReference(pSTC[bMotor]);
 8001b66:	4b04      	ldr	r3, [pc, #16]	@ (8001b78 <FOC_CalcCurrRef+0x40>)
 8001b68:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
 8001b6c:	f008 f88e 	bl	8009c8c <STC_CalcTorqueReference>
 8001b70:	83e0      	strh	r0, [r4, #30]
    IqdTmp.q = FOCVars[bMotor].hTeref;
 8001b72:	e7f0      	b.n	8001b56 <FOC_CalcCurrRef+0x1e>
 8001b74:	20000754 	.word	0x20000754
 8001b78:	2000003c 	.word	0x2000003c

08001b7c <TSK_MediumFrequencyTaskM1>:
{
 8001b7c:	b570      	push	{r4, r5, r6, lr}
 8001b7e:	b082      	sub	sp, #8
  int16_t wAux = 0;
 8001b80:	2300      	movs	r3, #0
  (void)ENC_CalcAvrgMecSpeedUnit(&ENCODER_M1, &wAux);
 8001b82:	f10d 0106 	add.w	r1, sp, #6
 8001b86:	48a4      	ldr	r0, [pc, #656]	@ (8001e18 <TSK_MediumFrequencyTaskM1+0x29c>)
  int16_t wAux = 0;
 8001b88:	f8ad 3006 	strh.w	r3, [sp, #6]
  (void)ENC_CalcAvrgMecSpeedUnit(&ENCODER_M1, &wAux);
 8001b8c:	f006 fcba 	bl	8008504 <ENC_CalcAvrgMecSpeedUnit>
  PQD_CalcElMotorPower(pMPM[M1]);
 8001b90:	4ba2      	ldr	r3, [pc, #648]	@ (8001e1c <TSK_MediumFrequencyTaskM1+0x2a0>)
  if (MCI_GetCurrentFaults(&Mci[M1]) == MC_NO_FAULTS)
 8001b92:	4ca3      	ldr	r4, [pc, #652]	@ (8001e20 <TSK_MediumFrequencyTaskM1+0x2a4>)
  PQD_CalcElMotorPower(pMPM[M1]);
 8001b94:	6818      	ldr	r0, [r3, #0]
 8001b96:	f007 f80d 	bl	8008bb4 <PQD_CalcElMotorPower>
  if (MCI_GetCurrentFaults(&Mci[M1]) == MC_NO_FAULTS)
 8001b9a:	4620      	mov	r0, r4
 8001b9c:	f7ff fbae 	bl	80012fc <MCI_GetCurrentFaults>
 8001ba0:	b120      	cbz	r0, 8001bac <TSK_MediumFrequencyTaskM1+0x30>
    Mci[M1].State = FAULT_NOW;
 8001ba2:	230a      	movs	r3, #10
 8001ba4:	f884 3023 	strb.w	r3, [r4, #35]	@ 0x23
}
 8001ba8:	b002      	add	sp, #8
 8001baa:	bd70      	pop	{r4, r5, r6, pc}
    if (MCI_GetOccurredFaults(&Mci[M1]) == MC_NO_FAULTS)
 8001bac:	4620      	mov	r0, r4
 8001bae:	f7ff fba3 	bl	80012f8 <MCI_GetOccurredFaults>
 8001bb2:	bb88      	cbnz	r0, 8001c18 <TSK_MediumFrequencyTaskM1+0x9c>
      switch (Mci[M1].State)
 8001bb4:	f894 3023 	ldrb.w	r3, [r4, #35]	@ 0x23
 8001bb8:	2b14      	cmp	r3, #20
 8001bba:	d8f5      	bhi.n	8001ba8 <TSK_MediumFrequencyTaskM1+0x2c>
 8001bbc:	a201      	add	r2, pc, #4	@ (adr r2, 8001bc4 <TSK_MediumFrequencyTaskM1+0x48>)
 8001bbe:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8001bc2:	bf00      	nop
 8001bc4:	08001d83 	.word	0x08001d83
 8001bc8:	08001ba9 	.word	0x08001ba9
 8001bcc:	08001d33 	.word	0x08001d33
 8001bd0:	08001ba9 	.word	0x08001ba9
 8001bd4:	08001ba9 	.word	0x08001ba9
 8001bd8:	08001ba9 	.word	0x08001ba9
 8001bdc:	08001d15 	.word	0x08001d15
 8001be0:	08001ba9 	.word	0x08001ba9
 8001be4:	08001d09 	.word	0x08001d09
 8001be8:	08001ba9 	.word	0x08001ba9
 8001bec:	08001c19 	.word	0x08001c19
 8001bf0:	08001cf9 	.word	0x08001cf9
 8001bf4:	08001ba9 	.word	0x08001ba9
 8001bf8:	08001ba9 	.word	0x08001ba9
 8001bfc:	08001ba9 	.word	0x08001ba9
 8001c00:	08001ba9 	.word	0x08001ba9
 8001c04:	08001ca5 	.word	0x08001ca5
 8001c08:	08001c6d 	.word	0x08001c6d
 8001c0c:	08001ba9 	.word	0x08001ba9
 8001c10:	08001ba9 	.word	0x08001ba9
 8001c14:	08001c23 	.word	0x08001c23
      Mci[M1].State = FAULT_OVER;
 8001c18:	230b      	movs	r3, #11
 8001c1a:	f884 3023 	strb.w	r3, [r4, #35]	@ 0x23
}
 8001c1e:	b002      	add	sp, #8
 8001c20:	bd70      	pop	{r4, r5, r6, pc}
          if (MCI_STOP == Mci[M1].DirectCommand)
 8001c22:	f894 3022 	ldrb.w	r3, [r4, #34]	@ 0x22
 8001c26:	2b05      	cmp	r3, #5
 8001c28:	f000 80bd 	beq.w	8001da6 <TSK_MediumFrequencyTaskM1+0x22a>
            if (TSK_StopPermanencyTimeHasElapsedM1())
 8001c2c:	f7ff fd7c 	bl	8001728 <TSK_StopPermanencyTimeHasElapsedM1>
 8001c30:	2800      	cmp	r0, #0
 8001c32:	d0b9      	beq.n	8001ba8 <TSK_MediumFrequencyTaskM1+0x2c>
              ENC_Clear(&ENCODER_M1);
 8001c34:	4878      	ldr	r0, [pc, #480]	@ (8001e18 <TSK_MediumFrequencyTaskM1+0x29c>)
 8001c36:	f006 fc3d 	bl	80084b4 <ENC_Clear>
              R3_1_SwitchOnPWM(pwmcHandle[M1]);
 8001c3a:	4b7a      	ldr	r3, [pc, #488]	@ (8001e24 <TSK_MediumFrequencyTaskM1+0x2a8>)
 8001c3c:	6818      	ldr	r0, [r3, #0]
 8001c3e:	f007 f919 	bl	8008e74 <R3_1_SwitchOnPWM>
              TC_EncAlignmentCommand(pPosCtrl[M1]);
 8001c42:	4b79      	ldr	r3, [pc, #484]	@ (8001e28 <TSK_MediumFrequencyTaskM1+0x2ac>)
 8001c44:	6818      	ldr	r0, [r3, #0]
 8001c46:	f008 fa1f 	bl	800a088 <TC_EncAlignmentCommand>
              FOC_InitAdditionalMethods(M1);
 8001c4a:	2000      	movs	r0, #0
 8001c4c:	f7ff ff72 	bl	8001b34 <FOC_InitAdditionalMethods>
              STC_ForceSpeedReferenceToCurrentSpeed(pSTC[M1]); /* Init the reference speed to current speed */
 8001c50:	4b76      	ldr	r3, [pc, #472]	@ (8001e2c <TSK_MediumFrequencyTaskM1+0x2b0>)
 8001c52:	6818      	ldr	r0, [r3, #0]
 8001c54:	f008 f862 	bl	8009d1c <STC_ForceSpeedReferenceToCurrentSpeed>
              MCI_ExecBufferedCommands(&Mci[M1]); /* Exec the speed ramp after changing of the speed sensor */
 8001c58:	4871      	ldr	r0, [pc, #452]	@ (8001e20 <TSK_MediumFrequencyTaskM1+0x2a4>)
 8001c5a:	f7ff fb09 	bl	8001270 <MCI_ExecBufferedCommands>
              FOC_CalcCurrRef(M1);
 8001c5e:	2000      	movs	r0, #0
 8001c60:	f7ff ff6a 	bl	8001b38 <FOC_CalcCurrRef>
              Mci[M1].State = RUN;
 8001c64:	2306      	movs	r3, #6
 8001c66:	f884 3023 	strb.w	r3, [r4, #35]	@ 0x23
 8001c6a:	e79d      	b.n	8001ba8 <TSK_MediumFrequencyTaskM1+0x2c>
          if (MCI_STOP == Mci[M1].DirectCommand)
 8001c6c:	f894 3022 	ldrb.w	r3, [r4, #34]	@ 0x22
            if (pwmcHandle[M1]->offsetCalibStatus == false)
 8001c70:	4d6c      	ldr	r5, [pc, #432]	@ (8001e24 <TSK_MediumFrequencyTaskM1+0x2a8>)
          if (MCI_STOP == Mci[M1].DirectCommand)
 8001c72:	2b05      	cmp	r3, #5
            if (pwmcHandle[M1]->offsetCalibStatus == false)
 8001c74:	6828      	ldr	r0, [r5, #0]
          if (MCI_STOP == Mci[M1].DirectCommand)
 8001c76:	f000 8098 	beq.w	8001daa <TSK_MediumFrequencyTaskM1+0x22e>
            if (PWMC_CurrentReadingCalibr(pwmcHandle[M1], CRC_EXEC))
 8001c7a:	2101      	movs	r1, #1
 8001c7c:	f000 fc8e 	bl	800259c <PWMC_CurrentReadingCalibr>
 8001c80:	2800      	cmp	r0, #0
 8001c82:	d091      	beq.n	8001ba8 <TSK_MediumFrequencyTaskM1+0x2c>
              if (MCI_MEASURE_OFFSETS == Mci[M1].DirectCommand)
 8001c84:	f894 3022 	ldrb.w	r3, [r4, #34]	@ 0x22
 8001c88:	2b03      	cmp	r3, #3
 8001c8a:	f000 80a9 	beq.w	8001de0 <TSK_MediumFrequencyTaskM1+0x264>
                R3_1_TurnOnLowSides(pwmcHandle[M1],M1_CHARGE_BOOT_CAP_DUTY_CYCLES);
 8001c8e:	6828      	ldr	r0, [r5, #0]
 8001c90:	2100      	movs	r1, #0
 8001c92:	f007 f9e9 	bl	8009068 <R3_1_TurnOnLowSides>
                TSK_SetChargeBootCapDelayM1(M1_CHARGE_BOOT_CAP_TICKS);
 8001c96:	2014      	movs	r0, #20
 8001c98:	f7ff fd30 	bl	80016fc <TSK_SetChargeBootCapDelayM1>
                Mci[M1].State = CHARGE_BOOT_CAP;
 8001c9c:	2310      	movs	r3, #16
 8001c9e:	f884 3023 	strb.w	r3, [r4, #35]	@ 0x23
 8001ca2:	e781      	b.n	8001ba8 <TSK_MediumFrequencyTaskM1+0x2c>
          if (MCI_STOP == Mci[M1].DirectCommand)
 8001ca4:	f894 3022 	ldrb.w	r3, [r4, #34]	@ 0x22
 8001ca8:	2b05      	cmp	r3, #5
 8001caa:	d07c      	beq.n	8001da6 <TSK_MediumFrequencyTaskM1+0x22a>
            if (TSK_ChargeBootCapDelayHasElapsedM1())
 8001cac:	f7ff fd2c 	bl	8001708 <TSK_ChargeBootCapDelayHasElapsedM1>
 8001cb0:	2800      	cmp	r0, #0
 8001cb2:	f43f af79 	beq.w	8001ba8 <TSK_MediumFrequencyTaskM1+0x2c>
              R3_1_SwitchOffPWM(pwmcHandle[M1]);
 8001cb6:	4d5b      	ldr	r5, [pc, #364]	@ (8001e24 <TSK_MediumFrequencyTaskM1+0x2a8>)
              STC_SetSpeedSensor( pSTC[M1], &VirtualSpeedSensorM1._Super );
 8001cb8:	4e5c      	ldr	r6, [pc, #368]	@ (8001e2c <TSK_MediumFrequencyTaskM1+0x2b0>)
              R3_1_SwitchOffPWM(pwmcHandle[M1]);
 8001cba:	6828      	ldr	r0, [r5, #0]
 8001cbc:	f007 f924 	bl	8008f08 <R3_1_SwitchOffPWM>
              FOCVars[M1].bDriveInput = EXTERNAL;
 8001cc0:	4b5b      	ldr	r3, [pc, #364]	@ (8001e30 <TSK_MediumFrequencyTaskM1+0x2b4>)
              STC_SetSpeedSensor( pSTC[M1], &VirtualSpeedSensorM1._Super );
 8001cc2:	495c      	ldr	r1, [pc, #368]	@ (8001e34 <TSK_MediumFrequencyTaskM1+0x2b8>)
 8001cc4:	6830      	ldr	r0, [r6, #0]
              FOCVars[M1].bDriveInput = EXTERNAL;
 8001cc6:	2201      	movs	r2, #1
 8001cc8:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
              STC_SetSpeedSensor( pSTC[M1], &VirtualSpeedSensorM1._Super );
 8001ccc:	f007 ff84 	bl	8009bd8 <STC_SetSpeedSensor>
              ENC_Clear(&ENCODER_M1);
 8001cd0:	4851      	ldr	r0, [pc, #324]	@ (8001e18 <TSK_MediumFrequencyTaskM1+0x29c>)
 8001cd2:	f006 fbef 	bl	80084b4 <ENC_Clear>
              FOC_Clear( M1 );
 8001cd6:	2000      	movs	r0, #0
 8001cd8:	f7ff fe6e 	bl	80019b8 <FOC_Clear>
static inline bool EAC_IsAligned(EncAlign_Handle_t *pHandle)
{
#ifdef NULL_PTR_CHECK_ENC_ALI_CTRL
  return ((NULL == pHandle) ? false : pHandle->EncAligned);
#else
  return (pHandle->EncAligned);
 8001cdc:	4856      	ldr	r0, [pc, #344]	@ (8001e38 <TSK_MediumFrequencyTaskM1+0x2bc>)
              if (EAC_IsAligned(&EncAlignCtrlM1) == false)
 8001cde:	7b83      	ldrb	r3, [r0, #14]
 8001ce0:	2b00      	cmp	r3, #0
 8001ce2:	f040 8083 	bne.w	8001dec <TSK_MediumFrequencyTaskM1+0x270>
                EAC_StartAlignment(&EncAlignCtrlM1);
 8001ce6:	f006 fb63 	bl	80083b0 <EAC_StartAlignment>
                Mci[M1].State = ALIGNMENT;
 8001cea:	2302      	movs	r3, #2
              PWMC_SwitchOnPWM(pwmcHandle[M1]);
 8001cec:	6828      	ldr	r0, [r5, #0]
                Mci[M1].State = ALIGNMENT;
 8001cee:	f884 3023 	strb.w	r3, [r4, #35]	@ 0x23
              PWMC_SwitchOnPWM(pwmcHandle[M1]);
 8001cf2:	f000 fc51 	bl	8002598 <PWMC_SwitchOnPWM>
 8001cf6:	e757      	b.n	8001ba8 <TSK_MediumFrequencyTaskM1+0x2c>
          if (MCI_ACK_FAULTS == Mci[M1].DirectCommand)
 8001cf8:	f894 3022 	ldrb.w	r3, [r4, #34]	@ 0x22
 8001cfc:	2b02      	cmp	r3, #2
 8001cfe:	f47f af53 	bne.w	8001ba8 <TSK_MediumFrequencyTaskM1+0x2c>
            Mci[M1].DirectCommand = MCI_NO_COMMAND;
 8001d02:	2300      	movs	r3, #0
 8001d04:	8463      	strh	r3, [r4, #34]	@ 0x22
 8001d06:	e74f      	b.n	8001ba8 <TSK_MediumFrequencyTaskM1+0x2c>
          if (TSK_StopPermanencyTimeHasElapsedM1())
 8001d08:	f7ff fd0e 	bl	8001728 <TSK_StopPermanencyTimeHasElapsedM1>
 8001d0c:	2800      	cmp	r0, #0
 8001d0e:	f43f af4b 	beq.w	8001ba8 <TSK_MediumFrequencyTaskM1+0x2c>
 8001d12:	e7f6      	b.n	8001d02 <TSK_MediumFrequencyTaskM1+0x186>
          if (MCI_STOP == Mci[M1].DirectCommand)
 8001d14:	f894 3022 	ldrb.w	r3, [r4, #34]	@ 0x22
 8001d18:	2b05      	cmp	r3, #5
 8001d1a:	d044      	beq.n	8001da6 <TSK_MediumFrequencyTaskM1+0x22a>
            TC_PositionRegulation(pPosCtrl[M1]);
 8001d1c:	4b42      	ldr	r3, [pc, #264]	@ (8001e28 <TSK_MediumFrequencyTaskM1+0x2ac>)
 8001d1e:	6818      	ldr	r0, [r3, #0]
 8001d20:	f008 f970 	bl	800a004 <TC_PositionRegulation>
            MCI_ExecBufferedCommands(&Mci[M1]);
 8001d24:	483e      	ldr	r0, [pc, #248]	@ (8001e20 <TSK_MediumFrequencyTaskM1+0x2a4>)
 8001d26:	f7ff faa3 	bl	8001270 <MCI_ExecBufferedCommands>
              FOC_CalcCurrRef(M1);
 8001d2a:	2000      	movs	r0, #0
 8001d2c:	f7ff ff04 	bl	8001b38 <FOC_CalcCurrRef>
 8001d30:	e73a      	b.n	8001ba8 <TSK_MediumFrequencyTaskM1+0x2c>
          if (MCI_STOP == Mci[M1].DirectCommand)
 8001d32:	f894 3022 	ldrb.w	r3, [r4, #34]	@ 0x22
 8001d36:	2b05      	cmp	r3, #5
 8001d38:	d035      	beq.n	8001da6 <TSK_MediumFrequencyTaskM1+0x22a>
 8001d3a:	483f      	ldr	r0, [pc, #252]	@ (8001e38 <TSK_MediumFrequencyTaskM1+0x2bc>)
 8001d3c:	7b86      	ldrb	r6, [r0, #14]
            bool EACDone = EAC_Exec(&EncAlignCtrlM1);
 8001d3e:	f006 fb65 	bl	800840c <EAC_Exec>
 8001d42:	4605      	mov	r5, r0
            if ((isAligned == false)  && (EACDone == false))
 8001d44:	b90e      	cbnz	r6, 8001d4a <TSK_MediumFrequencyTaskM1+0x1ce>
 8001d46:	2800      	cmp	r0, #0
 8001d48:	d042      	beq.n	8001dd0 <TSK_MediumFrequencyTaskM1+0x254>
              R3_1_SwitchOffPWM( pwmcHandle[M1] );
 8001d4a:	4d36      	ldr	r5, [pc, #216]	@ (8001e24 <TSK_MediumFrequencyTaskM1+0x2a8>)
              STC_SetControlMode(pSTC[M1], MCM_SPEED_MODE);
 8001d4c:	4e37      	ldr	r6, [pc, #220]	@ (8001e2c <TSK_MediumFrequencyTaskM1+0x2b0>)
              R3_1_SwitchOffPWM( pwmcHandle[M1] );
 8001d4e:	6828      	ldr	r0, [r5, #0]
 8001d50:	f007 f8da 	bl	8008f08 <R3_1_SwitchOffPWM>
              STC_SetControlMode(pSTC[M1], MCM_SPEED_MODE);
 8001d54:	6830      	ldr	r0, [r6, #0]
 8001d56:	2103      	movs	r1, #3
 8001d58:	f007 ff4c 	bl	8009bf4 <STC_SetControlMode>
              STC_SetSpeedSensor(pSTC[M1], &ENCODER_M1._Super);
 8001d5c:	492e      	ldr	r1, [pc, #184]	@ (8001e18 <TSK_MediumFrequencyTaskM1+0x29c>)
 8001d5e:	6830      	ldr	r0, [r6, #0]
 8001d60:	f007 ff3a 	bl	8009bd8 <STC_SetSpeedSensor>
              FOC_Clear(M1);
 8001d64:	2000      	movs	r0, #0
 8001d66:	f7ff fe27 	bl	80019b8 <FOC_Clear>
              R3_1_TurnOnLowSides(pwmcHandle[M1],M1_CHARGE_BOOT_CAP_DUTY_CYCLES);
 8001d6a:	6828      	ldr	r0, [r5, #0]
 8001d6c:	2100      	movs	r1, #0
 8001d6e:	f007 f97b 	bl	8009068 <R3_1_TurnOnLowSides>
              TSK_SetStopPermanencyTimeM1(STOPPERMANENCY_TICKS);
 8001d72:	f44f 7048 	mov.w	r0, #800	@ 0x320
 8001d76:	f7ff fcd1 	bl	800171c <TSK_SetStopPermanencyTimeM1>
              Mci[M1].State = WAIT_STOP_MOTOR;
 8001d7a:	2314      	movs	r3, #20
 8001d7c:	f884 3023 	strb.w	r3, [r4, #35]	@ 0x23
 8001d80:	e712      	b.n	8001ba8 <TSK_MediumFrequencyTaskM1+0x2c>
          if ((MCI_START == Mci[M1].DirectCommand) || (MCI_MEASURE_OFFSETS == Mci[M1].DirectCommand))
 8001d82:	f894 3022 	ldrb.w	r3, [r4, #34]	@ 0x22
 8001d86:	f003 03fd 	and.w	r3, r3, #253	@ 0xfd
 8001d8a:	2b01      	cmp	r3, #1
 8001d8c:	f47f af0c 	bne.w	8001ba8 <TSK_MediumFrequencyTaskM1+0x2c>
            if (pwmcHandle[M1]->offsetCalibStatus == false)
 8001d90:	4d24      	ldr	r5, [pc, #144]	@ (8001e24 <TSK_MediumFrequencyTaskM1+0x2a8>)
 8001d92:	6828      	ldr	r0, [r5, #0]
 8001d94:	f890 107f 	ldrb.w	r1, [r0, #127]	@ 0x7f
 8001d98:	b9a1      	cbnz	r1, 8001dc4 <TSK_MediumFrequencyTaskM1+0x248>
              (void)PWMC_CurrentReadingCalibr(pwmcHandle[M1], CRC_START);
 8001d9a:	f000 fbff 	bl	800259c <PWMC_CurrentReadingCalibr>
              Mci[M1].State = OFFSET_CALIB;
 8001d9e:	2311      	movs	r3, #17
 8001da0:	f884 3023 	strb.w	r3, [r4, #35]	@ 0x23
 8001da4:	e700      	b.n	8001ba8 <TSK_MediumFrequencyTaskM1+0x2c>
    R3_1_SwitchOffPWM(pwmcHandle[motor]);
 8001da6:	4b1f      	ldr	r3, [pc, #124]	@ (8001e24 <TSK_MediumFrequencyTaskM1+0x2a8>)
 8001da8:	6818      	ldr	r0, [r3, #0]
 8001daa:	f007 f8ad 	bl	8008f08 <R3_1_SwitchOffPWM>
  FOC_Clear(motor);
 8001dae:	2000      	movs	r0, #0
 8001db0:	f7ff fe02 	bl	80019b8 <FOC_Clear>
  TSK_SetStopPermanencyTimeM1(STOPPERMANENCY_TICKS);
 8001db4:	f44f 7048 	mov.w	r0, #800	@ 0x320
 8001db8:	f7ff fcb0 	bl	800171c <TSK_SetStopPermanencyTimeM1>
  Mci[motor].State = STOP;
 8001dbc:	2308      	movs	r3, #8
 8001dbe:	f884 3023 	strb.w	r3, [r4, #35]	@ 0x23
}
 8001dc2:	e6f1      	b.n	8001ba8 <TSK_MediumFrequencyTaskM1+0x2c>
              (void)PWMC_CurrentReadingCalibr(pwmcHandle[M1], CRC_EXEC);
 8001dc4:	4619      	mov	r1, r3
              pwmcHandle[M1]->OffCalibrWaitTimeCounter = 1u;
 8001dc6:	f8a0 3060 	strh.w	r3, [r0, #96]	@ 0x60
              (void)PWMC_CurrentReadingCalibr(pwmcHandle[M1], CRC_EXEC);
 8001dca:	f000 fbe7 	bl	800259c <PWMC_CurrentReadingCalibr>
              R3_1_TurnOnLowSides(pwmcHandle[M1],M1_CHARGE_BOOT_CAP_DUTY_CYCLES);
 8001dce:	e75e      	b.n	8001c8e <TSK_MediumFrequencyTaskM1+0x112>
              IqdRef.d = STC_CalcTorqueReference(pSTC[M1]);
 8001dd0:	4b16      	ldr	r3, [pc, #88]	@ (8001e2c <TSK_MediumFrequencyTaskM1+0x2b0>)
 8001dd2:	6818      	ldr	r0, [r3, #0]
 8001dd4:	f007 ff5a 	bl	8009c8c <STC_CalcTorqueReference>
              FOCVars[M1].Iqdref = IqdRef;
 8001dd8:	4b15      	ldr	r3, [pc, #84]	@ (8001e30 <TSK_MediumFrequencyTaskM1+0x2b4>)
 8001dda:	821d      	strh	r5, [r3, #16]
 8001ddc:	8258      	strh	r0, [r3, #18]
            {
 8001dde:	e6e3      	b.n	8001ba8 <TSK_MediumFrequencyTaskM1+0x2c>
                FOC_Clear(M1);
 8001de0:	2000      	movs	r0, #0
 8001de2:	f7ff fde9 	bl	80019b8 <FOC_Clear>
                Mci[M1].DirectCommand = MCI_NO_COMMAND;
 8001de6:	2300      	movs	r3, #0
 8001de8:	8463      	strh	r3, [r4, #34]	@ 0x22
 8001dea:	e6dd      	b.n	8001ba8 <TSK_MediumFrequencyTaskM1+0x2c>
                STC_SetControlMode(pSTC[M1], MCM_SPEED_MODE);
 8001dec:	6830      	ldr	r0, [r6, #0]
 8001dee:	2103      	movs	r1, #3
 8001df0:	f007 ff00 	bl	8009bf4 <STC_SetControlMode>
                STC_SetSpeedSensor(pSTC[M1], &ENCODER_M1._Super);
 8001df4:	4908      	ldr	r1, [pc, #32]	@ (8001e18 <TSK_MediumFrequencyTaskM1+0x29c>)
 8001df6:	6830      	ldr	r0, [r6, #0]
 8001df8:	f007 feee 	bl	8009bd8 <STC_SetSpeedSensor>
                FOC_InitAdditionalMethods(M1);
 8001dfc:	2000      	movs	r0, #0
 8001dfe:	f7ff fe99 	bl	8001b34 <FOC_InitAdditionalMethods>
                FOC_CalcCurrRef(M1);
 8001e02:	2000      	movs	r0, #0
 8001e04:	f7ff fe98 	bl	8001b38 <FOC_CalcCurrRef>
                STC_ForceSpeedReferenceToCurrentSpeed(pSTC[M1]); /* Init the reference speed to current speed */
 8001e08:	6830      	ldr	r0, [r6, #0]
 8001e0a:	f007 ff87 	bl	8009d1c <STC_ForceSpeedReferenceToCurrentSpeed>
                MCI_ExecBufferedCommands(&Mci[M1]); /* Exec the speed ramp after changing of the speed sensor */
 8001e0e:	4804      	ldr	r0, [pc, #16]	@ (8001e20 <TSK_MediumFrequencyTaskM1+0x2a4>)
 8001e10:	f7ff fa2e 	bl	8001270 <MCI_ExecBufferedCommands>
 8001e14:	2306      	movs	r3, #6
 8001e16:	e769      	b.n	8001cec <TSK_MediumFrequencyTaskM1+0x170>
 8001e18:	20000310 	.word	0x20000310
 8001e1c:	20000030 	.word	0x20000030
 8001e20:	20000000 	.word	0x20000000
 8001e24:	2000077c 	.word	0x2000077c
 8001e28:	2000002c 	.word	0x2000002c
 8001e2c:	2000003c 	.word	0x2000003c
 8001e30:	20000754 	.word	0x20000754
 8001e34:	200002bc 	.word	0x200002bc
 8001e38:	200002f4 	.word	0x200002f4

08001e3c <FOC_HighFrequencyTask>:
  * subsystem (see the state machine(s)).
  *
  * @retval Number of the  motor instance which FOC loop was executed.
  */
__weak uint8_t FOC_HighFrequencyTask(uint8_t bMotorNbr)
{
 8001e3c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001e40:	4605      	mov	r5, r0
 8001e42:	b086      	sub	sp, #24
  uint16_t hFOCreturn;
  /* USER CODE BEGIN HighFrequencyTask 0 */

  /* USER CODE END HighFrequencyTask 0 */

  (void)ENC_CalcAngle(&ENCODER_M1);   /* If not sensorless then 2nd parameter is MC_NULL */
 8001e44:	482d      	ldr	r0, [pc, #180]	@ (8001efc <FOC_HighFrequencyTask+0xc0>)
  int16_t hElAngle;
  uint16_t hCodeError;
  SpeednPosFdbk_Handle_t *speedHandle;
  speedHandle = STC_GetSpeedSensor(pSTC[M1]);
  hElAngle = SPD_GetElAngle(speedHandle);
  PWMC_GetPhaseCurrents(pwmcHandle[M1], &Iab);
 8001e46:	f8df 80d0 	ldr.w	r8, [pc, #208]	@ 8001f18 <FOC_HighFrequencyTask+0xdc>
  RCM_ReadOngoingConv();
  RCM_ExecNextConv();
  Ialphabeta = MCM_Clarke(Iab);
  Iqd = MCM_Park(Ialphabeta, hElAngle);
  Vqd.q = PI_Controller(pPIDIq[M1], (int32_t)(FOCVars[M1].Iqdref.q) - Iqd.q);
 8001e4a:	4c2d      	ldr	r4, [pc, #180]	@ (8001f00 <FOC_HighFrequencyTask+0xc4>)
  (void)ENC_CalcAngle(&ENCODER_M1);   /* If not sensorless then 2nd parameter is MC_NULL */
 8001e4c:	f006 fb40 	bl	80084d0 <ENC_CalcAngle>
  speedHandle = STC_GetSpeedSensor(pSTC[M1]);
 8001e50:	4b2c      	ldr	r3, [pc, #176]	@ (8001f04 <FOC_HighFrequencyTask+0xc8>)
  PWMC_GetPhaseCurrents(pwmcHandle[M1], &Iab);
 8001e52:	f8d8 0000 	ldr.w	r0, [r8]
 8001e56:	681b      	ldr	r3, [r3, #0]
static inline int16_t SPD_GetElAngle(const SpeednPosFdbk_Handle_t *pHandle)
{
#ifdef NULL_PTR_CHECK_SPD_POS_FBK
  return ((MC_NULL == pHandle) ? 0 : pHandle->hElAngle);
#else
  return (pHandle->hElAngle);
 8001e58:	695a      	ldr	r2, [r3, #20]
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->pFctGetPhaseCurrents(pHandle, Iab);
 8001e5a:	6803      	ldr	r3, [r0, #0]
 8001e5c:	f9b2 6004 	ldrsh.w	r6, [r2, #4]
 8001e60:	a903      	add	r1, sp, #12
 8001e62:	4798      	blx	r3
  RCM_ReadOngoingConv();
 8001e64:	f001 fdde 	bl	8003a24 <RCM_ReadOngoingConv>
  RCM_ExecNextConv();
 8001e68:	f001 fd98 	bl	800399c <RCM_ExecNextConv>
  Ialphabeta = MCM_Clarke(Iab);
 8001e6c:	9803      	ldr	r0, [sp, #12]
 8001e6e:	f7ff fb13 	bl	8001498 <MCM_Clarke>
  Iqd = MCM_Park(Ialphabeta, hElAngle);
 8001e72:	4631      	mov	r1, r6
  Ialphabeta = MCM_Clarke(Iab);
 8001e74:	9004      	str	r0, [sp, #16]
  Iqd = MCM_Park(Ialphabeta, hElAngle);
 8001e76:	f7ff fb4f 	bl	8001518 <MCM_Park>
  Vqd.q = PI_Controller(pPIDIq[M1], (int32_t)(FOCVars[M1].Iqdref.q) - Iqd.q);
 8001e7a:	f9b4 3010 	ldrsh.w	r3, [r4, #16]
  Iqd = MCM_Park(Ialphabeta, hElAngle);
 8001e7e:	9001      	str	r0, [sp, #4]
  Vqd.q = PI_Controller(pPIDIq[M1], (int32_t)(FOCVars[M1].Iqdref.q) - Iqd.q);
 8001e80:	b201      	sxth	r1, r0
 8001e82:	1a59      	subs	r1, r3, r1
 8001e84:	4b20      	ldr	r3, [pc, #128]	@ (8001f08 <FOC_HighFrequencyTask+0xcc>)
 8001e86:	6818      	ldr	r0, [r3, #0]
 8001e88:	f006 fe36 	bl	8008af8 <PI_Controller>
  Vqd.d = PI_Controller(pPIDId[M1], (int32_t)(FOCVars[M1].Iqdref.d) - Iqd.d);
 8001e8c:	f9bd 3006 	ldrsh.w	r3, [sp, #6]
 8001e90:	f9b4 1012 	ldrsh.w	r1, [r4, #18]
 8001e94:	1ac9      	subs	r1, r1, r3
 8001e96:	4b1d      	ldr	r3, [pc, #116]	@ (8001f0c <FOC_HighFrequencyTask+0xd0>)
  Vqd.q = PI_Controller(pPIDIq[M1], (int32_t)(FOCVars[M1].Iqdref.q) - Iqd.q);
 8001e98:	4607      	mov	r7, r0
  Vqd.d = PI_Controller(pPIDId[M1], (int32_t)(FOCVars[M1].Iqdref.d) - Iqd.d);
 8001e9a:	6818      	ldr	r0, [r3, #0]
 8001e9c:	f006 fe2c 	bl	8008af8 <PI_Controller>
  Vqd = Circle_Limitation(&CircleLimitationM1, Vqd);
 8001ea0:	f8ad 7008 	strh.w	r7, [sp, #8]
 8001ea4:	f8ad 000a 	strh.w	r0, [sp, #10]
 8001ea8:	9902      	ldr	r1, [sp, #8]
 8001eaa:	4819      	ldr	r0, [pc, #100]	@ (8001f10 <FOC_HighFrequencyTask+0xd4>)
 8001eac:	f006 fa4a 	bl	8008344 <Circle_Limitation>
  hElAngle += SPD_GetInstElSpeedDpp(speedHandle)*REV_PARK_ANGLE_COMPENSATION_FACTOR;
  Valphabeta = MCM_Rev_Park(Vqd, hElAngle);
 8001eb0:	4631      	mov	r1, r6
  Vqd = Circle_Limitation(&CircleLimitationM1, Vqd);
 8001eb2:	4607      	mov	r7, r0
  Valphabeta = MCM_Rev_Park(Vqd, hElAngle);
 8001eb4:	f7ff fb72 	bl	800159c <MCM_Rev_Park>
 8001eb8:	4601      	mov	r1, r0
  hCodeError = PWMC_SetPhaseVoltage(pwmcHandle[M1], Valphabeta);
 8001eba:	f8d8 0000 	ldr.w	r0, [r8]
  Valphabeta = MCM_Rev_Park(Vqd, hElAngle);
 8001ebe:	9105      	str	r1, [sp, #20]
  hCodeError = PWMC_SetPhaseVoltage(pwmcHandle[M1], Valphabeta);
 8001ec0:	f000 fa20 	bl	8002304 <PWMC_SetPhaseVoltage>
 8001ec4:	4601      	mov	r1, r0

  FOCVars[M1].Vqd = Vqd;
  FOCVars[M1].Iab = Iab;
 8001ec6:	9803      	ldr	r0, [sp, #12]
 8001ec8:	6020      	str	r0, [r4, #0]
  FOCVars[M1].Ialphabeta = Ialphabeta;
 8001eca:	9804      	ldr	r0, [sp, #16]
 8001ecc:	6060      	str	r0, [r4, #4]
  FOCVars[M1].Iqd = Iqd;
 8001ece:	9801      	ldr	r0, [sp, #4]
 8001ed0:	60e0      	str	r0, [r4, #12]
  if(hFOCreturn == MC_DURATION)
 8001ed2:	2901      	cmp	r1, #1
  FOCVars[M1].Valphabeta = Valphabeta;
 8001ed4:	9805      	ldr	r0, [sp, #20]
  FOCVars[M1].Vqd = Vqd;
 8001ed6:	f8c4 7016 	str.w	r7, [r4, #22]
  FOCVars[M1].Valphabeta = Valphabeta;
 8001eda:	f8c4 001a 	str.w	r0, [r4, #26]
  FOCVars[M1].hElAngle = hElAngle;
 8001ede:	8426      	strh	r6, [r4, #32]
  if(hFOCreturn == MC_DURATION)
 8001ee0:	d003      	beq.n	8001eea <FOC_HighFrequencyTask+0xae>
}
 8001ee2:	4628      	mov	r0, r5
 8001ee4:	b006      	add	sp, #24
 8001ee6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    MCI_FaultProcessing(&Mci[M1], MC_DURATION, 0);
 8001eea:	480a      	ldr	r0, [pc, #40]	@ (8001f14 <FOC_HighFrequencyTask+0xd8>)
 8001eec:	2200      	movs	r2, #0
 8001eee:	f7ff f9b3 	bl	8001258 <MCI_FaultProcessing>
}
 8001ef2:	4628      	mov	r0, r5
 8001ef4:	b006      	add	sp, #24
 8001ef6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001efa:	bf00      	nop
 8001efc:	20000310 	.word	0x20000310
 8001f00:	20000754 	.word	0x20000754
 8001f04:	2000003c 	.word	0x2000003c
 8001f08:	20000038 	.word	0x20000038
 8001f0c:	20000034 	.word	0x20000034
 8001f10:	20000040 	.word	0x20000040
 8001f14:	20000000 	.word	0x20000000
 8001f18:	2000077c 	.word	0x2000077c

08001f1c <RI_SetRegCommandParser>:
  * @param  txSyncFreeSpace Space available for synchronous transmission
  *
  * @retval Returns #MCP_CMD_OK if the command is acknowledged and #MCP_CMD_NOK if not.
  */
uint8_t RI_SetRegCommandParser (MCP_Handle_t * pHandle, uint16_t txSyncFreeSpace)
{
 8001f1c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  {
#endif
    uint16_t * dataElementID;
    uint8_t * rxData = pHandle->rxBuffer;
    uint8_t * txData = pHandle->txBuffer;
    int16_t rxLength = pHandle->rxLength;
 8001f20:	f9b0 400c 	ldrsh.w	r4, [r0, #12]
    uint8_t accessResult;

    uint16_t regID;
    uint8_t typeID;
    uint8_t motorID;
    uint8_t (*SetRegFcts[NBR_OF_MOTORS+1])(uint16_t, uint8_t, uint8_t*, uint16_t*, int16_t) = {&RI_SetRegisterGlobal, &RI_SetRegisterMotor1};
 8001f24:	4b31      	ldr	r3, [pc, #196]	@ (8001fec <RI_SetRegCommandParser+0xd0>)
{
 8001f26:	b089      	sub	sp, #36	@ 0x24
    uint16_t size = 0U;
 8001f28:	f04f 0900 	mov.w	r9, #0
    uint8_t (*SetRegFcts[NBR_OF_MOTORS+1])(uint16_t, uint8_t, uint8_t*, uint16_t*, int16_t) = {&RI_SetRegisterGlobal, &RI_SetRegisterMotor1};
 8001f2c:	9306      	str	r3, [sp, #24]
    uint8_t number_of_item =0;
    pHandle->txLength = 0;

    while (rxLength > 0)
 8001f2e:	454c      	cmp	r4, r9
    uint8_t (*SetRegFcts[NBR_OF_MOTORS+1])(uint16_t, uint8_t, uint8_t*, uint16_t*, int16_t) = {&RI_SetRegisterGlobal, &RI_SetRegisterMotor1};
 8001f30:	4b2f      	ldr	r3, [pc, #188]	@ (8001ff0 <RI_SetRegCommandParser+0xd4>)
    uint16_t size = 0U;
 8001f32:	f8ad 9016 	strh.w	r9, [sp, #22]
    uint8_t * txData = pHandle->txBuffer;
 8001f36:	e9d0 c601 	ldrd	ip, r6, [r0, #4]
{
 8001f3a:	4607      	mov	r7, r0
    uint8_t (*SetRegFcts[NBR_OF_MOTORS+1])(uint16_t, uint8_t, uint8_t*, uint16_t*, int16_t) = {&RI_SetRegisterGlobal, &RI_SetRegisterMotor1};
 8001f3c:	9307      	str	r3, [sp, #28]
    pHandle->txLength = 0;
 8001f3e:	f8a0 900e 	strh.w	r9, [r0, #14]
    while (rxLength > 0)
 8001f42:	dd47      	ble.n	8001fd4 <RI_SetRegCommandParser+0xb8>
 8001f44:	eb06 0801 	add.w	r8, r6, r1
  uint8_t retVal = MCP_CMD_OK;
 8001f48:	f8cd 900c 	str.w	r9, [sp, #12]
        accessResult = SetRegFcts[motorID](regID, typeID, rxData, &size, rxLength);
        /* Prepare next data*/
        rxLength = (int16_t) (rxLength - size);
        rxData = rxData+size;
        /* If there is only one CMD in the buffer, we do not store the result */
        if ((1U == number_of_item) && (0 == rxLength))
 8001f4c:	f1c6 0a01 	rsb	sl, r6, #1
      rxData = rxData+MCP_ID_SIZE; // Shift buffer to the next data
 8001f50:	f10c 0502 	add.w	r5, ip, #2
      regID = *dataElementID & REG_MASK;
 8001f54:	f8bc c000 	ldrh.w	ip, [ip]
      typeID = (uint8_t)*dataElementID & TYPE_MASK;
 8001f58:	fa5f f18c 	uxtb.w	r1, ip
      rxLength = rxLength-MCP_ID_SIZE; // We consume 2 byte in the DataID
 8001f5c:	3c02      	subs	r4, #2
        accessResult = SetRegFcts[motorID](regID, typeID, rxData, &size, rxLength);
 8001f5e:	f001 0b07 	and.w	fp, r1, #7
 8001f62:	f10d 0920 	add.w	r9, sp, #32
      if (motorID > NBR_OF_MOTORS)
 8001f66:	f01c 0f06 	tst.w	ip, #6
        accessResult = SetRegFcts[motorID](regID, typeID, rxData, &size, rxLength);
 8001f6a:	fa0f fe84 	sxth.w	lr, r4
 8001f6e:	f10d 0316 	add.w	r3, sp, #22
 8001f72:	462a      	mov	r2, r5
      rxLength = rxLength-MCP_ID_SIZE; // We consume 2 byte in the DataID
 8001f74:	b2a4      	uxth	r4, r4
      regID = *dataElementID & REG_MASK;
 8001f76:	f02c 0007 	bic.w	r0, ip, #7
        accessResult = SetRegFcts[motorID](regID, typeID, rxData, &size, rxLength);
 8001f7a:	eb09 0b8b 	add.w	fp, r9, fp, lsl #2
 8001f7e:	f001 0138 	and.w	r1, r1, #56	@ 0x38
      if (motorID > NBR_OF_MOTORS)
 8001f82:	d11b      	bne.n	8001fbc <RI_SetRegCommandParser+0xa0>
        accessResult = SetRegFcts[motorID](regID, typeID, rxData, &size, rxLength);
 8001f84:	f8cd e000 	str.w	lr, [sp]
 8001f88:	f85b bc08 	ldr.w	fp, [fp, #-8]
 8001f8c:	47d8      	blx	fp
        rxLength = (int16_t) (rxLength - size);
 8001f8e:	f8bd 2016 	ldrh.w	r2, [sp, #22]
        if ((1U == number_of_item) && (0 == rxLength))
 8001f92:	eb06 030a 	add.w	r3, r6, sl
 8001f96:	b2db      	uxtb	r3, r3
        rxLength = (int16_t) (rxLength - size);
 8001f98:	1aa4      	subs	r4, r4, r2
        if ((1U == number_of_item) && (0 == rxLength))
 8001f9a:	2b01      	cmp	r3, #1
        rxLength = (int16_t) (rxLength - size);
 8001f9c:	b224      	sxth	r4, r4
        rxData = rxData+size;
 8001f9e:	eb05 0c02 	add.w	ip, r5, r2
        if ((1U == number_of_item) && (0 == rxLength))
 8001fa2:	d013      	beq.n	8001fcc <RI_SetRegCommandParser+0xb0>
        {
          retVal = accessResult;
        }
        else
        {/* Store the result for each access to be able to report failing access */
          if (txSyncFreeSpace !=0 )
 8001fa4:	4546      	cmp	r6, r8
 8001fa6:	d00d      	beq.n	8001fc4 <RI_SetRegCommandParser+0xa8>
          {
            *txData = accessResult;
 8001fa8:	f806 0b01 	strb.w	r0, [r6], #1
            txData = txData+1;
            pHandle->txLength++;
 8001fac:	89fb      	ldrh	r3, [r7, #14]
 8001fae:	3301      	adds	r3, #1
 8001fb0:	81fb      	strh	r3, [r7, #14]
            txSyncFreeSpace--; /* decrement one by one no wraparound possible */
            retVal = (accessResult != MCP_CMD_OK) ? MCP_CMD_NOK : retVal;
 8001fb2:	b1a0      	cbz	r0, 8001fde <RI_SetRegCommandParser+0xc2>
            if ((accessResult == MCP_ERROR_BAD_DATA_TYPE) || (accessResult == MCP_ERROR_BAD_RAW_FORMAT))
 8001fb4:	2807      	cmp	r0, #7
 8001fb6:	d001      	beq.n	8001fbc <RI_SetRegCommandParser+0xa0>
 8001fb8:	280a      	cmp	r0, #10
 8001fba:	d10e      	bne.n	8001fda <RI_SetRegCommandParser+0xbe>
        retVal = MCP_CMD_NOK;
 8001fbc:	2001      	movs	r0, #1
    }
  #ifdef NULL_PTR_CHECK_REG_INT
  }
#endif
  return (retVal);
}
 8001fbe:	b009      	add	sp, #36	@ 0x24
 8001fc0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 8001fc4:	2008      	movs	r0, #8
}
 8001fc6:	b009      	add	sp, #36	@ 0x24
 8001fc8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ((1U == number_of_item) && (0 == rxLength))
 8001fcc:	2c00      	cmp	r4, #0
 8001fce:	d1e9      	bne.n	8001fa4 <RI_SetRegCommandParser+0x88>
    if (MCP_CMD_OK == retVal)
 8001fd0:	2800      	cmp	r0, #0
 8001fd2:	d1f4      	bne.n	8001fbe <RI_SetRegCommandParser+0xa2>
      pHandle->txLength = 0;
 8001fd4:	2000      	movs	r0, #0
 8001fd6:	81f8      	strh	r0, [r7, #14]
 8001fd8:	e7f1      	b.n	8001fbe <RI_SetRegCommandParser+0xa2>
            retVal = (accessResult != MCP_CMD_OK) ? MCP_CMD_NOK : retVal;
 8001fda:	2301      	movs	r3, #1
 8001fdc:	9303      	str	r3, [sp, #12]
    while (rxLength > 0)
 8001fde:	2c00      	cmp	r4, #0
 8001fe0:	dcb6      	bgt.n	8001f50 <RI_SetRegCommandParser+0x34>
 8001fe2:	9803      	ldr	r0, [sp, #12]
    if (MCP_CMD_OK == retVal)
 8001fe4:	2800      	cmp	r0, #0
 8001fe6:	d0f5      	beq.n	8001fd4 <RI_SetRegCommandParser+0xb8>
 8001fe8:	e7e9      	b.n	8001fbe <RI_SetRegCommandParser+0xa2>
 8001fea:	bf00      	nop
 8001fec:	08002665 	.word	0x08002665
 8001ff0:	0800277d 	.word	0x0800277d

08001ff4 <RI_GetRegCommandParser>:
  * @param  txSyncFreeSpace Space available for synchronous transmission
  *
  * @retval Returns #MCP_CMD_OK if the command is acknowledged and #MCP_CMD_NOK if not.
  */
uint8_t RI_GetRegCommandParser (MCP_Handle_t * pHandle, uint16_t txSyncFreeSpace)
{
 8001ff4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8001ff8:	b086      	sub	sp, #24
  {
#endif
    uint16_t * dataElementID;
    uint8_t * rxData = pHandle->rxBuffer;
    uint8_t * txData = pHandle->txBuffer;
    uint16_t size = 0U;
 8001ffa:	2300      	movs	r3, #0
 8001ffc:	f8ad 300e 	strh.w	r3, [sp, #14]

    uint16_t regID;
    uint8_t typeID;
    uint8_t motorID;
    uint8_t (*GetRegFcts[NBR_OF_MOTORS+1])(uint16_t, uint8_t, uint8_t*, uint16_t*, int16_t) = {&RI_GetRegisterGlobal, &RI_GetRegisterMotor1};
    pHandle->txLength = 0;
 8002000:	81c3      	strh	r3, [r0, #14]
    uint16_t rxLength = pHandle->rxLength;
 8002002:	f8b0 800c 	ldrh.w	r8, [r0, #12]
    uint8_t (*GetRegFcts[NBR_OF_MOTORS+1])(uint16_t, uint8_t, uint8_t*, uint16_t*, int16_t) = {&RI_GetRegisterGlobal, &RI_GetRegisterMotor1};
 8002006:	4b1d      	ldr	r3, [pc, #116]	@ (800207c <RI_GetRegCommandParser+0x88>)
 8002008:	9304      	str	r3, [sp, #16]
 800200a:	4b1d      	ldr	r3, [pc, #116]	@ (8002080 <RI_GetRegCommandParser+0x8c>)
    uint8_t * rxData = pHandle->rxBuffer;
 800200c:	f8d0 9004 	ldr.w	r9, [r0, #4]
    uint8_t * txData = pHandle->txBuffer;
 8002010:	6886      	ldr	r6, [r0, #8]
    uint8_t (*GetRegFcts[NBR_OF_MOTORS+1])(uint16_t, uint8_t, uint8_t*, uint16_t*, int16_t) = {&RI_GetRegisterGlobal, &RI_GetRegisterMotor1};
 8002012:	9305      	str	r3, [sp, #20]
    while (rxLength > 0U)
 8002014:	f1b8 0f00 	cmp.w	r8, #0
 8002018:	d016      	beq.n	8002048 <RI_GetRegCommandParser+0x54>
 800201a:	4607      	mov	r7, r0
 800201c:	b20d      	sxth	r5, r1
    uint8_t * rxData = pHandle->rxBuffer;
 800201e:	464c      	mov	r4, r9
    {
      dataElementID = (uint16_t *) rxData;
      rxLength = rxLength - MCP_ID_SIZE;
      rxData = rxData + MCP_ID_SIZE; // Shift buffer to the next MCP_ID

      regID = *dataElementID & REG_MASK;
 8002020:	f834 cb02 	ldrh.w	ip, [r4], #2
      typeID = (uint8_t)*dataElementID & TYPE_MASK;
 8002024:	fa5f f18c 	uxtb.w	r1, ip
        retVal = MCP_CMD_NOK;
        rxLength = 0;
      }
      else
      {
        retVal = GetRegFcts[motorID](regID, typeID, txData, &size, freeSpaceS16);
 8002028:	f001 0e07 	and.w	lr, r1, #7
 800202c:	f10d 0a18 	add.w	sl, sp, #24
      if (motorID > NBR_OF_MOTORS)
 8002030:	f01c 0f06 	tst.w	ip, #6
        retVal = GetRegFcts[motorID](regID, typeID, txData, &size, freeSpaceS16);
 8002034:	4632      	mov	r2, r6
      regID = *dataElementID & REG_MASK;
 8002036:	f02c 0007 	bic.w	r0, ip, #7
        retVal = GetRegFcts[motorID](regID, typeID, txData, &size, freeSpaceS16);
 800203a:	f10d 030e 	add.w	r3, sp, #14
 800203e:	eb0a 0e8e 	add.w	lr, sl, lr, lsl #2
 8002042:	f001 0138 	and.w	r1, r1, #56	@ 0x38
      if (motorID > NBR_OF_MOTORS)
 8002046:	d003      	beq.n	8002050 <RI_GetRegCommandParser+0x5c>
        retVal = MCP_CMD_NOK;
 8002048:	2001      	movs	r0, #1
    }
#ifdef NULL_PTR_CHECK_REG_INT
  }
#endif
  return (retVal);
}
 800204a:	b006      	add	sp, #24
 800204c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        retVal = GetRegFcts[motorID](regID, typeID, txData, &size, freeSpaceS16);
 8002050:	9500      	str	r5, [sp, #0]
 8002052:	f85e ac08 	ldr.w	sl, [lr, #-8]
 8002056:	47d0      	blx	sl
        if (retVal == MCP_CMD_OK )
 8002058:	eba8 0304 	sub.w	r3, r8, r4
    while (rxLength > 0U)
 800205c:	fa19 f383 	uxtah	r3, r9, r3
 8002060:	b29b      	uxth	r3, r3
        if (retVal == MCP_CMD_OK )
 8002062:	2800      	cmp	r0, #0
 8002064:	d1f1      	bne.n	800204a <RI_GetRegCommandParser+0x56>
          txData = txData+size;
 8002066:	f8bd 100e 	ldrh.w	r1, [sp, #14]
          pHandle->txLength += size;
 800206a:	89fa      	ldrh	r2, [r7, #14]
          freeSpaceS16 = freeSpaceS16-size;
 800206c:	1a6d      	subs	r5, r5, r1
          pHandle->txLength += size;
 800206e:	440a      	add	r2, r1
          txData = txData+size;
 8002070:	440e      	add	r6, r1
          pHandle->txLength += size;
 8002072:	81fa      	strh	r2, [r7, #14]
          freeSpaceS16 = freeSpaceS16-size;
 8002074:	b22d      	sxth	r5, r5
    while (rxLength > 0U)
 8002076:	2b00      	cmp	r3, #0
 8002078:	d1d2      	bne.n	8002020 <RI_GetRegCommandParser+0x2c>
 800207a:	e7e6      	b.n	800204a <RI_GetRegCommandParser+0x56>
 800207c:	08002c35 	.word	0x08002c35
 8002080:	08002d91 	.word	0x08002d91

08002084 <MCP_ReceivedPacket>:
  * @brief  Parses the header from the received packet and call the required function depending on the command sent by the controller device.
  *
  * @param  pHandle Handler of the current instance of the MCP component
  */
void MCP_ReceivedPacket(MCP_Handle_t *pHandle)
{
 8002084:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002086:	4604      	mov	r4, r0
  }
  else /* Length is 0, this is a request to send back the last packet */
  {
#endif
    packetHeader = (uint16_t *)pHandle->rxBuffer; //cstat !MISRAC2012-Rule-11.3
    command = (uint16_t)(*packetHeader & CMD_MASK);
 8002088:	6846      	ldr	r6, [r0, #4]
    pHandle->rxLength = pHandle->rxLength - MCP_HEADER_SIZE;
    pHandle->rxBuffer = pHandle->rxBuffer + MCP_HEADER_SIZE;

    /* Commands requiering payload response must be aware of space available for the payload */
    /* Last byte is reserved for MCP response*/
    txSyncFreeSpace = (int16_t)pHandle->pTransportLayer->txSyncMaxPayload - 1;
 800208a:	6822      	ldr	r2, [r4, #0]
    command = (uint16_t)(*packetHeader & CMD_MASK);
 800208c:	f836 3b02 	ldrh.w	r3, [r6], #2
    pHandle->rxLength = pHandle->rxLength - MCP_HEADER_SIZE;
 8002090:	8980      	ldrh	r0, [r0, #12]
    txSyncFreeSpace = (int16_t)pHandle->pTransportLayer->txSyncMaxPayload - 1;
 8002092:	8992      	ldrh	r2, [r2, #12]
    if ((command & MCP_USER_CMD_MASK) == MCP_USER_CMD)
 8002094:	f403 457f 	and.w	r5, r3, #65280	@ 0xff00
    txSyncFreeSpace = (int16_t)pHandle->pTransportLayer->txSyncMaxPayload - 1;
 8002098:	3a01      	subs	r2, #1
    pHandle->rxLength = pHandle->rxLength - MCP_HEADER_SIZE;
 800209a:	3802      	subs	r0, #2
    command = (uint16_t)(*packetHeader & CMD_MASK);
 800209c:	f023 0c07 	bic.w	ip, r3, #7
    if ((command & MCP_USER_CMD_MASK) == MCP_USER_CMD)
 80020a0:	f5b5 7f80 	cmp.w	r5, #256	@ 0x100
    txSyncFreeSpace = (int16_t)pHandle->pTransportLayer->txSyncMaxPayload - 1;
 80020a4:	b291      	uxth	r1, r2
{
 80020a6:	b083      	sub	sp, #12
    pHandle->rxLength = pHandle->rxLength - MCP_HEADER_SIZE;
 80020a8:	b280      	uxth	r0, r0
    command = (uint16_t)(*packetHeader & CMD_MASK);
 80020aa:	fa1f fc8c 	uxth.w	ip, ip
    txSyncFreeSpace = (int16_t)pHandle->pTransportLayer->txSyncMaxPayload - 1;
 80020ae:	b212      	sxth	r2, r2
    if ((command & MCP_USER_CMD_MASK) == MCP_USER_CMD)
 80020b0:	d048      	beq.n	8002144 <MCP_ReceivedPacket+0xc0>
    motorID = (uint8_t)((*packetHeader - 1U) & MOTOR_MASK);
 80020b2:	3b01      	subs	r3, #1
    MCI_Handle_t *pMCI = &Mci[motorID];
 80020b4:	f003 0307 	and.w	r3, r3, #7
 80020b8:	4d4e      	ldr	r5, [pc, #312]	@ (80021f4 <MCP_ReceivedPacket+0x170>)
    pHandle->rxLength = pHandle->rxLength - MCP_HEADER_SIZE;
 80020ba:	81a0      	strh	r0, [r4, #12]
    MCI_Handle_t *pMCI = &Mci[motorID];
 80020bc:	eb03 0783 	add.w	r7, r3, r3, lsl #2
 80020c0:	eb03 0347 	add.w	r3, r3, r7, lsl #1
 80020c4:	eb05 0783 	add.w	r7, r5, r3, lsl #2

    /* Initialization of the tx length, command which send back data has to increment the txLength
     * (case of Read register) */
    pHandle->txLength = 0U;

    switch (command)
 80020c8:	f1bc 0f38 	cmp.w	ip, #56	@ 0x38
    pHandle->txLength = 0U;
 80020cc:	f04f 0500 	mov.w	r5, #0
    pHandle->rxBuffer = pHandle->rxBuffer + MCP_HEADER_SIZE;
 80020d0:	6066      	str	r6, [r4, #4]
    pHandle->txLength = 0U;
 80020d2:	81e5      	strh	r5, [r4, #14]
    switch (command)
 80020d4:	d82a      	bhi.n	800212c <MCP_ReceivedPacket+0xa8>
 80020d6:	f1bc 0f38 	cmp.w	ip, #56	@ 0x38
 80020da:	d81e      	bhi.n	800211a <MCP_ReceivedPacket+0x96>
 80020dc:	e8df f00c 	tbb	[pc, ip]
 80020e0:	1d1d1d54 	.word	0x1d1d1d54
 80020e4:	1d1d1d1d 	.word	0x1d1d1d1d
 80020e8:	1d1d1d5c 	.word	0x1d1d1d5c
 80020ec:	1d1d1d1d 	.word	0x1d1d1d1d
 80020f0:	1d1d1d4f 	.word	0x1d1d1d4f
 80020f4:	1d1d1d1d 	.word	0x1d1d1d1d
 80020f8:	1d1d1d47 	.word	0x1d1d1d47
 80020fc:	1d1d1d1d 	.word	0x1d1d1d1d
 8002100:	1d1d1d41 	.word	0x1d1d1d41
 8002104:	1d1d1d1d 	.word	0x1d1d1d1d
 8002108:	1d1d1d61 	.word	0x1d1d1d61
 800210c:	1d1d1d1d 	.word	0x1d1d1d1d
 8002110:	1d1d1d3d 	.word	0x1d1d1d3d
 8002114:	1d1d1d1d 	.word	0x1d1d1d1d
 8002118:	69          	.byte	0x69
 8002119:	00          	.byte	0x00
 800211a:	2300      	movs	r3, #0
 800211c:	2002      	movs	r0, #2
      {
        MCPResponse = MCP_CMD_UNKNOWN;
        break;
      }
    }
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 800211e:	68a2      	ldr	r2, [r4, #8]
 8002120:	54d0      	strb	r0, [r2, r3]
    pHandle->txLength++;
 8002122:	89e3      	ldrh	r3, [r4, #14]
 8002124:	3301      	adds	r3, #1
 8002126:	81e3      	strh	r3, [r4, #14]
#ifdef NULL_PTR_CHECK_MCP
  }
#endif
}
 8002128:	b003      	add	sp, #12
 800212a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    switch (command)
 800212c:	f1bc 0f68 	cmp.w	ip, #104	@ 0x68
 8002130:	d045      	beq.n	80021be <MCP_ReceivedPacket+0x13a>
 8002132:	f1bc 0f48 	cmp.w	ip, #72	@ 0x48
 8002136:	d1f0      	bne.n	800211a <MCP_ReceivedPacket+0x96>
        MCI_Clear_Iqdref(pMCI);
 8002138:	4638      	mov	r0, r7
 800213a:	f7ff f9a3 	bl	8001484 <MCI_Clear_Iqdref>
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 800213e:	89e3      	ldrh	r3, [r4, #14]
        MCPResponse = MCP_CMD_OK;
 8002140:	4628      	mov	r0, r5
        break;
 8002142:	e7ec      	b.n	800211e <MCP_ReceivedPacket+0x9a>
      userCommand = ((uint8_t)(command & 0xF8U) >> 3U);
 8002144:	f3cc 0cc4 	ubfx	ip, ip, #3, #5
    pHandle->txLength = 0U;
 8002148:	2300      	movs	r3, #0
        if ((userCommand < MCP_USER_CALLBACK_MAX) && (MCP_UserCallBack[userCommand] != NULL))
 800214a:	f1bc 0f01 	cmp.w	ip, #1
    pHandle->rxLength = pHandle->rxLength - MCP_HEADER_SIZE;
 800214e:	81a0      	strh	r0, [r4, #12]
    pHandle->rxBuffer = pHandle->rxBuffer + MCP_HEADER_SIZE;
 8002150:	6066      	str	r6, [r4, #4]
    pHandle->txLength = 0U;
 8002152:	81e3      	strh	r3, [r4, #14]
        if ((userCommand < MCP_USER_CALLBACK_MAX) && (MCP_UserCallBack[userCommand] != NULL))
 8002154:	d93c      	bls.n	80021d0 <MCP_ReceivedPacket+0x14c>
          MCPResponse = MCP_ERROR_CALLBACK_NOT_REGISTRED;
 8002156:	200d      	movs	r0, #13
 8002158:	e7e1      	b.n	800211e <MCP_ReceivedPacket+0x9a>
        if (IDLE == MCI_GetSTMState(pMCI))
 800215a:	4638      	mov	r0, r7
 800215c:	f7ff f8c4 	bl	80012e8 <MCI_GetSTMState>
 8002160:	b128      	cbz	r0, 800216e <MCP_ReceivedPacket+0xea>
          (void)MCI_StopMotor(pMCI);
 8002162:	4638      	mov	r0, r7
 8002164:	f7ff f8e4 	bl	8001330 <MCI_StopMotor>
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002168:	89e3      	ldrh	r3, [r4, #14]
        MCPResponse = MCP_CMD_OK;
 800216a:	2000      	movs	r0, #0
 800216c:	e7d7      	b.n	800211e <MCP_ReceivedPacket+0x9a>
          MCPResponse = (MCI_StartMotor(pMCI) == true) ? MCP_CMD_OK : MCP_CMD_NOK;
 800216e:	4638      	mov	r0, r7
 8002170:	f7ff f8c6 	bl	8001300 <MCI_StartMotor>
 8002174:	f080 0001 	eor.w	r0, r0, #1
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002178:	89e3      	ldrh	r3, [r4, #14]
          MCPResponse = (MCI_StartMotor(pMCI) == true) ? MCP_CMD_OK : MCP_CMD_NOK;
 800217a:	b2c0      	uxtb	r0, r0
 800217c:	e7cf      	b.n	800211e <MCP_ReceivedPacket+0x9a>
        MCPResponse = RI_GetRegCommandParser(pHandle, (uint16_t)txSyncFreeSpace);
 800217e:	4620      	mov	r0, r4
 8002180:	f7ff ff38 	bl	8001ff4 <RI_GetRegCommandParser>
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002184:	89e3      	ldrh	r3, [r4, #14]
        break;
 8002186:	e7ca      	b.n	800211e <MCP_ReceivedPacket+0x9a>
        *pHandle->txBuffer = MCP_VERSION;
 8002188:	68a3      	ldr	r3, [r4, #8]
        pHandle->txLength = 4U;
 800218a:	2104      	movs	r1, #4
        *pHandle->txBuffer = MCP_VERSION;
 800218c:	2201      	movs	r2, #1
        pHandle->txLength = 4U;
 800218e:	81e1      	strh	r1, [r4, #14]
        *pHandle->txBuffer = MCP_VERSION;
 8002190:	701a      	strb	r2, [r3, #0]
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002192:	89e3      	ldrh	r3, [r4, #14]
        MCPResponse = MCP_CMD_OK;
 8002194:	2000      	movs	r0, #0
        break;
 8002196:	e7c2      	b.n	800211e <MCP_ReceivedPacket+0x9a>
        MCPResponse = RI_SetRegCommandParser(pHandle, (uint16_t)txSyncFreeSpace);
 8002198:	4620      	mov	r0, r4
 800219a:	f7ff febf 	bl	8001f1c <RI_SetRegCommandParser>
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 800219e:	89e3      	ldrh	r3, [r4, #14]
        break;
 80021a0:	e7bd      	b.n	800211e <MCP_ReceivedPacket+0x9a>
        if (RUN == MCI_GetSTMState(pMCI))
 80021a2:	4638      	mov	r0, r7
 80021a4:	f7ff f8a0 	bl	80012e8 <MCI_GetSTMState>
 80021a8:	2806      	cmp	r0, #6
 80021aa:	d01d      	beq.n	80021e8 <MCP_ReceivedPacket+0x164>
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 80021ac:	89e3      	ldrh	r3, [r4, #14]
        MCPResponse = MCP_CMD_OK;
 80021ae:	2000      	movs	r0, #0
 80021b0:	e7b5      	b.n	800211e <MCP_ReceivedPacket+0x9a>
        (void)MCI_FaultAcknowledged(pMCI);
 80021b2:	4638      	mov	r0, r7
 80021b4:	f7ff f8d8 	bl	8001368 <MCI_FaultAcknowledged>
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 80021b8:	89e3      	ldrh	r3, [r4, #14]
        MCPResponse = MCP_CMD_OK;
 80021ba:	2000      	movs	r0, #0
        break;
 80021bc:	e7af      	b.n	800211e <MCP_ReceivedPacket+0x9a>
        MCPResponse = MC_ProfilerCommand(pHandle->rxLength, pHandle->rxBuffer, txSyncFreeSpace, &pHandle->txLength,
 80021be:	68a3      	ldr	r3, [r4, #8]
 80021c0:	9300      	str	r3, [sp, #0]
 80021c2:	4631      	mov	r1, r6
 80021c4:	f104 030e 	add.w	r3, r4, #14
 80021c8:	f7fe fd2a 	bl	8000c20 <MC_ProfilerCommand>
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 80021cc:	89e3      	ldrh	r3, [r4, #14]
        break;
 80021ce:	e7a6      	b.n	800211e <MCP_ReceivedPacket+0x9a>
        if ((userCommand < MCP_USER_CALLBACK_MAX) && (MCP_UserCallBack[userCommand] != NULL))
 80021d0:	4b09      	ldr	r3, [pc, #36]	@ (80021f8 <MCP_ReceivedPacket+0x174>)
 80021d2:	f853 502c 	ldr.w	r5, [r3, ip, lsl #2]
 80021d6:	b15d      	cbz	r5, 80021f0 <MCP_ReceivedPacket+0x16c>
          MCPResponse = MCP_UserCallBack[userCommand](pHandle->rxLength, pHandle->rxBuffer, txSyncFreeSpace,
 80021d8:	68a3      	ldr	r3, [r4, #8]
 80021da:	9300      	str	r3, [sp, #0]
 80021dc:	4631      	mov	r1, r6
 80021de:	f104 030e 	add.w	r3, r4, #14
 80021e2:	47a8      	blx	r5
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 80021e4:	89e3      	ldrh	r3, [r4, #14]
          MCPResponse = MCP_UserCallBack[userCommand](pHandle->rxLength, pHandle->rxBuffer, txSyncFreeSpace,
 80021e6:	e79a      	b.n	800211e <MCP_ReceivedPacket+0x9a>
          MCI_StopRamp(pMCI);
 80021e8:	4638      	mov	r0, r7
 80021ea:	f7ff f8e5 	bl	80013b8 <MCI_StopRamp>
 80021ee:	e7dd      	b.n	80021ac <MCP_ReceivedPacket+0x128>
 80021f0:	462b      	mov	r3, r5
 80021f2:	e7b0      	b.n	8002156 <MCP_ReceivedPacket+0xd2>
 80021f4:	20000000 	.word	0x20000000
 80021f8:	20000798 	.word	0x20000798

080021fc <MX_MotorControl_Init>:
 *
 * CubeMX calls this function after all peripherals initializations and
 * before the NVIC is configured
 */
__weak void MX_MotorControl_Init(void)
{
 80021fc:	b508      	push	{r3, lr}

  /* Initialize the Motor Control Subsystem */
  MCboot(pMCI);
 80021fe:	4803      	ldr	r0, [pc, #12]	@ (800220c <MX_MotorControl_Init+0x10>)
 8002200:	f7ff f9fa 	bl	80015f8 <MCboot>
  mc_lock_pins();
}
 8002204:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  mc_lock_pins();
 8002208:	f7ff bb4c 	b.w	80018a4 <mc_lock_pins>
 800220c:	20001924 	.word	0x20001924

08002210 <vPortSetupTimerInterrupt>:

void vPortSetupTimerInterrupt( void )
{
 8002210:	b508      	push	{r3, lr}
  /* Reconfigure the SysTick interrupt to fire every 500 us. */
  (void)HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/SYS_TICK_FREQUENCY);
 8002212:	f003 fe3d 	bl	8005e90 <HAL_RCC_GetHCLKFreq>
 8002216:	4b04      	ldr	r3, [pc, #16]	@ (8002228 <vPortSetupTimerInterrupt+0x18>)
 8002218:	fba3 3000 	umull	r3, r0, r3, r0
 800221c:	09c0      	lsrs	r0, r0, #7
}
 800221e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  (void)HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/SYS_TICK_FREQUENCY);
 8002222:	f002 bf41 	b.w	80050a8 <HAL_SYSTICK_Config>
 8002226:	bf00      	nop
 8002228:	10624dd3 	.word	0x10624dd3

0800222c <startTimers>:
  *         @arg @ref LL_TIM_TS_ETRF
  * @retval None
  */
__STATIC_INLINE void LL_TIM_SetTriggerInput(TIM_TypeDef *TIMx, uint32_t TriggerInput)
{
  MODIFY_REG(TIMx->SMCR, TIM_SMCR_TS, TriggerInput);
 800222c:	4922      	ldr	r1, [pc, #136]	@ (80022b8 <startTimers+0x8c>)
  *         (*) value not defined in all devices.
  * @retval State of Periphs (1 or 0).
  */
__STATIC_INLINE uint32_t LL_APB1_GRP1_IsEnabledClock(uint32_t Periphs)
{
  return ((READ_BIT(RCC->APB1ENR1, Periphs) == Periphs) ? 1UL : 0UL);
 800222e:	4a23      	ldr	r2, [pc, #140]	@ (80022bc <startTimers+0x90>)
 8002230:	688b      	ldr	r3, [r1, #8]
 8002232:	f423 1340 	bic.w	r3, r3, #3145728	@ 0x300000
 8002236:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 800223a:	f043 0310 	orr.w	r3, r3, #16
  * When this function is called, TIM1 and/or TIM8 must be in a frozen state
  * with CNT, ARR, REP RATE and trigger correctly set (these settings are
  * usually performed in the Init method accordingly with the configuration)
  */
__weak void startTimers(void)
{
 800223e:	b410      	push	{r4}
 8002240:	608b      	str	r3, [r1, #8]
  MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, SlaveMode);
 8002242:	688b      	ldr	r3, [r1, #8]
 8002244:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8002248:	f023 0307 	bic.w	r3, r3, #7
 800224c:	f043 0306 	orr.w	r3, r3, #6
 8002250:	608b      	str	r3, [r1, #8]
 8002252:	6d93      	ldr	r3, [r2, #88]	@ 0x58
 8002254:	07db      	lsls	r3, r3, #31
 8002256:	b083      	sub	sp, #12
 8002258:	d416      	bmi.n	8002288 <startTimers+0x5c>
  SET_BIT(RCC->APB1ENR1, Periphs);
 800225a:	6d93      	ldr	r3, [r2, #88]	@ 0x58
 800225c:	f043 0301 	orr.w	r3, r3, #1
 8002260:	6593      	str	r3, [r2, #88]	@ 0x58
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 8002262:	6d93      	ldr	r3, [r2, #88]	@ 0x58
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_GenerateEvent_UPDATE(TIM_TypeDef *TIMx)
{
  SET_BIT(TIMx->EGR, TIM_EGR_UG);
 8002264:	f04f 4180 	mov.w	r1, #1073741824	@ 0x40000000
 8002268:	f003 0301 	and.w	r3, r3, #1
 800226c:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 800226e:	9b01      	ldr	r3, [sp, #4]
 8002270:	694b      	ldr	r3, [r1, #20]
 8002272:	f043 0301 	orr.w	r3, r3, #1
 8002276:	614b      	str	r3, [r1, #20]
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_APB1_GRP1_DisableClock(uint32_t Periphs)
{
  CLEAR_BIT(RCC->APB1ENR1, Periphs);
 8002278:	6d93      	ldr	r3, [r2, #88]	@ 0x58
 800227a:	f023 0301 	bic.w	r3, r3, #1
 800227e:	6593      	str	r3, [r2, #88]	@ 0x58
    trigOut = LL_TIM_ReadReg(TIM2, CR2) & TIM_CR2_MMS;
    LL_TIM_SetTriggerOutput(TIM2, LL_TIM_TRGO_UPDATE);
    LL_TIM_GenerateEvent_UPDATE(TIM2);
    LL_TIM_SetTriggerOutput(TIM2, trigOut);
  }
}
 8002280:	b003      	add	sp, #12
 8002282:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002286:	4770      	bx	lr
    trigOut = LL_TIM_ReadReg(TIM2, CR2) & TIM_CR2_MMS;
 8002288:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 800228c:	480c      	ldr	r0, [pc, #48]	@ (80022c0 <startTimers+0x94>)
 800228e:	685a      	ldr	r2, [r3, #4]
 8002290:	6859      	ldr	r1, [r3, #4]
 8002292:	4c0c      	ldr	r4, [pc, #48]	@ (80022c4 <startTimers+0x98>)
 8002294:	4001      	ands	r1, r0
 8002296:	f041 0120 	orr.w	r1, r1, #32
 800229a:	6059      	str	r1, [r3, #4]
  SET_BIT(TIMx->EGR, TIM_EGR_UG);
 800229c:	6959      	ldr	r1, [r3, #20]
 800229e:	f041 0101 	orr.w	r1, r1, #1
 80022a2:	6159      	str	r1, [r3, #20]
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 80022a4:	6859      	ldr	r1, [r3, #4]
 80022a6:	4022      	ands	r2, r4
 80022a8:	4001      	ands	r1, r0
 80022aa:	430a      	orrs	r2, r1
 80022ac:	605a      	str	r2, [r3, #4]
}
 80022ae:	b003      	add	sp, #12
 80022b0:	f85d 4b04 	ldr.w	r4, [sp], #4
 80022b4:	4770      	bx	lr
 80022b6:	bf00      	nop
 80022b8:	40012c00 	.word	0x40012c00
 80022bc:	40021000 	.word	0x40021000
 80022c0:	fdffff8f 	.word	0xfdffff8f
 80022c4:	02000070 	.word	0x02000070

080022c8 <waitForPolarizationEnd>:
  {
#endif
    uint16_t hCalibrationPeriodCounter;
    uint16_t hMaxPeriodsNumber;

    hMaxPeriodsNumber = ((uint16_t)2 * NB_CONVERSIONS) * (((uint16_t)repCnt + 1U) >> 1);
 80022c8:	3201      	adds	r2, #1
{
 80022ca:	b570      	push	{r4, r5, r6, lr}
    hMaxPeriodsNumber = ((uint16_t)2 * NB_CONVERSIONS) * (((uint16_t)repCnt + 1U) >> 1);
 80022cc:	0852      	lsrs	r2, r2, #1
  WRITE_REG(TIMx->SR, ~(TIM_SR_CC1IF));
 80022ce:	f06f 0602 	mvn.w	r6, #2
 80022d2:	0155      	lsls	r5, r2, #5
 80022d4:	6106      	str	r6, [r0, #16]

    /* Wait for NB_CONVERSIONS to be executed */
    LL_TIM_ClearFlag_CC1(TIMx);
    hCalibrationPeriodCounter = 0u;
 80022d6:	2200      	movs	r2, #0
    while (*cnt < NB_CONVERSIONS)
 80022d8:	f893 c000 	ldrb.w	ip, [r3]
 80022dc:	f1bc 0f0f 	cmp.w	ip, #15
    {
      if ((uint32_t)ERROR == LL_TIM_IsActiveFlag_CC1(TIMx))
      {
        LL_TIM_ClearFlag_CC1(TIMx);
        hCalibrationPeriodCounter++;
 80022e0:	f102 0e01 	add.w	lr, r2, #1
    while (*cnt < NB_CONVERSIONS)
 80022e4:	d80c      	bhi.n	8002300 <waitForPolarizationEnd+0x38>
  return ((READ_BIT(TIMx->SR, TIM_SR_CC1IF) == (TIM_SR_CC1IF)) ? 1UL : 0UL);
 80022e6:	6904      	ldr	r4, [r0, #16]
 80022e8:	07a4      	lsls	r4, r4, #30
 80022ea:	d5f5      	bpl.n	80022d8 <waitForPolarizationEnd+0x10>
        hCalibrationPeriodCounter++;
 80022ec:	fa1f f28e 	uxth.w	r2, lr
        if (hCalibrationPeriodCounter >= hMaxPeriodsNumber)
 80022f0:	4295      	cmp	r5, r2
  WRITE_REG(TIMx->SR, ~(TIM_SR_CC1IF));
 80022f2:	6106      	str	r6, [r0, #16]
 80022f4:	d8f0      	bhi.n	80022d8 <waitForPolarizationEnd+0x10>
        {
          if (*cnt < NB_CONVERSIONS)
 80022f6:	781c      	ldrb	r4, [r3, #0]
 80022f8:	2c0f      	cmp	r4, #15
 80022fa:	d8ed      	bhi.n	80022d8 <waitForPolarizationEnd+0x10>
          {
            *SWerror = 1u;
 80022fc:	2301      	movs	r3, #1
 80022fe:	800b      	strh	r3, [r1, #0]
      }
    }
#ifdef NULL_PTR_CHECK_POW_COM
  }
#endif
  }
 8002300:	bd70      	pop	{r4, r5, r6, pc}
 8002302:	bf00      	nop

08002304 <PWMC_SetPhaseVoltage>:
  * @param  Valfa_beta: Voltage Components expressed in the @f$(\alpha, \beta)@f$ reference frame.
  * @retval #MC_NO_ERROR if no error occurred or #MC_DURATION if the duty cycles were
  *         set too late for being taken into account in the next PWM cycle.
  */
__weak uint16_t PWMC_SetPhaseVoltage(PWMC_Handle_t *pHandle, alphabeta_t Valfa_beta)
{
 8002304:	b530      	push	{r4, r5, lr}
    int32_t wTimePhA;
    int32_t wTimePhB;
    int32_t wTimePhC;

    wUAlpha = Valfa_beta.alpha * (int32_t)pHandle->hT_Sqrt3;
    wUBeta = -(Valfa_beta.beta * ((int32_t)pHandle->PWMperiod)) * 2;
 8002306:	f8b0 4070 	ldrh.w	r4, [r0, #112]	@ 0x70
    wUAlpha = Valfa_beta.alpha * (int32_t)pHandle->hT_Sqrt3;
 800230a:	f8b0 204e 	ldrh.w	r2, [r0, #78]	@ 0x4e
    wUBeta = -(Valfa_beta.beta * ((int32_t)pHandle->PWMperiod)) * 2;
 800230e:	ea4f 4c21 	mov.w	ip, r1, asr #16
    wUAlpha = Valfa_beta.alpha * (int32_t)pHandle->hT_Sqrt3;
 8002312:	b20b      	sxth	r3, r1
    wUBeta = -(Valfa_beta.beta * ((int32_t)pHandle->PWMperiod)) * 2;
 8002314:	fb04 fc0c 	mul.w	ip, r4, ip
 8002318:	ebcc 7ccc 	rsb	ip, ip, ip, lsl #31
    wUAlpha = Valfa_beta.alpha * (int32_t)pHandle->hT_Sqrt3;
 800231c:	fb02 f303 	mul.w	r3, r2, r3

    wX = wUBeta;
    wY = (wUBeta + wUAlpha) / 2;
 8002320:	eb03 024c 	add.w	r2, r3, ip, lsl #1
    wZ = (wUBeta - wUAlpha) / 2;
 8002324:	ebc3 034c 	rsb	r3, r3, ip, lsl #1
    wY = (wUBeta + wUAlpha) / 2;
 8002328:	eb02 7ed2 	add.w	lr, r2, r2, lsr #31
    wZ = (wUBeta - wUAlpha) / 2;
 800232c:	eb03 71d3 	add.w	r1, r3, r3, lsr #31

    /* Sector calculation from wX, wY, wZ */
    if (wY < 0)
 8002330:	1c55      	adds	r5, r2, #1
{
 8002332:	b083      	sub	sp, #12
    {
      if (wZ < 0)
      {
        pHandle->Sector = SECTOR_5;
        wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wY - wZ) / (int32_t)262144);
 8002334:	ea4f 0494 	mov.w	r4, r4, lsr #2
    wUBeta = -(Valfa_beta.beta * ((int32_t)pHandle->PWMperiod)) * 2;
 8002338:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
    wY = (wUBeta + wUAlpha) / 2;
 800233c:	ea4f 0e6e 	mov.w	lr, lr, asr #1
    wZ = (wUBeta - wUAlpha) / 2;
 8002340:	ea4f 0161 	mov.w	r1, r1, asr #1
    if (wY < 0)
 8002344:	db6b      	blt.n	800241e <PWMC_SetPhaseVoltage+0x11a>
        }
        }
    }
    else /* wY > 0 */
    {
      if (wZ >= 0)
 8002346:	1c5d      	adds	r5, r3, #1
 8002348:	db3d      	blt.n	80023c6 <PWMC_SetPhaseVoltage+0xc2>
      {
        pHandle->Sector = SECTOR_2;
        wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wY - wZ) / (int32_t)262144);
 800234a:	ebbe 0e01 	subs.w	lr, lr, r1
 800234e:	bf44      	itt	mi
 8002350:	f50e 3e7f 	addmi.w	lr, lr, #261120	@ 0x3fc00
 8002354:	f20e 3eff 	addwmi	lr, lr, #1023	@ 0x3ff
        wTimePhB = wTimePhA + (wZ / 131072);
 8002358:	2b00      	cmp	r3, #0
 800235a:	bfbc      	itt	lt
 800235c:	f503 337f 	addlt.w	r3, r3, #261120	@ 0x3fc00
 8002360:	f203 33ff 	addwlt	r3, r3, #1023	@ 0x3ff
        wTimePhC = wTimePhA - (wY / 131072);
 8002364:	2a00      	cmp	r2, #0
 8002366:	bfb8      	it	lt
 8002368:	f502 327f 	addlt.w	r2, r2, #261120	@ 0x3fc00

        if(true == pHandle->SingleShuntTopology)
 800236c:	f890 1085 	ldrb.w	r1, [r0, #133]	@ 0x85
        wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wY - wZ) / (int32_t)262144);
 8002370:	eb04 4eae 	add.w	lr, r4, lr, asr #18
        pHandle->Sector = SECTOR_2;
 8002374:	f04f 0501 	mov.w	r5, #1
        wTimePhC = wTimePhA - (wY / 131072);
 8002378:	bfb8      	it	lt
 800237a:	f202 32ff 	addwlt	r2, r2, #1023	@ 0x3ff
        pHandle->Sector = SECTOR_2;
 800237e:	f880 507a 	strb.w	r5, [r0, #122]	@ 0x7a
        wTimePhB = wTimePhA + (wZ / 131072);
 8002382:	eb0e 43a3 	add.w	r3, lr, r3, asr #18
        wTimePhC = wTimePhA - (wY / 131072);
 8002386:	ebae 42a2 	sub.w	r2, lr, r2, asr #18
        if(true == pHandle->SingleShuntTopology)
 800238a:	2900      	cmp	r1, #0
 800238c:	d16e      	bne.n	800246c <PWMC_SetPhaseVoltage+0x168>
          pHandle->midDuty = 0U;
          pHandle->highDuty = 1U;
        }
        else
        {
        pHandle->lowDuty = (uint16_t)wTimePhB;
 800238e:	fa1f fc83 	uxth.w	ip, r3
        pHandle->midDuty = (uint16_t)wTimePhA;
 8002392:	fa1f f48e 	uxth.w	r4, lr
        pHandle->highDuty = (uint16_t)wTimePhC;
 8002396:	b291      	uxth	r1, r2
            pHandle->highDuty = 2U;
 8002398:	f8a0 105c 	strh.w	r1, [r0, #92]	@ 0x5c

    pHandle->CntPhA = (uint16_t)(MAX(wTimePhA, 0));
    pHandle->CntPhB = (uint16_t)(MAX(wTimePhB, 0));
    pHandle->CntPhC = (uint16_t)(MAX(wTimePhC, 0));

    returnValue = pHandle->pFctSetADCSampPointSectX(pHandle);
 800239c:	6941      	ldr	r1, [r0, #20]
            pHandle->lowDuty = 0U;
 800239e:	f8a0 c058 	strh.w	ip, [r0, #88]	@ 0x58
    pHandle->CntPhA = (uint16_t)(MAX(wTimePhA, 0));
 80023a2:	ea2e 7eee 	bic.w	lr, lr, lr, asr #31
    pHandle->CntPhB = (uint16_t)(MAX(wTimePhB, 0));
 80023a6:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    pHandle->CntPhC = (uint16_t)(MAX(wTimePhC, 0));
 80023aa:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
            pHandle->midDuty = 1U;
 80023ae:	f8a0 405a 	strh.w	r4, [r0, #90]	@ 0x5a
    pHandle->CntPhA = (uint16_t)(MAX(wTimePhA, 0));
 80023b2:	f8a0 e050 	strh.w	lr, [r0, #80]	@ 0x50
    pHandle->CntPhB = (uint16_t)(MAX(wTimePhB, 0));
 80023b6:	f8a0 3052 	strh.w	r3, [r0, #82]	@ 0x52
    pHandle->CntPhC = (uint16_t)(MAX(wTimePhC, 0));
 80023ba:	f8a0 2054 	strh.w	r2, [r0, #84]	@ 0x54
#ifdef NULL_PTR_CHECK_PWR_CUR_FDB
  }
#endif
  return (returnValue);
}
 80023be:	b003      	add	sp, #12
 80023c0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    returnValue = pHandle->pFctSetADCSampPointSectX(pHandle);
 80023c4:	4708      	bx	r1
        if ( wX <= 0 )
 80023c6:	f1bc 0f00 	cmp.w	ip, #0
 80023ca:	dd7b      	ble.n	80024c4 <PWMC_SetPhaseVoltage+0x1c0>
          wTimePhB = wTimePhA + (wZ / 131072);
 80023cc:	2b00      	cmp	r3, #0
 80023ce:	bfb8      	it	lt
 80023d0:	f503 337f 	addlt.w	r3, r3, #261120	@ 0x3fc00
          wTimePhA = (((int32_t)pHandle->PWMperiod) / 4)+ ((wX - wZ) / (int32_t)262144);
 80023d4:	ebac 0101 	sub.w	r1, ip, r1
          wTimePhB = wTimePhA + (wZ / 131072);
 80023d8:	bfb8      	it	lt
 80023da:	f203 33ff 	addwlt	r3, r3, #1023	@ 0x3ff
          wTimePhC = wTimePhB - (wX / 131072);
 80023de:	f1bc 0f00 	cmp.w	ip, #0
          wTimePhA = (((int32_t)pHandle->PWMperiod) / 4)+ ((wX - wZ) / (int32_t)262144);
 80023e2:	eb04 4ea1 	add.w	lr, r4, r1, asr #18
          wTimePhC = wTimePhB - (wX / 131072);
 80023e6:	bfb8      	it	lt
 80023e8:	f50c 3cff 	addlt.w	ip, ip, #130560	@ 0x1fe00
          if((pHandle->DPWM_Mode == true) || (pHandle->SingleShuntTopology == true))
 80023ec:	f890 107d 	ldrb.w	r1, [r0, #125]	@ 0x7d
          pHandle->Sector = SECTOR_1;
 80023f0:	f04f 0200 	mov.w	r2, #0
          wTimePhB = wTimePhA + (wZ / 131072);
 80023f4:	eb0e 43a3 	add.w	r3, lr, r3, asr #18
          wTimePhC = wTimePhB - (wX / 131072);
 80023f8:	bfb8      	it	lt
 80023fa:	f20c 1cff 	addwlt	ip, ip, #511	@ 0x1ff
          pHandle->Sector = SECTOR_1;
 80023fe:	f880 207a 	strb.w	r2, [r0, #122]	@ 0x7a
          wTimePhC = wTimePhB - (wX / 131072);
 8002402:	eba3 426c 	sub.w	r2, r3, ip, asr #17
          if((pHandle->DPWM_Mode == true) || (pHandle->SingleShuntTopology == true))
 8002406:	2900      	cmp	r1, #0
 8002408:	f040 80ae 	bne.w	8002568 <PWMC_SetPhaseVoltage+0x264>
 800240c:	f890 4085 	ldrb.w	r4, [r0, #133]	@ 0x85
 8002410:	2c00      	cmp	r4, #0
 8002412:	f000 80b9 	beq.w	8002588 <PWMC_SetPhaseVoltage+0x284>
 8002416:	f04f 0c02 	mov.w	ip, #2
 800241a:	2401      	movs	r4, #1
 800241c:	e7bc      	b.n	8002398 <PWMC_SetPhaseVoltage+0x94>
      if (wZ < 0)
 800241e:	f1b3 3fff 	cmp.w	r3, #4294967295
        if(true == pHandle->SingleShuntTopology)
 8002422:	f890 5085 	ldrb.w	r5, [r0, #133]	@ 0x85
      if (wZ < 0)
 8002426:	db70      	blt.n	800250a <PWMC_SetPhaseVoltage+0x206>
        if (wX <= 0)
 8002428:	f1bc 0f00 	cmp.w	ip, #0
 800242c:	dd23      	ble.n	8002476 <PWMC_SetPhaseVoltage+0x172>
          wTimePhA = (((int32_t )pHandle->PWMperiod) / 4)+ ((wY - wX) / (int32_t)262144);
 800242e:	ebbe 0e0c 	subs.w	lr, lr, ip
 8002432:	bf44      	itt	mi
 8002434:	f50e 3e7f 	addmi.w	lr, lr, #261120	@ 0x3fc00
 8002438:	f20e 3eff 	addwmi	lr, lr, #1023	@ 0x3ff
          wTimePhC = wTimePhA - (wY / 131072);
 800243c:	2a00      	cmp	r2, #0
 800243e:	bfb8      	it	lt
 8002440:	f502 327f 	addlt.w	r2, r2, #261120	@ 0x3fc00
          wTimePhA = (((int32_t )pHandle->PWMperiod) / 4)+ ((wY - wX) / (int32_t)262144);
 8002444:	eb04 4eae 	add.w	lr, r4, lr, asr #18
          wTimePhC = wTimePhA - (wY / 131072);
 8002448:	bfb8      	it	lt
 800244a:	f202 32ff 	addwlt	r2, r2, #1023	@ 0x3ff
          pHandle->Sector = SECTOR_3;
 800244e:	2302      	movs	r3, #2
          wTimePhC = wTimePhA - (wY / 131072);
 8002450:	ebae 42a2 	sub.w	r2, lr, r2, asr #18
          pHandle->Sector = SECTOR_3;
 8002454:	f880 307a 	strb.w	r3, [r0, #122]	@ 0x7a
          wTimePhB = wTimePhC + (wX / 131072);
 8002458:	eb02 436c 	add.w	r3, r2, ip, asr #17
          if(true == pHandle->SingleShuntTopology)
 800245c:	2d00      	cmp	r5, #0
 800245e:	d17e      	bne.n	800255e <PWMC_SetPhaseVoltage+0x25a>
          pHandle->lowDuty = (uint16_t)wTimePhB;
 8002460:	fa1f fc83 	uxth.w	ip, r3
          pHandle->midDuty = (uint16_t)wTimePhC;
 8002464:	b294      	uxth	r4, r2
          pHandle->highDuty = (uint16_t)wTimePhA;
 8002466:	fa1f f18e 	uxth.w	r1, lr
 800246a:	e795      	b.n	8002398 <PWMC_SetPhaseVoltage+0x94>
 800246c:	f04f 0c02 	mov.w	ip, #2
 8002470:	2400      	movs	r4, #0
 8002472:	2101      	movs	r1, #1
 8002474:	e790      	b.n	8002398 <PWMC_SetPhaseVoltage+0x94>
          wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wX - wZ) / (int32_t)262144);
 8002476:	ebbc 0101 	subs.w	r1, ip, r1
 800247a:	bf44      	itt	mi
 800247c:	f501 317f 	addmi.w	r1, r1, #261120	@ 0x3fc00
 8002480:	f201 31ff 	addwmi	r1, r1, #1023	@ 0x3ff
          wTimePhB = wTimePhA + (wZ / 131072);
 8002484:	2b00      	cmp	r3, #0
 8002486:	bfb8      	it	lt
 8002488:	f503 337f 	addlt.w	r3, r3, #261120	@ 0x3fc00
          pHandle->Sector = SECTOR_4;
 800248c:	f04f 0203 	mov.w	r2, #3
          wTimePhB = wTimePhA + (wZ / 131072);
 8002490:	bfb8      	it	lt
 8002492:	f203 33ff 	addwlt	r3, r3, #1023	@ 0x3ff
          pHandle->Sector = SECTOR_4;
 8002496:	f880 207a 	strb.w	r2, [r0, #122]	@ 0x7a
          wTimePhC = wTimePhB - (wX / 131072);
 800249a:	f1bc 0200 	subs.w	r2, ip, #0
 800249e:	bfb8      	it	lt
 80024a0:	f502 32ff 	addlt.w	r2, r2, #130560	@ 0x1fe00
          wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wX - wZ) / (int32_t)262144);
 80024a4:	eb04 4ea1 	add.w	lr, r4, r1, asr #18
          wTimePhB = wTimePhA + (wZ / 131072);
 80024a8:	eb0e 43a3 	add.w	r3, lr, r3, asr #18
          wTimePhC = wTimePhB - (wX / 131072);
 80024ac:	bfb8      	it	lt
 80024ae:	f202 12ff 	addwlt	r2, r2, #511	@ 0x1ff
 80024b2:	eba3 4262 	sub.w	r2, r3, r2, asr #17
          if(true == pHandle->SingleShuntTopology)
 80024b6:	2d00      	cmp	r5, #0
 80024b8:	d060      	beq.n	800257c <PWMC_SetPhaseVoltage+0x278>
 80024ba:	f04f 0c00 	mov.w	ip, #0
 80024be:	2401      	movs	r4, #1
 80024c0:	2102      	movs	r1, #2
 80024c2:	e769      	b.n	8002398 <PWMC_SetPhaseVoltage+0x94>
          wTimePhC = wTimePhA - (wY / 131072);
 80024c4:	2a00      	cmp	r2, #0
 80024c6:	bfb8      	it	lt
 80024c8:	f502 327f 	addlt.w	r2, r2, #261120	@ 0x3fc00
          pHandle->Sector = SECTOR_6;
 80024cc:	f04f 0305 	mov.w	r3, #5
          wTimePhC = wTimePhA - (wY / 131072);
 80024d0:	bfb8      	it	lt
 80024d2:	f202 32ff 	addwlt	r2, r2, #1023	@ 0x3ff
          wTimePhA = (((int32_t )pHandle->PWMperiod) / 4) + ((wY - wX) / (int32_t)262144);
 80024d6:	ebae 0e0c 	sub.w	lr, lr, ip
          pHandle->Sector = SECTOR_6;
 80024da:	f880 307a 	strb.w	r3, [r0, #122]	@ 0x7a
          wTimePhB = wTimePhC + (wX / 131072);
 80024de:	f1bc 0300 	subs.w	r3, ip, #0
 80024e2:	bfb8      	it	lt
 80024e4:	f503 33ff 	addlt.w	r3, r3, #130560	@ 0x1fe00
          wTimePhA = (((int32_t )pHandle->PWMperiod) / 4) + ((wY - wX) / (int32_t)262144);
 80024e8:	eb04 4eae 	add.w	lr, r4, lr, asr #18
          if(true == pHandle->SingleShuntTopology)
 80024ec:	f890 1085 	ldrb.w	r1, [r0, #133]	@ 0x85
          wTimePhC = wTimePhA - (wY / 131072);
 80024f0:	ebae 42a2 	sub.w	r2, lr, r2, asr #18
          wTimePhB = wTimePhC + (wX / 131072);
 80024f4:	bfb8      	it	lt
 80024f6:	f203 13ff 	addwlt	r3, r3, #511	@ 0x1ff
 80024fa:	eb02 4363 	add.w	r3, r2, r3, asr #17
          if(true == pHandle->SingleShuntTopology)
 80024fe:	b3c1      	cbz	r1, 8002572 <PWMC_SetPhaseVoltage+0x26e>
 8002500:	f04f 0c01 	mov.w	ip, #1
 8002504:	2402      	movs	r4, #2
 8002506:	2100      	movs	r1, #0
 8002508:	e746      	b.n	8002398 <PWMC_SetPhaseVoltage+0x94>
        wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wY - wZ) / (int32_t)262144);
 800250a:	ebbe 0e01 	subs.w	lr, lr, r1
 800250e:	bf44      	itt	mi
 8002510:	f50e 3e7f 	addmi.w	lr, lr, #261120	@ 0x3fc00
 8002514:	f20e 3eff 	addwmi	lr, lr, #1023	@ 0x3ff
        wTimePhB = wTimePhA + (wZ / 131072);
 8002518:	2b00      	cmp	r3, #0
 800251a:	bfbc      	itt	lt
 800251c:	f503 337f 	addlt.w	r3, r3, #261120	@ 0x3fc00
 8002520:	f203 33ff 	addwlt	r3, r3, #1023	@ 0x3ff
        wTimePhC = wTimePhA - (wY / 131072) ;
 8002524:	2a00      	cmp	r2, #0
 8002526:	bfb8      	it	lt
 8002528:	f502 327f 	addlt.w	r2, r2, #261120	@ 0x3fc00
        wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wY - wZ) / (int32_t)262144);
 800252c:	eb04 4eae 	add.w	lr, r4, lr, asr #18
        pHandle->Sector = SECTOR_5;
 8002530:	f04f 0c04 	mov.w	ip, #4
        wTimePhC = wTimePhA - (wY / 131072) ;
 8002534:	bfb8      	it	lt
 8002536:	f202 32ff 	addwlt	r2, r2, #1023	@ 0x3ff
        pHandle->Sector = SECTOR_5;
 800253a:	f880 c07a 	strb.w	ip, [r0, #122]	@ 0x7a
        wTimePhB = wTimePhA + (wZ / 131072);
 800253e:	eb0e 43a3 	add.w	r3, lr, r3, asr #18
        wTimePhC = wTimePhA - (wY / 131072) ;
 8002542:	ebae 42a2 	sub.w	r2, lr, r2, asr #18
        if(true == pHandle->SingleShuntTopology)
 8002546:	b92d      	cbnz	r5, 8002554 <PWMC_SetPhaseVoltage+0x250>
          pHandle->lowDuty = (uint16_t)wTimePhC;
 8002548:	fa1f fc82 	uxth.w	ip, r2
          pHandle->midDuty = (uint16_t)wTimePhA;
 800254c:	fa1f f48e 	uxth.w	r4, lr
          pHandle->highDuty = (uint16_t)wTimePhB;
 8002550:	b299      	uxth	r1, r3
 8002552:	e721      	b.n	8002398 <PWMC_SetPhaseVoltage+0x94>
 8002554:	f04f 0c01 	mov.w	ip, #1
 8002558:	2400      	movs	r4, #0
 800255a:	2102      	movs	r1, #2
 800255c:	e71c      	b.n	8002398 <PWMC_SetPhaseVoltage+0x94>
 800255e:	f04f 0c00 	mov.w	ip, #0
 8002562:	2402      	movs	r4, #2
 8002564:	2101      	movs	r1, #1
 8002566:	e717      	b.n	8002398 <PWMC_SetPhaseVoltage+0x94>
 8002568:	f04f 0c02 	mov.w	ip, #2
 800256c:	2401      	movs	r4, #1
 800256e:	2100      	movs	r1, #0
 8002570:	e712      	b.n	8002398 <PWMC_SetPhaseVoltage+0x94>
            pHandle->lowDuty = (uint16_t)wTimePhA;
 8002572:	fa1f fc8e 	uxth.w	ip, lr
            pHandle->midDuty = (uint16_t)wTimePhC;
 8002576:	b294      	uxth	r4, r2
            pHandle->highDuty = (uint16_t)wTimePhB;
 8002578:	b299      	uxth	r1, r3
 800257a:	e70d      	b.n	8002398 <PWMC_SetPhaseVoltage+0x94>
          pHandle->lowDuty = (uint16_t)wTimePhC;
 800257c:	fa1f fc82 	uxth.w	ip, r2
          pHandle->midDuty = (uint16_t)wTimePhB;
 8002580:	b29c      	uxth	r4, r3
          pHandle->highDuty = (uint16_t)wTimePhA;
 8002582:	fa1f f18e 	uxth.w	r1, lr
 8002586:	e707      	b.n	8002398 <PWMC_SetPhaseVoltage+0x94>
            pHandle->lowDuty = (uint16_t)wTimePhA;
 8002588:	fa1f fc8e 	uxth.w	ip, lr
            pHandle->midDuty = (uint16_t)wTimePhB;
 800258c:	b29c      	uxth	r4, r3
            pHandle->highDuty = (uint16_t)wTimePhC;
 800258e:	b291      	uxth	r1, r2
 8002590:	e702      	b.n	8002398 <PWMC_SetPhaseVoltage+0x94>
 8002592:	bf00      	nop

08002594 <PWMC_SwitchOffPWM>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->pFctSwitchOffPwm(pHandle);
 8002594:	6843      	ldr	r3, [r0, #4]
 8002596:	4718      	bx	r3

08002598 <PWMC_SwitchOnPWM>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->pFctSwitchOnPwm(pHandle);
 8002598:	6883      	ldr	r3, [r0, #8]
 800259a:	4718      	bx	r3

0800259c <PWMC_CurrentReadingCalibr>:
  *         #CRC_EXEC to execute the offset calibration.
  * @retval true if the current calibration has been completed, **false** if it is
  *         still ongoing.
  */
__weak bool PWMC_CurrentReadingCalibr(PWMC_Handle_t *pHandle, CRCAction_t action)
{
 800259c:	b510      	push	{r4, lr}
 800259e:	4604      	mov	r4, r0
    /* Nothing to do */
  }
  else
  {
#endif
    if (CRC_START == action)
 80025a0:	b179      	cbz	r1, 80025c2 <PWMC_CurrentReadingCalibr+0x26>
    {
      PWMC_SwitchOffPWM(pHandle);
      pHandle->pFctCurrReadingCalib(pHandle);
      retVal = true;
    }
    else if (CRC_EXEC == action)
 80025a2:	2901      	cmp	r1, #1
 80025a4:	d001      	beq.n	80025aa <PWMC_CurrentReadingCalibr+0xe>
  bool retVal = false;
 80025a6:	2000      	movs	r0, #0
    }
#ifdef NULL_PTR_CHECK_PWR_CUR_FDB
  }
#endif
  return (retVal);
}
 80025a8:	bd10      	pop	{r4, pc}
      if (pHandle->OffCalibrWaitTimeCounter > 0u)
 80025aa:	f8b0 3060 	ldrh.w	r3, [r0, #96]	@ 0x60
 80025ae:	b16b      	cbz	r3, 80025cc <PWMC_CurrentReadingCalibr+0x30>
        pHandle->OffCalibrWaitTimeCounter--;
 80025b0:	3b01      	subs	r3, #1
 80025b2:	b29b      	uxth	r3, r3
 80025b4:	f8a0 3060 	strh.w	r3, [r0, #96]	@ 0x60
        if (0U == pHandle->OffCalibrWaitTimeCounter)
 80025b8:	2b00      	cmp	r3, #0
 80025ba:	d1f4      	bne.n	80025a6 <PWMC_CurrentReadingCalibr+0xa>
          pHandle->pFctCurrReadingCalib(pHandle);
 80025bc:	68c3      	ldr	r3, [r0, #12]
 80025be:	4798      	blx	r3
          retVal = true;
 80025c0:	e004      	b.n	80025cc <PWMC_CurrentReadingCalibr+0x30>
      PWMC_SwitchOffPWM(pHandle);
 80025c2:	f7ff ffe7 	bl	8002594 <PWMC_SwitchOffPWM>
      pHandle->pFctCurrReadingCalib(pHandle);
 80025c6:	68e3      	ldr	r3, [r4, #12]
 80025c8:	4620      	mov	r0, r4
 80025ca:	4798      	blx	r3
      retVal = true;
 80025cc:	2001      	movs	r0, #1
}
 80025ce:	bd10      	pop	{r4, pc}

080025d0 <PWMC_OCP_Handler>:
    tempPointer = MC_NULL;
  }
  else
  {
#endif
    if (false == pHandle->BrakeActionLock)
 80025d0:	f890 3083 	ldrb.w	r3, [r0, #131]	@ 0x83
 80025d4:	b91b      	cbnz	r3, 80025de <PWMC_OCP_Handler+0xe>
    {
      if (ES_GPIO == pHandle->LowSideOutputs)
 80025d6:	f890 307b 	ldrb.w	r3, [r0, #123]	@ 0x7b
 80025da:	2b02      	cmp	r3, #2
 80025dc:	d004      	beq.n	80025e8 <PWMC_OCP_Handler+0x18>
    }
    else
    {
      /* Nothing to do */
    }
    pHandle->OverCurrentFlag = true;
 80025de:	2301      	movs	r3, #1
 80025e0:	f880 3080 	strb.w	r3, [r0, #128]	@ 0x80
    tempPointer = &(pHandle->Motor);
#ifdef NULL_PTR_CHECK_PWR_CUR_FDB
  }
#endif
  return (tempPointer);
}
 80025e4:	3078      	adds	r0, #120	@ 0x78
 80025e6:	4770      	bx	lr
        LL_GPIO_ResetOutputPin(pHandle->pwm_en_v_port, pHandle->pwm_en_v_pin);
 80025e8:	e9d0 210f 	ldrd	r2, r1, [r0, #60]	@ 0x3c
{
 80025ec:	b410      	push	{r4}
        LL_GPIO_ResetOutputPin(pHandle->pwm_en_w_port, pHandle->pwm_en_w_pin);
 80025ee:	6c43      	ldr	r3, [r0, #68]	@ 0x44
        LL_GPIO_ResetOutputPin(pHandle->pwm_en_u_port, pHandle->pwm_en_u_pin);
 80025f0:	f8b0 4048 	ldrh.w	r4, [r0, #72]	@ 0x48
  *         @arg @ref LL_GPIO_PIN_ALL
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_ResetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
{
  WRITE_REG(GPIOx->BRR, PinMask);
 80025f4:	6294      	str	r4, [r2, #40]	@ 0x28
        LL_GPIO_ResetOutputPin(pHandle->pwm_en_v_port, pHandle->pwm_en_v_pin);
 80025f6:	f8b0 404a 	ldrh.w	r4, [r0, #74]	@ 0x4a
        LL_GPIO_ResetOutputPin(pHandle->pwm_en_w_port, pHandle->pwm_en_w_pin);
 80025fa:	f8b0 204c 	ldrh.w	r2, [r0, #76]	@ 0x4c
 80025fe:	628c      	str	r4, [r1, #40]	@ 0x28
 8002600:	629a      	str	r2, [r3, #40]	@ 0x28
    pHandle->OverCurrentFlag = true;
 8002602:	2301      	movs	r3, #1
 8002604:	f880 3080 	strb.w	r3, [r0, #128]	@ 0x80
}
 8002608:	f85d 4b04 	ldr.w	r4, [sp], #4
 800260c:	3078      	adds	r0, #120	@ 0x78
 800260e:	4770      	bx	lr

08002610 <PWMC_OVP_Handler>:
    tempPointer = MC_NULL;
  }
  else
  {
#endif
    TIMx->BDTR |= LL_TIM_OSSI_ENABLE;
 8002610:	6c4a      	ldr	r2, [r1, #68]	@ 0x44
{
 8002612:	4603      	mov	r3, r0
    pHandle->OverVoltageFlag = true;
 8002614:	f04f 0c01 	mov.w	ip, #1
    TIMx->BDTR |= LL_TIM_OSSI_ENABLE;
 8002618:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 800261c:	644a      	str	r2, [r1, #68]	@ 0x44
    tempPointer = &(pHandle->Motor);
#ifdef NULL_PTR_CHECK_PWR_CUR_FDB
  }
#endif
  return (tempPointer);
}
 800261e:	3078      	adds	r0, #120	@ 0x78
    pHandle->OverVoltageFlag = true;
 8002620:	f883 c081 	strb.w	ip, [r3, #129]	@ 0x81
    pHandle->BrakeActionLock = true;
 8002624:	f883 c083 	strb.w	ip, [r3, #131]	@ 0x83
}
 8002628:	4770      	bx	lr
 800262a:	bf00      	nop

0800262c <PWMC_IsFaultOccurred>:
  * @param  pHdl: Handler of the current instance of the PWM component.
  * @retval uint16_t Returns #MC_OVER_CURR if an overcurrent has been
  *                  detected since last method call, #MC_NO_FAULTS otherwise.
  */
__weak uint16_t PWMC_IsFaultOccurred(PWMC_Handle_t *pHandle)
{
 800262c:	4603      	mov	r3, r0
  uint16_t retVal = MC_NO_FAULTS;

  if (true == pHandle->OverVoltageFlag)
 800262e:	f890 0081 	ldrb.w	r0, [r0, #129]	@ 0x81
 8002632:	b1a8      	cbz	r0, 8002660 <PWMC_IsFaultOccurred+0x34>
  {
    retVal = MC_OVER_VOLT;
    pHandle->OverVoltageFlag = false;
 8002634:	2200      	movs	r2, #0
 8002636:	f883 2081 	strb.w	r2, [r3, #129]	@ 0x81
 800263a:	2142      	movs	r1, #66	@ 0x42
    retVal = MC_OVER_VOLT;
 800263c:	2002      	movs	r0, #2
  else
  {
    /* Nothing to do */
  }

  if (true == pHandle->OverCurrentFlag)
 800263e:	f893 2080 	ldrb.w	r2, [r3, #128]	@ 0x80
 8002642:	b11a      	cbz	r2, 800264c <PWMC_IsFaultOccurred+0x20>
  {
    retVal |= MC_OVER_CURR;
    pHandle->OverCurrentFlag = false;
 8002644:	2200      	movs	r2, #0
 8002646:	f883 2080 	strb.w	r2, [r3, #128]	@ 0x80
    retVal |= MC_OVER_CURR;
 800264a:	4608      	mov	r0, r1
  else
  {
    /* Nothing to do */
  }

  if (true == pHandle->driverProtectionFlag)
 800264c:	f893 2082 	ldrb.w	r2, [r3, #130]	@ 0x82
 8002650:	b12a      	cbz	r2, 800265e <PWMC_IsFaultOccurred+0x32>
  {
    retVal |= MC_DP_FAULT;
 8002652:	f440 6080 	orr.w	r0, r0, #1024	@ 0x400
    pHandle->driverProtectionFlag = false;
 8002656:	2200      	movs	r2, #0
    retVal |= MC_DP_FAULT;
 8002658:	b280      	uxth	r0, r0
    pHandle->driverProtectionFlag = false;
 800265a:	f883 2082 	strb.w	r2, [r3, #130]	@ 0x82
  {
    /* Nothing to do */
  }

  return (retVal);
}
 800265e:	4770      	bx	lr
 8002660:	2140      	movs	r1, #64	@ 0x40
 8002662:	e7ec      	b.n	800263e <PWMC_IsFaultOccurred+0x12>

08002664 <RI_SetRegisterGlobal>:
#include "mcpa.h"
#include "dac_ui.h"
#include "mc_configuration_registers.h"

uint8_t RI_SetRegisterGlobal(uint16_t regID, uint8_t typeID, uint8_t *data, uint16_t *size, int16_t dataAvailable)
{
 8002664:	b510      	push	{r4, lr}
  uint8_t retVal = MCP_CMD_OK;
  switch(typeID)
 8002666:	3908      	subs	r1, #8
{
 8002668:	f9bd c008 	ldrsh.w	ip, [sp, #8]
 800266c:	461c      	mov	r4, r3
  switch(typeID)
 800266e:	2920      	cmp	r1, #32
 8002670:	d812      	bhi.n	8002698 <RI_SetRegisterGlobal+0x34>
 8002672:	e8df f001 	tbb	[pc, r1]
 8002676:	1115      	.short	0x1115
 8002678:	11111111 	.word	0x11111111
 800267c:	111d1111 	.word	0x111d1111
 8002680:	11111111 	.word	0x11111111
 8002684:	112a1111 	.word	0x112a1111
 8002688:	11111111 	.word	0x11111111
 800268c:	11321111 	.word	0x11321111
 8002690:	11111111 	.word	0x11111111
 8002694:	1111      	.short	0x1111
 8002696:	44          	.byte	0x44
 8002697:	00          	.byte	0x00
    }

    default:
    {
      retVal = MCP_ERROR_BAD_DATA_TYPE;
      *size =0; /* From this point we are not able anymore to decode the RX buffer */
 8002698:	2300      	movs	r3, #0
 800269a:	8023      	strh	r3, [r4, #0]
      retVal = MCP_ERROR_BAD_DATA_TYPE;
 800269c:	2007      	movs	r0, #7
      break;
    }
  }
  return (retVal);
}
 800269e:	bd10      	pop	{r4, pc}
          retVal = MCP_ERROR_RO_REG;
 80026a0:	2848      	cmp	r0, #72	@ 0x48
      *size = 1;
 80026a2:	f04f 0301 	mov.w	r3, #1
          retVal = MCP_ERROR_RO_REG;
 80026a6:	bf14      	ite	ne
 80026a8:	2005      	movne	r0, #5
 80026aa:	2004      	moveq	r0, #4
      *size = 1;
 80026ac:	8023      	strh	r3, [r4, #0]
}
 80026ae:	bd10      	pop	{r4, pc}
      uint16_t regdata16 = *(uint16_t *)data; //cstat !MISRAC2012-Rule-11.3
 80026b0:	f5b0 6fd2 	cmp.w	r0, #1680	@ 0x690
 80026b4:	8812      	ldrh	r2, [r2, #0]
      switch (regID)
 80026b6:	d054      	beq.n	8002762 <RI_SetRegisterGlobal+0xfe>
 80026b8:	d83a      	bhi.n	8002730 <RI_SetRegisterGlobal+0xcc>
 80026ba:	f5b0 6fca 	cmp.w	r0, #1616	@ 0x650
 80026be:	d055      	beq.n	800276c <RI_SetRegisterGlobal+0x108>
 80026c0:	d92e      	bls.n	8002720 <RI_SetRegisterGlobal+0xbc>
 80026c2:	2005      	movs	r0, #5
      *size = 2;
 80026c4:	2302      	movs	r3, #2
 80026c6:	8023      	strh	r3, [r4, #0]
}
 80026c8:	bd10      	pop	{r4, pc}
          retVal = MCP_ERROR_RO_REG;
 80026ca:	2818      	cmp	r0, #24
      *size = 4;
 80026cc:	f04f 0304 	mov.w	r3, #4
          retVal = MCP_ERROR_RO_REG;
 80026d0:	bf14      	ite	ne
 80026d2:	2005      	movne	r0, #5
 80026d4:	4618      	moveq	r0, r3
      *size = 4;
 80026d6:	8023      	strh	r3, [r4, #0]
}
 80026d8:	bd10      	pop	{r4, pc}
uint8_t RI_MovString(const char_t *srcString, char_t *destString, uint16_t *size, int16_t maxSize)
{
  uint8_t retVal = MCP_CMD_OK;
  const char_t *tempsrcString = srcString;
  char_t *tempdestString = destString;
  *size= 1U ; /* /0 is the min String size */
 80026da:	2101      	movs	r1, #1
 80026dc:	8021      	strh	r1, [r4, #0]

  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 80026de:	f992 3000 	ldrsb.w	r3, [r2]
 80026e2:	b39b      	cbz	r3, 800274c <RI_SetRegisterGlobal+0xe8>
 80026e4:	fa1f f38c 	uxth.w	r3, ip
 80026e8:	e003      	b.n	80026f2 <RI_SetRegisterGlobal+0x8e>
  {
    *tempdestString = *tempsrcString;
    tempdestString++;
    tempsrcString++;
    *size = *size + 1U;
 80026ea:	8021      	strh	r1, [r4, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 80026ec:	f912 0f01 	ldrsb.w	r0, [r2, #1]!
 80026f0:	b360      	cbz	r0, 800274c <RI_SetRegisterGlobal+0xe8>
    *size = *size + 1U;
 80026f2:	1c48      	adds	r0, r1, #1
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 80026f4:	4299      	cmp	r1, r3
    *size = *size + 1U;
 80026f6:	b281      	uxth	r1, r0
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 80026f8:	d3f7      	bcc.n	80026ea <RI_SetRegisterGlobal+0x86>
      retVal = MCP_ERROR_RO_REG;
 80026fa:	2004      	movs	r0, #4
}
 80026fc:	bd10      	pop	{r4, pc}
      *size = rawSize + 2U;
 80026fe:	8812      	ldrh	r2, [r2, #0]
 8002700:	3202      	adds	r2, #2
 8002702:	b292      	uxth	r2, r2
      if (*size > (uint16_t)dataAvailable)
 8002704:	fa1f f38c 	uxth.w	r3, ip
 8002708:	429a      	cmp	r2, r3
      *size = rawSize + 2U;
 800270a:	8022      	strh	r2, [r4, #0]
      if (*size > (uint16_t)dataAvailable)
 800270c:	d825      	bhi.n	800275a <RI_SetRegisterGlobal+0xf6>
        switch (regID)
 800270e:	28a8      	cmp	r0, #168	@ 0xa8
 8002710:	d0f3      	beq.n	80026fa <RI_SetRegisterGlobal+0x96>
 8002712:	d81f      	bhi.n	8002754 <RI_SetRegisterGlobal+0xf0>
 8002714:	f020 0040 	bic.w	r0, r0, #64	@ 0x40
 8002718:	2828      	cmp	r0, #40	@ 0x28
 800271a:	d0ee      	beq.n	80026fa <RI_SetRegisterGlobal+0x96>
 800271c:	2005      	movs	r0, #5
}
 800271e:	bd10      	pop	{r4, pc}
 8002720:	f020 0040 	bic.w	r0, r0, #64	@ 0x40
 8002724:	f5b0 6fb2 	cmp.w	r0, #1424	@ 0x590
 8002728:	bf0c      	ite	eq
 800272a:	2004      	moveq	r0, #4
 800272c:	2005      	movne	r0, #5
 800272e:	e7c9      	b.n	80026c4 <RI_SetRegisterGlobal+0x60>
 8002730:	f5b0 6f69 	cmp.w	r0, #3728	@ 0xe90
 8002734:	d008      	beq.n	8002748 <RI_SetRegisterGlobal+0xe4>
 8002736:	f641 3358 	movw	r3, #7000	@ 0x1b58
 800273a:	4298      	cmp	r0, r3
 800273c:	d101      	bne.n	8002742 <RI_SetRegisterGlobal+0xde>
          retVal = MCP_ERROR_RO_REG;
 800273e:	2004      	movs	r0, #4
 8002740:	e7c0      	b.n	80026c4 <RI_SetRegisterGlobal+0x60>
 8002742:	f5b0 6f65 	cmp.w	r0, #3664	@ 0xe50
 8002746:	d1bc      	bne.n	80026c2 <RI_SetRegisterGlobal+0x5e>
  uint8_t retVal = MCP_CMD_OK;
 8002748:	2000      	movs	r0, #0
 800274a:	e7bb      	b.n	80026c4 <RI_SetRegisterGlobal+0x60>
  { /* Last string char must be 0 */
    retVal = MCP_ERROR_STRING_FORMAT;
  }
  else
  {
    *tempdestString = (int8_t)0;
 800274c:	2300      	movs	r3, #0
 800274e:	7013      	strb	r3, [r2, #0]
      retVal = MCP_ERROR_RO_REG;
 8002750:	2004      	movs	r0, #4
 8002752:	e7d3      	b.n	80026fc <RI_SetRegisterGlobal+0x98>
 8002754:	28e8      	cmp	r0, #232	@ 0xe8
 8002756:	d1e1      	bne.n	800271c <RI_SetRegisterGlobal+0xb8>
 8002758:	e7cf      	b.n	80026fa <RI_SetRegisterGlobal+0x96>
        *size = 0;
 800275a:	2300      	movs	r3, #0
 800275c:	8023      	strh	r3, [r4, #0]
        retVal = MCP_ERROR_BAD_RAW_FORMAT; /* This error stop the parsing of the CMD buffer */
 800275e:	200a      	movs	r0, #10
}
 8002760:	bd10      	pop	{r4, pc}
          DAC_SetChannelConfig(&DAC_Handle , DAC_CH2, regdata16);
 8002762:	4805      	ldr	r0, [pc, #20]	@ (8002778 <RI_SetRegisterGlobal+0x114>)
 8002764:	2101      	movs	r1, #1
 8002766:	f7fe fa35 	bl	8000bd4 <DAC_SetChannelConfig>
          break;
 800276a:	e7ed      	b.n	8002748 <RI_SetRegisterGlobal+0xe4>
          DAC_SetChannelConfig(&DAC_Handle , DAC_CH1, regdata16);
 800276c:	4802      	ldr	r0, [pc, #8]	@ (8002778 <RI_SetRegisterGlobal+0x114>)
 800276e:	2100      	movs	r1, #0
 8002770:	f7fe fa30 	bl	8000bd4 <DAC_SetChannelConfig>
          break;
 8002774:	e7e8      	b.n	8002748 <RI_SetRegisterGlobal+0xe4>
 8002776:	bf00      	nop
 8002778:	200004a0 	.word	0x200004a0

0800277c <RI_SetRegisterMotor1>:
{
 800277c:	b510      	push	{r4, lr}
 800277e:	b084      	sub	sp, #16
  switch(typeID)
 8002780:	3908      	subs	r1, #8
{
 8002782:	f9bd c018 	ldrsh.w	ip, [sp, #24]
 8002786:	4696      	mov	lr, r2
 8002788:	461c      	mov	r4, r3
  switch(typeID)
 800278a:	2920      	cmp	r1, #32
 800278c:	d812      	bhi.n	80027b4 <RI_SetRegisterMotor1+0x38>
 800278e:	e8df f001 	tbb	[pc, r1]
 8002792:	1116      	.short	0x1116
 8002794:	11111111 	.word	0x11111111
 8002798:	11281111 	.word	0x11281111
 800279c:	11111111 	.word	0x11111111
 80027a0:	11501111 	.word	0x11501111
 80027a4:	11111111 	.word	0x11111111
 80027a8:	115e1111 	.word	0x115e1111
 80027ac:	11111111 	.word	0x11111111
 80027b0:	1111      	.short	0x1111
 80027b2:	75          	.byte	0x75
 80027b3:	00          	.byte	0x00
      *size =0; /* From this point we are not able anymore to decode the RX buffer */
 80027b4:	2300      	movs	r3, #0
 80027b6:	8023      	strh	r3, [r4, #0]
      retVal = MCP_ERROR_BAD_DATA_TYPE;
 80027b8:	2007      	movs	r0, #7
}
 80027ba:	b004      	add	sp, #16
 80027bc:	bd10      	pop	{r4, pc}
      switch (regID)
 80027be:	2888      	cmp	r0, #136	@ 0x88
 80027c0:	f000 81a4 	beq.w	8002b0c <RI_SetRegisterMotor1+0x390>
 80027c4:	f240 80bf 	bls.w	8002946 <RI_SetRegisterMotor1+0x1ca>
 80027c8:	f5b0 6fa9 	cmp.w	r0, #1352	@ 0x548
 80027cc:	f000 81ae 	beq.w	8002b2c <RI_SetRegisterMotor1+0x3b0>
 80027d0:	f5b0 6fb1 	cmp.w	r0, #1416	@ 0x588
 80027d4:	bf0c      	ite	eq
 80027d6:	2004      	moveq	r0, #4
 80027d8:	2005      	movne	r0, #5
      *size = 1;
 80027da:	2301      	movs	r3, #1
 80027dc:	8023      	strh	r3, [r4, #0]
}
 80027de:	b004      	add	sp, #16
 80027e0:	bd10      	pop	{r4, pc}
      uint16_t regdata16 = *(uint16_t *)data; //cstat !MISRAC2012-Rule-11.3
 80027e2:	f241 33d0 	movw	r3, #5072	@ 0x13d0
 80027e6:	4298      	cmp	r0, r3
 80027e8:	8811      	ldrh	r1, [r2, #0]
      switch (regID)
 80027ea:	f000 81f0 	beq.w	8002bce <RI_SetRegisterMotor1+0x452>
 80027ee:	f200 80c0 	bhi.w	8002972 <RI_SetRegisterMotor1+0x1f6>
 80027f2:	f5b0 7f24 	cmp.w	r0, #656	@ 0x290
 80027f6:	f000 81dd 	beq.w	8002bb4 <RI_SetRegisterMotor1+0x438>
 80027fa:	f240 80a9 	bls.w	8002950 <RI_SetRegisterMotor1+0x1d4>
 80027fe:	f5b0 6f15 	cmp.w	r0, #2384	@ 0x950
 8002802:	f000 81ca 	beq.w	8002b9a <RI_SetRegisterMotor1+0x41e>
 8002806:	d96b      	bls.n	80028e0 <RI_SetRegisterMotor1+0x164>
 8002808:	f5b0 6f65 	cmp.w	r0, #3664	@ 0xe50
 800280c:	d00c      	beq.n	8002828 <RI_SetRegisterMotor1+0xac>
 800280e:	d957      	bls.n	80028c0 <RI_SetRegisterMotor1+0x144>
 8002810:	f5b0 6f69 	cmp.w	r0, #3728	@ 0xe90
 8002814:	d008      	beq.n	8002828 <RI_SetRegisterMotor1+0xac>
 8002816:	f241 3390 	movw	r3, #5008	@ 0x1390
 800281a:	4298      	cmp	r0, r3
 800281c:	f040 80cf 	bne.w	80029be <RI_SetRegisterMotor1+0x242>
          PID_SetKP(&PID_PosParamsM1, regdata16);
 8002820:	48a5      	ldr	r0, [pc, #660]	@ (8002ab8 <RI_SetRegisterMotor1+0x33c>)
 8002822:	b209      	sxth	r1, r1
 8002824:	f006 f92a 	bl	8008a7c <PID_SetKP>
  uint8_t retVal = MCP_CMD_OK;
 8002828:	2000      	movs	r0, #0
      *size = 2;
 800282a:	2302      	movs	r3, #2
 800282c:	8023      	strh	r3, [r4, #0]
}
 800282e:	b004      	add	sp, #16
 8002830:	bd10      	pop	{r4, pc}
      switch (regID)
 8002832:	2858      	cmp	r0, #88	@ 0x58
 8002834:	f000 817c 	beq.w	8002b30 <RI_SetRegisterMotor1+0x3b4>
 8002838:	2898      	cmp	r0, #152	@ 0x98
 800283a:	f000 8159 	beq.w	8002af0 <RI_SetRegisterMotor1+0x374>
 800283e:	2818      	cmp	r0, #24
 8002840:	bf0c      	ite	eq
 8002842:	2004      	moveq	r0, #4
 8002844:	2005      	movne	r0, #5
      *size = 4;
 8002846:	2304      	movs	r3, #4
 8002848:	8023      	strh	r3, [r4, #0]
}
 800284a:	b004      	add	sp, #16
 800284c:	bd10      	pop	{r4, pc}
  *size= 1U ; /* /0 is the min String size */
 800284e:	2001      	movs	r0, #1
 8002850:	8020      	strh	r0, [r4, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8002852:	f992 3000 	ldrsb.w	r3, [r2]
 8002856:	2b00      	cmp	r3, #0
 8002858:	f000 8129 	beq.w	8002aae <RI_SetRegisterMotor1+0x332>
 800285c:	fa1f f38c 	uxth.w	r3, ip
 8002860:	e005      	b.n	800286e <RI_SetRegisterMotor1+0xf2>
    *size = *size + 1U;
 8002862:	8020      	strh	r0, [r4, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8002864:	f91e 1f01 	ldrsb.w	r1, [lr, #1]!
 8002868:	2900      	cmp	r1, #0
 800286a:	f000 8120 	beq.w	8002aae <RI_SetRegisterMotor1+0x332>
    *size = *size + 1U;
 800286e:	f100 0c01 	add.w	ip, r0, #1
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8002872:	4283      	cmp	r3, r0
    *size = *size + 1U;
 8002874:	fa1f f08c 	uxth.w	r0, ip
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8002878:	d8f3      	bhi.n	8002862 <RI_SetRegisterMotor1+0xe6>
 800287a:	e116      	b.n	8002aaa <RI_SetRegisterMotor1+0x32e>
      *size = rawSize + 2U;
 800287c:	8812      	ldrh	r2, [r2, #0]
 800287e:	3202      	adds	r2, #2
 8002880:	b292      	uxth	r2, r2
      if (*size > (uint16_t)dataAvailable)
 8002882:	fa1f f38c 	uxth.w	r3, ip
 8002886:	429a      	cmp	r2, r3
      *size = rawSize + 2U;
 8002888:	8022      	strh	r2, [r4, #0]
      if (*size > (uint16_t)dataAvailable)
 800288a:	f200 812d 	bhi.w	8002ae8 <RI_SetRegisterMotor1+0x36c>
        switch (regID)
 800288e:	f5b0 7f5a 	cmp.w	r0, #872	@ 0x368
 8002892:	f000 8169 	beq.w	8002b68 <RI_SetRegisterMotor1+0x3ec>
 8002896:	f200 8119 	bhi.w	8002acc <RI_SetRegisterMotor1+0x350>
 800289a:	f5b0 7fd4 	cmp.w	r0, #424	@ 0x1a8
 800289e:	f000 8155 	beq.w	8002b4c <RI_SetRegisterMotor1+0x3d0>
 80028a2:	f240 80fd 	bls.w	8002aa0 <RI_SetRegisterMotor1+0x324>
 80028a6:	f5b0 7ff4 	cmp.w	r0, #488	@ 0x1e8
 80028aa:	f040 80f6 	bne.w	8002a9a <RI_SetRegisterMotor1+0x31e>
            MCI_ExecTorqueRamp(pMCIN, (int16_t)torque, duration);
 80028ae:	f8be 2006 	ldrh.w	r2, [lr, #6]
 80028b2:	f9be 1002 	ldrsh.w	r1, [lr, #2]
 80028b6:	4881      	ldr	r0, [pc, #516]	@ (8002abc <RI_SetRegisterMotor1+0x340>)
 80028b8:	f7fe fc84 	bl	80011c4 <MCI_ExecTorqueRamp>
  uint8_t retVal = MCP_CMD_OK;
 80028bc:	2000      	movs	r0, #0
 80028be:	e77c      	b.n	80027ba <RI_SetRegisterMotor1+0x3e>
 80028c0:	f5b0 6f19 	cmp.w	r0, #2448	@ 0x990
 80028c4:	d17a      	bne.n	80029bc <RI_SetRegisterMotor1+0x240>
          currComp = MCI_GetIqdref(pMCIN);
 80028c6:	487d      	ldr	r0, [pc, #500]	@ (8002abc <RI_SetRegisterMotor1+0x340>)
 80028c8:	9101      	str	r1, [sp, #4]
 80028ca:	f7fe fdad 	bl	8001428 <MCI_GetIqdref>
          currComp.d = (int16_t)regdata16;
 80028ce:	9901      	ldr	r1, [sp, #4]
          currComp = MCI_GetIqdref(pMCIN);
 80028d0:	9003      	str	r0, [sp, #12]
          currComp.d = (int16_t)regdata16;
 80028d2:	f8ad 100e 	strh.w	r1, [sp, #14]
          MCI_SetCurrentReferences(pMCIN,currComp);
 80028d6:	9903      	ldr	r1, [sp, #12]
 80028d8:	4878      	ldr	r0, [pc, #480]	@ (8002abc <RI_SetRegisterMotor1+0x340>)
 80028da:	f7fe fc7d 	bl	80011d8 <MCI_SetCurrentReferences>
          break;
 80028de:	e7a3      	b.n	8002828 <RI_SetRegisterMotor1+0xac>
 80028e0:	f5b0 7f44 	cmp.w	r0, #784	@ 0x310
 80028e4:	f000 8185 	beq.w	8002bf2 <RI_SetRegisterMotor1+0x476>
 80028e8:	d912      	bls.n	8002910 <RI_SetRegisterMotor1+0x194>
 80028ea:	f5b0 6f01 	cmp.w	r0, #2064	@ 0x810
 80028ee:	d00d      	beq.n	800290c <RI_SetRegisterMotor1+0x190>
 80028f0:	d91f      	bls.n	8002932 <RI_SetRegisterMotor1+0x1b6>
 80028f2:	f5b0 6f0d 	cmp.w	r0, #2256	@ 0x8d0
 80028f6:	d009      	beq.n	800290c <RI_SetRegisterMotor1+0x190>
 80028f8:	d912      	bls.n	8002920 <RI_SetRegisterMotor1+0x1a4>
          retVal = MCP_ERROR_UNKNOWN_REG;
 80028fa:	f5b0 6f11 	cmp.w	r0, #2320	@ 0x910
      *size = 2;
 80028fe:	f04f 0302 	mov.w	r3, #2
          retVal = MCP_ERROR_UNKNOWN_REG;
 8002902:	bf0c      	ite	eq
 8002904:	2004      	moveq	r0, #4
 8002906:	2005      	movne	r0, #5
      *size = 2;
 8002908:	8023      	strh	r3, [r4, #0]
      break;
 800290a:	e790      	b.n	800282e <RI_SetRegisterMotor1+0xb2>
 800290c:	2004      	movs	r0, #4
 800290e:	e78c      	b.n	800282a <RI_SetRegisterMotor1+0xae>
 8002910:	f5b0 7f34 	cmp.w	r0, #720	@ 0x2d0
 8002914:	d153      	bne.n	80029be <RI_SetRegisterMotor1+0x242>
          PID_SetKI(&PIDIdHandle_M1, (int16_t)regdata16);
 8002916:	486a      	ldr	r0, [pc, #424]	@ (8002ac0 <RI_SetRegisterMotor1+0x344>)
 8002918:	b209      	sxth	r1, r1
 800291a:	f006 f8b1 	bl	8008a80 <PID_SetKI>
          break;
 800291e:	e783      	b.n	8002828 <RI_SetRegisterMotor1+0xac>
 8002920:	f5b0 6f05 	cmp.w	r0, #2128	@ 0x850
 8002924:	d0f2      	beq.n	800290c <RI_SetRegisterMotor1+0x190>
          retVal = MCP_ERROR_UNKNOWN_REG;
 8002926:	f5b0 6f09 	cmp.w	r0, #2192	@ 0x890
 800292a:	bf0c      	ite	eq
 800292c:	2004      	moveq	r0, #4
 800292e:	2005      	movne	r0, #5
 8002930:	e77b      	b.n	800282a <RI_SetRegisterMotor1+0xae>
 8002932:	f5b0 6ff2 	cmp.w	r0, #1936	@ 0x790
 8002936:	d0e9      	beq.n	800290c <RI_SetRegisterMotor1+0x190>
 8002938:	d938      	bls.n	80029ac <RI_SetRegisterMotor1+0x230>
 800293a:	f5b0 6ffa 	cmp.w	r0, #2000	@ 0x7d0
 800293e:	bf0c      	ite	eq
 8002940:	2004      	moveq	r0, #4
 8002942:	2005      	movne	r0, #5
 8002944:	e771      	b.n	800282a <RI_SetRegisterMotor1+0xae>
 8002946:	2848      	cmp	r0, #72	@ 0x48
 8002948:	bf0c      	ite	eq
 800294a:	2004      	moveq	r0, #4
 800294c:	2005      	movne	r0, #5
 800294e:	e744      	b.n	80027da <RI_SetRegisterMotor1+0x5e>
 8002950:	f5b0 7fc8 	cmp.w	r0, #400	@ 0x190
 8002954:	f000 811c 	beq.w	8002b90 <RI_SetRegisterMotor1+0x414>
 8002958:	d940      	bls.n	80029dc <RI_SetRegisterMotor1+0x260>
 800295a:	f5b0 7fe8 	cmp.w	r0, #464	@ 0x1d0
 800295e:	f000 8143 	beq.w	8002be8 <RI_SetRegisterMotor1+0x46c>
 8002962:	f5b0 7f04 	cmp.w	r0, #528	@ 0x210
 8002966:	d12a      	bne.n	80029be <RI_SetRegisterMotor1+0x242>
          PID_SetKD(&PIDIqHandle_M1, (int16_t)regdata16);
 8002968:	4856      	ldr	r0, [pc, #344]	@ (8002ac4 <RI_SetRegisterMotor1+0x348>)
 800296a:	b209      	sxth	r1, r1
 800296c:	f006 f8b6 	bl	8008adc <PID_SetKD>
          break;
 8002970:	e75a      	b.n	8002828 <RI_SetRegisterMotor1+0xac>
 8002972:	f241 5390 	movw	r3, #5520	@ 0x1590
 8002976:	4298      	cmp	r0, r3
 8002978:	f000 8106 	beq.w	8002b88 <RI_SetRegisterMotor1+0x40c>
 800297c:	d958      	bls.n	8002a30 <RI_SetRegisterMotor1+0x2b4>
 800297e:	f241 6390 	movw	r3, #5776	@ 0x1690
 8002982:	4298      	cmp	r0, r3
 8002984:	f000 811f 	beq.w	8002bc6 <RI_SetRegisterMotor1+0x44a>
 8002988:	d945      	bls.n	8002a16 <RI_SetRegisterMotor1+0x29a>
 800298a:	f241 7310 	movw	r3, #5904	@ 0x1710
 800298e:	4298      	cmp	r0, r3
 8002990:	f000 813d 	beq.w	8002c0e <RI_SetRegisterMotor1+0x492>
 8002994:	f641 3358 	movw	r3, #7000	@ 0x1b58
 8002998:	4298      	cmp	r0, r3
 800299a:	d0b7      	beq.n	800290c <RI_SetRegisterMotor1+0x190>
 800299c:	f241 63d0 	movw	r3, #5840	@ 0x16d0
 80029a0:	4298      	cmp	r0, r3
 80029a2:	d10c      	bne.n	80029be <RI_SetRegisterMotor1+0x242>
          PID_SetKIDivisorPOW2(&PID_PosParamsM1, regdata16);
 80029a4:	4844      	ldr	r0, [pc, #272]	@ (8002ab8 <RI_SetRegisterMotor1+0x33c>)
 80029a6:	f006 f885 	bl	8008ab4 <PID_SetKIDivisorPOW2>
          break;
 80029aa:	e73d      	b.n	8002828 <RI_SetRegisterMotor1+0xac>
 80029ac:	f020 0040 	bic.w	r0, r0, #64	@ 0x40
          retVal = MCP_ERROR_UNKNOWN_REG;
 80029b0:	f5b0 6fb2 	cmp.w	r0, #1424	@ 0x590
 80029b4:	bf0c      	ite	eq
 80029b6:	2004      	moveq	r0, #4
 80029b8:	2005      	movne	r0, #5
 80029ba:	e736      	b.n	800282a <RI_SetRegisterMotor1+0xae>
 80029bc:	d201      	bcs.n	80029c2 <RI_SetRegisterMotor1+0x246>
 80029be:	2005      	movs	r0, #5
 80029c0:	e733      	b.n	800282a <RI_SetRegisterMotor1+0xae>
 80029c2:	f5b0 6f29 	cmp.w	r0, #2704	@ 0xa90
 80029c6:	d0a1      	beq.n	800290c <RI_SetRegisterMotor1+0x190>
 80029c8:	d913      	bls.n	80029f2 <RI_SetRegisterMotor1+0x276>
 80029ca:	f5b0 6f2d 	cmp.w	r0, #2768	@ 0xad0
 80029ce:	d09d      	beq.n	800290c <RI_SetRegisterMotor1+0x190>
 80029d0:	f5b0 6f31 	cmp.w	r0, #2832	@ 0xb10
 80029d4:	bf0c      	ite	eq
 80029d6:	2004      	moveq	r0, #4
 80029d8:	2005      	movne	r0, #5
 80029da:	e726      	b.n	800282a <RI_SetRegisterMotor1+0xae>
 80029dc:	28d0      	cmp	r0, #208	@ 0xd0
 80029de:	f000 8111 	beq.w	8002c04 <RI_SetRegisterMotor1+0x488>
 80029e2:	f5b0 7f88 	cmp.w	r0, #272	@ 0x110
 80029e6:	d10f      	bne.n	8002a08 <RI_SetRegisterMotor1+0x28c>
          PID_SetKD(&PIDSpeedHandle_M1, (int16_t)regdata16);
 80029e8:	4837      	ldr	r0, [pc, #220]	@ (8002ac8 <RI_SetRegisterMotor1+0x34c>)
 80029ea:	b209      	sxth	r1, r1
 80029ec:	f006 f876 	bl	8008adc <PID_SetKD>
          break;
 80029f0:	e71a      	b.n	8002828 <RI_SetRegisterMotor1+0xac>
 80029f2:	f020 0340 	bic.w	r3, r0, #64	@ 0x40
 80029f6:	f5b3 6f21 	cmp.w	r3, #2576	@ 0xa10
 80029fa:	d087      	beq.n	800290c <RI_SetRegisterMotor1+0x190>
          retVal = MCP_ERROR_UNKNOWN_REG;
 80029fc:	f5b0 6f1d 	cmp.w	r0, #2512	@ 0x9d0
 8002a00:	bf0c      	ite	eq
 8002a02:	2004      	moveq	r0, #4
 8002a04:	2005      	movne	r0, #5
 8002a06:	e710      	b.n	800282a <RI_SetRegisterMotor1+0xae>
 8002a08:	2890      	cmp	r0, #144	@ 0x90
 8002a0a:	d1d8      	bne.n	80029be <RI_SetRegisterMotor1+0x242>
          PID_SetKP(&PIDSpeedHandle_M1, (int16_t)regdata16);
 8002a0c:	482e      	ldr	r0, [pc, #184]	@ (8002ac8 <RI_SetRegisterMotor1+0x34c>)
 8002a0e:	b209      	sxth	r1, r1
 8002a10:	f006 f834 	bl	8008a7c <PID_SetKP>
          break;
 8002a14:	e708      	b.n	8002828 <RI_SetRegisterMotor1+0xac>
 8002a16:	f241 6310 	movw	r3, #5648	@ 0x1610
 8002a1a:	4298      	cmp	r0, r3
 8002a1c:	f000 80ee 	beq.w	8002bfc <RI_SetRegisterMotor1+0x480>
 8002a20:	f241 6350 	movw	r3, #5712	@ 0x1650
 8002a24:	4298      	cmp	r0, r3
 8002a26:	d116      	bne.n	8002a56 <RI_SetRegisterMotor1+0x2da>
          PID_SetKDDivisorPOW2(&PIDIqHandle_M1, regdata16);
 8002a28:	4826      	ldr	r0, [pc, #152]	@ (8002ac4 <RI_SetRegisterMotor1+0x348>)
 8002a2a:	f006 f85f 	bl	8008aec <PID_SetKDDivisorPOW2>
          break;
 8002a2e:	e6fb      	b.n	8002828 <RI_SetRegisterMotor1+0xac>
 8002a30:	f241 43d0 	movw	r3, #5328	@ 0x14d0
 8002a34:	4298      	cmp	r0, r3
 8002a36:	f000 80c2 	beq.w	8002bbe <RI_SetRegisterMotor1+0x442>
 8002a3a:	d914      	bls.n	8002a66 <RI_SetRegisterMotor1+0x2ea>
 8002a3c:	f241 5310 	movw	r3, #5392	@ 0x1510
 8002a40:	4298      	cmp	r0, r3
 8002a42:	f000 80c9 	beq.w	8002bd8 <RI_SetRegisterMotor1+0x45c>
 8002a46:	f241 5350 	movw	r3, #5456	@ 0x1550
 8002a4a:	4298      	cmp	r0, r3
 8002a4c:	d1b7      	bne.n	80029be <RI_SetRegisterMotor1+0x242>
          PID_SetKIDivisorPOW2(&PIDIdHandle_M1, regdata16);
 8002a4e:	481c      	ldr	r0, [pc, #112]	@ (8002ac0 <RI_SetRegisterMotor1+0x344>)
 8002a50:	f006 f830 	bl	8008ab4 <PID_SetKIDivisorPOW2>
          break;
 8002a54:	e6e8      	b.n	8002828 <RI_SetRegisterMotor1+0xac>
 8002a56:	f241 53d0 	movw	r3, #5584	@ 0x15d0
 8002a5a:	4298      	cmp	r0, r3
 8002a5c:	d1af      	bne.n	80029be <RI_SetRegisterMotor1+0x242>
          PID_SetKPDivisorPOW2(&PIDIqHandle_M1, regdata16);
 8002a5e:	4819      	ldr	r0, [pc, #100]	@ (8002ac4 <RI_SetRegisterMotor1+0x348>)
 8002a60:	f006 f81c 	bl	8008a9c <PID_SetKPDivisorPOW2>
          break;
 8002a64:	e6e0      	b.n	8002828 <RI_SetRegisterMotor1+0xac>
 8002a66:	f241 4350 	movw	r3, #5200	@ 0x1450
 8002a6a:	4298      	cmp	r0, r3
 8002a6c:	f000 80b8 	beq.w	8002be0 <RI_SetRegisterMotor1+0x464>
 8002a70:	f241 4390 	movw	r3, #5264	@ 0x1490
 8002a74:	4298      	cmp	r0, r3
 8002a76:	d103      	bne.n	8002a80 <RI_SetRegisterMotor1+0x304>
          PID_SetKIDivisorPOW2(&PIDSpeedHandle_M1, regdata16);
 8002a78:	4813      	ldr	r0, [pc, #76]	@ (8002ac8 <RI_SetRegisterMotor1+0x34c>)
 8002a7a:	f006 f81b 	bl	8008ab4 <PID_SetKIDivisorPOW2>
          break;
 8002a7e:	e6d3      	b.n	8002828 <RI_SetRegisterMotor1+0xac>
 8002a80:	f241 4310 	movw	r3, #5136	@ 0x1410
 8002a84:	4298      	cmp	r0, r3
 8002a86:	d19a      	bne.n	80029be <RI_SetRegisterMotor1+0x242>
          PID_SetKD(&PID_PosParamsM1, regdata16);
 8002a88:	480b      	ldr	r0, [pc, #44]	@ (8002ab8 <RI_SetRegisterMotor1+0x33c>)
 8002a8a:	b209      	sxth	r1, r1
 8002a8c:	f006 f826 	bl	8008adc <PID_SetKD>
          break;
 8002a90:	e6ca      	b.n	8002828 <RI_SetRegisterMotor1+0xac>
 8002a92:	f020 0040 	bic.w	r0, r0, #64	@ 0x40
 8002a96:	2828      	cmp	r0, #40	@ 0x28
 8002a98:	d007      	beq.n	8002aaa <RI_SetRegisterMotor1+0x32e>
 8002a9a:	2005      	movs	r0, #5
}
 8002a9c:	b004      	add	sp, #16
 8002a9e:	bd10      	pop	{r4, pc}
 8002aa0:	28a8      	cmp	r0, #168	@ 0xa8
 8002aa2:	d002      	beq.n	8002aaa <RI_SetRegisterMotor1+0x32e>
 8002aa4:	d9f5      	bls.n	8002a92 <RI_SetRegisterMotor1+0x316>
 8002aa6:	28e8      	cmp	r0, #232	@ 0xe8
 8002aa8:	d1f7      	bne.n	8002a9a <RI_SetRegisterMotor1+0x31e>
      retVal = MCP_ERROR_RO_REG;
 8002aaa:	2004      	movs	r0, #4
 8002aac:	e685      	b.n	80027ba <RI_SetRegisterMotor1+0x3e>
    *tempdestString = (int8_t)0;
 8002aae:	2300      	movs	r3, #0
 8002ab0:	f88e 3000 	strb.w	r3, [lr]
 8002ab4:	e7f9      	b.n	8002aaa <RI_SetRegisterMotor1+0x32e>
 8002ab6:	bf00      	nop
 8002ab8:	200001a4 	.word	0x200001a4
 8002abc:	20000000 	.word	0x20000000
 8002ac0:	200001d0 	.word	0x200001d0
 8002ac4:	200001fc 	.word	0x200001fc
 8002ac8:	20000228 	.word	0x20000228
 8002acc:	f5b0 7f6a 	cmp.w	r0, #936	@ 0x3a8
 8002ad0:	d030      	beq.n	8002b34 <RI_SetRegisterMotor1+0x3b8>
 8002ad2:	f5b0 6fa5 	cmp.w	r0, #1320	@ 0x528
 8002ad6:	d1e0      	bne.n	8002a9a <RI_SetRegisterMotor1+0x31e>
            retVal =  MCPA_cfgLog (&MCPA_UART_A, rawData);
 8002ad8:	484f      	ldr	r0, [pc, #316]	@ (8002c18 <RI_SetRegisterMotor1+0x49c>)
 8002ada:	f10e 0102 	add.w	r1, lr, #2
}
 8002ade:	b004      	add	sp, #16
 8002ae0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            retVal =  MCPA_cfgLog (&MCPA_UART_A, rawData);
 8002ae4:	f005 bef6 	b.w	80088d4 <MCPA_cfgLog>
        *size = 0;
 8002ae8:	2300      	movs	r3, #0
 8002aea:	8023      	strh	r3, [r4, #0]
        retVal = MCP_ERROR_BAD_RAW_FORMAT; /* This error stop the parsing of the CMD buffer */
 8002aec:	200a      	movs	r0, #10
 8002aee:	e664      	b.n	80027ba <RI_SetRegisterMotor1+0x3e>
          MCI_ExecSpeedRamp(pMCIN,((((int16_t)regdata32) * ((int16_t)SPEED_UNIT)) / (int16_t)U_RPM), 0);
 8002af0:	f9b2 3000 	ldrsh.w	r3, [r2]
 8002af4:	4949      	ldr	r1, [pc, #292]	@ (8002c1c <RI_SetRegisterMotor1+0x4a0>)
 8002af6:	484a      	ldr	r0, [pc, #296]	@ (8002c20 <RI_SetRegisterMotor1+0x4a4>)
 8002af8:	fb81 2103 	smull	r2, r1, r1, r3
 8002afc:	eba1 71e3 	sub.w	r1, r1, r3, asr #31
 8002b00:	2200      	movs	r2, #0
 8002b02:	b209      	sxth	r1, r1
 8002b04:	f7fe fb54 	bl	80011b0 <MCI_ExecSpeedRamp>
  uint8_t retVal = MCP_CMD_OK;
 8002b08:	2000      	movs	r0, #0
          break;
 8002b0a:	e69c      	b.n	8002846 <RI_SetRegisterMotor1+0xca>
          uint8_t regdata8 = *data;
 8002b0c:	7813      	ldrb	r3, [r2, #0]
          if ((uint8_t)MCM_TORQUE_MODE == regdata8)
 8002b0e:	2b04      	cmp	r3, #4
 8002b10:	d003      	beq.n	8002b1a <RI_SetRegisterMotor1+0x39e>
          if ((uint8_t)MCM_SPEED_MODE == regdata8)
 8002b12:	2b03      	cmp	r3, #3
 8002b14:	d02f      	beq.n	8002b76 <RI_SetRegisterMotor1+0x3fa>
  uint8_t retVal = MCP_CMD_OK;
 8002b16:	2000      	movs	r0, #0
 8002b18:	e65f      	b.n	80027da <RI_SetRegisterMotor1+0x5e>
            MCI_ExecTorqueRamp(pMCIN, MCI_GetTeref(pMCIN), 0);
 8002b1a:	4841      	ldr	r0, [pc, #260]	@ (8002c20 <RI_SetRegisterMotor1+0x4a4>)
 8002b1c:	f7fe fcae 	bl	800147c <MCI_GetTeref>
 8002b20:	2200      	movs	r2, #0
 8002b22:	4601      	mov	r1, r0
 8002b24:	483e      	ldr	r0, [pc, #248]	@ (8002c20 <RI_SetRegisterMotor1+0x4a4>)
 8002b26:	f7fe fb4d 	bl	80011c4 <MCI_ExecTorqueRamp>
          if ((uint8_t)MCM_SPEED_MODE == regdata8)
 8002b2a:	e7f4      	b.n	8002b16 <RI_SetRegisterMotor1+0x39a>
            retVal = MCP_ERROR_RO_REG;
 8002b2c:	2004      	movs	r0, #4
 8002b2e:	e654      	b.n	80027da <RI_SetRegisterMotor1+0x5e>
          retVal = MCP_ERROR_RO_REG;
 8002b30:	2004      	movs	r0, #4
 8002b32:	e688      	b.n	8002846 <RI_SetRegisterMotor1+0xca>
            MCI_ExecPositionCommand(pMCIN, Position.Float_Val, Duration.Float_Val);
 8002b34:	f8de 3006 	ldr.w	r3, [lr, #6]
 8002b38:	4839      	ldr	r0, [pc, #228]	@ (8002c20 <RI_SetRegisterMotor1+0x4a4>)
 8002b3a:	ee00 3a90 	vmov	s1, r3
 8002b3e:	f8de 3002 	ldr.w	r3, [lr, #2]
 8002b42:	ee00 3a10 	vmov	s0, r3
 8002b46:	f7fe fb51 	bl	80011ec <MCI_ExecPositionCommand>
            break;
 8002b4a:	e6b7      	b.n	80028bc <RI_SetRegisterMotor1+0x140>
            MCI_ExecSpeedRamp(pMCIN, (int16_t)((rpm * SPEED_UNIT) / U_RPM), duration);
 8002b4c:	f8de 1002 	ldr.w	r1, [lr, #2]
 8002b50:	4b32      	ldr	r3, [pc, #200]	@ (8002c1c <RI_SetRegisterMotor1+0x4a0>)
 8002b52:	f8be 2006 	ldrh.w	r2, [lr, #6]
 8002b56:	fb83 0301 	smull	r0, r3, r3, r1
 8002b5a:	eba3 71e1 	sub.w	r1, r3, r1, asr #31
 8002b5e:	4830      	ldr	r0, [pc, #192]	@ (8002c20 <RI_SetRegisterMotor1+0x4a4>)
 8002b60:	b209      	sxth	r1, r1
 8002b62:	f7fe fb25 	bl	80011b0 <MCI_ExecSpeedRamp>
            break;
 8002b66:	e6a9      	b.n	80028bc <RI_SetRegisterMotor1+0x140>
            currComp.q = *((int16_t *) rawData); //cstat !MISRAC2012-Rule-11.3
 8002b68:	f8de 1002 	ldr.w	r1, [lr, #2]
            MCI_SetCurrentReferences(pMCIN, currComp);
 8002b6c:	482c      	ldr	r0, [pc, #176]	@ (8002c20 <RI_SetRegisterMotor1+0x4a4>)
            currComp.q = *((int16_t *) rawData); //cstat !MISRAC2012-Rule-11.3
 8002b6e:	9103      	str	r1, [sp, #12]
            MCI_SetCurrentReferences(pMCIN, currComp);
 8002b70:	f7fe fb32 	bl	80011d8 <MCI_SetCurrentReferences>
            break;
 8002b74:	e6a2      	b.n	80028bc <RI_SetRegisterMotor1+0x140>
            MCI_ExecSpeedRamp(pMCIN, MCI_GetMecSpeedRefUnit(pMCIN), 0);
 8002b76:	482a      	ldr	r0, [pc, #168]	@ (8002c20 <RI_SetRegisterMotor1+0x4a4>)
 8002b78:	f7fe fc28 	bl	80013cc <MCI_GetMecSpeedRefUnit>
 8002b7c:	2200      	movs	r2, #0
 8002b7e:	4601      	mov	r1, r0
 8002b80:	4827      	ldr	r0, [pc, #156]	@ (8002c20 <RI_SetRegisterMotor1+0x4a4>)
 8002b82:	f7fe fb15 	bl	80011b0 <MCI_ExecSpeedRamp>
 8002b86:	e7c6      	b.n	8002b16 <RI_SetRegisterMotor1+0x39a>
          PID_SetKDDivisorPOW2(&PIDIdHandle_M1, regdata16);
 8002b88:	4826      	ldr	r0, [pc, #152]	@ (8002c24 <RI_SetRegisterMotor1+0x4a8>)
 8002b8a:	f005 ffaf 	bl	8008aec <PID_SetKDDivisorPOW2>
          break;
 8002b8e:	e64b      	b.n	8002828 <RI_SetRegisterMotor1+0xac>
          PID_SetKP(&PIDIqHandle_M1, (int16_t)regdata16);
 8002b90:	4825      	ldr	r0, [pc, #148]	@ (8002c28 <RI_SetRegisterMotor1+0x4ac>)
 8002b92:	b209      	sxth	r1, r1
 8002b94:	f005 ff72 	bl	8008a7c <PID_SetKP>
          break;
 8002b98:	e646      	b.n	8002828 <RI_SetRegisterMotor1+0xac>
          currComp = MCI_GetIqdref(pMCIN);
 8002b9a:	4821      	ldr	r0, [pc, #132]	@ (8002c20 <RI_SetRegisterMotor1+0x4a4>)
 8002b9c:	9101      	str	r1, [sp, #4]
 8002b9e:	f7fe fc43 	bl	8001428 <MCI_GetIqdref>
          currComp.q = (int16_t)regdata16;
 8002ba2:	9901      	ldr	r1, [sp, #4]
          currComp = MCI_GetIqdref(pMCIN);
 8002ba4:	9003      	str	r0, [sp, #12]
          currComp.q = (int16_t)regdata16;
 8002ba6:	f8ad 100c 	strh.w	r1, [sp, #12]
          MCI_SetCurrentReferences(pMCIN,currComp);
 8002baa:	9903      	ldr	r1, [sp, #12]
 8002bac:	481c      	ldr	r0, [pc, #112]	@ (8002c20 <RI_SetRegisterMotor1+0x4a4>)
 8002bae:	f7fe fb13 	bl	80011d8 <MCI_SetCurrentReferences>
          break;
 8002bb2:	e639      	b.n	8002828 <RI_SetRegisterMotor1+0xac>
          PID_SetKP(&PIDIdHandle_M1, (int16_t)regdata16);
 8002bb4:	481b      	ldr	r0, [pc, #108]	@ (8002c24 <RI_SetRegisterMotor1+0x4a8>)
 8002bb6:	b209      	sxth	r1, r1
 8002bb8:	f005 ff60 	bl	8008a7c <PID_SetKP>
          break;
 8002bbc:	e634      	b.n	8002828 <RI_SetRegisterMotor1+0xac>
          PID_SetKDDivisorPOW2(&PIDSpeedHandle_M1, regdata16);
 8002bbe:	481b      	ldr	r0, [pc, #108]	@ (8002c2c <RI_SetRegisterMotor1+0x4b0>)
 8002bc0:	f005 ff94 	bl	8008aec <PID_SetKDDivisorPOW2>
          break;
 8002bc4:	e630      	b.n	8002828 <RI_SetRegisterMotor1+0xac>
          PID_SetKPDivisorPOW2(&PID_PosParamsM1, regdata16);
 8002bc6:	481a      	ldr	r0, [pc, #104]	@ (8002c30 <RI_SetRegisterMotor1+0x4b4>)
 8002bc8:	f005 ff68 	bl	8008a9c <PID_SetKPDivisorPOW2>
          break;
 8002bcc:	e62c      	b.n	8002828 <RI_SetRegisterMotor1+0xac>
          PID_SetKI(&PID_PosParamsM1, regdata16);
 8002bce:	4818      	ldr	r0, [pc, #96]	@ (8002c30 <RI_SetRegisterMotor1+0x4b4>)
 8002bd0:	b209      	sxth	r1, r1
 8002bd2:	f005 ff55 	bl	8008a80 <PID_SetKI>
          break;
 8002bd6:	e627      	b.n	8002828 <RI_SetRegisterMotor1+0xac>
          PID_SetKPDivisorPOW2(&PIDIdHandle_M1, regdata16);
 8002bd8:	4812      	ldr	r0, [pc, #72]	@ (8002c24 <RI_SetRegisterMotor1+0x4a8>)
 8002bda:	f005 ff5f 	bl	8008a9c <PID_SetKPDivisorPOW2>
          break;
 8002bde:	e623      	b.n	8002828 <RI_SetRegisterMotor1+0xac>
          PID_SetKPDivisorPOW2(&PIDSpeedHandle_M1, regdata16);
 8002be0:	4812      	ldr	r0, [pc, #72]	@ (8002c2c <RI_SetRegisterMotor1+0x4b0>)
 8002be2:	f005 ff5b 	bl	8008a9c <PID_SetKPDivisorPOW2>
          break;
 8002be6:	e61f      	b.n	8002828 <RI_SetRegisterMotor1+0xac>
          PID_SetKI(&PIDIqHandle_M1, (int16_t)regdata16);
 8002be8:	480f      	ldr	r0, [pc, #60]	@ (8002c28 <RI_SetRegisterMotor1+0x4ac>)
 8002bea:	b209      	sxth	r1, r1
 8002bec:	f005 ff48 	bl	8008a80 <PID_SetKI>
          break;
 8002bf0:	e61a      	b.n	8002828 <RI_SetRegisterMotor1+0xac>
          PID_SetKD(&PIDIdHandle_M1, (int16_t)regdata16);
 8002bf2:	480c      	ldr	r0, [pc, #48]	@ (8002c24 <RI_SetRegisterMotor1+0x4a8>)
 8002bf4:	b209      	sxth	r1, r1
 8002bf6:	f005 ff71 	bl	8008adc <PID_SetKD>
          break;
 8002bfa:	e615      	b.n	8002828 <RI_SetRegisterMotor1+0xac>
          PID_SetKIDivisorPOW2(&PIDIqHandle_M1, regdata16);
 8002bfc:	480a      	ldr	r0, [pc, #40]	@ (8002c28 <RI_SetRegisterMotor1+0x4ac>)
 8002bfe:	f005 ff59 	bl	8008ab4 <PID_SetKIDivisorPOW2>
          break;
 8002c02:	e611      	b.n	8002828 <RI_SetRegisterMotor1+0xac>
          PID_SetKI(&PIDSpeedHandle_M1, (int16_t)regdata16);
 8002c04:	4809      	ldr	r0, [pc, #36]	@ (8002c2c <RI_SetRegisterMotor1+0x4b0>)
 8002c06:	b209      	sxth	r1, r1
 8002c08:	f005 ff3a 	bl	8008a80 <PID_SetKI>
          break;
 8002c0c:	e60c      	b.n	8002828 <RI_SetRegisterMotor1+0xac>
          PID_SetKDDivisorPOW2(&PID_PosParamsM1, regdata16);
 8002c0e:	4808      	ldr	r0, [pc, #32]	@ (8002c30 <RI_SetRegisterMotor1+0x4b4>)
 8002c10:	f005 ff6c 	bl	8008aec <PID_SetKDDivisorPOW2>
          break;
 8002c14:	e608      	b.n	8002828 <RI_SetRegisterMotor1+0xac>
 8002c16:	bf00      	nop
 8002c18:	200003b0 	.word	0x200003b0
 8002c1c:	2aaaaaab 	.word	0x2aaaaaab
 8002c20:	20000000 	.word	0x20000000
 8002c24:	200001d0 	.word	0x200001d0
 8002c28:	200001fc 	.word	0x200001fc
 8002c2c:	20000228 	.word	0x20000228
 8002c30:	200001a4 	.word	0x200001a4

08002c34 <RI_GetRegisterGlobal>:
uint8_t RI_GetRegisterGlobal(uint16_t regID,uint8_t typeID,uint8_t * data,uint16_t *size,int16_t freeSpace){
 8002c34:	b538      	push	{r3, r4, r5, lr}
 8002c36:	461c      	mov	r4, r3
    switch (typeID)
 8002c38:	f1a1 0308 	sub.w	r3, r1, #8
uint8_t RI_GetRegisterGlobal(uint16_t regID,uint8_t typeID,uint8_t * data,uint16_t *size,int16_t freeSpace){
 8002c3c:	f9bd c010 	ldrsh.w	ip, [sp, #16]
 8002c40:	4615      	mov	r5, r2
    switch (typeID)
 8002c42:	2b20      	cmp	r3, #32
 8002c44:	d812      	bhi.n	8002c6c <RI_GetRegisterGlobal+0x38>
 8002c46:	e8df f003 	tbb	[pc, r3]
 8002c4a:	111b      	.short	0x111b
 8002c4c:	11111111 	.word	0x11111111
 8002c50:	11271111 	.word	0x11271111
 8002c54:	11111111 	.word	0x11111111
 8002c58:	11221111 	.word	0x11221111
 8002c5c:	11111111 	.word	0x11111111
 8002c60:	11371111 	.word	0x11371111
 8002c64:	11111111 	.word	0x11111111
 8002c68:	1111      	.short	0x1111
 8002c6a:	13          	.byte	0x13
 8002c6b:	00          	.byte	0x00
 8002c6c:	2007      	movs	r0, #7
}
 8002c6e:	bd38      	pop	{r3, r4, r5, pc}
        switch (regID)
 8002c70:	2828      	cmp	r0, #40	@ 0x28
 8002c72:	d04f      	beq.n	8002d14 <RI_GetRegisterGlobal+0xe0>
        *size = (*rawSize) + 2U;
 8002c74:	882b      	ldrh	r3, [r5, #0]
 8002c76:	3302      	adds	r3, #2
            retVal = MCP_ERROR_UNKNOWN_REG;
 8002c78:	2005      	movs	r0, #5
        *size = (*rawSize) + 2U;
 8002c7a:	b29b      	uxth	r3, r3
 8002c7c:	8023      	strh	r3, [r4, #0]
}
 8002c7e:	bd38      	pop	{r3, r4, r5, pc}
        if (freeSpace > 0)
 8002c80:	f1bc 0f00 	cmp.w	ip, #0
 8002c84:	dd44      	ble.n	8002d10 <RI_GetRegisterGlobal+0xdc>
 8002c86:	2301      	movs	r3, #1
            *size= 0 ; /* */
 8002c88:	8023      	strh	r3, [r4, #0]
              retVal = MCP_ERROR_UNKNOWN_REG;
 8002c8a:	2005      	movs	r0, #5
}
 8002c8c:	bd38      	pop	{r3, r4, r5, pc}
        if (freeSpace >= 4)
 8002c8e:	f1bc 0f03 	cmp.w	ip, #3
 8002c92:	dd2b      	ble.n	8002cec <RI_GetRegisterGlobal+0xb8>
 8002c94:	2304      	movs	r3, #4
 8002c96:	e7f7      	b.n	8002c88 <RI_GetRegisterGlobal+0x54>
        if (freeSpace >= 2)
 8002c98:	f1bc 0f01 	cmp.w	ip, #1
 8002c9c:	dd26      	ble.n	8002cec <RI_GetRegisterGlobal+0xb8>
          switch (regID)
 8002c9e:	f5b0 6fd2 	cmp.w	r0, #1680	@ 0x690
 8002ca2:	d066      	beq.n	8002d72 <RI_GetRegisterGlobal+0x13e>
 8002ca4:	d824      	bhi.n	8002cf0 <RI_GetRegisterGlobal+0xbc>
 8002ca6:	f5b0 6fca 	cmp.w	r0, #1616	@ 0x650
 8002caa:	d160      	bne.n	8002d6e <RI_GetRegisterGlobal+0x13a>
              *regdata16 = (int16_t)DAC_GetChannelConfig(&DAC_Handle , DAC_CH1);
 8002cac:	4834      	ldr	r0, [pc, #208]	@ (8002d80 <RI_GetRegisterGlobal+0x14c>)
 8002cae:	2100      	movs	r1, #0
 8002cb0:	f7fd ff9a 	bl	8000be8 <DAC_GetChannelConfig>
 8002cb4:	8028      	strh	r0, [r5, #0]
              break;
 8002cb6:	e021      	b.n	8002cfc <RI_GetRegisterGlobal+0xc8>
        switch (regID)
 8002cb8:	2820      	cmp	r0, #32
 8002cba:	d035      	beq.n	8002d28 <RI_GetRegisterGlobal+0xf4>
 8002cbc:	2860      	cmp	r0, #96	@ 0x60
 8002cbe:	d121      	bne.n	8002d04 <RI_GetRegisterGlobal+0xd0>
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8002cc0:	4930      	ldr	r1, [pc, #192]	@ (8002d84 <RI_GetRegisterGlobal+0x150>)
 8002cc2:	f991 2000 	ldrsb.w	r2, [r1]
  *size= 1U ; /* /0 is the min String size */
 8002cc6:	2301      	movs	r3, #1
 8002cc8:	8023      	strh	r3, [r4, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8002cca:	b1ea      	cbz	r2, 8002d08 <RI_GetRegisterGlobal+0xd4>
 8002ccc:	fa1f fc8c 	uxth.w	ip, ip
 8002cd0:	e008      	b.n	8002ce4 <RI_GetRegisterGlobal+0xb0>
    *tempdestString = *tempsrcString;
 8002cd2:	f805 2b01 	strb.w	r2, [r5], #1
    *size = *size + 1U;
 8002cd6:	8823      	ldrh	r3, [r4, #0]
 8002cd8:	3301      	adds	r3, #1
 8002cda:	b29b      	uxth	r3, r3
 8002cdc:	8023      	strh	r3, [r4, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8002cde:	f911 2f01 	ldrsb.w	r2, [r1, #1]!
 8002ce2:	b18a      	cbz	r2, 8002d08 <RI_GetRegisterGlobal+0xd4>
 8002ce4:	4563      	cmp	r3, ip
 8002ce6:	d3f4      	bcc.n	8002cd2 <RI_GetRegisterGlobal+0x9e>
    retVal = MCP_ERROR_STRING_FORMAT;
 8002ce8:	2006      	movs	r0, #6
}
 8002cea:	bd38      	pop	{r3, r4, r5, pc}
          retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 8002cec:	2008      	movs	r0, #8
}
 8002cee:	bd38      	pop	{r3, r4, r5, pc}
 8002cf0:	f5b0 6f65 	cmp.w	r0, #3664	@ 0xe50
 8002cf4:	d002      	beq.n	8002cfc <RI_GetRegisterGlobal+0xc8>
 8002cf6:	f5b0 6f69 	cmp.w	r0, #3728	@ 0xe90
 8002cfa:	d138      	bne.n	8002d6e <RI_GetRegisterGlobal+0x13a>
    uint8_t retVal = MCP_CMD_OK;
 8002cfc:	2000      	movs	r0, #0
          *size = 2;
 8002cfe:	2302      	movs	r3, #2
 8002d00:	8023      	strh	r3, [r4, #0]
}
 8002d02:	bd38      	pop	{r3, r4, r5, pc}
 8002d04:	2300      	movs	r3, #0
 8002d06:	e7bf      	b.n	8002c88 <RI_GetRegisterGlobal+0x54>
    *tempdestString = (int8_t)0;
 8002d08:	2300      	movs	r3, #0
 8002d0a:	702b      	strb	r3, [r5, #0]
  uint8_t retVal = MCP_CMD_OK;
 8002d0c:	2000      	movs	r0, #0
}
 8002d0e:	bd38      	pop	{r3, r4, r5, pc}
          retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 8002d10:	4608      	mov	r0, r1
}
 8002d12:	bd38      	pop	{r3, r4, r5, pc}
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8002d14:	fa1f fc8c 	uxth.w	ip, ip
            *rawSize = (uint16_t)sizeof(GlobalConfig_reg_t);
 8002d18:	230a      	movs	r3, #10
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8002d1a:	f1bc 0f0b 	cmp.w	ip, #11
            *rawSize = (uint16_t)sizeof(GlobalConfig_reg_t);
 8002d1e:	802b      	strh	r3, [r5, #0]
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8002d20:	d819      	bhi.n	8002d56 <RI_GetRegisterGlobal+0x122>
 8002d22:	230c      	movs	r3, #12
              retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 8002d24:	2008      	movs	r0, #8
 8002d26:	e7a9      	b.n	8002c7c <RI_GetRegisterGlobal+0x48>
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8002d28:	4917      	ldr	r1, [pc, #92]	@ (8002d88 <RI_GetRegisterGlobal+0x154>)
 8002d2a:	f991 2000 	ldrsb.w	r2, [r1]
  *size= 1U ; /* /0 is the min String size */
 8002d2e:	2301      	movs	r3, #1
 8002d30:	8023      	strh	r3, [r4, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8002d32:	2a00      	cmp	r2, #0
 8002d34:	d0e8      	beq.n	8002d08 <RI_GetRegisterGlobal+0xd4>
 8002d36:	fa1f fc8c 	uxth.w	ip, ip
 8002d3a:	e009      	b.n	8002d50 <RI_GetRegisterGlobal+0x11c>
    *tempdestString = *tempsrcString;
 8002d3c:	f805 2b01 	strb.w	r2, [r5], #1
    *size = *size + 1U;
 8002d40:	8823      	ldrh	r3, [r4, #0]
 8002d42:	3301      	adds	r3, #1
 8002d44:	b29b      	uxth	r3, r3
 8002d46:	8023      	strh	r3, [r4, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8002d48:	f911 2f01 	ldrsb.w	r2, [r1, #1]!
 8002d4c:	2a00      	cmp	r2, #0
 8002d4e:	d0db      	beq.n	8002d08 <RI_GetRegisterGlobal+0xd4>
 8002d50:	459c      	cmp	ip, r3
 8002d52:	d8f3      	bhi.n	8002d3c <RI_GetRegisterGlobal+0x108>
 8002d54:	e7c8      	b.n	8002ce8 <RI_GetRegisterGlobal+0xb4>
              (void)memcpy(rawData, &globalConfig_reg, sizeof(GlobalConfig_reg_t));
 8002d56:	4b0d      	ldr	r3, [pc, #52]	@ (8002d8c <RI_GetRegisterGlobal+0x158>)
 8002d58:	6819      	ldr	r1, [r3, #0]
 8002d5a:	685a      	ldr	r2, [r3, #4]
 8002d5c:	891b      	ldrh	r3, [r3, #8]
 8002d5e:	816b      	strh	r3, [r5, #10]
 8002d60:	f8c5 1002 	str.w	r1, [r5, #2]
 8002d64:	f8c5 2006 	str.w	r2, [r5, #6]
 8002d68:	230c      	movs	r3, #12
    uint8_t retVal = MCP_CMD_OK;
 8002d6a:	2000      	movs	r0, #0
 8002d6c:	e786      	b.n	8002c7c <RI_GetRegisterGlobal+0x48>
 8002d6e:	2005      	movs	r0, #5
 8002d70:	e7c5      	b.n	8002cfe <RI_GetRegisterGlobal+0xca>
              *regdata16 = (int16_t)DAC_GetChannelConfig(&DAC_Handle , DAC_CH2);
 8002d72:	4803      	ldr	r0, [pc, #12]	@ (8002d80 <RI_GetRegisterGlobal+0x14c>)
 8002d74:	2101      	movs	r1, #1
 8002d76:	f7fd ff37 	bl	8000be8 <DAC_GetChannelConfig>
 8002d7a:	8028      	strh	r0, [r5, #0]
              break;
 8002d7c:	e7be      	b.n	8002cfc <RI_GetRegisterGlobal+0xc8>
 8002d7e:	bf00      	nop
 8002d80:	200004a0 	.word	0x200004a0
 8002d84:	0800a50c 	.word	0x0800a50c
 8002d88:	0800a4e4 	.word	0x0800a4e4
 8002d8c:	0800a4d8 	.word	0x0800a4d8

08002d90 <RI_GetRegisterMotor1>:
  uint8_t RI_GetRegisterMotor1(uint16_t regID,uint8_t typeID,uint8_t * data,uint16_t *size,int16_t freeSpace) {
 8002d90:	b570      	push	{r4, r5, r6, lr}
 8002d92:	b090      	sub	sp, #64	@ 0x40
 8002d94:	461d      	mov	r5, r3
    switch (typeID)
 8002d96:	f1a1 0308 	sub.w	r3, r1, #8
  uint8_t RI_GetRegisterMotor1(uint16_t regID,uint8_t typeID,uint8_t * data,uint16_t *size,int16_t freeSpace) {
 8002d9a:	f9bd c050 	ldrsh.w	ip, [sp, #80]	@ 0x50
 8002d9e:	4614      	mov	r4, r2
    switch (typeID)
 8002da0:	2b20      	cmp	r3, #32
 8002da2:	d812      	bhi.n	8002dca <RI_GetRegisterMotor1+0x3a>
 8002da4:	e8df f003 	tbb	[pc, r3]
 8002da8:	11111133 	.word	0x11111133
 8002dac:	11111111 	.word	0x11111111
 8002db0:	11111171 	.word	0x11111171
 8002db4:	11111111 	.word	0x11111111
 8002db8:	1111114c 	.word	0x1111114c
 8002dbc:	11111111 	.word	0x11111111
 8002dc0:	11111167 	.word	0x11111167
 8002dc4:	11111111 	.word	0x11111111
 8002dc8:	14          	.byte	0x14
 8002dc9:	00          	.byte	0x00
 8002dca:	2007      	movs	r0, #7
  }
 8002dcc:	b010      	add	sp, #64	@ 0x40
 8002dce:	bd70      	pop	{r4, r5, r6, pc}
        rawData++;
 8002dd0:	f5b0 7fd4 	cmp.w	r0, #424	@ 0x1a8
 8002dd4:	f104 0302 	add.w	r3, r4, #2
        switch (regID)
 8002dd8:	f000 8288 	beq.w	80032ec <RI_GetRegisterMotor1+0x55c>
 8002ddc:	f200 8086 	bhi.w	8002eec <RI_GetRegisterMotor1+0x15c>
 8002de0:	28e8      	cmp	r0, #232	@ 0xe8
 8002de2:	f000 8279 	beq.w	80032d8 <RI_GetRegisterMotor1+0x548>
 8002de6:	d872      	bhi.n	8002ece <RI_GetRegisterMotor1+0x13e>
 8002de8:	2868      	cmp	r0, #104	@ 0x68
 8002dea:	f000 8290 	beq.w	800330e <RI_GetRegisterMotor1+0x57e>
 8002dee:	28a8      	cmp	r0, #168	@ 0xa8
 8002df0:	f040 826d 	bne.w	80032ce <RI_GetRegisterMotor1+0x53e>
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8002df4:	fa1f fc8c 	uxth.w	ip, ip
            *rawSize = (uint16_t)sizeof(ApplicationConfig_reg_t);
 8002df8:	2210      	movs	r2, #16
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8002dfa:	f1bc 0f11 	cmp.w	ip, #17
            *rawSize = (uint16_t)sizeof(ApplicationConfig_reg_t);
 8002dfe:	8022      	strh	r2, [r4, #0]
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8002e00:	f200 8239 	bhi.w	8003276 <RI_GetRegisterMotor1+0x4e6>
 8002e04:	2312      	movs	r3, #18
              retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 8002e06:	2008      	movs	r0, #8
        *size = (*rawSize) + 2U;
 8002e08:	802b      	strh	r3, [r5, #0]
  }
 8002e0a:	b010      	add	sp, #64	@ 0x40
 8002e0c:	bd70      	pop	{r4, r5, r6, pc}
        if (freeSpace > 0)
 8002e0e:	f1bc 0f00 	cmp.w	ip, #0
 8002e12:	f340 823d 	ble.w	8003290 <RI_GetRegisterMotor1+0x500>
          switch (regID)
 8002e16:	f5b0 6fa9 	cmp.w	r0, #1352	@ 0x548
 8002e1a:	f000 8243 	beq.w	80032a4 <RI_GetRegisterMotor1+0x514>
 8002e1e:	f200 8094 	bhi.w	8002f4a <RI_GetRegisterMotor1+0x1ba>
 8002e22:	2848      	cmp	r0, #72	@ 0x48
 8002e24:	f000 823a 	beq.w	800329c <RI_GetRegisterMotor1+0x50c>
 8002e28:	2888      	cmp	r0, #136	@ 0x88
 8002e2a:	f040 8235 	bne.w	8003298 <RI_GetRegisterMotor1+0x508>
              *data = (uint8_t)MCI_GetControlMode(pMCIN);
 8002e2e:	48ae      	ldr	r0, [pc, #696]	@ (80030e8 <RI_GetRegisterMotor1+0x358>)
 8002e30:	f7fe fab4 	bl	800139c <MCI_GetControlMode>
 8002e34:	7020      	strb	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8002e36:	2000      	movs	r0, #0
          *size = 1;
 8002e38:	2301      	movs	r3, #1
 8002e3a:	802b      	strh	r3, [r5, #0]
  }
 8002e3c:	b010      	add	sp, #64	@ 0x40
 8002e3e:	bd70      	pop	{r4, r5, r6, pc}
        if (freeSpace >= 4)
 8002e40:	f1bc 0f03 	cmp.w	ip, #3
 8002e44:	f340 81d3 	ble.w	80031ee <RI_GetRegisterMotor1+0x45e>
          switch (regID)
 8002e48:	2898      	cmp	r0, #152	@ 0x98
 8002e4a:	f000 8277 	beq.w	800333c <RI_GetRegisterMotor1+0x5ac>
 8002e4e:	f200 81bb 	bhi.w	80031c8 <RI_GetRegisterMotor1+0x438>
 8002e52:	2818      	cmp	r0, #24
 8002e54:	f000 826d 	beq.w	8003332 <RI_GetRegisterMotor1+0x5a2>
 8002e58:	2858      	cmp	r0, #88	@ 0x58
 8002e5a:	f040 8307 	bne.w	800346c <RI_GetRegisterMotor1+0x6dc>
              *regdata32 = (((int32_t)MCI_GetAvrgMecSpeedUnit(pMCIN) * U_RPM) / SPEED_UNIT);
 8002e5e:	48a2      	ldr	r0, [pc, #648]	@ (80030e8 <RI_GetRegisterMotor1+0x358>)
 8002e60:	f7fe fab0 	bl	80013c4 <MCI_GetAvrgMecSpeedUnit>
 8002e64:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8002e68:	0040      	lsls	r0, r0, #1
 8002e6a:	6020      	str	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8002e6c:	2000      	movs	r0, #0
          *size = 4;
 8002e6e:	2304      	movs	r3, #4
 8002e70:	802b      	strh	r3, [r5, #0]
  }
 8002e72:	b010      	add	sp, #64	@ 0x40
 8002e74:	bd70      	pop	{r4, r5, r6, pc}
        switch (regID)
 8002e76:	28a0      	cmp	r0, #160	@ 0xa0
 8002e78:	f000 81d9 	beq.w	800322e <RI_GetRegisterMotor1+0x49e>
 8002e7c:	28e0      	cmp	r0, #224	@ 0xe0
 8002e7e:	f000 81b9 	beq.w	80031f4 <RI_GetRegisterMotor1+0x464>
            *size= 0 ; /* */
 8002e82:	2300      	movs	r3, #0
 8002e84:	802b      	strh	r3, [r5, #0]
            retVal = MCP_ERROR_UNKNOWN_REG;
 8002e86:	2005      	movs	r0, #5
            break;
 8002e88:	e7a0      	b.n	8002dcc <RI_GetRegisterMotor1+0x3c>
        if (freeSpace >= 2)
 8002e8a:	f1bc 0f01 	cmp.w	ip, #1
 8002e8e:	f340 81ae 	ble.w	80031ee <RI_GetRegisterMotor1+0x45e>
          switch (regID)
 8002e92:	f5b0 6f21 	cmp.w	r0, #2576	@ 0xa10
 8002e96:	f000 82e2 	beq.w	800345e <RI_GetRegisterMotor1+0x6ce>
 8002e9a:	f200 8089 	bhi.w	8002fb0 <RI_GetRegisterMotor1+0x220>
 8002e9e:	f5b0 6fba 	cmp.w	r0, #1488	@ 0x5d0
 8002ea2:	f000 82d7 	beq.w	8003454 <RI_GetRegisterMotor1+0x6c4>
 8002ea6:	d870      	bhi.n	8002f8a <RI_GetRegisterMotor1+0x1fa>
 8002ea8:	f5b0 7f04 	cmp.w	r0, #528	@ 0x210
 8002eac:	f000 82cd 	beq.w	800344a <RI_GetRegisterMotor1+0x6ba>
 8002eb0:	d95c      	bls.n	8002f6c <RI_GetRegisterMotor1+0x1dc>
 8002eb2:	f5b0 7f44 	cmp.w	r0, #784	@ 0x310
 8002eb6:	f000 82c3 	beq.w	8003440 <RI_GetRegisterMotor1+0x6b0>
 8002eba:	d94e      	bls.n	8002f5a <RI_GetRegisterMotor1+0x1ca>
 8002ebc:	f5b0 6fb2 	cmp.w	r0, #1424	@ 0x590
 8002ec0:	f040 81e8 	bne.w	8003294 <RI_GetRegisterMotor1+0x504>
              *regdataU16 = VBS_GetAvBusVoltage_V(BusVoltageSensor);
 8002ec4:	4889      	ldr	r0, [pc, #548]	@ (80030ec <RI_GetRegisterMotor1+0x35c>)
 8002ec6:	f005 fa37 	bl	8008338 <VBS_GetAvBusVoltage_V>
 8002eca:	8020      	strh	r0, [r4, #0]
              break;
 8002ecc:	e0b1      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
 8002ece:	f5b0 7f94 	cmp.w	r0, #296	@ 0x128
 8002ed2:	f040 81fc 	bne.w	80032ce <RI_GetRegisterMotor1+0x53e>
            if ((*rawSize) +2U > (uint16_t)freeSpace)
 8002ed6:	fa1f fc8c 	uxth.w	ip, ip
            *rawSize = 12;
 8002eda:	220c      	movs	r2, #12
            if ((*rawSize) +2U > (uint16_t)freeSpace)
 8002edc:	f1bc 0f0d 	cmp.w	ip, #13
            *rawSize = 12;
 8002ee0:	8022      	strh	r2, [r4, #0]
            if ((*rawSize) +2U > (uint16_t)freeSpace)
 8002ee2:	f200 81bc 	bhi.w	800325e <RI_GetRegisterMotor1+0x4ce>
 8002ee6:	230e      	movs	r3, #14
              retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 8002ee8:	2008      	movs	r0, #8
 8002eea:	e78d      	b.n	8002e08 <RI_GetRegisterMotor1+0x78>
 8002eec:	f5b0 7f5a 	cmp.w	r0, #872	@ 0x368
 8002ef0:	f000 81dc 	beq.w	80032ac <RI_GetRegisterMotor1+0x51c>
 8002ef4:	f5b0 7f6a 	cmp.w	r0, #936	@ 0x3a8
 8002ef8:	d114      	bne.n	8002f24 <RI_GetRegisterMotor1+0x194>
            *rawSize = 8;
 8002efa:	2308      	movs	r3, #8
 8002efc:	8023      	strh	r3, [r4, #0]
            Position = TC_GetMoveDuration(&PosCtrlM1);   /* Does this duration make sense ? */
 8002efe:	487c      	ldr	r0, [pc, #496]	@ (80030f0 <RI_GetRegisterMotor1+0x360>)
 8002f00:	f007 f974 	bl	800a1ec <TC_GetMoveDuration>
            Duration = TC_GetTargetPosition(&PosCtrlM1);
 8002f04:	487a      	ldr	r0, [pc, #488]	@ (80030f0 <RI_GetRegisterMotor1+0x360>)
            Position = TC_GetMoveDuration(&PosCtrlM1);   /* Does this duration make sense ? */
 8002f06:	ee10 6a10 	vmov	r6, s0
            Duration = TC_GetTargetPosition(&PosCtrlM1);
 8002f0a:	f007 f96b 	bl	800a1e4 <TC_GetTargetPosition>
        *size = (*rawSize) + 2U;
 8002f0e:	8823      	ldrh	r3, [r4, #0]
            (void)memcpy(rawData, &Position, 4);
 8002f10:	f8c4 6002 	str.w	r6, [r4, #2]
            (void)memcpy(&rawData[4], &Duration, 4);
 8002f14:	ee10 2a10 	vmov	r2, s0
        *size = (*rawSize) + 2U;
 8002f18:	3302      	adds	r3, #2
            (void)memcpy(&rawData[4], &Duration, 4);
 8002f1a:	f8c4 2006 	str.w	r2, [r4, #6]
        *size = (*rawSize) + 2U;
 8002f1e:	b29b      	uxth	r3, r3
    uint8_t retVal = MCP_CMD_OK;
 8002f20:	2000      	movs	r0, #0
 8002f22:	e771      	b.n	8002e08 <RI_GetRegisterMotor1+0x78>
 8002f24:	f5b0 7ff4 	cmp.w	r0, #488	@ 0x1e8
 8002f28:	f040 81d1 	bne.w	80032ce <RI_GetRegisterMotor1+0x53e>
            *rawSize = 4;
 8002f2c:	2304      	movs	r3, #4
 8002f2e:	8023      	strh	r3, [r4, #0]
            *torque = MCI_GetLastRampFinalTorque(pMCIN);
 8002f30:	486d      	ldr	r0, [pc, #436]	@ (80030e8 <RI_GetRegisterMotor1+0x358>)
 8002f32:	f7fe fa3b 	bl	80013ac <MCI_GetLastRampFinalTorque>
 8002f36:	8060      	strh	r0, [r4, #2]
            *duration = MCI_GetLastRampFinalDuration(pMCIN) ;
 8002f38:	486b      	ldr	r0, [pc, #428]	@ (80030e8 <RI_GetRegisterMotor1+0x358>)
 8002f3a:	f7fe fa3b 	bl	80013b4 <MCI_GetLastRampFinalDuration>
        *size = (*rawSize) + 2U;
 8002f3e:	8823      	ldrh	r3, [r4, #0]
            *duration = MCI_GetLastRampFinalDuration(pMCIN) ;
 8002f40:	80a0      	strh	r0, [r4, #4]
        *size = (*rawSize) + 2U;
 8002f42:	3302      	adds	r3, #2
 8002f44:	b29b      	uxth	r3, r3
    uint8_t retVal = MCP_CMD_OK;
 8002f46:	2000      	movs	r0, #0
            break;
 8002f48:	e75e      	b.n	8002e08 <RI_GetRegisterMotor1+0x78>
 8002f4a:	f5b0 6fb1 	cmp.w	r0, #1416	@ 0x588
 8002f4e:	f040 81a3 	bne.w	8003298 <RI_GetRegisterMotor1+0x508>
              *data = (uint8_t) TC_GetAlignmentStatus(&PosCtrlM1);
 8002f52:	4867      	ldr	r0, [pc, #412]	@ (80030f0 <RI_GetRegisterMotor1+0x360>)
 8002f54:	f007 f952 	bl	800a1fc <TC_GetAlignmentStatus>
              break;
 8002f58:	e76c      	b.n	8002e34 <RI_GetRegisterMotor1+0xa4>
 8002f5a:	f5b0 7f24 	cmp.w	r0, #656	@ 0x290
 8002f5e:	f040 810a 	bne.w	8003176 <RI_GetRegisterMotor1+0x3e6>
              *regdata16 = PID_GetKP(&PIDIdHandle_M1);
 8002f62:	4864      	ldr	r0, [pc, #400]	@ (80030f4 <RI_GetRegisterMotor1+0x364>)
 8002f64:	f005 fd8e 	bl	8008a84 <PID_GetKP>
 8002f68:	8020      	strh	r0, [r4, #0]
              break;
 8002f6a:	e062      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
 8002f6c:	f5b0 7f88 	cmp.w	r0, #272	@ 0x110
 8002f70:	f000 8227 	beq.w	80033c2 <RI_GetRegisterMotor1+0x632>
 8002f74:	f240 8111 	bls.w	800319a <RI_GetRegisterMotor1+0x40a>
 8002f78:	f5b0 7fc8 	cmp.w	r0, #400	@ 0x190
 8002f7c:	f040 8104 	bne.w	8003188 <RI_GetRegisterMotor1+0x3f8>
              *regdata16 = PID_GetKP(&PIDIqHandle_M1);
 8002f80:	485d      	ldr	r0, [pc, #372]	@ (80030f8 <RI_GetRegisterMotor1+0x368>)
 8002f82:	f005 fd7f 	bl	8008a84 <PID_GetKP>
 8002f86:	8020      	strh	r0, [r4, #0]
              break;
 8002f88:	e053      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
 8002f8a:	f5b0 6f0d 	cmp.w	r0, #2256	@ 0x8d0
 8002f8e:	f000 8252 	beq.w	8003436 <RI_GetRegisterMotor1+0x6a6>
 8002f92:	d933      	bls.n	8002ffc <RI_GetRegisterMotor1+0x26c>
 8002f94:	f5b0 6f19 	cmp.w	r0, #2448	@ 0x990
 8002f98:	f000 8246 	beq.w	8003428 <RI_GetRegisterMotor1+0x698>
 8002f9c:	d924      	bls.n	8002fe8 <RI_GetRegisterMotor1+0x258>
 8002f9e:	f5b0 6f1d 	cmp.w	r0, #2512	@ 0x9d0
 8002fa2:	f040 8177 	bne.w	8003294 <RI_GetRegisterMotor1+0x504>
              *regdata16 = MCI_GetVqd(pMCIN).q;
 8002fa6:	4850      	ldr	r0, [pc, #320]	@ (80030e8 <RI_GetRegisterMotor1+0x358>)
 8002fa8:	f7fe fa4c 	bl	8001444 <MCI_GetVqd>
 8002fac:	8020      	strh	r0, [r4, #0]
              break;
 8002fae:	e040      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
 8002fb0:	f241 43d0 	movw	r3, #5328	@ 0x14d0
 8002fb4:	4298      	cmp	r0, r3
 8002fb6:	f000 8232 	beq.w	800341e <RI_GetRegisterMotor1+0x68e>
 8002fba:	d859      	bhi.n	8003070 <RI_GetRegisterMotor1+0x2e0>
 8002fbc:	f241 3390 	movw	r3, #5008	@ 0x1390
 8002fc0:	4298      	cmp	r0, r3
 8002fc2:	f000 8227 	beq.w	8003414 <RI_GetRegisterMotor1+0x684>
 8002fc6:	d929      	bls.n	800301c <RI_GetRegisterMotor1+0x28c>
 8002fc8:	f241 4350 	movw	r3, #5200	@ 0x1450
 8002fcc:	4298      	cmp	r0, r3
 8002fce:	f000 81f3 	beq.w	80033b8 <RI_GetRegisterMotor1+0x628>
 8002fd2:	d944      	bls.n	800305e <RI_GetRegisterMotor1+0x2ce>
 8002fd4:	f241 4390 	movw	r3, #5264	@ 0x1490
 8002fd8:	4298      	cmp	r0, r3
 8002fda:	f040 815b 	bne.w	8003294 <RI_GetRegisterMotor1+0x504>
              *regdataU16 = (uint16_t)PID_GetKIDivisorPOW2(&PIDSpeedHandle_M1);
 8002fde:	4847      	ldr	r0, [pc, #284]	@ (80030fc <RI_GetRegisterMotor1+0x36c>)
 8002fe0:	f005 fd62 	bl	8008aa8 <PID_GetKIDivisorPOW2>
 8002fe4:	8020      	strh	r0, [r4, #0]
              break;
 8002fe6:	e024      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
 8002fe8:	f5b0 6f11 	cmp.w	r0, #2320	@ 0x910
 8002fec:	d156      	bne.n	800309c <RI_GetRegisterMotor1+0x30c>
              *regdata16 = MCI_GetIqd(pMCIN).d;
 8002fee:	483e      	ldr	r0, [pc, #248]	@ (80030e8 <RI_GetRegisterMotor1+0x358>)
 8002ff0:	f7fe fa0c 	bl	800140c <MCI_GetIqd>
 8002ff4:	f3c0 430f 	ubfx	r3, r0, #16, #16
 8002ff8:	8023      	strh	r3, [r4, #0]
              break;
 8002ffa:	e01a      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
 8002ffc:	f5b0 6f05 	cmp.w	r0, #2128	@ 0x850
 8003000:	f000 81d5 	beq.w	80033ae <RI_GetRegisterMotor1+0x61e>
 8003004:	d95e      	bls.n	80030c4 <RI_GetRegisterMotor1+0x334>
 8003006:	f5b0 6f09 	cmp.w	r0, #2192	@ 0x890
 800300a:	f040 8143 	bne.w	8003294 <RI_GetRegisterMotor1+0x504>
              *regdata16 = MCI_GetIalphabeta(pMCIN).beta;
 800300e:	4836      	ldr	r0, [pc, #216]	@ (80030e8 <RI_GetRegisterMotor1+0x358>)
 8003010:	f7fe f9ee 	bl	80013f0 <MCI_GetIalphabeta>
 8003014:	f3c0 430f 	ubfx	r3, r0, #16, #16
 8003018:	8023      	strh	r3, [r4, #0]
              break;
 800301a:	e00a      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
 800301c:	f5b0 6f2d 	cmp.w	r0, #2768	@ 0xad0
 8003020:	f000 81c0 	beq.w	80033a4 <RI_GetRegisterMotor1+0x614>
 8003024:	d913      	bls.n	800304e <RI_GetRegisterMotor1+0x2be>
 8003026:	f5b0 6f65 	cmp.w	r0, #3664	@ 0xe50
 800302a:	d002      	beq.n	8003032 <RI_GetRegisterMotor1+0x2a2>
 800302c:	f5b0 6f69 	cmp.w	r0, #3728	@ 0xe90
 8003030:	d104      	bne.n	800303c <RI_GetRegisterMotor1+0x2ac>
    uint8_t retVal = MCP_CMD_OK;
 8003032:	2000      	movs	r0, #0
          *size = 2;
 8003034:	2302      	movs	r3, #2
 8003036:	802b      	strh	r3, [r5, #0]
  }
 8003038:	b010      	add	sp, #64	@ 0x40
 800303a:	bd70      	pop	{r4, r5, r6, pc}
 800303c:	f5b0 6f31 	cmp.w	r0, #2832	@ 0xb10
 8003040:	f040 8128 	bne.w	8003294 <RI_GetRegisterMotor1+0x504>
              *regdata16 = SPD_GetS16Speed ((SpeednPosFdbk_Handle_t*) &ENCODER_M1); //cstat !MISRAC2012-Rule-11.3
 8003044:	482e      	ldr	r0, [pc, #184]	@ (8003100 <RI_GetRegisterMotor1+0x370>)
 8003046:	f006 fda7 	bl	8009b98 <SPD_GetS16Speed>
 800304a:	8020      	strh	r0, [r4, #0]
              break;
 800304c:	e7f1      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
 800304e:	f5b0 6f25 	cmp.w	r0, #2640	@ 0xa50
 8003052:	d12c      	bne.n	80030ae <RI_GetRegisterMotor1+0x31e>
              *regdata16 = MCI_GetValphabeta(pMCIN).alpha;
 8003054:	4824      	ldr	r0, [pc, #144]	@ (80030e8 <RI_GetRegisterMotor1+0x358>)
 8003056:	f7fe fa03 	bl	8001460 <MCI_GetValphabeta>
 800305a:	8020      	strh	r0, [r4, #0]
              break;
 800305c:	e7e9      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
 800305e:	f241 33d0 	movw	r3, #5072	@ 0x13d0
 8003062:	4298      	cmp	r0, r3
 8003064:	d136      	bne.n	80030d4 <RI_GetRegisterMotor1+0x344>
              *regdata16 = PID_GetKI( &PID_PosParamsM1);
 8003066:	4827      	ldr	r0, [pc, #156]	@ (8003104 <RI_GetRegisterMotor1+0x374>)
 8003068:	f005 fd10 	bl	8008a8c <PID_GetKI>
 800306c:	8020      	strh	r0, [r4, #0]
              break;
 800306e:	e7e0      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
 8003070:	f241 6310 	movw	r3, #5648	@ 0x1610
 8003074:	4298      	cmp	r0, r3
 8003076:	f000 81c8 	beq.w	800340a <RI_GetRegisterMotor1+0x67a>
 800307a:	d959      	bls.n	8003130 <RI_GetRegisterMotor1+0x3a0>
 800307c:	f241 63d0 	movw	r3, #5840	@ 0x16d0
 8003080:	4298      	cmp	r0, r3
 8003082:	f000 81bd 	beq.w	8003400 <RI_GetRegisterMotor1+0x670>
 8003086:	d94a      	bls.n	800311e <RI_GetRegisterMotor1+0x38e>
 8003088:	f241 7310 	movw	r3, #5904	@ 0x1710
 800308c:	4298      	cmp	r0, r3
 800308e:	f040 8101 	bne.w	8003294 <RI_GetRegisterMotor1+0x504>
              *regdataU16 = PID_GetKDDivisorPOW2(&PID_PosParamsM1);
 8003092:	481c      	ldr	r0, [pc, #112]	@ (8003104 <RI_GetRegisterMotor1+0x374>)
 8003094:	f005 fd28 	bl	8008ae8 <PID_GetKDDivisorPOW2>
 8003098:	8020      	strh	r0, [r4, #0]
              break;
 800309a:	e7ca      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
 800309c:	f5b0 6f15 	cmp.w	r0, #2384	@ 0x950
 80030a0:	f040 80f8 	bne.w	8003294 <RI_GetRegisterMotor1+0x504>
              *regdata16 = MCI_GetIqdref(pMCIN).q;
 80030a4:	4810      	ldr	r0, [pc, #64]	@ (80030e8 <RI_GetRegisterMotor1+0x358>)
 80030a6:	f7fe f9bf 	bl	8001428 <MCI_GetIqdref>
 80030aa:	8020      	strh	r0, [r4, #0]
              break;
 80030ac:	e7c1      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
 80030ae:	f5b0 6f29 	cmp.w	r0, #2704	@ 0xa90
 80030b2:	f040 80ef 	bne.w	8003294 <RI_GetRegisterMotor1+0x504>
              *regdata16 = MCI_GetValphabeta(pMCIN).beta;
 80030b6:	480c      	ldr	r0, [pc, #48]	@ (80030e8 <RI_GetRegisterMotor1+0x358>)
 80030b8:	f7fe f9d2 	bl	8001460 <MCI_GetValphabeta>
 80030bc:	f3c0 430f 	ubfx	r3, r0, #16, #16
 80030c0:	8023      	strh	r3, [r4, #0]
              break;
 80030c2:	e7b6      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
 80030c4:	f5b0 6ffa 	cmp.w	r0, #2000	@ 0x7d0
 80030c8:	d11e      	bne.n	8003108 <RI_GetRegisterMotor1+0x378>
              *regdata16 = MCI_GetIab(pMCIN).a;
 80030ca:	4807      	ldr	r0, [pc, #28]	@ (80030e8 <RI_GetRegisterMotor1+0x358>)
 80030cc:	f7fe f982 	bl	80013d4 <MCI_GetIab>
 80030d0:	8020      	strh	r0, [r4, #0]
              break;
 80030d2:	e7ae      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
 80030d4:	f241 4310 	movw	r3, #5136	@ 0x1410
 80030d8:	4298      	cmp	r0, r3
 80030da:	f040 80db 	bne.w	8003294 <RI_GetRegisterMotor1+0x504>
              *regdata16 = PID_GetKD( &PID_PosParamsM1);
 80030de:	4809      	ldr	r0, [pc, #36]	@ (8003104 <RI_GetRegisterMotor1+0x374>)
 80030e0:	f005 fcfe 	bl	8008ae0 <PID_GetKD>
 80030e4:	8020      	strh	r0, [r4, #0]
              break;
 80030e6:	e7a4      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
 80030e8:	20000000 	.word	0x20000000
 80030ec:	20000264 	.word	0x20000264
 80030f0:	20000134 	.word	0x20000134
 80030f4:	200001d0 	.word	0x200001d0
 80030f8:	200001fc 	.word	0x200001fc
 80030fc:	20000228 	.word	0x20000228
 8003100:	20000310 	.word	0x20000310
 8003104:	200001a4 	.word	0x200001a4
 8003108:	f5b0 6f01 	cmp.w	r0, #2064	@ 0x810
 800310c:	f040 80c2 	bne.w	8003294 <RI_GetRegisterMotor1+0x504>
              *regdata16 = MCI_GetIab(pMCIN).b;
 8003110:	48ae      	ldr	r0, [pc, #696]	@ (80033cc <RI_GetRegisterMotor1+0x63c>)
 8003112:	f7fe f95f 	bl	80013d4 <MCI_GetIab>
 8003116:	f3c0 430f 	ubfx	r3, r0, #16, #16
 800311a:	8023      	strh	r3, [r4, #0]
              break;
 800311c:	e789      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
 800311e:	f241 6350 	movw	r3, #5712	@ 0x1650
 8003122:	4298      	cmp	r0, r3
 8003124:	d114      	bne.n	8003150 <RI_GetRegisterMotor1+0x3c0>
              *regdataU16 = PID_GetKDDivisorPOW2(&PIDIqHandle_M1);
 8003126:	48aa      	ldr	r0, [pc, #680]	@ (80033d0 <RI_GetRegisterMotor1+0x640>)
 8003128:	f005 fcde 	bl	8008ae8 <PID_GetKDDivisorPOW2>
 800312c:	8020      	strh	r0, [r4, #0]
              break;
 800312e:	e780      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
 8003130:	f241 5390 	movw	r3, #5520	@ 0x1590
 8003134:	4298      	cmp	r0, r3
 8003136:	f000 8130 	beq.w	800339a <RI_GetRegisterMotor1+0x60a>
 800313a:	d913      	bls.n	8003164 <RI_GetRegisterMotor1+0x3d4>
 800313c:	f241 53d0 	movw	r3, #5584	@ 0x15d0
 8003140:	4298      	cmp	r0, r3
 8003142:	f040 80a7 	bne.w	8003294 <RI_GetRegisterMotor1+0x504>
              *regdataU16 = PID_GetKPDivisorPOW2(&PIDIqHandle_M1);
 8003146:	48a2      	ldr	r0, [pc, #648]	@ (80033d0 <RI_GetRegisterMotor1+0x640>)
 8003148:	f005 fca6 	bl	8008a98 <PID_GetKPDivisorPOW2>
 800314c:	8020      	strh	r0, [r4, #0]
              break;
 800314e:	e770      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
 8003150:	f241 6390 	movw	r3, #5776	@ 0x1690
 8003154:	4298      	cmp	r0, r3
 8003156:	f040 809d 	bne.w	8003294 <RI_GetRegisterMotor1+0x504>
              *regdataU16 = PID_GetKPDivisorPOW2(&PID_PosParamsM1);
 800315a:	489e      	ldr	r0, [pc, #632]	@ (80033d4 <RI_GetRegisterMotor1+0x644>)
 800315c:	f005 fc9c 	bl	8008a98 <PID_GetKPDivisorPOW2>
 8003160:	8020      	strh	r0, [r4, #0]
              break;
 8003162:	e766      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
 8003164:	f241 5310 	movw	r3, #5392	@ 0x1510
 8003168:	4298      	cmp	r0, r3
 800316a:	d11d      	bne.n	80031a8 <RI_GetRegisterMotor1+0x418>
              *regdataU16 = PID_GetKPDivisorPOW2(&PIDIdHandle_M1);
 800316c:	489a      	ldr	r0, [pc, #616]	@ (80033d8 <RI_GetRegisterMotor1+0x648>)
 800316e:	f005 fc93 	bl	8008a98 <PID_GetKPDivisorPOW2>
 8003172:	8020      	strh	r0, [r4, #0]
              break;
 8003174:	e75d      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
 8003176:	f5b0 7f34 	cmp.w	r0, #720	@ 0x2d0
 800317a:	f040 808b 	bne.w	8003294 <RI_GetRegisterMotor1+0x504>
              *regdata16 = PID_GetKI(&PIDIdHandle_M1);
 800317e:	4896      	ldr	r0, [pc, #600]	@ (80033d8 <RI_GetRegisterMotor1+0x648>)
 8003180:	f005 fc84 	bl	8008a8c <PID_GetKI>
 8003184:	8020      	strh	r0, [r4, #0]
              break;
 8003186:	e754      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
 8003188:	f5b0 7fe8 	cmp.w	r0, #464	@ 0x1d0
 800318c:	f040 8082 	bne.w	8003294 <RI_GetRegisterMotor1+0x504>
              *regdata16 = PID_GetKI(&PIDIqHandle_M1);
 8003190:	488f      	ldr	r0, [pc, #572]	@ (80033d0 <RI_GetRegisterMotor1+0x640>)
 8003192:	f005 fc7b 	bl	8008a8c <PID_GetKI>
 8003196:	8020      	strh	r0, [r4, #0]
              break;
 8003198:	e74b      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
 800319a:	2890      	cmp	r0, #144	@ 0x90
 800319c:	d10d      	bne.n	80031ba <RI_GetRegisterMotor1+0x42a>
              *regdata16 = PID_GetKP(&PIDSpeedHandle_M1);
 800319e:	488f      	ldr	r0, [pc, #572]	@ (80033dc <RI_GetRegisterMotor1+0x64c>)
 80031a0:	f005 fc70 	bl	8008a84 <PID_GetKP>
 80031a4:	8020      	strh	r0, [r4, #0]
              break;
 80031a6:	e744      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
 80031a8:	f241 5350 	movw	r3, #5456	@ 0x1550
 80031ac:	4298      	cmp	r0, r3
 80031ae:	d171      	bne.n	8003294 <RI_GetRegisterMotor1+0x504>
              *regdataU16 = PID_GetKIDivisorPOW2(&PIDIdHandle_M1);
 80031b0:	4889      	ldr	r0, [pc, #548]	@ (80033d8 <RI_GetRegisterMotor1+0x648>)
 80031b2:	f005 fc79 	bl	8008aa8 <PID_GetKIDivisorPOW2>
 80031b6:	8020      	strh	r0, [r4, #0]
              break;
 80031b8:	e73b      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
 80031ba:	28d0      	cmp	r0, #208	@ 0xd0
 80031bc:	d16a      	bne.n	8003294 <RI_GetRegisterMotor1+0x504>
              *regdata16 = PID_GetKI(&PIDSpeedHandle_M1);
 80031be:	4887      	ldr	r0, [pc, #540]	@ (80033dc <RI_GetRegisterMotor1+0x64c>)
 80031c0:	f005 fc64 	bl	8008a8c <PID_GetKI>
 80031c4:	8020      	strh	r0, [r4, #0]
              break;
 80031c6:	e734      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
 80031c8:	f640 2358 	movw	r3, #2648	@ 0xa58
 80031cc:	4298      	cmp	r0, r3
 80031ce:	f000 80a8 	beq.w	8003322 <RI_GetRegisterMotor1+0x592>
 80031d2:	f641 3358 	movw	r3, #7000	@ 0x1b58
 80031d6:	4298      	cmp	r0, r3
 80031d8:	f040 8148 	bne.w	800346c <RI_GetRegisterMotor1+0x6dc>
              ReadVal.Float_Val = PQD_GetAvrgElMotorPowerW(pMPM[M1]);
 80031dc:	4b80      	ldr	r3, [pc, #512]	@ (80033e0 <RI_GetRegisterMotor1+0x650>)
 80031de:	6818      	ldr	r0, [r3, #0]
 80031e0:	f005 fd04 	bl	8008bec <PQD_GetAvrgElMotorPowerW>
 80031e4:	ed8d 0a01 	vstr	s0, [sp, #4]
              *regdataU32 = ReadVal.U32_Val; //cstat !UNION-type-punning
 80031e8:	9b01      	ldr	r3, [sp, #4]
 80031ea:	6023      	str	r3, [r4, #0]
              break;
 80031ec:	e63e      	b.n	8002e6c <RI_GetRegisterMotor1+0xdc>
          retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 80031ee:	2008      	movs	r0, #8
  }
 80031f0:	b010      	add	sp, #64	@ 0x40
 80031f2:	bd70      	pop	{r4, r5, r6, pc}
            retVal = RI_MovString (MotorConfig_reg[motorID]->name ,charData, size, freeSpace);
 80031f4:	4b7b      	ldr	r3, [pc, #492]	@ (80033e4 <RI_GetRegisterMotor1+0x654>)
 80031f6:	681a      	ldr	r2, [r3, #0]
  *size= 1U ; /* /0 is the min String size */
 80031f8:	2301      	movs	r3, #1
 80031fa:	802b      	strh	r3, [r5, #0]
            retVal = RI_MovString (MotorConfig_reg[motorID]->name ,charData, size, freeSpace);
 80031fc:	f102 0124 	add.w	r1, r2, #36	@ 0x24
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8003200:	f992 2024 	ldrsb.w	r2, [r2, #36]	@ 0x24
 8003204:	b17a      	cbz	r2, 8003226 <RI_GetRegisterMotor1+0x496>
 8003206:	fa1f fc8c 	uxth.w	ip, ip
 800320a:	e008      	b.n	800321e <RI_GetRegisterMotor1+0x48e>
    *tempdestString = *tempsrcString;
 800320c:	f804 2b01 	strb.w	r2, [r4], #1
    *size = *size + 1U;
 8003210:	882b      	ldrh	r3, [r5, #0]
 8003212:	3301      	adds	r3, #1
 8003214:	b29b      	uxth	r3, r3
 8003216:	802b      	strh	r3, [r5, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8003218:	f911 2f01 	ldrsb.w	r2, [r1, #1]!
 800321c:	b11a      	cbz	r2, 8003226 <RI_GetRegisterMotor1+0x496>
 800321e:	459c      	cmp	ip, r3
 8003220:	d8f4      	bhi.n	800320c <RI_GetRegisterMotor1+0x47c>
    retVal = MCP_ERROR_STRING_FORMAT;
 8003222:	2006      	movs	r0, #6
 8003224:	e5d2      	b.n	8002dcc <RI_GetRegisterMotor1+0x3c>
    *tempdestString = (int8_t)0;
 8003226:	2300      	movs	r3, #0
 8003228:	7023      	strb	r3, [r4, #0]
  uint8_t retVal = MCP_CMD_OK;
 800322a:	2000      	movs	r0, #0
 800322c:	e5ce      	b.n	8002dcc <RI_GetRegisterMotor1+0x3c>
            retVal = RI_MovString (PWR_BOARD_NAME[motorID], charData, size, freeSpace);
 800322e:	4a6e      	ldr	r2, [pc, #440]	@ (80033e8 <RI_GetRegisterMotor1+0x658>)
  *size= 1U ; /* /0 is the min String size */
 8003230:	2301      	movs	r3, #1
            retVal = RI_MovString (PWR_BOARD_NAME[motorID], charData, size, freeSpace);
 8003232:	6811      	ldr	r1, [r2, #0]
  *size= 1U ; /* /0 is the min String size */
 8003234:	802b      	strh	r3, [r5, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8003236:	f991 2000 	ldrsb.w	r2, [r1]
 800323a:	2a00      	cmp	r2, #0
 800323c:	d0f3      	beq.n	8003226 <RI_GetRegisterMotor1+0x496>
 800323e:	fa1f fc8c 	uxth.w	ip, ip
 8003242:	e009      	b.n	8003258 <RI_GetRegisterMotor1+0x4c8>
    *tempdestString = *tempsrcString;
 8003244:	f804 2b01 	strb.w	r2, [r4], #1
    *size = *size + 1U;
 8003248:	882b      	ldrh	r3, [r5, #0]
 800324a:	3301      	adds	r3, #1
 800324c:	b29b      	uxth	r3, r3
 800324e:	802b      	strh	r3, [r5, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8003250:	f911 2f01 	ldrsb.w	r2, [r1, #1]!
 8003254:	2a00      	cmp	r2, #0
 8003256:	d0e6      	beq.n	8003226 <RI_GetRegisterMotor1+0x496>
 8003258:	459c      	cmp	ip, r3
 800325a:	d8f3      	bhi.n	8003244 <RI_GetRegisterMotor1+0x4b4>
 800325c:	e7e1      	b.n	8003222 <RI_GetRegisterMotor1+0x492>
              memcpy(rawData, &scaleParams_M1, sizeof(ScaleParams_t) );
 800325e:	4a63      	ldr	r2, [pc, #396]	@ (80033ec <RI_GetRegisterMotor1+0x65c>)
 8003260:	6850      	ldr	r0, [r2, #4]
 8003262:	6814      	ldr	r4, [r2, #0]
 8003264:	6891      	ldr	r1, [r2, #8]
 8003266:	68d2      	ldr	r2, [r2, #12]
 8003268:	60da      	str	r2, [r3, #12]
 800326a:	6058      	str	r0, [r3, #4]
 800326c:	601c      	str	r4, [r3, #0]
 800326e:	6099      	str	r1, [r3, #8]
    uint8_t retVal = MCP_CMD_OK;
 8003270:	2000      	movs	r0, #0
              memcpy(rawData, &scaleParams_M1, sizeof(ScaleParams_t) );
 8003272:	230e      	movs	r3, #14
 8003274:	e5c8      	b.n	8002e08 <RI_GetRegisterMotor1+0x78>
              ApplicationConfig_reg_t const *pApplicationConfig_reg = ApplicationConfig_reg[motorID];
 8003276:	4a5e      	ldr	r2, [pc, #376]	@ (80033f0 <RI_GetRegisterMotor1+0x660>)
              (void)memcpy(rawData, (const uint8_t *)pApplicationConfig_reg, sizeof(ApplicationConfig_reg_t));
 8003278:	6812      	ldr	r2, [r2, #0]
 800327a:	6850      	ldr	r0, [r2, #4]
 800327c:	6814      	ldr	r4, [r2, #0]
 800327e:	6891      	ldr	r1, [r2, #8]
 8003280:	68d2      	ldr	r2, [r2, #12]
 8003282:	60da      	str	r2, [r3, #12]
 8003284:	6058      	str	r0, [r3, #4]
 8003286:	601c      	str	r4, [r3, #0]
 8003288:	6099      	str	r1, [r3, #8]
    uint8_t retVal = MCP_CMD_OK;
 800328a:	2000      	movs	r0, #0
              (void)memcpy(rawData, (const uint8_t *)pApplicationConfig_reg, sizeof(ApplicationConfig_reg_t));
 800328c:	2312      	movs	r3, #18
 800328e:	e5bb      	b.n	8002e08 <RI_GetRegisterMotor1+0x78>
          retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 8003290:	4608      	mov	r0, r1
 8003292:	e59b      	b.n	8002dcc <RI_GetRegisterMotor1+0x3c>
 8003294:	2005      	movs	r0, #5
 8003296:	e6cd      	b.n	8003034 <RI_GetRegisterMotor1+0x2a4>
 8003298:	2005      	movs	r0, #5
 800329a:	e5cd      	b.n	8002e38 <RI_GetRegisterMotor1+0xa8>
              *data = (uint8_t)MCI_GetSTMState(pMCIN);
 800329c:	484b      	ldr	r0, [pc, #300]	@ (80033cc <RI_GetRegisterMotor1+0x63c>)
 800329e:	f7fe f823 	bl	80012e8 <MCI_GetSTMState>
              break;
 80032a2:	e5c7      	b.n	8002e34 <RI_GetRegisterMotor1+0xa4>
              *data = (uint8_t) TC_GetControlPositionStatus(&PosCtrlM1);
 80032a4:	4853      	ldr	r0, [pc, #332]	@ (80033f4 <RI_GetRegisterMotor1+0x664>)
 80032a6:	f006 ffa5 	bl	800a1f4 <TC_GetControlPositionStatus>
              break;
 80032aa:	e5c3      	b.n	8002e34 <RI_GetRegisterMotor1+0xa4>
            *rawSize = 4;
 80032ac:	2304      	movs	r3, #4
 80032ae:	8023      	strh	r3, [r4, #0]
            *iqref = (uint16_t)MCI_GetIqdref(pMCIN).q;
 80032b0:	4846      	ldr	r0, [pc, #280]	@ (80033cc <RI_GetRegisterMotor1+0x63c>)
 80032b2:	f7fe f8b9 	bl	8001428 <MCI_GetIqdref>
 80032b6:	8060      	strh	r0, [r4, #2]
            *idref = (uint16_t)MCI_GetIqdref(pMCIN).d;
 80032b8:	4844      	ldr	r0, [pc, #272]	@ (80033cc <RI_GetRegisterMotor1+0x63c>)
 80032ba:	f7fe f8b5 	bl	8001428 <MCI_GetIqdref>
        *size = (*rawSize) + 2U;
 80032be:	8823      	ldrh	r3, [r4, #0]
            *idref = (uint16_t)MCI_GetIqdref(pMCIN).d;
 80032c0:	f3c0 400f 	ubfx	r0, r0, #16, #16
        *size = (*rawSize) + 2U;
 80032c4:	3302      	adds	r3, #2
            *idref = (uint16_t)MCI_GetIqdref(pMCIN).d;
 80032c6:	80a0      	strh	r0, [r4, #4]
        *size = (*rawSize) + 2U;
 80032c8:	b29b      	uxth	r3, r3
    uint8_t retVal = MCP_CMD_OK;
 80032ca:	2000      	movs	r0, #0
            break;
 80032cc:	e59c      	b.n	8002e08 <RI_GetRegisterMotor1+0x78>
        *size = (*rawSize) + 2U;
 80032ce:	8823      	ldrh	r3, [r4, #0]
 80032d0:	3302      	adds	r3, #2
            retVal = MCP_ERROR_UNKNOWN_REG;
 80032d2:	2005      	movs	r0, #5
        *size = (*rawSize) + 2U;
 80032d4:	b29b      	uxth	r3, r3
 80032d6:	e597      	b.n	8002e08 <RI_GetRegisterMotor1+0x78>
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 80032d8:	fa1f fc8c 	uxth.w	ip, ip
            *rawSize = (uint16_t)sizeof(FOCFwConfig_reg_t);
 80032dc:	220e      	movs	r2, #14
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 80032de:	f1bc 0f0f 	cmp.w	ip, #15
            *rawSize = (uint16_t)sizeof(FOCFwConfig_reg_t);
 80032e2:	8022      	strh	r2, [r4, #0]
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 80032e4:	d84c      	bhi.n	8003380 <RI_GetRegisterMotor1+0x5f0>
 80032e6:	2310      	movs	r3, #16
              retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 80032e8:	2008      	movs	r0, #8
 80032ea:	e58d      	b.n	8002e08 <RI_GetRegisterMotor1+0x78>
            *rpm = (((int32_t)MCI_GetLastRampFinalSpeed(pMCIN) * U_RPM) / (int32_t)SPEED_UNIT);
 80032ec:	4837      	ldr	r0, [pc, #220]	@ (80033cc <RI_GetRegisterMotor1+0x63c>)
 80032ee:	f7fe f859 	bl	80013a4 <MCI_GetLastRampFinalSpeed>
 80032f2:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80032f6:	0043      	lsls	r3, r0, #1
 80032f8:	f8c4 3002 	str.w	r3, [r4, #2]
            *duration = MCI_GetLastRampFinalDuration(pMCIN);
 80032fc:	4833      	ldr	r0, [pc, #204]	@ (80033cc <RI_GetRegisterMotor1+0x63c>)
 80032fe:	f7fe f859 	bl	80013b4 <MCI_GetLastRampFinalDuration>
            *rawSize = 6;
 8003302:	2306      	movs	r3, #6
            *duration = MCI_GetLastRampFinalDuration(pMCIN);
 8003304:	80e0      	strh	r0, [r4, #6]
            *rawSize = 6;
 8003306:	8023      	strh	r3, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003308:	2000      	movs	r0, #0
            break;
 800330a:	2308      	movs	r3, #8
 800330c:	e57c      	b.n	8002e08 <RI_GetRegisterMotor1+0x78>
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 800330e:	fa1f fc8c 	uxth.w	ip, ip
            *rawSize = (uint16_t)sizeof(MotorConfig_reg_t);
 8003312:	223c      	movs	r2, #60	@ 0x3c
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8003314:	f1bc 0f3d 	cmp.w	ip, #61	@ 0x3d
            *rawSize = (uint16_t)sizeof(MotorConfig_reg_t);
 8003318:	8022      	strh	r2, [r4, #0]
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 800331a:	d817      	bhi.n	800334c <RI_GetRegisterMotor1+0x5bc>
 800331c:	233e      	movs	r3, #62	@ 0x3e
              retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 800331e:	2008      	movs	r0, #8
 8003320:	e572      	b.n	8002e08 <RI_GetRegisterMotor1+0x78>
              ReadVal.Float_Val = MCI_GetCurrentPosition(pMCIN);
 8003322:	482a      	ldr	r0, [pc, #168]	@ (80033cc <RI_GetRegisterMotor1+0x63c>)
 8003324:	f7fd ffe4 	bl	80012f0 <MCI_GetCurrentPosition>
 8003328:	ed8d 0a01 	vstr	s0, [sp, #4]
              *regdataU32 = ReadVal.U32_Val;
 800332c:	9b01      	ldr	r3, [sp, #4]
 800332e:	6023      	str	r3, [r4, #0]
              break;
 8003330:	e59c      	b.n	8002e6c <RI_GetRegisterMotor1+0xdc>
              *regdataU32 = MCI_GetFaultState(pMCIN);
 8003332:	4826      	ldr	r0, [pc, #152]	@ (80033cc <RI_GetRegisterMotor1+0x63c>)
 8003334:	f7fe f82c 	bl	8001390 <MCI_GetFaultState>
 8003338:	6020      	str	r0, [r4, #0]
              break;
 800333a:	e597      	b.n	8002e6c <RI_GetRegisterMotor1+0xdc>
              *regdata32 = (((int32_t)MCI_GetMecSpeedRefUnit(pMCIN) * U_RPM) / SPEED_UNIT);
 800333c:	4823      	ldr	r0, [pc, #140]	@ (80033cc <RI_GetRegisterMotor1+0x63c>)
 800333e:	f7fe f845 	bl	80013cc <MCI_GetMecSpeedRefUnit>
 8003342:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8003346:	0040      	lsls	r0, r0, #1
 8003348:	6020      	str	r0, [r4, #0]
              break;
 800334a:	e58f      	b.n	8002e6c <RI_GetRegisterMotor1+0xdc>
              MotorConfig_reg_t const *pMotorConfig_reg = MotorConfig_reg[motorID];
 800334c:	4a25      	ldr	r2, [pc, #148]	@ (80033e4 <RI_GetRegisterMotor1+0x654>)
              (void)memcpy(rawData, (const uint8_t *)pMotorConfig_reg, sizeof(MotorConfig_reg_t));
 800334e:	6812      	ldr	r2, [r2, #0]
 8003350:	f102 0c30 	add.w	ip, r2, #48	@ 0x30
 8003354:	6814      	ldr	r4, [r2, #0]
 8003356:	6850      	ldr	r0, [r2, #4]
 8003358:	6891      	ldr	r1, [r2, #8]
 800335a:	68d6      	ldr	r6, [r2, #12]
 800335c:	60de      	str	r6, [r3, #12]
 800335e:	3210      	adds	r2, #16
 8003360:	4562      	cmp	r2, ip
 8003362:	601c      	str	r4, [r3, #0]
 8003364:	6058      	str	r0, [r3, #4]
 8003366:	6099      	str	r1, [r3, #8]
 8003368:	f103 0310 	add.w	r3, r3, #16
 800336c:	d1f2      	bne.n	8003354 <RI_GetRegisterMotor1+0x5c4>
 800336e:	6810      	ldr	r0, [r2, #0]
 8003370:	6851      	ldr	r1, [r2, #4]
 8003372:	6892      	ldr	r2, [r2, #8]
 8003374:	609a      	str	r2, [r3, #8]
 8003376:	6018      	str	r0, [r3, #0]
 8003378:	6059      	str	r1, [r3, #4]
    uint8_t retVal = MCP_CMD_OK;
 800337a:	2000      	movs	r0, #0
              (void)memcpy(rawData, (const uint8_t *)pMotorConfig_reg, sizeof(MotorConfig_reg_t));
 800337c:	233e      	movs	r3, #62	@ 0x3e
 800337e:	e543      	b.n	8002e08 <RI_GetRegisterMotor1+0x78>
              FOCFwConfig_reg_t const *pFOCConfig_reg = FOCConfig_reg[motorID];
 8003380:	4a1d      	ldr	r2, [pc, #116]	@ (80033f8 <RI_GetRegisterMotor1+0x668>)
              (void)memcpy(rawData, (const uint8_t *)pFOCConfig_reg, sizeof(FOCFwConfig_reg_t));
 8003382:	6812      	ldr	r2, [r2, #0]
 8003384:	6810      	ldr	r0, [r2, #0]
 8003386:	6851      	ldr	r1, [r2, #4]
 8003388:	6894      	ldr	r4, [r2, #8]
 800338a:	609c      	str	r4, [r3, #8]
 800338c:	6018      	str	r0, [r3, #0]
 800338e:	6059      	str	r1, [r3, #4]
 8003390:	8992      	ldrh	r2, [r2, #12]
 8003392:	819a      	strh	r2, [r3, #12]
    uint8_t retVal = MCP_CMD_OK;
 8003394:	2000      	movs	r0, #0
              (void)memcpy(rawData, (const uint8_t *)pFOCConfig_reg, sizeof(FOCFwConfig_reg_t));
 8003396:	2310      	movs	r3, #16
 8003398:	e536      	b.n	8002e08 <RI_GetRegisterMotor1+0x78>
              *regdataU16 = PID_GetKDDivisorPOW2(&PIDIdHandle_M1);
 800339a:	480f      	ldr	r0, [pc, #60]	@ (80033d8 <RI_GetRegisterMotor1+0x648>)
 800339c:	f005 fba4 	bl	8008ae8 <PID_GetKDDivisorPOW2>
 80033a0:	8020      	strh	r0, [r4, #0]
              break;
 80033a2:	e646      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
 80033a4:	4b15      	ldr	r3, [pc, #84]	@ (80033fc <RI_GetRegisterMotor1+0x66c>)
 80033a6:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
              *regdata16 = SPD_GetElAngle ((SpeednPosFdbk_Handle_t*) &ENCODER_M1); //cstat !MISRAC2012-Rule-11.3
 80033aa:	8023      	strh	r3, [r4, #0]
              break;
 80033ac:	e641      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
              *regdata16 = MCI_GetIalphabeta(pMCIN).alpha;
 80033ae:	4807      	ldr	r0, [pc, #28]	@ (80033cc <RI_GetRegisterMotor1+0x63c>)
 80033b0:	f7fe f81e 	bl	80013f0 <MCI_GetIalphabeta>
 80033b4:	8020      	strh	r0, [r4, #0]
              break;
 80033b6:	e63c      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
              *regdataU16 = (uint16_t)PID_GetKPDivisorPOW2(&PIDSpeedHandle_M1);
 80033b8:	4808      	ldr	r0, [pc, #32]	@ (80033dc <RI_GetRegisterMotor1+0x64c>)
 80033ba:	f005 fb6d 	bl	8008a98 <PID_GetKPDivisorPOW2>
 80033be:	8020      	strh	r0, [r4, #0]
              break;
 80033c0:	e637      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
              *regdata16 = PID_GetKD(&PIDSpeedHandle_M1);
 80033c2:	4806      	ldr	r0, [pc, #24]	@ (80033dc <RI_GetRegisterMotor1+0x64c>)
 80033c4:	f005 fb8c 	bl	8008ae0 <PID_GetKD>
 80033c8:	8020      	strh	r0, [r4, #0]
              break;
 80033ca:	e632      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
 80033cc:	20000000 	.word	0x20000000
 80033d0:	200001fc 	.word	0x200001fc
 80033d4:	200001a4 	.word	0x200001a4
 80033d8:	200001d0 	.word	0x200001d0
 80033dc:	20000228 	.word	0x20000228
 80033e0:	20000030 	.word	0x20000030
 80033e4:	20000394 	.word	0x20000394
 80033e8:	2000039c 	.word	0x2000039c
 80033ec:	200003a0 	.word	0x200003a0
 80033f0:	20000390 	.word	0x20000390
 80033f4:	20000134 	.word	0x20000134
 80033f8:	20000398 	.word	0x20000398
 80033fc:	20000310 	.word	0x20000310
              *regdataU16 = PID_GetKIDivisorPOW2(&PID_PosParamsM1);
 8003400:	481b      	ldr	r0, [pc, #108]	@ (8003470 <RI_GetRegisterMotor1+0x6e0>)
 8003402:	f005 fb51 	bl	8008aa8 <PID_GetKIDivisorPOW2>
 8003406:	8020      	strh	r0, [r4, #0]
              break;
 8003408:	e613      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
              *regdataU16 = PID_GetKIDivisorPOW2(&PIDIqHandle_M1);
 800340a:	481a      	ldr	r0, [pc, #104]	@ (8003474 <RI_GetRegisterMotor1+0x6e4>)
 800340c:	f005 fb4c 	bl	8008aa8 <PID_GetKIDivisorPOW2>
 8003410:	8020      	strh	r0, [r4, #0]
              break;
 8003412:	e60e      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
              *regdata16 = PID_GetKP( &PID_PosParamsM1);
 8003414:	4816      	ldr	r0, [pc, #88]	@ (8003470 <RI_GetRegisterMotor1+0x6e0>)
 8003416:	f005 fb35 	bl	8008a84 <PID_GetKP>
 800341a:	8020      	strh	r0, [r4, #0]
              break;
 800341c:	e609      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
              *regdataU16 = PID_GetKDDivisorPOW2(&PIDSpeedHandle_M1);
 800341e:	4816      	ldr	r0, [pc, #88]	@ (8003478 <RI_GetRegisterMotor1+0x6e8>)
 8003420:	f005 fb62 	bl	8008ae8 <PID_GetKDDivisorPOW2>
 8003424:	8020      	strh	r0, [r4, #0]
              break;
 8003426:	e604      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
              *regdata16 = MCI_GetIqdref(pMCIN).d;
 8003428:	4814      	ldr	r0, [pc, #80]	@ (800347c <RI_GetRegisterMotor1+0x6ec>)
 800342a:	f7fd fffd 	bl	8001428 <MCI_GetIqdref>
 800342e:	f3c0 430f 	ubfx	r3, r0, #16, #16
 8003432:	8023      	strh	r3, [r4, #0]
              break;
 8003434:	e5fd      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
              *regdata16 = MCI_GetIqd(pMCIN).q;
 8003436:	4811      	ldr	r0, [pc, #68]	@ (800347c <RI_GetRegisterMotor1+0x6ec>)
 8003438:	f7fd ffe8 	bl	800140c <MCI_GetIqd>
 800343c:	8020      	strh	r0, [r4, #0]
              break;
 800343e:	e5f8      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
              *regdata16 = PID_GetKD(&PIDIdHandle_M1);
 8003440:	480f      	ldr	r0, [pc, #60]	@ (8003480 <RI_GetRegisterMotor1+0x6f0>)
 8003442:	f005 fb4d 	bl	8008ae0 <PID_GetKD>
 8003446:	8020      	strh	r0, [r4, #0]
              break;
 8003448:	e5f3      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
              *regdata16 = PID_GetKD(&PIDIqHandle_M1);
 800344a:	480a      	ldr	r0, [pc, #40]	@ (8003474 <RI_GetRegisterMotor1+0x6e4>)
 800344c:	f005 fb48 	bl	8008ae0 <PID_GetKD>
 8003450:	8020      	strh	r0, [r4, #0]
              break;
 8003452:	e5ee      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
              *regdata16 = NTC_GetAvTemp_C(&TempSensor_M1);
 8003454:	480b      	ldr	r0, [pc, #44]	@ (8003484 <RI_GetRegisterMotor1+0x6f4>)
 8003456:	f005 faf7 	bl	8008a48 <NTC_GetAvTemp_C>
 800345a:	8020      	strh	r0, [r4, #0]
              break;
 800345c:	e5e9      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
              *regdata16 = MCI_GetVqd(pMCIN).d;
 800345e:	4807      	ldr	r0, [pc, #28]	@ (800347c <RI_GetRegisterMotor1+0x6ec>)
 8003460:	f7fd fff0 	bl	8001444 <MCI_GetVqd>
 8003464:	f3c0 430f 	ubfx	r3, r0, #16, #16
 8003468:	8023      	strh	r3, [r4, #0]
              break;
 800346a:	e5e2      	b.n	8003032 <RI_GetRegisterMotor1+0x2a2>
 800346c:	2005      	movs	r0, #5
 800346e:	e4fe      	b.n	8002e6e <RI_GetRegisterMotor1+0xde>
 8003470:	200001a4 	.word	0x200001a4
 8003474:	200001fc 	.word	0x200001fc
 8003478:	20000228 	.word	0x20000228
 800347c:	20000000 	.word	0x20000000
 8003480:	200001d0 	.word	0x200001d0
 8003484:	20000290 	.word	0x20000290

08003488 <RI_GetIDSize>:
  return (retVal);
}

uint8_t RI_GetIDSize(uint16_t dataID)
{
  uint8_t typeID = ((uint8_t)dataID) & TYPE_MASK;
 8003488:	f000 0038 	and.w	r0, r0, #56	@ 0x38
 800348c:	3808      	subs	r0, #8
 800348e:	b2c0      	uxtb	r0, r0
 8003490:	2810      	cmp	r0, #16
 8003492:	bf9a      	itte	ls
 8003494:	4b01      	ldrls	r3, [pc, #4]	@ (800349c <RI_GetIDSize+0x14>)
 8003496:	5c18      	ldrbls	r0, [r3, r0]
 8003498:	2000      	movhi	r0, #0
      break;
    }
  }

  return (result);
}
 800349a:	4770      	bx	lr
 800349c:	0800a588 	.word	0x0800a588

080034a0 <RI_GetPtrReg>:

    MCI_Handle_t *pMCIN = &Mci[0];
    uint16_t regID = dataID & REG_MASK;
    uint8_t typeID = ((uint8_t)dataID) & TYPE_MASK;

    switch (typeID)
 80034a0:	f000 0338 	and.w	r3, r0, #56	@ 0x38
 80034a4:	2b10      	cmp	r3, #16
 80034a6:	d003      	beq.n	80034b0 <RI_GetPtrReg+0x10>
 80034a8:	4a3c      	ldr	r2, [pc, #240]	@ (800359c <RI_GetPtrReg+0xfc>)
      }

      default:
      {
        *dataPtr = &nullData16;
        retVal = MCP_ERROR_UNKNOWN_REG;
 80034aa:	2005      	movs	r0, #5
            *dataPtr = &(pMCIN->pFOCVars->Iab.a);
 80034ac:	600a      	str	r2, [r1, #0]
    }
#ifdef NULL_PTR_CHECK_REG_INT
  }
#endif
  return (retVal);
}
 80034ae:	4770      	bx	lr
    uint16_t regID = dataID & REG_MASK;
 80034b0:	f020 0007 	bic.w	r0, r0, #7
 80034b4:	f5b0 6f19 	cmp.w	r0, #2448	@ 0x990
 80034b8:	b283      	uxth	r3, r0
 80034ba:	d051      	beq.n	8003560 <RI_GetPtrReg+0xc0>
 80034bc:	d80e      	bhi.n	80034dc <RI_GetPtrReg+0x3c>
 80034be:	f5b3 6f09 	cmp.w	r3, #2192	@ 0x890
 80034c2:	d052      	beq.n	800356a <RI_GetPtrReg+0xca>
 80034c4:	d923      	bls.n	800350e <RI_GetPtrReg+0x6e>
 80034c6:	f5b3 6f11 	cmp.w	r3, #2320	@ 0x910
 80034ca:	d053      	beq.n	8003574 <RI_GetPtrReg+0xd4>
 80034cc:	f5b3 6f15 	cmp.w	r3, #2384	@ 0x950
 80034d0:	d115      	bne.n	80034fe <RI_GetPtrReg+0x5e>
            *dataPtr = &(pMCIN->pFOCVars->Iqdref.q);
 80034d2:	4b33      	ldr	r3, [pc, #204]	@ (80035a0 <RI_GetPtrReg+0x100>)
 80034d4:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 80034d6:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Iqdref.q);
 80034d8:	3210      	adds	r2, #16
            break;
 80034da:	e7e7      	b.n	80034ac <RI_GetPtrReg+0xc>
 80034dc:	f5b3 6f29 	cmp.w	r3, #2704	@ 0xa90
 80034e0:	d04d      	beq.n	800357e <RI_GetPtrReg+0xde>
 80034e2:	d91f      	bls.n	8003524 <RI_GetPtrReg+0x84>
 80034e4:	f5b3 6f2d 	cmp.w	r3, #2768	@ 0xad0
 80034e8:	d036      	beq.n	8003558 <RI_GetPtrReg+0xb8>
 80034ea:	482c      	ldr	r0, [pc, #176]	@ (800359c <RI_GetPtrReg+0xfc>)
 80034ec:	4a2d      	ldr	r2, [pc, #180]	@ (80035a4 <RI_GetPtrReg+0x104>)
 80034ee:	f5b3 6f31 	cmp.w	r3, #2832	@ 0xb10
 80034f2:	bf16      	itet	ne
 80034f4:	4602      	movne	r2, r0
 80034f6:	2000      	moveq	r0, #0
 80034f8:	2005      	movne	r0, #5
            *dataPtr = &(pMCIN->pFOCVars->Iab.a);
 80034fa:	600a      	str	r2, [r1, #0]
}
 80034fc:	4770      	bx	lr
 80034fe:	f5b3 6f0d 	cmp.w	r3, #2256	@ 0x8d0
 8003502:	d1d1      	bne.n	80034a8 <RI_GetPtrReg+0x8>
            *dataPtr = &(pMCIN->pFOCVars->Iqd.q);
 8003504:	4b26      	ldr	r3, [pc, #152]	@ (80035a0 <RI_GetPtrReg+0x100>)
 8003506:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 8003508:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Iqd.q);
 800350a:	320c      	adds	r2, #12
            break;
 800350c:	e7ce      	b.n	80034ac <RI_GetPtrReg+0xc>
 800350e:	f5b3 6f01 	cmp.w	r3, #2064	@ 0x810
 8003512:	d039      	beq.n	8003588 <RI_GetPtrReg+0xe8>
 8003514:	f5b3 6f05 	cmp.w	r3, #2128	@ 0x850
 8003518:	d10f      	bne.n	800353a <RI_GetPtrReg+0x9a>
            *dataPtr = &(pMCIN->pFOCVars->Ialphabeta.alpha);
 800351a:	4b21      	ldr	r3, [pc, #132]	@ (80035a0 <RI_GetPtrReg+0x100>)
 800351c:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 800351e:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Ialphabeta.alpha);
 8003520:	3204      	adds	r2, #4
            break;
 8003522:	e7c3      	b.n	80034ac <RI_GetPtrReg+0xc>
 8003524:	f5b3 6f21 	cmp.w	r3, #2576	@ 0xa10
 8003528:	d033      	beq.n	8003592 <RI_GetPtrReg+0xf2>
 800352a:	f5b3 6f25 	cmp.w	r3, #2640	@ 0xa50
 800352e:	d10b      	bne.n	8003548 <RI_GetPtrReg+0xa8>
            *dataPtr = &(pMCIN->pFOCVars->Valphabeta.alpha);
 8003530:	4b1b      	ldr	r3, [pc, #108]	@ (80035a0 <RI_GetPtrReg+0x100>)
 8003532:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 8003534:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Valphabeta.alpha);
 8003536:	321a      	adds	r2, #26
            break;
 8003538:	e7b8      	b.n	80034ac <RI_GetPtrReg+0xc>
 800353a:	f5b3 6ffa 	cmp.w	r3, #2000	@ 0x7d0
 800353e:	d1b3      	bne.n	80034a8 <RI_GetPtrReg+0x8>
            *dataPtr = &(pMCIN->pFOCVars->Iab.a);
 8003540:	4b17      	ldr	r3, [pc, #92]	@ (80035a0 <RI_GetPtrReg+0x100>)
  uint8_t retVal = MCP_CMD_OK;
 8003542:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Iab.a);
 8003544:	685a      	ldr	r2, [r3, #4]
             break;
 8003546:	e7b1      	b.n	80034ac <RI_GetPtrReg+0xc>
 8003548:	f5b3 6f1d 	cmp.w	r3, #2512	@ 0x9d0
 800354c:	d1ac      	bne.n	80034a8 <RI_GetPtrReg+0x8>
            *dataPtr = &(pMCIN->pFOCVars->Vqd.q);
 800354e:	4b14      	ldr	r3, [pc, #80]	@ (80035a0 <RI_GetPtrReg+0x100>)
 8003550:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 8003552:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Vqd.q);
 8003554:	3216      	adds	r2, #22
            break;
 8003556:	e7a9      	b.n	80034ac <RI_GetPtrReg+0xc>
 8003558:	4a13      	ldr	r2, [pc, #76]	@ (80035a8 <RI_GetPtrReg+0x108>)
            *dataPtr = &(pMCIN->pFOCVars->Iab.a);
 800355a:	600a      	str	r2, [r1, #0]
  uint8_t retVal = MCP_CMD_OK;
 800355c:	2000      	movs	r0, #0
}
 800355e:	4770      	bx	lr
            *dataPtr = &(pMCIN->pFOCVars->Iqdref.d);
 8003560:	4b0f      	ldr	r3, [pc, #60]	@ (80035a0 <RI_GetPtrReg+0x100>)
 8003562:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 8003564:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Iqdref.d);
 8003566:	3212      	adds	r2, #18
            break;
 8003568:	e7a0      	b.n	80034ac <RI_GetPtrReg+0xc>
            *dataPtr = &(pMCIN->pFOCVars->Ialphabeta.beta);
 800356a:	4b0d      	ldr	r3, [pc, #52]	@ (80035a0 <RI_GetPtrReg+0x100>)
 800356c:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 800356e:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Ialphabeta.beta);
 8003570:	3206      	adds	r2, #6
            break;
 8003572:	e79b      	b.n	80034ac <RI_GetPtrReg+0xc>
            *dataPtr = &(pMCIN->pFOCVars->Iqd.d);
 8003574:	4b0a      	ldr	r3, [pc, #40]	@ (80035a0 <RI_GetPtrReg+0x100>)
 8003576:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 8003578:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Iqd.d);
 800357a:	320e      	adds	r2, #14
            break;
 800357c:	e796      	b.n	80034ac <RI_GetPtrReg+0xc>
            *dataPtr = &(pMCIN->pFOCVars->Valphabeta.beta);
 800357e:	4b08      	ldr	r3, [pc, #32]	@ (80035a0 <RI_GetPtrReg+0x100>)
 8003580:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 8003582:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Valphabeta.beta);
 8003584:	321c      	adds	r2, #28
            break;
 8003586:	e791      	b.n	80034ac <RI_GetPtrReg+0xc>
            *dataPtr = &(pMCIN->pFOCVars->Iab.b);
 8003588:	4b05      	ldr	r3, [pc, #20]	@ (80035a0 <RI_GetPtrReg+0x100>)
 800358a:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 800358c:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Iab.b);
 800358e:	3202      	adds	r2, #2
            break;
 8003590:	e78c      	b.n	80034ac <RI_GetPtrReg+0xc>
            *dataPtr = &(pMCIN->pFOCVars->Vqd.d);
 8003592:	4b03      	ldr	r3, [pc, #12]	@ (80035a0 <RI_GetPtrReg+0x100>)
 8003594:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 8003596:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Vqd.d);
 8003598:	3218      	adds	r2, #24
            break;
 800359a:	e787      	b.n	80034ac <RI_GetPtrReg+0xc>
 800359c:	20001928 	.word	0x20001928
 80035a0:	20000000 	.word	0x20000000
 80035a4:	2000031c 	.word	0x2000031c
 80035a8:	20000314 	.word	0x20000314

080035ac <RCM_RegisterRegConv>:
  * @param  regConv Pointer to the regular conversion parameters.
  *         Contains ADC, Channel and sampling time to be used.
  *
  */
void RCM_RegisterRegConv(RegConv_t *regConv)
{
 80035ac:	b470      	push	{r4, r5, r6}

    /* Parse the array to be sure that same
     * conversion does not already exist*/
    while (i < RCM_MAX_CONV)
    {
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 80035ae:	4e79      	ldr	r6, [pc, #484]	@ (8003794 <RCM_RegisterRegConv+0x1e8>)
 80035b0:	6832      	ldr	r2, [r6, #0]
 80035b2:	2a00      	cmp	r2, #0
 80035b4:	d035      	beq.n	8003622 <RCM_RegisterRegConv+0x76>
        /* Nothing to do */
      }
      /* Ticket 64042 : If RCM_handle_array [i] is null access to data member will cause Memory Fault */
      if (RCM_handle_array [i] != 0)
      {
        if ((RCM_handle_array [i]->channel == regConv->channel)
 80035b6:	7901      	ldrb	r1, [r0, #4]
 80035b8:	7913      	ldrb	r3, [r2, #4]
 80035ba:	4299      	cmp	r1, r3
 80035bc:	d01f      	beq.n	80035fe <RCM_RegisterRegConv+0x52>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 80035be:	6874      	ldr	r4, [r6, #4]
 80035c0:	2c00      	cmp	r4, #0
 80035c2:	f000 80c5 	beq.w	8003750 <RCM_RegisterRegConv+0x1a4>
        if ((RCM_handle_array [i]->channel == regConv->channel)
 80035c6:	7923      	ldrb	r3, [r4, #4]
 80035c8:	428b      	cmp	r3, r1
  uint8_t handle = 255U;
 80035ca:	f04f 02ff 	mov.w	r2, #255	@ 0xff
        if ((RCM_handle_array [i]->channel == regConv->channel)
 80035ce:	d030      	beq.n	8003632 <RCM_RegisterRegConv+0x86>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 80035d0:	68b5      	ldr	r5, [r6, #8]
 80035d2:	2d00      	cmp	r5, #0
 80035d4:	f000 80a2 	beq.w	800371c <RCM_RegisterRegConv+0x170>
        if ((RCM_handle_array [i]->channel == regConv->channel)
 80035d8:	792b      	ldrb	r3, [r5, #4]
 80035da:	428b      	cmp	r3, r1
 80035dc:	d02f      	beq.n	800363e <RCM_RegisterRegConv+0x92>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 80035de:	68f4      	ldr	r4, [r6, #12]
 80035e0:	2c00      	cmp	r4, #0
 80035e2:	f000 80a7 	beq.w	8003734 <RCM_RegisterRegConv+0x188>
        if ((RCM_handle_array [i]->channel == regConv->channel)
 80035e6:	7923      	ldrb	r3, [r4, #4]
 80035e8:	428b      	cmp	r3, r1
 80035ea:	f000 80aa 	beq.w	8003742 <RCM_RegisterRegConv+0x196>
      {
        /* Nothing to do */
      }
      i++;
    }
    if (handle < RCM_MAX_CONV)
 80035ee:	2a03      	cmp	r2, #3
 80035f0:	bf88      	it	hi
 80035f2:	22ff      	movhi	r2, #255	@ 0xff
 80035f4:	f240 80b6 	bls.w	8003764 <RCM_RegisterRegConv+0x1b8>
    }
#ifdef NULL_PTR_CHECK_REG_CON_MNG
  }
#endif
  regConv->convHandle = handle;
}
 80035f8:	bc70      	pop	{r4, r5, r6}
  regConv->convHandle = handle;
 80035fa:	7302      	strb	r2, [r0, #12]
}
 80035fc:	4770      	bx	lr
         && (RCM_handle_array [i]->regADC == regConv->regADC))
 80035fe:	6803      	ldr	r3, [r0, #0]
 8003600:	6812      	ldr	r2, [r2, #0]
 8003602:	4293      	cmp	r3, r2
 8003604:	d021      	beq.n	800364a <RCM_RegisterRegConv+0x9e>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 8003606:	6874      	ldr	r4, [r6, #4]
 8003608:	2c00      	cmp	r4, #0
 800360a:	d1dc      	bne.n	80035c6 <RCM_RegisterRegConv+0x1a>
 800360c:	68b5      	ldr	r5, [r6, #8]
      i++;
 800360e:	2201      	movs	r2, #1
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 8003610:	2d00      	cmp	r5, #0
 8003612:	d1e1      	bne.n	80035d8 <RCM_RegisterRegConv+0x2c>
 8003614:	68f4      	ldr	r4, [r6, #12]
 8003616:	b1dc      	cbz	r4, 8003650 <RCM_RegisterRegConv+0xa4>
        if ((RCM_handle_array [i]->channel == regConv->channel)
 8003618:	7925      	ldrb	r5, [r4, #4]
 800361a:	7901      	ldrb	r1, [r0, #4]
 800361c:	428d      	cmp	r5, r1
 800361e:	d115      	bne.n	800364c <RCM_RegisterRegConv+0xa0>
 8003620:	e090      	b.n	8003744 <RCM_RegisterRegConv+0x198>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 8003622:	6874      	ldr	r4, [r6, #4]
 8003624:	2c00      	cmp	r4, #0
 8003626:	f000 80a5 	beq.w	8003774 <RCM_RegisterRegConv+0x1c8>
 800362a:	7901      	ldrb	r1, [r0, #4]
        if ((RCM_handle_array [i]->channel == regConv->channel)
 800362c:	7923      	ldrb	r3, [r4, #4]
 800362e:	428b      	cmp	r3, r1
 8003630:	d1ce      	bne.n	80035d0 <RCM_RegisterRegConv+0x24>
         && (RCM_handle_array [i]->regADC == regConv->regADC))
 8003632:	6824      	ldr	r4, [r4, #0]
 8003634:	6803      	ldr	r3, [r0, #0]
 8003636:	42a3      	cmp	r3, r4
 8003638:	d1ca      	bne.n	80035d0 <RCM_RegisterRegConv+0x24>
      i++;
 800363a:	2201      	movs	r2, #1
 800363c:	e006      	b.n	800364c <RCM_RegisterRegConv+0xa0>
         && (RCM_handle_array [i]->regADC == regConv->regADC))
 800363e:	682c      	ldr	r4, [r5, #0]
 8003640:	6803      	ldr	r3, [r0, #0]
 8003642:	429c      	cmp	r4, r3
 8003644:	d1cb      	bne.n	80035de <RCM_RegisterRegConv+0x32>
      i++;
 8003646:	2202      	movs	r2, #2
 8003648:	e000      	b.n	800364c <RCM_RegisterRegConv+0xa0>
    uint8_t i = 0;
 800364a:	2200      	movs	r2, #0
    while (i < RCM_MAX_CONV)
 800364c:	f04f 0400 	mov.w	r4, #0
 8003650:	f362 0407 	bfi	r4, r2, #0, #8
 8003654:	f362 240f 	bfi	r4, r2, #8, #8
      RCM_CB_array [handle].cb = NULL; /* If a previous callback was attached, it is cleared */
 8003658:	4d4f      	ldr	r5, [pc, #316]	@ (8003798 <RCM_RegisterRegConv+0x1ec>)
  * @param  ADCx ADC instance
  * @retval 0: ADC is disabled, 1: ADC is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsEnabled(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 800365a:	6899      	ldr	r1, [r3, #8]
      RCM_handle_array [handle] = regConv;
 800365c:	f846 0022 	str.w	r0, [r6, r2, lsl #2]
      RCM_CB_array [handle].cb = NULL; /* If a previous callback was attached, it is cleared */
 8003660:	2600      	movs	r6, #0
 8003662:	f845 6032 	str.w	r6, [r5, r2, lsl #3]
 8003666:	07ce      	lsls	r6, r1, #31
 8003668:	d422      	bmi.n	80036b0 <RCM_RegisterRegConv+0x104>
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableIT_EOC(ADC_TypeDef *ADCx)
{
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_EOC);
 800366a:	6859      	ldr	r1, [r3, #4]
 800366c:	f021 0104 	bic.w	r1, r1, #4
 8003670:	6059      	str	r1, [r3, #4]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_EOC);
 8003672:	2104      	movs	r1, #4
 8003674:	6019      	str	r1, [r3, #0]
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableIT_JEOC(ADC_TypeDef *ADCx)
{
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_JEOC);
 8003676:	6859      	ldr	r1, [r3, #4]
 8003678:	f021 0120 	bic.w	r1, r1, #32
 800367c:	6059      	str	r1, [r3, #4]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_JEOC);
 800367e:	2120      	movs	r1, #32
 8003680:	6019      	str	r1, [r3, #0]
  MODIFY_REG(ADCx->CR,
 8003682:	6899      	ldr	r1, [r3, #8]
 8003684:	f021 4140 	bic.w	r1, r1, #3221225472	@ 0xc0000000
 8003688:	f021 013f 	bic.w	r1, r1, #63	@ 0x3f
 800368c:	f041 4100 	orr.w	r1, r1, #2147483648	@ 0x80000000
 8003690:	6099      	str	r1, [r3, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADCAL) == (ADC_CR_ADCAL)) ? 1UL : 0UL);
 8003692:	6899      	ldr	r1, [r3, #8]
 8003694:	2900      	cmp	r1, #0
 8003696:	dbfc      	blt.n	8003692 <RCM_RegisterRegConv+0xe6>
  return ((READ_BIT(ADCx->ISR, LL_ADC_FLAG_ADRDY) == (LL_ADC_FLAG_ADRDY)) ? 1UL : 0UL);
 8003698:	6819      	ldr	r1, [r3, #0]
 800369a:	07cd      	lsls	r5, r1, #31
 800369c:	d408      	bmi.n	80036b0 <RCM_RegisterRegConv+0x104>
  MODIFY_REG(ADCx->CR,
 800369e:	4d3f      	ldr	r5, [pc, #252]	@ (800379c <RCM_RegisterRegConv+0x1f0>)
 80036a0:	6899      	ldr	r1, [r3, #8]
 80036a2:	4029      	ands	r1, r5
 80036a4:	f041 0101 	orr.w	r1, r1, #1
 80036a8:	6099      	str	r1, [r3, #8]
  return ((READ_BIT(ADCx->ISR, LL_ADC_FLAG_ADRDY) == (LL_ADC_FLAG_ADRDY)) ? 1UL : 0UL);
 80036aa:	6819      	ldr	r1, [r3, #0]
 80036ac:	07c9      	lsls	r1, r1, #31
 80036ae:	d5f7      	bpl.n	80036a0 <RCM_RegisterRegConv+0xf4>
      RCM_NoInj_array[handle].enable = false;
 80036b0:	4d3b      	ldr	r5, [pc, #236]	@ (80037a0 <RCM_RegisterRegConv+0x1f4>)
 80036b2:	eb02 0142 	add.w	r1, r2, r2, lsl #1
 80036b6:	0049      	lsls	r1, r1, #1
      RCM_NoInj_array[handle].prev = handle;
 80036b8:	1d2e      	adds	r6, r5, #4
 80036ba:	5274      	strh	r4, [r6, r1]
      RCM_NoInj_array[handle].enable = false;
 80036bc:	2400      	movs	r4, #0
 80036be:	546c      	strb	r4, [r5, r1]
  MODIFY_REG(ADCx->SQR1, ADC_SQR1_L, SequencerNbRanks);
 80036c0:	6b1c      	ldr	r4, [r3, #48]	@ 0x30
 80036c2:	f024 040f 	bic.w	r4, r4, #15
 80036c6:	631c      	str	r4, [r3, #48]	@ 0x30
      LL_ADC_SetChannelSamplingTime(regConv->regADC, __LL_ADC_DECIMAL_NB_TO_CHANNEL(regConv->channel),
 80036c8:	f890 c004 	ldrb.w	ip, [r0, #4]
 80036cc:	2101      	movs	r1, #1
 80036ce:	fa01 f10c 	lsl.w	r1, r1, ip
 80036d2:	f1bc 0f09 	cmp.w	ip, #9
 80036d6:	ea41 618c 	orr.w	r1, r1, ip, lsl #26
 80036da:	eb0c 044c 	add.w	r4, ip, ip, lsl #1
 80036de:	d817      	bhi.n	8003710 <RCM_RegisterRegConv+0x164>
 80036e0:	ea41 5104 	orr.w	r1, r1, r4, lsl #20
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1,
 80036e4:	0dcc      	lsrs	r4, r1, #23
 80036e6:	f004 0404 	and.w	r4, r4, #4
 80036ea:	f103 0c14 	add.w	ip, r3, #20
  MODIFY_REG(*preg,
 80036ee:	6885      	ldr	r5, [r0, #8]
 80036f0:	f85c 3004 	ldr.w	r3, [ip, r4]
 80036f4:	f3c1 5104 	ubfx	r1, r1, #20, #5
 80036f8:	2607      	movs	r6, #7
 80036fa:	408d      	lsls	r5, r1
 80036fc:	fa06 f101 	lsl.w	r1, r6, r1
 8003700:	ea23 0101 	bic.w	r1, r3, r1
 8003704:	4329      	orrs	r1, r5
 8003706:	f84c 1004 	str.w	r1, [ip, r4]
}
 800370a:	bc70      	pop	{r4, r5, r6}
  regConv->convHandle = handle;
 800370c:	7302      	strb	r2, [r0, #12]
}
 800370e:	4770      	bx	lr
      LL_ADC_SetChannelSamplingTime(regConv->regADC, __LL_ADC_DECIMAL_NB_TO_CHANNEL(regConv->channel),
 8003710:	3c1e      	subs	r4, #30
 8003712:	ea41 5104 	orr.w	r1, r1, r4, lsl #20
 8003716:	f041 7100 	orr.w	r1, r1, #33554432	@ 0x2000000
 800371a:	e7e3      	b.n	80036e4 <RCM_RegisterRegConv+0x138>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 800371c:	2a04      	cmp	r2, #4
 800371e:	d92e      	bls.n	800377e <RCM_RegisterRegConv+0x1d2>
 8003720:	68f2      	ldr	r2, [r6, #12]
 8003722:	b372      	cbz	r2, 8003782 <RCM_RegisterRegConv+0x1d6>
        if ((RCM_handle_array [i]->channel == regConv->channel)
 8003724:	7913      	ldrb	r3, [r2, #4]
 8003726:	4299      	cmp	r1, r3
         && (RCM_handle_array [i]->regADC == regConv->regADC))
 8003728:	6803      	ldr	r3, [r0, #0]
        if ((RCM_handle_array [i]->channel == regConv->channel)
 800372a:	d02f      	beq.n	800378c <RCM_RegisterRegConv+0x1e0>
      i++;
 800372c:	2202      	movs	r2, #2
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 800372e:	f240 2402 	movw	r4, #514	@ 0x202
 8003732:	e791      	b.n	8003658 <RCM_RegisterRegConv+0xac>
 8003734:	2a04      	cmp	r2, #4
 8003736:	d917      	bls.n	8003768 <RCM_RegisterRegConv+0x1bc>
 8003738:	6803      	ldr	r3, [r0, #0]
 800373a:	2203      	movs	r2, #3
 800373c:	f240 3403 	movw	r4, #771	@ 0x303
 8003740:	e78a      	b.n	8003658 <RCM_RegisterRegConv+0xac>
 8003742:	6803      	ldr	r3, [r0, #0]
         && (RCM_handle_array [i]->regADC == regConv->regADC))
 8003744:	6821      	ldr	r1, [r4, #0]
 8003746:	4299      	cmp	r1, r3
 8003748:	f47f af51 	bne.w	80035ee <RCM_RegisterRegConv+0x42>
      i++;
 800374c:	2203      	movs	r2, #3
 800374e:	e77d      	b.n	800364c <RCM_RegisterRegConv+0xa0>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 8003750:	68b5      	ldr	r5, [r6, #8]
      i++;
 8003752:	2201      	movs	r2, #1
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 8003754:	2d00      	cmp	r5, #0
 8003756:	f47f af3f 	bne.w	80035d8 <RCM_RegisterRegConv+0x2c>
 800375a:	68f4      	ldr	r4, [r6, #12]
 800375c:	b124      	cbz	r4, 8003768 <RCM_RegisterRegConv+0x1bc>
        if ((RCM_handle_array [i]->channel == regConv->channel)
 800375e:	7923      	ldrb	r3, [r4, #4]
 8003760:	428b      	cmp	r3, r1
 8003762:	d0ee      	beq.n	8003742 <RCM_RegisterRegConv+0x196>
 8003764:	f04f 0400 	mov.w	r4, #0
 8003768:	f362 0407 	bfi	r4, r2, #0, #8
 800376c:	6803      	ldr	r3, [r0, #0]
 800376e:	f362 240f 	bfi	r4, r2, #8, #8
 8003772:	e771      	b.n	8003658 <RCM_RegisterRegConv+0xac>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 8003774:	68b5      	ldr	r5, [r6, #8]
 8003776:	b135      	cbz	r5, 8003786 <RCM_RegisterRegConv+0x1da>
 8003778:	7901      	ldrb	r1, [r0, #4]
    uint8_t i = 0;
 800377a:	4622      	mov	r2, r4
 800377c:	e72c      	b.n	80035d8 <RCM_RegisterRegConv+0x2c>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 800377e:	462a      	mov	r2, r5
 8003780:	e7eb      	b.n	800375a <RCM_RegisterRegConv+0x1ae>
 8003782:	6803      	ldr	r3, [r0, #0]
 8003784:	e7d2      	b.n	800372c <RCM_RegisterRegConv+0x180>
 8003786:	6803      	ldr	r3, [r0, #0]
    uint8_t i = 0;
 8003788:	462a      	mov	r2, r5
 800378a:	e743      	b.n	8003614 <RCM_RegisterRegConv+0x68>
         && (RCM_handle_array [i]->regADC == regConv->regADC))
 800378c:	6812      	ldr	r2, [r2, #0]
 800378e:	4293      	cmp	r3, r2
 8003790:	d0dc      	beq.n	800374c <RCM_RegisterRegConv+0x1a0>
 8003792:	e7cb      	b.n	800372c <RCM_RegisterRegConv+0x180>
 8003794:	20001970 	.word	0x20001970
 8003798:	20001950 	.word	0x20001950
 800379c:	7fffffc0 	.word	0x7fffffc0
 80037a0:	20001938 	.word	0x20001938

080037a4 <RCM_ExecRegularConv>:
 * Otherwise, the latest stored conversion result will be returned.
 *
 * NOTE: This function is not part of the public API and users should not call it.
 */
uint16_t RCM_ExecRegularConv (RegConv_t *regConv)
{
 80037a4:	b510      	push	{r4, lr}
  uint16_t retVal;
  uint8_t handle = regConv->convHandle;
 80037a6:	7b03      	ldrb	r3, [r0, #12]
  uint8_t formerNext;
  uint8_t i=0;
  uint8_t LastEnable = RCM_MAX_CONV;

  if (false == RCM_NoInj_array [handle].enable)
 80037a8:	4a5e      	ldr	r2, [pc, #376]	@ (8003924 <RCM_ExecRegularConv+0x180>)
 80037aa:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 80037ae:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80037b2:	f812 0011 	ldrb.w	r0, [r2, r1, lsl #1]
 80037b6:	2800      	cmp	r0, #0
 80037b8:	d139      	bne.n	800382e <RCM_ExecRegularConv+0x8a>
  {
    /* Find position in the list */
    while (i < RCM_MAX_CONV)
    {
      if (true == RCM_NoInj_array [i].enable)
 80037ba:	7811      	ldrb	r1, [r2, #0]
 80037bc:	b991      	cbnz	r1, 80037e4 <RCM_ExecRegularConv+0x40>
  uint8_t LastEnable = RCM_MAX_CONV;
 80037be:	2004      	movs	r0, #4
      if (true == RCM_NoInj_array [i].enable)
 80037c0:	7991      	ldrb	r1, [r2, #6]
 80037c2:	2900      	cmp	r1, #0
 80037c4:	d175      	bne.n	80038b2 <RCM_ExecRegularConv+0x10e>
 80037c6:	7b11      	ldrb	r1, [r2, #12]
 80037c8:	2900      	cmp	r1, #0
 80037ca:	d177      	bne.n	80038bc <RCM_ExecRegularConv+0x118>
 80037cc:	7c91      	ldrb	r1, [r2, #18]
 80037ce:	2900      	cmp	r1, #0
 80037d0:	f000 809a 	beq.w	8003908 <RCM_ExecRegularConv+0x164>
      {
        if (RCM_NoInj_array[i].next > handle)
 80037d4:	7dd1      	ldrb	r1, [r2, #23]
 80037d6:	4299      	cmp	r1, r3
 80037d8:	f240 80a0 	bls.w	800391c <RCM_ExecRegularConv+0x178>
 80037dc:	f04f 0e03 	mov.w	lr, #3
      if (true == RCM_NoInj_array [i].enable)
 80037e0:	4670      	mov	r0, lr
 80037e2:	e003      	b.n	80037ec <RCM_ExecRegularConv+0x48>
        if (RCM_NoInj_array[i].next > handle)
 80037e4:	7951      	ldrb	r1, [r2, #5]
 80037e6:	428b      	cmp	r3, r1
 80037e8:	d2ea      	bcs.n	80037c0 <RCM_ExecRegularConv+0x1c>
  uint8_t i=0;
 80037ea:	4686      	mov	lr, r0
        /* We found a previous reg conv to link with */
        {
          formerNext = RCM_NoInj_array [i].next;
          RCM_NoInj_array[handle].next = formerNext;
 80037ec:	eb0c 0403 	add.w	r4, ip, r3
 80037f0:	eb02 0444 	add.w	r4, r2, r4, lsl #1
          RCM_NoInj_array[handle].prev = i;
          RCM_NoInj_array[i].next = handle;
 80037f4:	eb00 0040 	add.w	r0, r0, r0, lsl #1
          RCM_NoInj_array[handle].next = formerNext;
 80037f8:	7161      	strb	r1, [r4, #5]
          RCM_NoInj_array[formerNext].prev = handle;
 80037fa:	eb01 0141 	add.w	r1, r1, r1, lsl #1
          RCM_NoInj_array[handle].prev = i;
 80037fe:	f884 e004 	strb.w	lr, [r4, #4]
          RCM_NoInj_array[formerNext].prev = handle;
 8003802:	eb02 0141 	add.w	r1, r2, r1, lsl #1
      }
    }
    /* The handle is now linked with others, we can set the enable flag */
    RCM_NoInj_array[handle].enable = true;
    RCM_NoInj_array[handle].status = notvalid;
    if (RCM_NoInj_array[RCM_currentHandle].status != ongoing)
 8003806:	4c48      	ldr	r4, [pc, #288]	@ (8003928 <RCM_ExecRegularConv+0x184>)
          RCM_NoInj_array[formerNext].prev = handle;
 8003808:	710b      	strb	r3, [r1, #4]
          RCM_NoInj_array[i].next = handle;
 800380a:	eb02 0040 	add.w	r0, r2, r0, lsl #1
    if (RCM_NoInj_array[RCM_currentHandle].status != ongoing)
 800380e:	7821      	ldrb	r1, [r4, #0]
          RCM_NoInj_array[i].next = handle;
 8003810:	7143      	strb	r3, [r0, #5]
    RCM_NoInj_array[handle].enable = true;
 8003812:	eb0c 0003 	add.w	r0, ip, r3
 8003816:	f04f 0e01 	mov.w	lr, #1
    if (RCM_NoInj_array[RCM_currentHandle].status != ongoing)
 800381a:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    RCM_NoInj_array[handle].enable = true;
 800381e:	f822 e010 	strh.w	lr, [r2, r0, lsl #1]
    if (RCM_NoInj_array[RCM_currentHandle].status != ongoing)
 8003822:	eb02 0141 	add.w	r1, r2, r1, lsl #1
 8003826:	7849      	ldrb	r1, [r1, #1]
 8003828:	4571      	cmp	r1, lr
    {/* Select the new conversion to be the next scheduled only if a conversion is not ongoing */
      RCM_currentHandle = handle;
 800382a:	bf18      	it	ne
 800382c:	7023      	strbne	r3, [r4, #0]
  }
  else
  {
    /* Nothing to do the current handle is already scheduled */
  }
  if (false == PWM_Handle_M1.ADCRegularLocked)
 800382e:	493f      	ldr	r1, [pc, #252]	@ (800392c <RCM_ExecRegularConv+0x188>)
 8003830:	f891 10a0 	ldrb.w	r1, [r1, #160]	@ 0xa0
 8003834:	2900      	cmp	r1, #0
 8003836:	d137      	bne.n	80038a8 <RCM_ExecRegularConv+0x104>
  /* The ADC is free to be used asynchronously */
  {
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[handle]->regADC,
 8003838:	493d      	ldr	r1, [pc, #244]	@ (8003930 <RCM_ExecRegularConv+0x18c>)
 800383a:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
                                 LL_ADC_REG_RANK_1,
                                 __LL_ADC_DECIMAL_NB_TO_CHANNEL(RCM_handle_array[handle]->channel));
 800383e:	790c      	ldrb	r4, [r1, #4]
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[handle]->regADC,
 8003840:	6808      	ldr	r0, [r1, #0]
                                 __LL_ADC_DECIMAL_NB_TO_CHANNEL(RCM_handle_array[handle]->channel));
 8003842:	2101      	movs	r1, #1
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[handle]->regADC,
 8003844:	2c09      	cmp	r4, #9
                                 __LL_ADC_DECIMAL_NB_TO_CHANNEL(RCM_handle_array[handle]->channel));
 8003846:	eb04 0e44 	add.w	lr, r4, r4, lsl #1
 800384a:	fa01 f104 	lsl.w	r1, r1, r4
 800384e:	ea41 6184 	orr.w	r1, r1, r4, lsl #26
 8003852:	bf84      	itt	hi
 8003854:	f1ae 0e1e 	subhi.w	lr, lr, #30
 8003858:	ea41 510e 	orrhi.w	r1, r1, lr, lsl #20
  MODIFY_REG(*preg,
 800385c:	6b04      	ldr	r4, [r0, #48]	@ 0x30
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[handle]->regADC,
 800385e:	bf94      	ite	ls
 8003860:	ea41 510e 	orrls.w	r1, r1, lr, lsl #20
 8003864:	f041 7100 	orrhi.w	r1, r1, #33554432	@ 0x2000000
 8003868:	0d09      	lsrs	r1, r1, #20
 800386a:	f401 61f8 	and.w	r1, r1, #1984	@ 0x7c0
 800386e:	f424 64f8 	bic.w	r4, r4, #1984	@ 0x7c0
 8003872:	4321      	orrs	r1, r4
 8003874:	6301      	str	r1, [r0, #48]	@ 0x30
* param  ADCx ADC instance
* retval Value between Min_Data=0x0000 and Max_Data=0xFFF0
*/
__STATIC_INLINE uint16_t LL_ADC_REG_ReadConversionData12L(const ADC_TypeDef *ADCx)
{
  return (uint16_t)(READ_REG(ADCx->DR) & 0x0000FFF0UL);
 8003876:	6c01      	ldr	r1, [r0, #64]	@ 0x40
  MODIFY_REG(ADCx->CR,
 8003878:	6881      	ldr	r1, [r0, #8]
 800387a:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 800387e:	f021 013f 	bic.w	r1, r1, #63	@ 0x3f
 8003882:	f041 0104 	orr.w	r1, r1, #4
 8003886:	6081      	str	r1, [r0, #8]
  return ((READ_BIT(ADCx->ISR, ADC_ISR_EOC) == (ADC_ISR_EOC)) ? 1UL : 0UL);
 8003888:	6801      	ldr	r1, [r0, #0]
 800388a:	0749      	lsls	r1, r1, #29
 800388c:	d5fc      	bpl.n	8003888 <RCM_ExecRegularConv+0xe4>
 800388e:	6c00      	ldr	r0, [r0, #64]	@ 0x40
    {
      /* Nothing to do */
    }

    /* Read the "Regular" conversion (Not related to current sampling) */
    RCM_NoInj_array[handle].value = LL_ADC_REG_ReadConversionData12L(RCM_handle_array[handle]->regADC);
 8003890:	eb0c 0103 	add.w	r1, ip, r3
 8003894:	eb02 0141 	add.w	r1, r2, r1, lsl #1
 8003898:	f020 000f 	bic.w	r0, r0, #15
 800389c:	8048      	strh	r0, [r1, #2]
    RCM_currentHandle = RCM_NoInj_array[handle].next;
 800389e:	4822      	ldr	r0, [pc, #136]	@ (8003928 <RCM_ExecRegularConv+0x184>)
 80038a0:	794c      	ldrb	r4, [r1, #5]
 80038a2:	7004      	strb	r4, [r0, #0]
    RCM_NoInj_array[handle].status = valid;
 80038a4:	2002      	movs	r0, #2
 80038a6:	7048      	strb	r0, [r1, #1]
  }
  else
  {
    /* Nothing to do */
  }
  retVal = RCM_NoInj_array[handle].value;
 80038a8:	449c      	add	ip, r3
 80038aa:	eb02 024c 	add.w	r2, r2, ip, lsl #1
  return (retVal);
}
 80038ae:	8850      	ldrh	r0, [r2, #2]
 80038b0:	bd10      	pop	{r4, pc}
        if (RCM_NoInj_array[i].next > handle)
 80038b2:	7ad1      	ldrb	r1, [r2, #11]
 80038b4:	428b      	cmp	r3, r1
 80038b6:	d31d      	bcc.n	80038f4 <RCM_ExecRegularConv+0x150>
      if (true == RCM_NoInj_array [i].enable)
 80038b8:	7b11      	ldrb	r1, [r2, #12]
 80038ba:	b1f9      	cbz	r1, 80038fc <RCM_ExecRegularConv+0x158>
        if (RCM_NoInj_array[i].next > handle)
 80038bc:	7c51      	ldrb	r1, [r2, #17]
 80038be:	4299      	cmp	r1, r3
 80038c0:	d828      	bhi.n	8003914 <RCM_ExecRegularConv+0x170>
      if (true == RCM_NoInj_array [i].enable)
 80038c2:	7c91      	ldrb	r1, [r2, #18]
 80038c4:	2900      	cmp	r1, #0
 80038c6:	d185      	bne.n	80037d4 <RCM_ExecRegularConv+0x30>
 80038c8:	2102      	movs	r1, #2
         formerNext = RCM_NoInj_array[LastEnable].next;
 80038ca:	4608      	mov	r0, r1
 80038cc:	eb00 0040 	add.w	r0, r0, r0, lsl #1
         RCM_NoInj_array[handle].next = formerNext;
 80038d0:	eb0c 0403 	add.w	r4, ip, r3
 80038d4:	eb02 0444 	add.w	r4, r2, r4, lsl #1
         formerNext = RCM_NoInj_array[LastEnable].next;
 80038d8:	eb02 0040 	add.w	r0, r2, r0, lsl #1
         RCM_NoInj_array[handle].prev = LastEnable;
 80038dc:	7121      	strb	r1, [r4, #4]
         formerNext = RCM_NoInj_array[LastEnable].next;
 80038de:	7941      	ldrb	r1, [r0, #5]
         RCM_NoInj_array[handle].next = formerNext;
 80038e0:	7161      	strb	r1, [r4, #5]
         RCM_NoInj_array[formerNext].prev = handle;
 80038e2:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 80038e6:	eb02 0141 	add.w	r1, r2, r1, lsl #1
    if (RCM_NoInj_array[RCM_currentHandle].status != ongoing)
 80038ea:	4c0f      	ldr	r4, [pc, #60]	@ (8003928 <RCM_ExecRegularConv+0x184>)
         RCM_NoInj_array[formerNext].prev = handle;
 80038ec:	710b      	strb	r3, [r1, #4]
         RCM_NoInj_array[LastEnable].next = handle;
 80038ee:	7143      	strb	r3, [r0, #5]
    if (RCM_NoInj_array[RCM_currentHandle].status != ongoing)
 80038f0:	7821      	ldrb	r1, [r4, #0]
 80038f2:	e78e      	b.n	8003812 <RCM_ExecRegularConv+0x6e>
        if (RCM_NoInj_array[i].next > handle)
 80038f4:	f04f 0e01 	mov.w	lr, #1
      if (true == RCM_NoInj_array [i].enable)
 80038f8:	4670      	mov	r0, lr
 80038fa:	e777      	b.n	80037ec <RCM_ExecRegularConv+0x48>
 80038fc:	7c91      	ldrb	r1, [r2, #18]
 80038fe:	2900      	cmp	r1, #0
 8003900:	f47f af68 	bne.w	80037d4 <RCM_ExecRegularConv+0x30>
 8003904:	2101      	movs	r1, #1
 8003906:	e7e0      	b.n	80038ca <RCM_ExecRegularConv+0x126>
       if (LastEnable != RCM_MAX_CONV )
 8003908:	2800      	cmp	r0, #0
 800390a:	d0de      	beq.n	80038ca <RCM_ExecRegularConv+0x126>
         RCM_currentHandle = handle;
 800390c:	4c06      	ldr	r4, [pc, #24]	@ (8003928 <RCM_ExecRegularConv+0x184>)
 800390e:	4619      	mov	r1, r3
 8003910:	7023      	strb	r3, [r4, #0]
    while (i < RCM_MAX_CONV)
 8003912:	e77e      	b.n	8003812 <RCM_ExecRegularConv+0x6e>
        if (RCM_NoInj_array[i].next > handle)
 8003914:	f04f 0e02 	mov.w	lr, #2
      if (true == RCM_NoInj_array [i].enable)
 8003918:	4670      	mov	r0, lr
 800391a:	e767      	b.n	80037ec <RCM_ExecRegularConv+0x48>
 800391c:	2003      	movs	r0, #3
 800391e:	4601      	mov	r1, r0
 8003920:	e7d4      	b.n	80038cc <RCM_ExecRegularConv+0x128>
 8003922:	bf00      	nop
 8003924:	20001938 	.word	0x20001938
 8003928:	20001934 	.word	0x20001934
 800392c:	2000005c 	.word	0x2000005c
 8003930:	20001970 	.word	0x20001970

08003934 <RCM_ExecUserConv>:
 * NOTE: This function is not part of the public API and users should not call it.
 */
void RCM_ExecUserConv()
{
  uint8_t handle;
  if (RCM_UserConvHandle != NULL)
 8003934:	4b14      	ldr	r3, [pc, #80]	@ (8003988 <RCM_ExecUserConv+0x54>)
{
 8003936:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (RCM_UserConvHandle != NULL)
 800393a:	681c      	ldr	r4, [r3, #0]
 800393c:	b124      	cbz	r4, 8003948 <RCM_ExecUserConv+0x14>
  {
    handle = RCM_UserConvHandle->convHandle;
    if (RCM_USERCONV_REQUESTED == RCM_UserConvState)
 800393e:	4d13      	ldr	r5, [pc, #76]	@ (800398c <RCM_ExecUserConv+0x58>)
    handle = RCM_UserConvHandle->convHandle;
 8003940:	7b26      	ldrb	r6, [r4, #12]
    if (RCM_USERCONV_REQUESTED == RCM_UserConvState)
 8003942:	782b      	ldrb	r3, [r5, #0]
 8003944:	2b01      	cmp	r3, #1
 8003946:	d001      	beq.n	800394c <RCM_ExecUserConv+0x18>
  }
  else
  {
     /* Nothing to do */
  }
}
 8003948:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      RCM_UserConvValue = RCM_ExecRegularConv(RCM_UserConvHandle);
 800394c:	4620      	mov	r0, r4
 800394e:	f7ff ff29 	bl	80037a4 <RCM_ExecRegularConv>
 8003952:	4b0f      	ldr	r3, [pc, #60]	@ (8003990 <RCM_ExecUserConv+0x5c>)
 8003954:	8018      	strh	r0, [r3, #0]
      if (RCM_NoInj_array [handle].status != notvalid)
 8003956:	4b0f      	ldr	r3, [pc, #60]	@ (8003994 <RCM_ExecUserConv+0x60>)
 8003958:	eb06 0246 	add.w	r2, r6, r6, lsl #1
 800395c:	eb03 0342 	add.w	r3, r3, r2, lsl #1
      RCM_UserConvValue = RCM_ExecRegularConv(RCM_UserConvHandle);
 8003960:	4601      	mov	r1, r0
      if (RCM_NoInj_array [handle].status != notvalid)
 8003962:	785b      	ldrb	r3, [r3, #1]
 8003964:	b10b      	cbz	r3, 800396a <RCM_ExecUserConv+0x36>
        RCM_UserConvState = RCM_USERCONV_EOC;
 8003966:	2302      	movs	r3, #2
 8003968:	702b      	strb	r3, [r5, #0]
      if (RCM_CB_array[handle].cb != NULL)
 800396a:	4b0b      	ldr	r3, [pc, #44]	@ (8003998 <RCM_ExecUserConv+0x64>)
 800396c:	f853 7036 	ldr.w	r7, [r3, r6, lsl #3]
 8003970:	2f00      	cmp	r7, #0
 8003972:	d0e9      	beq.n	8003948 <RCM_ExecUserConv+0x14>
        RCM_CB_array[handle].cb(RCM_UserConvHandle, RCM_UserConvValue,
 8003974:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
 8003978:	4620      	mov	r0, r4
 800397a:	685a      	ldr	r2, [r3, #4]
        RCM_UserConvState = RCM_USERCONV_IDLE;
 800397c:	2300      	movs	r3, #0
 800397e:	702b      	strb	r3, [r5, #0]
        RCM_CB_array[handle].cb(RCM_UserConvHandle, RCM_UserConvValue,
 8003980:	463b      	mov	r3, r7
}
 8003982:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        RCM_CB_array[handle].cb(RCM_UserConvHandle, RCM_UserConvValue,
 8003986:	4718      	bx	r3
 8003988:	2000192c 	.word	0x2000192c
 800398c:	20001930 	.word	0x20001930
 8003990:	20001932 	.word	0x20001932
 8003994:	20001938 	.word	0x20001938
 8003998:	20001950 	.word	0x20001950

0800399c <RCM_ExecNextConv>:
 *
 * NOTE: This function is not part of the public API and users should not call it.
 */
void RCM_ExecNextConv(void)
{
  if (true == RCM_NoInj_array [RCM_currentHandle].enable)
 800399c:	4b1e      	ldr	r3, [pc, #120]	@ (8003a18 <RCM_ExecNextConv+0x7c>)
 800399e:	491f      	ldr	r1, [pc, #124]	@ (8003a1c <RCM_ExecNextConv+0x80>)
 80039a0:	781a      	ldrb	r2, [r3, #0]
 80039a2:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 80039a6:	f811 3013 	ldrb.w	r3, [r1, r3, lsl #1]
 80039aa:	b3a3      	cbz	r3, 8003a16 <RCM_ExecNextConv+0x7a>
    /* When this function is called, the ADC conversions triggered by External
       event for current reading has been completed.
       ADC is therefore ready to be started because already stopped */

    /* Clear EOC */
    LL_ADC_ClearFlag_EOC(RCM_handle_array[RCM_currentHandle]->regADC);
 80039ac:	4b1c      	ldr	r3, [pc, #112]	@ (8003a20 <RCM_ExecNextConv+0x84>)
{
 80039ae:	b510      	push	{r4, lr}
    LL_ADC_ClearFlag_EOC(RCM_handle_array[RCM_currentHandle]->regADC);
 80039b0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80039b4:	6818      	ldr	r0, [r3, #0]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_EOC);
 80039b6:	2404      	movs	r4, #4
 80039b8:	6004      	str	r4, [r0, #0]
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[RCM_currentHandle]->regADC,
                                 LL_ADC_REG_RANK_1,
                                 __LL_ADC_DECIMAL_NB_TO_CHANNEL(RCM_handle_array[RCM_currentHandle]->channel));
 80039ba:	f893 c004 	ldrb.w	ip, [r3, #4]
 80039be:	2301      	movs	r3, #1
 80039c0:	eb0c 044c 	add.w	r4, ip, ip, lsl #1
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[RCM_currentHandle]->regADC,
 80039c4:	f1bc 0f09 	cmp.w	ip, #9
                                 __LL_ADC_DECIMAL_NB_TO_CHANNEL(RCM_handle_array[RCM_currentHandle]->channel));
 80039c8:	fa03 f30c 	lsl.w	r3, r3, ip
 80039cc:	ea43 638c 	orr.w	r3, r3, ip, lsl #26
 80039d0:	bf84      	itt	hi
 80039d2:	3c1e      	subhi	r4, #30
 80039d4:	ea43 5304 	orrhi.w	r3, r3, r4, lsl #20
 80039d8:	ea4f 0e42 	mov.w	lr, r2, lsl #1
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[RCM_currentHandle]->regADC,
 80039dc:	bf98      	it	ls
 80039de:	ea43 5304 	orrls.w	r3, r3, r4, lsl #20

    (void)LL_ADC_REG_ReadConversionData12L(RCM_handle_array[RCM_currentHandle]->regADC);

    /* Start ADC for regular conversion */
    LL_ADC_REG_StartConversion(RCM_handle_array[RCM_currentHandle]->regADC);
    RCM_NoInj_array[RCM_currentHandle].status = ongoing;
 80039e2:	4496      	add	lr, r2
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[RCM_currentHandle]->regADC,
 80039e4:	bf88      	it	hi
 80039e6:	f043 7300 	orrhi.w	r3, r3, #33554432	@ 0x2000000
  MODIFY_REG(*preg,
 80039ea:	6b02      	ldr	r2, [r0, #48]	@ 0x30
 80039ec:	0d1b      	lsrs	r3, r3, #20
 80039ee:	f403 63f8 	and.w	r3, r3, #1984	@ 0x7c0
 80039f2:	f422 62f8 	bic.w	r2, r2, #1984	@ 0x7c0
 80039f6:	4313      	orrs	r3, r2
 80039f8:	6303      	str	r3, [r0, #48]	@ 0x30
 80039fa:	6c03      	ldr	r3, [r0, #64]	@ 0x40
  MODIFY_REG(ADCx->CR,
 80039fc:	6883      	ldr	r3, [r0, #8]
 80039fe:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
    RCM_NoInj_array[RCM_currentHandle].status = ongoing;
 8003a02:	eb01 014e 	add.w	r1, r1, lr, lsl #1
 8003a06:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
 8003a0a:	2401      	movs	r4, #1
 8003a0c:	f043 0304 	orr.w	r3, r3, #4
 8003a10:	6083      	str	r3, [r0, #8]
 8003a12:	704c      	strb	r4, [r1, #1]
  }
  else
  {
    /* Nothing to do, conversion not enabled have already notvalid status */
  }
}
 8003a14:	bd10      	pop	{r4, pc}
 8003a16:	4770      	bx	lr
 8003a18:	20001934 	.word	0x20001934
 8003a1c:	20001938 	.word	0x20001938
 8003a20:	20001970 	.word	0x20001970

08003a24 <RCM_ReadOngoingConv>:
 * and user conversion.
 *
 * NOTE: This function is not part of the public API and users should not call it.
 */
void RCM_ReadOngoingConv(void)
{
 8003a24:	b430      	push	{r4, r5}
  uint32_t result;
  RCM_status_t status;

  if (true == RCM_NoInj_array [RCM_currentHandle].enable)
 8003a26:	4812      	ldr	r0, [pc, #72]	@ (8003a70 <RCM_ReadOngoingConv+0x4c>)
 8003a28:	4a12      	ldr	r2, [pc, #72]	@ (8003a74 <RCM_ReadOngoingConv+0x50>)
 8003a2a:	7803      	ldrb	r3, [r0, #0]
 8003a2c:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 8003a30:	f812 4011 	ldrb.w	r4, [r2, r1, lsl #1]
 8003a34:	eb02 0141 	add.w	r1, r2, r1, lsl #1
 8003a38:	b16c      	cbz	r4, 8003a56 <RCM_ReadOngoingConv+0x32>
  {
    status = RCM_NoInj_array[RCM_currentHandle].status;
    result = LL_ADC_IsActiveFlag_EOC(RCM_handle_array[RCM_currentHandle]->regADC);
 8003a3a:	4c0f      	ldr	r4, [pc, #60]	@ (8003a78 <RCM_ReadOngoingConv+0x54>)
 8003a3c:	f854 4023 	ldr.w	r4, [r4, r3, lsl #2]
 8003a40:	6824      	ldr	r4, [r4, #0]
  return ((READ_BIT(ADCx->ISR, ADC_ISR_EOC) == (ADC_ISR_EOC)) ? 1UL : 0UL);
 8003a42:	6825      	ldr	r5, [r4, #0]
 8003a44:	076d      	lsls	r5, r5, #29
 8003a46:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8003a4a:	d406      	bmi.n	8003a5a <RCM_ReadOngoingConv+0x36>
      RCM_NoInj_array[RCM_currentHandle].status = valid;
      /* Restore back DMA configuration */
    }

    /* Prepare next conversion */
    RCM_currentHandle = RCM_NoInj_array [RCM_currentHandle].next;
 8003a4c:	449c      	add	ip, r3
 8003a4e:	eb02 024c 	add.w	r2, r2, ip, lsl #1
 8003a52:	7953      	ldrb	r3, [r2, #5]
 8003a54:	7003      	strb	r3, [r0, #0]
    }
    else
    {
      /* Nothing to do */
    }
}
 8003a56:	bc30      	pop	{r4, r5}
 8003a58:	4770      	bx	lr
    if (( valid == status ) || ( notvalid == status ) || ( 0U == result ))
 8003a5a:	784d      	ldrb	r5, [r1, #1]
 8003a5c:	f015 0ffd 	tst.w	r5, #253	@ 0xfd
 8003a60:	d0f4      	beq.n	8003a4c <RCM_ReadOngoingConv+0x28>
 8003a62:	6c24      	ldr	r4, [r4, #64]	@ 0x40
 8003a64:	f024 040f 	bic.w	r4, r4, #15
                    = LL_ADC_REG_ReadConversionData12L(RCM_handle_array[RCM_currentHandle]->regADC);
 8003a68:	804c      	strh	r4, [r1, #2]
      RCM_NoInj_array[RCM_currentHandle].status = valid;
 8003a6a:	2402      	movs	r4, #2
 8003a6c:	704c      	strb	r4, [r1, #1]
 8003a6e:	e7ed      	b.n	8003a4c <RCM_ReadOngoingConv+0x28>
 8003a70:	20001934 	.word	0x20001934
 8003a74:	20001938 	.word	0x20001938
 8003a78:	20001970 	.word	0x20001970

08003a7c <TIM2_IRQHandler>:
  /* USER CODE BEGIN SPD_TIM_M1_IRQn 0 */

  /* USER CODE END SPD_TIM_M1_IRQn 0 */

  /* Encoder Timer UPDATE IT is dynamicaly enabled/disabled, checking enable state is required */
  if (LL_TIM_IsEnabledIT_UPDATE(ENCODER_M1.TIMx) != 0U)
 8003a7c:	4806      	ldr	r0, [pc, #24]	@ (8003a98 <TIM2_IRQHandler+0x1c>)
 8003a7e:	6a03      	ldr	r3, [r0, #32]
  return ((READ_BIT(TIMx->DIER, TIM_DIER_UIE) == (TIM_DIER_UIE)) ? 1UL : 0UL);
 8003a80:	68da      	ldr	r2, [r3, #12]
 8003a82:	07d1      	lsls	r1, r2, #31
 8003a84:	d507      	bpl.n	8003a96 <TIM2_IRQHandler+0x1a>
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 8003a86:	691a      	ldr	r2, [r3, #16]
 8003a88:	07d2      	lsls	r2, r2, #31
 8003a8a:	d504      	bpl.n	8003a96 <TIM2_IRQHandler+0x1a>
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8003a8c:	f06f 0201 	mvn.w	r2, #1
 8003a90:	611a      	str	r2, [r3, #16]
  {
    if (LL_TIM_IsActiveFlag_UPDATE(ENCODER_M1.TIMx) != 0U)
    {
      LL_TIM_ClearFlag_UPDATE(ENCODER_M1.TIMx);
      (void)ENC_IRQHandler(&ENCODER_M1);
 8003a92:	f004 be27 	b.w	80086e4 <ENC_IRQHandler>
  }

  /* USER CODE BEGIN SPD_TIM_M1_IRQn 1 */

  /* USER CODE END SPD_TIM_M1_IRQn 1 */
}
 8003a96:	4770      	bx	lr
 8003a98:	20000310 	.word	0x20000310

08003a9c <USART2_IRQHandler>:
  * @param  USARTx USART Instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_TC(const USART_TypeDef *USARTx)
{
  return ((READ_BIT(USARTx->ISR, USART_ISR_TC) == (USART_ISR_TC)) ? 1UL : 0UL);
 8003a9c:	4b43      	ldr	r3, [pc, #268]	@ (8003bac <USART2_IRQHandler+0x110>)
 8003a9e:	69da      	ldr	r2, [r3, #28]
 8003aa0:	0652      	lsls	r2, r2, #25
  * @brief  This function handles USART interrupt request.
  * @param  None
  */
//cstat !MISRAC2012-Rule-8.4
void USART2_IRQHandler(void)
{
 8003aa2:	b510      	push	{r4, lr}
 8003aa4:	d509      	bpl.n	8003aba <USART2_IRQHandler+0x1e>
  * @retval None
  */
__STATIC_INLINE void LL_DMA_DisableChannel(DMA_TypeDef *DMAx, uint32_t Channel)
{
  uint32_t dma_base_addr = (uint32_t)DMAx;
  CLEAR_BIT(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CCR, DMA_CCR_EN);
 8003aa6:	4942      	ldr	r1, [pc, #264]	@ (8003bb0 <USART2_IRQHandler+0x114>)
    /* Disable the DMA channel to prepare the next chunck of data*/
    LL_DMA_DisableChannel(DMA_TX_A, DMACH_TX_A);
    LL_USART_ClearFlag_TC(USARTA);
    /* Data Sent by UART*/
    /* Need to free the buffer, and to check pending transfer*/
    ASPEP_HWDataTransmittedIT(&aspepOverUartA);
 8003aa8:	4842      	ldr	r0, [pc, #264]	@ (8003bb4 <USART2_IRQHandler+0x118>)
 8003aaa:	69ca      	ldr	r2, [r1, #28]
  * @param  USARTx USART Instance
  * @retval None
  */
__STATIC_INLINE void LL_USART_ClearFlag_TC(USART_TypeDef *USARTx)
{
  WRITE_REG(USARTx->ICR, USART_ICR_TCCF);
 8003aac:	2440      	movs	r4, #64	@ 0x40
 8003aae:	f022 0201 	bic.w	r2, r2, #1
 8003ab2:	61ca      	str	r2, [r1, #28]
 8003ab4:	621c      	str	r4, [r3, #32]
 8003ab6:	f7fc feb1 	bl	800081c <ASPEP_HWDataTransmittedIT>
  return ((READ_BIT(USARTx->ISR, USART_ISR_ORE) == (USART_ISR_ORE)) ? 1UL : 0UL);
 8003aba:	4b3c      	ldr	r3, [pc, #240]	@ (8003bac <USART2_IRQHandler+0x110>)
 8003abc:	69d8      	ldr	r0, [r3, #28]
  return ((READ_BIT(USARTx->ISR, USART_ISR_FE) == (USART_ISR_FE)) ? 1UL : 0UL);
 8003abe:	69da      	ldr	r2, [r3, #28]
  return ((READ_BIT(USARTx->ISR, USART_ISR_NE) == (USART_ISR_NE)) ? 1UL : 0UL);
 8003ac0:	69d9      	ldr	r1, [r3, #28]
  * @param  USARTx USART Instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_USART_IsEnabledIT_ERROR(const USART_TypeDef *USARTx)
{
  return ((READ_BIT(USARTx->CR3, USART_CR3_EIE) == (USART_CR3_EIE)) ? 1UL : 0UL);
 8003ac2:	689c      	ldr	r4, [r3, #8]
 8003ac4:	07e4      	lsls	r4, r4, #31
 8003ac6:	d526      	bpl.n	8003b16 <USART2_IRQHandler+0x7a>
  return ((READ_BIT(USARTx->ISR, USART_ISR_FE) == (USART_ISR_FE)) ? 1UL : 0UL);
 8003ac8:	f002 0202 	and.w	r2, r2, #2
  return ((READ_BIT(USARTx->ISR, USART_ISR_ORE) == (USART_ISR_ORE)) ? 1UL : 0UL);
 8003acc:	f000 0008 	and.w	r0, r0, #8
  feFlag = LL_USART_IsActiveFlag_FE(USARTA);
  neFlag = LL_USART_IsActiveFlag_NE(USARTA);
  errorMask = LL_USART_IsEnabledIT_ERROR(USARTA);

  flags = ((oreFlag | feFlag | neFlag) & errorMask);
  if (0U == flags)
 8003ad0:	4302      	orrs	r2, r0
  return ((READ_BIT(USARTx->ISR, USART_ISR_NE) == (USART_ISR_NE)) ? 1UL : 0UL);
 8003ad2:	f001 0104 	and.w	r1, r1, #4
 8003ad6:	430a      	orrs	r2, r1
 8003ad8:	d01d      	beq.n	8003b16 <USART2_IRQHandler+0x7a>
  {
    /* Nothing to do */
  }
  else
  { /* Stopping the debugger will generate an OverRun error*/
    WRITE_REG(USARTA->ICR, USART_ICR_FECF | USART_ICR_ORECF | USART_ICR_NECF);
 8003ada:	220e      	movs	r2, #14
 8003adc:	621a      	str	r2, [r3, #32]
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8003ade:	f04f 2240 	mov.w	r2, #1073758208	@ 0x40004000
 8003ae2:	f502 6381 	add.w	r3, r2, #1032	@ 0x408
 8003ae6:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_EIE);
 8003aea:	f023 0301 	bic.w	r3, r3, #1
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8003aee:	f502 6081 	add.w	r0, r2, #1032	@ 0x408
 8003af2:	e840 3100 	strex	r1, r3, [r0]
 8003af6:	2900      	cmp	r1, #0
 8003af8:	d1f3      	bne.n	8003ae2 <USART2_IRQHandler+0x46>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8003afa:	f04f 2240 	mov.w	r2, #1073758208	@ 0x40004000
 8003afe:	f502 6380 	add.w	r3, r2, #1024	@ 0x400
 8003b02:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 8003b06:	f043 0310 	orr.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8003b0a:	f502 6080 	add.w	r0, r2, #1024	@ 0x400
 8003b0e:	e840 3100 	strex	r1, r3, [r0]
 8003b12:	2900      	cmp	r1, #0
 8003b14:	d1f3      	bne.n	8003afe <USART2_IRQHandler+0x62>
  return ((READ_BIT(USARTx->ISR, USART_ISR_IDLE) == (USART_ISR_IDLE)) ? 1UL : 0UL);
 8003b16:	4b25      	ldr	r3, [pc, #148]	@ (8003bac <USART2_IRQHandler+0x110>)
 8003b18:	69da      	ldr	r2, [r3, #28]
  return ((READ_BIT(USARTx->CR1, USART_CR1_IDLEIE) == (USART_CR1_IDLEIE)) ? 1UL : 0UL);
 8003b1a:	681b      	ldr	r3, [r3, #0]
  return ((READ_BIT(USARTx->ISR, USART_ISR_IDLE) == (USART_ISR_IDLE)) ? 1UL : 0UL);
 8003b1c:	06d2      	lsls	r2, r2, #27
 8003b1e:	d543      	bpl.n	8003ba8 <USART2_IRQHandler+0x10c>
  return ((READ_BIT(USARTx->CR1, USART_CR1_IDLEIE) == (USART_CR1_IDLEIE)) ? 1UL : 0UL);
 8003b20:	06db      	lsls	r3, r3, #27
 8003b22:	d541      	bpl.n	8003ba8 <USART2_IRQHandler+0x10c>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8003b24:	f04f 2240 	mov.w	r2, #1073758208	@ 0x40004000
 8003b28:	f502 6380 	add.w	r3, r2, #1024	@ 0x400
 8003b2c:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 8003b30:	f023 0310 	bic.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8003b34:	f502 6080 	add.w	r0, r2, #1024	@ 0x400
 8003b38:	e840 3100 	strex	r1, r3, [r0]
 8003b3c:	2900      	cmp	r1, #0
 8003b3e:	d1f3      	bne.n	8003b28 <USART2_IRQHandler+0x8c>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8003b40:	f04f 2240 	mov.w	r2, #1073758208	@ 0x40004000
 8003b44:	f502 6381 	add.w	r3, r2, #1032	@ 0x408
 8003b48:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_EIE);
 8003b4c:	f043 0301 	orr.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8003b50:	f502 6081 	add.w	r0, r2, #1032	@ 0x408
 8003b54:	e840 3100 	strex	r1, r3, [r0]
 8003b58:	2900      	cmp	r1, #0
 8003b5a:	d1f3      	bne.n	8003b44 <USART2_IRQHandler+0xa8>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8003b5c:	f04f 2240 	mov.w	r2, #1073758208	@ 0x40004000
 8003b60:	f502 6381 	add.w	r3, r2, #1032	@ 0x408
 8003b64:	e853 3f00 	ldrex	r3, [r3]
  * @param  USARTx USART Instance
  * @retval None
  */
__STATIC_INLINE void LL_USART_DisableDMAReq_RX(USART_TypeDef *USARTx)
{
  ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_DMAR);
 8003b68:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8003b6c:	f502 6081 	add.w	r0, r2, #1032	@ 0x408
 8003b70:	e840 3100 	strex	r1, r3, [r0]
 8003b74:	2900      	cmp	r1, #0
 8003b76:	d1f3      	bne.n	8003b60 <USART2_IRQHandler+0xc4>
  * @param  USARTx USART Instance
  * @retval Value between Min_Data=0x00 and Max_Data=0xFF
  */
__STATIC_INLINE uint8_t LL_USART_ReceiveData8(const USART_TypeDef *USARTx)
{
  return (uint8_t)(READ_BIT(USARTx->RDR, USART_RDR_RDR) & 0xFFU);
 8003b78:	4b0c      	ldr	r3, [pc, #48]	@ (8003bac <USART2_IRQHandler+0x110>)
 8003b7a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8003b7c:	f04f 2240 	mov.w	r2, #1073758208	@ 0x40004000
 8003b80:	f502 6381 	add.w	r3, r2, #1032	@ 0x408
 8003b84:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAR);
 8003b88:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8003b8c:	f502 6081 	add.w	r0, r2, #1032	@ 0x408
 8003b90:	e840 3100 	strex	r1, r3, [r0]
 8003b94:	2900      	cmp	r1, #0
 8003b96:	d1f3      	bne.n	8003b80 <USART2_IRQHandler+0xe4>
    WRITE_REG (DMAx->IFCR, DMA_IFCR_CTCIF1 << ((Channel-LL_DMA_CHANNEL_1)<<2));
 8003b98:	4b05      	ldr	r3, [pc, #20]	@ (8003bb0 <USART2_IRQHandler+0x114>)
    LL_USART_DisableDMAReq_RX(USARTA);
    (void)LL_USART_ReceiveData8(USARTA);
    LL_USART_EnableDMAReq_RX(USARTA);
    /* Clear pending DMA TC to process only new received packet */
    LL_DMA_ClearFlag_TC(DMA_RX_A, DMACH_RX_A);
    ASPEP_HWReset(&aspepOverUartA);
 8003b9a:	4806      	ldr	r0, [pc, #24]	@ (8003bb4 <USART2_IRQHandler+0x118>)
 8003b9c:	2202      	movs	r2, #2
  }

  /* USER CODE BEGIN USART2_IRQHandler 1 */

  /* USER CODE END USART2_IRQHandler 1 */
}
 8003b9e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8003ba2:	605a      	str	r2, [r3, #4]
    ASPEP_HWReset(&aspepOverUartA);
 8003ba4:	f7fc bfe6 	b.w	8000b74 <ASPEP_HWReset>
}
 8003ba8:	bd10      	pop	{r4, pc}
 8003baa:	bf00      	nop
 8003bac:	40004400 	.word	0x40004400
 8003bb0:	40020000 	.word	0x40020000
 8003bb4:	200003ec 	.word	0x200003ec

08003bb8 <HardFault_Handler>:
/**
  * @brief  This function handles Hard Fault exception.
  * @param  None
  */
void HardFault_Handler(void)
{
 8003bb8:	b508      	push	{r3, lr}
 /* USER CODE BEGIN HardFault_IRQn 0 */

 /* USER CODE END HardFault_IRQn 0 */

  TSK_HardwareFaultTask();
 8003bba:	f7fd fe49 	bl	8001850 <TSK_HardwareFaultTask>

  /* Go to infinite loop when Hard Fault exception occurs */
  while (true)
 8003bbe:	e7fe      	b.n	8003bbe <HardFault_Handler+0x6>

08003bc0 <EXTI15_10_IRQHandler>:
  * @note   Please check each device line mapping for EXTI Line availability
  * @retval @note This bit is set when the selected edge event arrives on the interrupt
  */
__STATIC_INLINE uint32_t LL_EXTI_ReadFlag_0_31(uint32_t ExtiLine)
{
  return (uint32_t)(READ_BIT(EXTI->PR1, ExtiLine));
 8003bc0:	4b04      	ldr	r3, [pc, #16]	@ (8003bd4 <EXTI15_10_IRQHandler+0x14>)
 8003bc2:	695a      	ldr	r2, [r3, #20]

  */
void EXTI15_10_IRQHandler(void)
{
  /* USER CODE BEGIN START_STOP_BTN */
  if (LL_EXTI_ReadFlag_0_31(LL_EXTI_LINE_13))
 8003bc4:	0492      	lsls	r2, r2, #18
 8003bc6:	d400      	bmi.n	8003bca <EXTI15_10_IRQHandler+0xa>
  else
  {
    /* Nothing to do */
  }

}
 8003bc8:	4770      	bx	lr
  * @note   Please check each device line mapping for EXTI Line availability
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_ClearFlag_0_31(uint32_t ExtiLine)
{
  WRITE_REG(EXTI->PR1, ExtiLine);
 8003bca:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 8003bce:	615a      	str	r2, [r3, #20]
    (void)UI_HandleStartStopButton_cb();
 8003bd0:	f7fd be5c 	b.w	800188c <UI_HandleStartStopButton_cb>
 8003bd4:	40010400 	.word	0x40010400

08003bd8 <HAL_MspInit>:

  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8003bd8:	4b0f      	ldr	r3, [pc, #60]	@ (8003c18 <HAL_MspInit+0x40>)
{
 8003bda:	b510      	push	{r4, lr}
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8003bdc:	6e18      	ldr	r0, [r3, #96]	@ 0x60
 8003bde:	f040 0001 	orr.w	r0, r0, #1
 8003be2:	6618      	str	r0, [r3, #96]	@ 0x60
 8003be4:	6e1c      	ldr	r4, [r3, #96]	@ 0x60
{
 8003be6:	b082      	sub	sp, #8
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8003be8:	f004 0401 	and.w	r4, r4, #1
 8003bec:	9400      	str	r4, [sp, #0]
 8003bee:	9c00      	ldr	r4, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 8003bf0:	6d9c      	ldr	r4, [r3, #88]	@ 0x58
 8003bf2:	f044 5480 	orr.w	r4, r4, #268435456	@ 0x10000000
 8003bf6:	659c      	str	r4, [r3, #88]	@ 0x58
 8003bf8:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8003bfa:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8003bfe:	9301      	str	r3, [sp, #4]

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 8003c00:	2200      	movs	r2, #0
 8003c02:	210f      	movs	r1, #15
 8003c04:	f06f 0001 	mvn.w	r0, #1
  __HAL_RCC_PWR_CLK_ENABLE();
 8003c08:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 8003c0a:	f001 fa03 	bl	8005014 <HAL_NVIC_SetPriority>
  HAL_PWREx_DisableUCPDDeadBattery();

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8003c0e:	b002      	add	sp, #8
 8003c10:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_PWREx_DisableUCPDDeadBattery();
 8003c14:	f001 bdb2 	b.w	800577c <HAL_PWREx_DisableUCPDDeadBattery>
 8003c18:	40021000 	.word	0x40021000

08003c1c <HAL_ADC_MspInit>:
* This function configures the hardware resources used in this example
* @param hadc: ADC handle pointer
* @retval None
*/
void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
 8003c1c:	b510      	push	{r4, lr}
 8003c1e:	4604      	mov	r4, r0
 8003c20:	b09a      	sub	sp, #104	@ 0x68
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8003c22:	2100      	movs	r1, #0
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8003c24:	2244      	movs	r2, #68	@ 0x44
 8003c26:	a809      	add	r0, sp, #36	@ 0x24
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8003c28:	e9cd 1104 	strd	r1, r1, [sp, #16]
 8003c2c:	e9cd 1106 	strd	r1, r1, [sp, #24]
 8003c30:	9108      	str	r1, [sp, #32]
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8003c32:	f006 fb35 	bl	800a2a0 <memset>
  if(hadc->Instance==ADC1)
 8003c36:	6823      	ldr	r3, [r4, #0]
 8003c38:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 8003c3c:	d001      	beq.n	8003c42 <HAL_ADC_MspInit+0x26>

  /* USER CODE END ADC1_MspInit 1 */

  }

}
 8003c3e:	b01a      	add	sp, #104	@ 0x68
 8003c40:	bd10      	pop	{r4, pc}
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC12;
 8003c42:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
    PeriphClkInit.Adc12ClockSelection = RCC_ADC12CLKSOURCE_PLL;
 8003c46:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8003c4a:	a809      	add	r0, sp, #36	@ 0x24
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC12;
 8003c4c:	9209      	str	r2, [sp, #36]	@ 0x24
    PeriphClkInit.Adc12ClockSelection = RCC_ADC12CLKSOURCE_PLL;
 8003c4e:	9318      	str	r3, [sp, #96]	@ 0x60
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8003c50:	f002 f972 	bl	8005f38 <HAL_RCCEx_PeriphCLKConfig>
 8003c54:	2800      	cmp	r0, #0
 8003c56:	d131      	bne.n	8003cbc <HAL_ADC_MspInit+0xa0>
    __HAL_RCC_ADC12_CLK_ENABLE();
 8003c58:	4b1a      	ldr	r3, [pc, #104]	@ (8003cc4 <HAL_ADC_MspInit+0xa8>)
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8003c5a:	481b      	ldr	r0, [pc, #108]	@ (8003cc8 <HAL_ADC_MspInit+0xac>)
    __HAL_RCC_ADC12_CLK_ENABLE();
 8003c5c:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8003c5e:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
 8003c62:	64da      	str	r2, [r3, #76]	@ 0x4c
 8003c64:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8003c66:	f402 5200 	and.w	r2, r2, #8192	@ 0x2000
 8003c6a:	9201      	str	r2, [sp, #4]
 8003c6c:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8003c6e:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8003c70:	f042 0204 	orr.w	r2, r2, #4
 8003c74:	64da      	str	r2, [r3, #76]	@ 0x4c
 8003c76:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8003c78:	f002 0204 	and.w	r2, r2, #4
 8003c7c:	9202      	str	r2, [sp, #8]
 8003c7e:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8003c80:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8003c82:	f042 0201 	orr.w	r2, r2, #1
 8003c86:	64da      	str	r2, [r3, #76]	@ 0x4c
 8003c88:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8003c8a:	f003 0301 	and.w	r3, r3, #1
 8003c8e:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8003c90:	2400      	movs	r4, #0
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8003c92:	a904      	add	r1, sp, #16
    GPIO_InitStruct.Pin = M1_CURR_AMPL_W_Pin|M1_CURR_AMPL_V_Pin|M1_TEMPERATURE_Pin;
 8003c94:	2207      	movs	r2, #7
 8003c96:	2303      	movs	r3, #3
 8003c98:	e9cd 2304 	strd	r2, r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8003c9c:	9406      	str	r4, [sp, #24]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8003c9e:	9b03      	ldr	r3, [sp, #12]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8003ca0:	f001 fbf2 	bl	8005488 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = M1_CURR_AMPL_U_Pin|M1_BUS_VOLTAGE_Pin;
 8003ca4:	2203      	movs	r2, #3
 8003ca6:	2303      	movs	r3, #3
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8003ca8:	a904      	add	r1, sp, #16
 8003caa:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
    GPIO_InitStruct.Pin = M1_CURR_AMPL_U_Pin|M1_BUS_VOLTAGE_Pin;
 8003cae:	e9cd 2304 	strd	r2, r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8003cb2:	9406      	str	r4, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8003cb4:	f001 fbe8 	bl	8005488 <HAL_GPIO_Init>
}
 8003cb8:	b01a      	add	sp, #104	@ 0x68
 8003cba:	bd10      	pop	{r4, pc}
      Error_Handler();
 8003cbc:	f7fd fa72 	bl	80011a4 <Error_Handler>
 8003cc0:	e7ca      	b.n	8003c58 <HAL_ADC_MspInit+0x3c>
 8003cc2:	bf00      	nop
 8003cc4:	40021000 	.word	0x40021000
 8003cc8:	48000800 	.word	0x48000800

08003ccc <HAL_CORDIC_MspInit>:
* @param hcordic: CORDIC handle pointer
* @retval None
*/
void HAL_CORDIC_MspInit(CORDIC_HandleTypeDef* hcordic)
{
  if(hcordic->Instance==CORDIC)
 8003ccc:	4b0a      	ldr	r3, [pc, #40]	@ (8003cf8 <HAL_CORDIC_MspInit+0x2c>)
 8003cce:	6802      	ldr	r2, [r0, #0]
 8003cd0:	429a      	cmp	r2, r3
 8003cd2:	d000      	beq.n	8003cd6 <HAL_CORDIC_MspInit+0xa>
 8003cd4:	4770      	bx	lr
  {
  /* USER CODE BEGIN CORDIC_MspInit 0 */

  /* USER CODE END CORDIC_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_CORDIC_CLK_ENABLE();
 8003cd6:	f8d3 2448 	ldr.w	r2, [r3, #1096]	@ 0x448
 8003cda:	f042 0208 	orr.w	r2, r2, #8
 8003cde:	f8c3 2448 	str.w	r2, [r3, #1096]	@ 0x448
 8003ce2:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
{
 8003ce6:	b082      	sub	sp, #8
    __HAL_RCC_CORDIC_CLK_ENABLE();
 8003ce8:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8003cea:	f003 0308 	and.w	r3, r3, #8
 8003cee:	9301      	str	r3, [sp, #4]
 8003cf0:	9b01      	ldr	r3, [sp, #4]

  /* USER CODE END CORDIC_MspInit 1 */

  }

}
 8003cf2:	b002      	add	sp, #8
 8003cf4:	4770      	bx	lr
 8003cf6:	bf00      	nop
 8003cf8:	40020c00 	.word	0x40020c00

08003cfc <HAL_DAC_MspInit>:
* This function configures the hardware resources used in this example
* @param hdac: DAC handle pointer
* @retval None
*/
void HAL_DAC_MspInit(DAC_HandleTypeDef* hdac)
{
 8003cfc:	b510      	push	{r4, lr}
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(hdac->Instance==DAC1)
 8003cfe:	4b1b      	ldr	r3, [pc, #108]	@ (8003d6c <HAL_DAC_MspInit+0x70>)
 8003d00:	6802      	ldr	r2, [r0, #0]
{
 8003d02:	b088      	sub	sp, #32
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8003d04:	2400      	movs	r4, #0
  if(hdac->Instance==DAC1)
 8003d06:	429a      	cmp	r2, r3
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8003d08:	e9cd 4402 	strd	r4, r4, [sp, #8]
 8003d0c:	e9cd 4404 	strd	r4, r4, [sp, #16]
 8003d10:	9406      	str	r4, [sp, #24]
  if(hdac->Instance==DAC1)
 8003d12:	d001      	beq.n	8003d18 <HAL_DAC_MspInit+0x1c>

  /* USER CODE END DAC1_MspInit 1 */

  }

}
 8003d14:	b008      	add	sp, #32
 8003d16:	bd10      	pop	{r4, pc}
    __HAL_RCC_DAC1_CLK_ENABLE();
 8003d18:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
 8003d1c:	f503 3302 	add.w	r3, r3, #133120	@ 0x20800
    HAL_GPIO_Init(DBG_DAC_CH1_GPIO_Port, &GPIO_InitStruct);
 8003d20:	a902      	add	r1, sp, #8
    __HAL_RCC_DAC1_CLK_ENABLE();
 8003d22:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8003d24:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 8003d28:	64da      	str	r2, [r3, #76]	@ 0x4c
 8003d2a:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8003d2c:	f402 3280 	and.w	r2, r2, #65536	@ 0x10000
 8003d30:	9200      	str	r2, [sp, #0]
 8003d32:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8003d34:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8003d36:	f042 0201 	orr.w	r2, r2, #1
 8003d3a:	64da      	str	r2, [r3, #76]	@ 0x4c
 8003d3c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8003d3e:	f003 0301 	and.w	r3, r3, #1
 8003d42:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Pin = DBG_DAC_CH1_Pin;
 8003d44:	2210      	movs	r2, #16
    HAL_GPIO_Init(DBG_DAC_CH1_GPIO_Port, &GPIO_InitStruct);
 8003d46:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
    GPIO_InitStruct.Pin = DBG_DAC_CH1_Pin;
 8003d4a:	2303      	movs	r3, #3
 8003d4c:	e9cd 2302 	strd	r2, r3, [sp, #8]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8003d50:	9b01      	ldr	r3, [sp, #4]
    HAL_GPIO_Init(DBG_DAC_CH1_GPIO_Port, &GPIO_InitStruct);
 8003d52:	f001 fb99 	bl	8005488 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(TIM6_DAC_IRQn, 0, 0);
 8003d56:	4622      	mov	r2, r4
 8003d58:	4621      	mov	r1, r4
 8003d5a:	2036      	movs	r0, #54	@ 0x36
 8003d5c:	f001 f95a 	bl	8005014 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM6_DAC_IRQn);
 8003d60:	2036      	movs	r0, #54	@ 0x36
 8003d62:	f001 f993 	bl	800508c <HAL_NVIC_EnableIRQ>
}
 8003d66:	b008      	add	sp, #32
 8003d68:	bd10      	pop	{r4, pc}
 8003d6a:	bf00      	nop
 8003d6c:	50000800 	.word	0x50000800

08003d70 <HAL_TIM_PWM_MspInit>:
* This function configures the hardware resources used in this example
* @param htim_pwm: TIM_PWM handle pointer
* @retval None
*/
void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef* htim_pwm)
{
 8003d70:	b510      	push	{r4, lr}
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(htim_pwm->Instance==TIM1)
 8003d72:	4a1b      	ldr	r2, [pc, #108]	@ (8003de0 <HAL_TIM_PWM_MspInit+0x70>)
 8003d74:	6801      	ldr	r1, [r0, #0]
{
 8003d76:	b088      	sub	sp, #32
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8003d78:	2300      	movs	r3, #0
  if(htim_pwm->Instance==TIM1)
 8003d7a:	4291      	cmp	r1, r2
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8003d7c:	e9cd 3302 	strd	r3, r3, [sp, #8]
 8003d80:	e9cd 3304 	strd	r3, r3, [sp, #16]
 8003d84:	9306      	str	r3, [sp, #24]
  if(htim_pwm->Instance==TIM1)
 8003d86:	d001      	beq.n	8003d8c <HAL_TIM_PWM_MspInit+0x1c>

  /* USER CODE END TIM1_MspInit 1 */

  }

}
 8003d88:	b008      	add	sp, #32
 8003d8a:	bd10      	pop	{r4, pc}
    __HAL_RCC_TIM1_CLK_ENABLE();
 8003d8c:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 8003d90:	f503 3304 	add.w	r3, r3, #135168	@ 0x21000
    GPIO_InitStruct.Pin = M1_OCP_Pin;
 8003d94:	ed9f 7b10 	vldr	d7, [pc, #64]	@ 8003dd8 <HAL_TIM_PWM_MspInit+0x68>
    __HAL_RCC_TIM1_CLK_ENABLE();
 8003d98:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
 8003d9a:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 8003d9e:	661a      	str	r2, [r3, #96]	@ 0x60
 8003da0:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
 8003da2:	f402 6200 	and.w	r2, r2, #2048	@ 0x800
 8003da6:	9200      	str	r2, [sp, #0]
 8003da8:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8003daa:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8003dac:	f042 0201 	orr.w	r2, r2, #1
 8003db0:	64da      	str	r2, [r3, #76]	@ 0x4c
 8003db2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8003db4:	f003 0301 	and.w	r3, r3, #1
 8003db8:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8003dba:	2201      	movs	r2, #1
    GPIO_InitStruct.Alternate = GPIO_AF6_TIM1;
 8003dbc:	2306      	movs	r3, #6
    HAL_GPIO_Init(M1_OCP_GPIO_Port, &GPIO_InitStruct);
 8003dbe:	a902      	add	r1, sp, #8
 8003dc0:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
    GPIO_InitStruct.Pin = M1_OCP_Pin;
 8003dc4:	ed8d 7b02 	vstr	d7, [sp, #8]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8003dc8:	9c01      	ldr	r4, [sp, #4]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8003dca:	9204      	str	r2, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF6_TIM1;
 8003dcc:	9306      	str	r3, [sp, #24]
    HAL_GPIO_Init(M1_OCP_GPIO_Port, &GPIO_InitStruct);
 8003dce:	f001 fb5b 	bl	8005488 <HAL_GPIO_Init>
}
 8003dd2:	b008      	add	sp, #32
 8003dd4:	bd10      	pop	{r4, pc}
 8003dd6:	bf00      	nop
 8003dd8:	00000040 	.word	0x00000040
 8003ddc:	00000012 	.word	0x00000012
 8003de0:	40012c00 	.word	0x40012c00

08003de4 <HAL_TIM_Encoder_MspInit>:
* This function configures the hardware resources used in this example
* @param htim_encoder: TIM_Encoder handle pointer
* @retval None
*/
void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef* htim_encoder)
{
 8003de4:	b530      	push	{r4, r5, lr}
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(htim_encoder->Instance==TIM2)
 8003de6:	6803      	ldr	r3, [r0, #0]
{
 8003de8:	b08b      	sub	sp, #44	@ 0x2c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8003dea:	2400      	movs	r4, #0
  if(htim_encoder->Instance==TIM2)
 8003dec:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8003df0:	e9cd 4404 	strd	r4, r4, [sp, #16]
 8003df4:	e9cd 4406 	strd	r4, r4, [sp, #24]
 8003df8:	9408      	str	r4, [sp, #32]
  if(htim_encoder->Instance==TIM2)
 8003dfa:	d001      	beq.n	8003e00 <HAL_TIM_Encoder_MspInit+0x1c>

  /* USER CODE END TIM2_MspInit 1 */

  }

}
 8003dfc:	b00b      	add	sp, #44	@ 0x2c
 8003dfe:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_TIM2_CLK_ENABLE();
 8003e00:	f503 3304 	add.w	r3, r3, #135168	@ 0x21000
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 8003e04:	2501      	movs	r5, #1
    __HAL_RCC_TIM2_CLK_ENABLE();
 8003e06:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 8003e08:	f042 0201 	orr.w	r2, r2, #1
 8003e0c:	659a      	str	r2, [r3, #88]	@ 0x58
 8003e0e:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 8003e10:	f002 0201 	and.w	r2, r2, #1
 8003e14:	9201      	str	r2, [sp, #4]
 8003e16:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8003e18:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8003e1a:	f042 0201 	orr.w	r2, r2, #1
 8003e1e:	64da      	str	r2, [r3, #76]	@ 0x4c
 8003e20:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8003e22:	f002 0201 	and.w	r2, r2, #1
 8003e26:	9202      	str	r2, [sp, #8]
 8003e28:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8003e2a:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8003e2c:	f042 0202 	orr.w	r2, r2, #2
 8003e30:	64da      	str	r2, [r3, #76]	@ 0x4c
 8003e32:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 8003e34:	9508      	str	r5, [sp, #32]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8003e36:	f003 0302 	and.w	r3, r3, #2
 8003e3a:	9303      	str	r3, [sp, #12]
    HAL_GPIO_Init(M1_ENCODER_A_GPIO_Port, &GPIO_InitStruct);
 8003e3c:	a904      	add	r1, sp, #16
    GPIO_InitStruct.Pin = M1_ENCODER_A_Pin;
 8003e3e:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
    HAL_GPIO_Init(M1_ENCODER_A_GPIO_Port, &GPIO_InitStruct);
 8003e42:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
    GPIO_InitStruct.Pin = M1_ENCODER_A_Pin;
 8003e46:	2302      	movs	r3, #2
 8003e48:	e9cd 2304 	strd	r2, r3, [sp, #16]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8003e4c:	9b03      	ldr	r3, [sp, #12]
    HAL_GPIO_Init(M1_ENCODER_A_GPIO_Port, &GPIO_InitStruct);
 8003e4e:	f001 fb1b 	bl	8005488 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = M1_ENCODER_B_Pin;
 8003e52:	2208      	movs	r2, #8
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8003e54:	2302      	movs	r3, #2
    HAL_GPIO_Init(M1_ENCODER_B_GPIO_Port, &GPIO_InitStruct);
 8003e56:	4805      	ldr	r0, [pc, #20]	@ (8003e6c <HAL_TIM_Encoder_MspInit+0x88>)
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 8003e58:	9508      	str	r5, [sp, #32]
    HAL_GPIO_Init(M1_ENCODER_B_GPIO_Port, &GPIO_InitStruct);
 8003e5a:	a904      	add	r1, sp, #16
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8003e5c:	e9cd 2304 	strd	r2, r3, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8003e60:	e9cd 4406 	strd	r4, r4, [sp, #24]
    HAL_GPIO_Init(M1_ENCODER_B_GPIO_Port, &GPIO_InitStruct);
 8003e64:	f001 fb10 	bl	8005488 <HAL_GPIO_Init>
}
 8003e68:	b00b      	add	sp, #44	@ 0x2c
 8003e6a:	bd30      	pop	{r4, r5, pc}
 8003e6c:	48000400 	.word	0x48000400

08003e70 <HAL_TIM_MspPostInit>:

void HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim)
{
 8003e70:	b5d0      	push	{r4, r6, r7, lr}
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(htim->Instance==TIM1)
 8003e72:	4a27      	ldr	r2, [pc, #156]	@ (8003f10 <HAL_TIM_MspPostInit+0xa0>)
 8003e74:	6801      	ldr	r1, [r0, #0]
{
 8003e76:	b088      	sub	sp, #32
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8003e78:	2300      	movs	r3, #0
  if(htim->Instance==TIM1)
 8003e7a:	4291      	cmp	r1, r2
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8003e7c:	e9cd 3302 	strd	r3, r3, [sp, #8]
 8003e80:	e9cd 3304 	strd	r3, r3, [sp, #16]
 8003e84:	9306      	str	r3, [sp, #24]
  if(htim->Instance==TIM1)
 8003e86:	d001      	beq.n	8003e8c <HAL_TIM_MspPostInit+0x1c>
  /* USER CODE BEGIN TIM1_MspPostInit 1 */

  /* USER CODE END TIM1_MspPostInit 1 */
  }

}
 8003e88:	b008      	add	sp, #32
 8003e8a:	bdd0      	pop	{r4, r6, r7, pc}
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8003e8c:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 8003e90:	f503 3304 	add.w	r3, r3, #135168	@ 0x21000
    GPIO_InitStruct.Alternate = GPIO_AF6_TIM1;
 8003e94:	2406      	movs	r4, #6
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8003e96:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8003e98:	f042 0201 	orr.w	r2, r2, #1
 8003e9c:	64da      	str	r2, [r3, #76]	@ 0x4c
 8003e9e:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8003ea0:	f002 0201 	and.w	r2, r2, #1
 8003ea4:	9200      	str	r2, [sp, #0]
 8003ea6:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8003ea8:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8003eaa:	f042 0202 	orr.w	r2, r2, #2
 8003eae:	64da      	str	r2, [r3, #76]	@ 0x4c
 8003eb0:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
    GPIO_InitStruct.Alternate = GPIO_AF6_TIM1;
 8003eb2:	9406      	str	r4, [sp, #24]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8003eb4:	f003 0302 	and.w	r3, r3, #2
 8003eb8:	9301      	str	r3, [sp, #4]
    HAL_GPIO_Init(M1_PWM_UL_GPIO_Port, &GPIO_InitStruct);
 8003eba:	a902      	add	r1, sp, #8
    GPIO_InitStruct.Pin = M1_PWM_UL_Pin;
 8003ebc:	2280      	movs	r2, #128	@ 0x80
 8003ebe:	2601      	movs	r6, #1
 8003ec0:	2702      	movs	r7, #2
    HAL_GPIO_Init(M1_PWM_UL_GPIO_Port, &GPIO_InitStruct);
 8003ec2:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
    GPIO_InitStruct.Pin = M1_PWM_UL_Pin;
 8003ec6:	2302      	movs	r3, #2
 8003ec8:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8003ecc:	e9cd 6704 	strd	r6, r7, [sp, #16]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8003ed0:	9b01      	ldr	r3, [sp, #4]
    HAL_GPIO_Init(M1_PWM_UL_GPIO_Port, &GPIO_InitStruct);
 8003ed2:	f001 fad9 	bl	8005488 <HAL_GPIO_Init>
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8003ed6:	a902      	add	r1, sp, #8
    GPIO_InitStruct.Pin = M1_PWM_VL_Pin|M1_PWM_WL_Pin;
 8003ed8:	2203      	movs	r2, #3
 8003eda:	2302      	movs	r3, #2
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8003edc:	480d      	ldr	r0, [pc, #52]	@ (8003f14 <HAL_TIM_MspPostInit+0xa4>)
    GPIO_InitStruct.Alternate = GPIO_AF6_TIM1;
 8003ede:	9406      	str	r4, [sp, #24]
    GPIO_InitStruct.Pin = M1_PWM_VL_Pin|M1_PWM_WL_Pin;
 8003ee0:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8003ee4:	e9cd 6704 	strd	r6, r7, [sp, #16]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8003ee8:	f001 face 	bl	8005488 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = M1_PWM_UH_Pin|M1_PWM_VH_Pin|M1_PWM_WH_Pin;
 8003eec:	f44f 62e0 	mov.w	r2, #1792	@ 0x700
 8003ef0:	2302      	movs	r3, #2
 8003ef2:	e9cd 2302 	strd	r2, r3, [sp, #8]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8003ef6:	a902      	add	r1, sp, #8
    GPIO_InitStruct.Pin = M1_PWM_UH_Pin|M1_PWM_VH_Pin|M1_PWM_WH_Pin;
 8003ef8:	2202      	movs	r2, #2
 8003efa:	2302      	movs	r3, #2
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8003efc:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
    GPIO_InitStruct.Pin = M1_PWM_UH_Pin|M1_PWM_VH_Pin|M1_PWM_WH_Pin;
 8003f00:	e9cd 2304 	strd	r2, r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF6_TIM1;
 8003f04:	9406      	str	r4, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8003f06:	f001 fabf 	bl	8005488 <HAL_GPIO_Init>
}
 8003f0a:	b008      	add	sp, #32
 8003f0c:	bdd0      	pop	{r4, r6, r7, pc}
 8003f0e:	bf00      	nop
 8003f10:	40012c00 	.word	0x40012c00
 8003f14:	48000400 	.word	0x48000400

08003f18 <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 8003f18:	b570      	push	{r4, r5, r6, lr}
 8003f1a:	4604      	mov	r4, r0
 8003f1c:	b098      	sub	sp, #96	@ 0x60
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8003f1e:	2100      	movs	r1, #0
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8003f20:	2244      	movs	r2, #68	@ 0x44
 8003f22:	a807      	add	r0, sp, #28
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8003f24:	e9cd 1102 	strd	r1, r1, [sp, #8]
 8003f28:	e9cd 1104 	strd	r1, r1, [sp, #16]
 8003f2c:	9106      	str	r1, [sp, #24]
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8003f2e:	f006 f9b7 	bl	800a2a0 <memset>
  if(huart->Instance==USART2)
 8003f32:	4b32      	ldr	r3, [pc, #200]	@ (8003ffc <HAL_UART_MspInit+0xe4>)
 8003f34:	6822      	ldr	r2, [r4, #0]
 8003f36:	429a      	cmp	r2, r3
 8003f38:	d001      	beq.n	8003f3e <HAL_UART_MspInit+0x26>

  /* USER CODE END USART2_MspInit 1 */

  }

}
 8003f3a:	b018      	add	sp, #96	@ 0x60
 8003f3c:	bd70      	pop	{r4, r5, r6, pc}
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2;
 8003f3e:	2302      	movs	r3, #2
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8003f40:	a807      	add	r0, sp, #28
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2;
 8003f42:	9307      	str	r3, [sp, #28]
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8003f44:	f001 fff8 	bl	8005f38 <HAL_RCCEx_PeriphCLKConfig>
 8003f48:	2800      	cmp	r0, #0
 8003f4a:	d14d      	bne.n	8003fe8 <HAL_UART_MspInit+0xd0>
    __HAL_RCC_USART2_CLK_ENABLE();
 8003f4c:	4b2c      	ldr	r3, [pc, #176]	@ (8004000 <HAL_UART_MspInit+0xe8>)
    hdma_usart2_rx.Instance = DMA1_Channel1;
 8003f4e:	4e2d      	ldr	r6, [pc, #180]	@ (8004004 <HAL_UART_MspInit+0xec>)
    __HAL_RCC_USART2_CLK_ENABLE();
 8003f50:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 8003f52:	f442 3200 	orr.w	r2, r2, #131072	@ 0x20000
 8003f56:	659a      	str	r2, [r3, #88]	@ 0x58
 8003f58:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 8003f5a:	f402 3200 	and.w	r2, r2, #131072	@ 0x20000
 8003f5e:	9200      	str	r2, [sp, #0]
 8003f60:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8003f62:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8003f64:	f042 0201 	orr.w	r2, r2, #1
 8003f68:	64da      	str	r2, [r3, #76]	@ 0x4c
 8003f6a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8003f6c:	f003 0301 	and.w	r3, r3, #1
 8003f70:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Pin = UART_TX_Pin|UART_RX_Pin;
 8003f72:	220c      	movs	r2, #12
 8003f74:	2302      	movs	r3, #2
 8003f76:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8003f7a:	2200      	movs	r2, #0
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8003f7c:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = UART_TX_Pin|UART_RX_Pin;
 8003f7e:	2300      	movs	r3, #0
 8003f80:	e9cd 2304 	strd	r2, r3, [sp, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8003f84:	a902      	add	r1, sp, #8
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 8003f86:	2307      	movs	r3, #7
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8003f88:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 8003f8c:	9306      	str	r3, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8003f8e:	f001 fa7b 	bl	8005488 <HAL_GPIO_Init>
    hdma_usart2_rx.Init.Request = DMA_REQUEST_USART2_RX;
 8003f92:	491d      	ldr	r1, [pc, #116]	@ (8004008 <HAL_UART_MspInit+0xf0>)
 8003f94:	221a      	movs	r2, #26
 8003f96:	2300      	movs	r3, #0
 8003f98:	e9c6 1200 	strd	r1, r2, [r6]
    if (HAL_DMA_Init(&hdma_usart2_rx) != HAL_OK)
 8003f9c:	4630      	mov	r0, r6
    hdma_usart2_rx.Init.Request = DMA_REQUEST_USART2_RX;
 8003f9e:	2280      	movs	r2, #128	@ 0x80
 8003fa0:	e9c6 3302 	strd	r3, r3, [r6, #8]
 8003fa4:	e9c6 2304 	strd	r2, r3, [r6, #16]
 8003fa8:	e9c6 3306 	strd	r3, r3, [r6, #24]
 8003fac:	6233      	str	r3, [r6, #32]
    if (HAL_DMA_Init(&hdma_usart2_rx) != HAL_OK)
 8003fae:	f001 f9d9 	bl	8005364 <HAL_DMA_Init>
 8003fb2:	b9f8      	cbnz	r0, 8003ff4 <HAL_UART_MspInit+0xdc>
    hdma_usart2_tx.Instance = DMA1_Channel2;
 8003fb4:	4d15      	ldr	r5, [pc, #84]	@ (800400c <HAL_UART_MspInit+0xf4>)
 8003fb6:	4916      	ldr	r1, [pc, #88]	@ (8004010 <HAL_UART_MspInit+0xf8>)
    __HAL_LINKDMA(huart,hdmarx,hdma_usart2_rx);
 8003fb8:	f8c4 6080 	str.w	r6, [r4, #128]	@ 0x80
    hdma_usart2_tx.Init.Request = DMA_REQUEST_USART2_TX;
 8003fbc:	221b      	movs	r2, #27
 8003fbe:	2300      	movs	r3, #0
 8003fc0:	e9c5 1200 	strd	r1, r2, [r5]
    if (HAL_DMA_Init(&hdma_usart2_tx) != HAL_OK)
 8003fc4:	4628      	mov	r0, r5
    hdma_usart2_tx.Init.Request = DMA_REQUEST_USART2_TX;
 8003fc6:	2110      	movs	r1, #16
 8003fc8:	2280      	movs	r2, #128	@ 0x80
 8003fca:	e9c5 1302 	strd	r1, r3, [r5, #8]
 8003fce:	e9c5 3305 	strd	r3, r3, [r5, #20]
 8003fd2:	e9c5 3307 	strd	r3, r3, [r5, #28]
    __HAL_LINKDMA(huart,hdmarx,hdma_usart2_rx);
 8003fd6:	62b4      	str	r4, [r6, #40]	@ 0x28
    hdma_usart2_tx.Init.Request = DMA_REQUEST_USART2_TX;
 8003fd8:	612a      	str	r2, [r5, #16]
    if (HAL_DMA_Init(&hdma_usart2_tx) != HAL_OK)
 8003fda:	f001 f9c3 	bl	8005364 <HAL_DMA_Init>
 8003fde:	b930      	cbnz	r0, 8003fee <HAL_UART_MspInit+0xd6>
    __HAL_LINKDMA(huart,hdmatx,hdma_usart2_tx);
 8003fe0:	67e5      	str	r5, [r4, #124]	@ 0x7c
 8003fe2:	62ac      	str	r4, [r5, #40]	@ 0x28
}
 8003fe4:	b018      	add	sp, #96	@ 0x60
 8003fe6:	bd70      	pop	{r4, r5, r6, pc}
      Error_Handler();
 8003fe8:	f7fd f8dc 	bl	80011a4 <Error_Handler>
 8003fec:	e7ae      	b.n	8003f4c <HAL_UART_MspInit+0x34>
      Error_Handler();
 8003fee:	f7fd f8d9 	bl	80011a4 <Error_Handler>
 8003ff2:	e7f5      	b.n	8003fe0 <HAL_UART_MspInit+0xc8>
      Error_Handler();
 8003ff4:	f7fd f8d6 	bl	80011a4 <Error_Handler>
 8003ff8:	e7dc      	b.n	8003fb4 <HAL_UART_MspInit+0x9c>
 8003ffa:	bf00      	nop
 8003ffc:	40004400 	.word	0x40004400
 8004000:	40021000 	.word	0x40021000
 8004004:	2000051c 	.word	0x2000051c
 8004008:	40020008 	.word	0x40020008
 800400c:	200004bc 	.word	0x200004bc
 8004010:	4002001c 	.word	0x4002001c

08004014 <HAL_InitTick>:
  uint32_t              uwPrescalerValue = 0;
  uint32_t              pFLatency;
  HAL_StatusTypeDef     status;

  /* Enable TIM6 clock */
  __HAL_RCC_TIM6_CLK_ENABLE();
 8004014:	4b1f      	ldr	r3, [pc, #124]	@ (8004094 <HAL_InitTick+0x80>)
{
 8004016:	b570      	push	{r4, r5, r6, lr}
  __HAL_RCC_TIM6_CLK_ENABLE();
 8004018:	6d9a      	ldr	r2, [r3, #88]	@ 0x58

  /* Compute the prescaler value to have TIM6 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);

  /* Initialize TIM6 */
  htim6.Instance = TIM6;
 800401a:	4c1f      	ldr	r4, [pc, #124]	@ (8004098 <HAL_InitTick+0x84>)
  __HAL_RCC_TIM6_CLK_ENABLE();
 800401c:	f042 0210 	orr.w	r2, r2, #16
 8004020:	659a      	str	r2, [r3, #88]	@ 0x58
 8004022:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
{
 8004024:	b088      	sub	sp, #32
  __HAL_RCC_TIM6_CLK_ENABLE();
 8004026:	f003 0310 	and.w	r3, r3, #16
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 800402a:	a901      	add	r1, sp, #4
  __HAL_RCC_TIM6_CLK_ENABLE();
 800402c:	9302      	str	r3, [sp, #8]
{
 800402e:	4606      	mov	r6, r0
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8004030:	a803      	add	r0, sp, #12
  __HAL_RCC_TIM6_CLK_ENABLE();
 8004032:	9b02      	ldr	r3, [sp, #8]
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8004034:	f001 ff56 	bl	8005ee4 <HAL_RCC_GetClockConfig>
  uwTimclock = HAL_RCC_GetPCLK1Freq();
 8004038:	f001 ff30 	bl	8005e9c <HAL_RCC_GetPCLK1Freq>
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 800403c:	4a17      	ldr	r2, [pc, #92]	@ (800409c <HAL_InitTick+0x88>)
  htim6.Instance = TIM6;
 800403e:	4918      	ldr	r1, [pc, #96]	@ (80040a0 <HAL_InitTick+0x8c>)
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 8004040:	fba2 2300 	umull	r2, r3, r2, r0
 8004044:	0c9b      	lsrs	r3, r3, #18
 8004046:	3b01      	subs	r3, #1
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim6.Init.Period = (1000000U / 1000U) - 1U;
  htim6.Init.Prescaler = uwPrescalerValue;
  htim6.Init.ClockDivision = 0;
 8004048:	2200      	movs	r2, #0
  htim6.Init.Prescaler = uwPrescalerValue;
 800404a:	e9c4 1300 	strd	r1, r3, [r4]
  htim6.Init.CounterMode = TIM_COUNTERMODE_UP;

  status = HAL_TIM_Base_Init(&htim6);
 800404e:	4620      	mov	r0, r4
  htim6.Init.Period = (1000000U / 1000U) - 1U;
 8004050:	f240 33e7 	movw	r3, #999	@ 0x3e7
  htim6.Init.ClockDivision = 0;
 8004054:	6122      	str	r2, [r4, #16]
  htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
 8004056:	60a2      	str	r2, [r4, #8]
  htim6.Init.Period = (1000000U / 1000U) - 1U;
 8004058:	60e3      	str	r3, [r4, #12]
  status = HAL_TIM_Base_Init(&htim6);
 800405a:	f002 f97d 	bl	8006358 <HAL_TIM_Base_Init>
  if (status == HAL_OK)
 800405e:	4605      	mov	r5, r0
 8004060:	b110      	cbz	r0, 8004068 <HAL_InitTick+0x54>
    }
  }

 /* Return function status */
  return status;
}
 8004062:	4628      	mov	r0, r5
 8004064:	b008      	add	sp, #32
 8004066:	bd70      	pop	{r4, r5, r6, pc}
    status = HAL_TIM_Base_Start_IT(&htim6);
 8004068:	4620      	mov	r0, r4
 800406a:	f002 f9f3 	bl	8006454 <HAL_TIM_Base_Start_IT>
    if (status == HAL_OK)
 800406e:	4605      	mov	r5, r0
 8004070:	2800      	cmp	r0, #0
 8004072:	d1f6      	bne.n	8004062 <HAL_InitTick+0x4e>
        HAL_NVIC_EnableIRQ(TIM6_DAC_IRQn);
 8004074:	2036      	movs	r0, #54	@ 0x36
 8004076:	f001 f809 	bl	800508c <HAL_NVIC_EnableIRQ>
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 800407a:	2e0f      	cmp	r6, #15
 800407c:	d901      	bls.n	8004082 <HAL_InitTick+0x6e>
        status = HAL_ERROR;
 800407e:	2501      	movs	r5, #1
 8004080:	e7ef      	b.n	8004062 <HAL_InitTick+0x4e>
        HAL_NVIC_SetPriority(TIM6_DAC_IRQn, TickPriority, 0U);
 8004082:	462a      	mov	r2, r5
 8004084:	4631      	mov	r1, r6
 8004086:	2036      	movs	r0, #54	@ 0x36
 8004088:	f000 ffc4 	bl	8005014 <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 800408c:	4b05      	ldr	r3, [pc, #20]	@ (80040a4 <HAL_InitTick+0x90>)
 800408e:	601e      	str	r6, [r3, #0]
 8004090:	e7e7      	b.n	8004062 <HAL_InitTick+0x4e>
 8004092:	bf00      	nop
 8004094:	40021000 	.word	0x40021000
 8004098:	20001980 	.word	0x20001980
 800409c:	431bde83 	.word	0x431bde83
 80040a0:	40001000 	.word	0x40001000
 80040a4:	2000047c 	.word	0x2000047c

080040a8 <TIM6_DAC_IRQHandler>:

/**
  * @brief This function handles TIM6 global interrupt, DAC1 and DAC3 channel underrun error interrupts.
  */
void TIM6_DAC_IRQHandler(void)
{
 80040a8:	b508      	push	{r3, lr}
  /* USER CODE BEGIN TIM6_DAC_IRQn 0 */

  /* USER CODE END TIM6_DAC_IRQn 0 */
  HAL_TIM_IRQHandler(&htim6);
 80040aa:	4804      	ldr	r0, [pc, #16]	@ (80040bc <TIM6_DAC_IRQHandler+0x14>)
 80040ac:	f002 fb32 	bl	8006714 <HAL_TIM_IRQHandler>
  HAL_DAC_IRQHandler(&hdac1);
  /* USER CODE BEGIN TIM6_DAC_IRQn 1 */

  /* USER CODE END TIM6_DAC_IRQn 1 */
}
 80040b0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_DAC_IRQHandler(&hdac1);
 80040b4:	4802      	ldr	r0, [pc, #8]	@ (80040c0 <TIM6_DAC_IRQHandler+0x18>)
 80040b6:	f001 b829 	b.w	800510c <HAL_DAC_IRQHandler>
 80040ba:	bf00      	nop
 80040bc:	20001980 	.word	0x20001980
 80040c0:	200006a8 	.word	0x200006a8

080040c4 <ADC1_2_IRQHandler>:
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_JEOS);
 80040c4:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
 80040c8:	2240      	movs	r2, #64	@ 0x40
 80040ca:	601a      	str	r2, [r3, #0]

    /* Clear Flags M1 */
    LL_ADC_ClearFlag_JEOS(ADC1);

  /* Highfrequency task */
  (void)TSK_HighFrequencyTask();
 80040cc:	f7fd bb36 	b.w	800173c <TSK_HighFrequencyTask>

080040d0 <TIM1_UP_TIM16_IRQHandler>:
 80040d0:	4b03      	ldr	r3, [pc, #12]	@ (80040e0 <TIM1_UP_TIM16_IRQHandler+0x10>)
 /* USER CODE BEGIN TIMx_UP_M1_IRQn 0 */

 /* USER CODE END  TIMx_UP_M1_IRQn 0 */

  LL_TIM_ClearFlag_UPDATE(TIM1);
  (void)R3_1_TIMx_UP_IRQHandler(&PWM_Handle_M1);
 80040d2:	4804      	ldr	r0, [pc, #16]	@ (80040e4 <TIM1_UP_TIM16_IRQHandler+0x14>)
 80040d4:	f06f 0201 	mvn.w	r2, #1
 80040d8:	611a      	str	r2, [r3, #16]
 80040da:	f005 bae3 	b.w	80096a4 <R3_1_TIMx_UP_IRQHandler>
 80040de:	bf00      	nop
 80040e0:	40012c00 	.word	0x40012c00
 80040e4:	2000005c 	.word	0x2000005c

080040e8 <TIM1_BRK_TIM15_IRQHandler>:

 /* USER CODE END  TIMx_UP_M1_IRQn 1 */
}

void TIMx_BRK_M1_IRQHandler(void)
{
 80040e8:	b508      	push	{r3, lr}
  return ((READ_BIT(TIMx->SR, TIM_SR_BIF) == (TIM_SR_BIF)) ? 1UL : 0UL);
 80040ea:	4b0c      	ldr	r3, [pc, #48]	@ (800411c <TIM1_BRK_TIM15_IRQHandler+0x34>)
 80040ec:	691a      	ldr	r2, [r3, #16]
 80040ee:	0612      	lsls	r2, r2, #24
 80040f0:	d505      	bpl.n	80040fe <TIM1_BRK_TIM15_IRQHandler+0x16>
  WRITE_REG(TIMx->SR, ~(TIM_SR_BIF));
 80040f2:	f06f 0280 	mvn.w	r2, #128	@ 0x80
    /* Nothing to do */
  }
  else
  {
    LL_TIM_ClearFlag_BRK(TIM1);
    PWMC_OCP_Handler(&PWM_Handle_M1._Super);
 80040f6:	480a      	ldr	r0, [pc, #40]	@ (8004120 <TIM1_BRK_TIM15_IRQHandler+0x38>)
 80040f8:	611a      	str	r2, [r3, #16]
 80040fa:	f7fe fa69 	bl	80025d0 <PWMC_OCP_Handler>
  return ((READ_BIT(TIMx->SR, TIM_SR_B2IF) == (TIM_SR_B2IF)) ? 1UL : 0UL);
 80040fe:	4907      	ldr	r1, [pc, #28]	@ (800411c <TIM1_BRK_TIM15_IRQHandler+0x34>)
 8004100:	690b      	ldr	r3, [r1, #16]
 8004102:	05db      	lsls	r3, r3, #23
 8004104:	d505      	bpl.n	8004112 <TIM1_BRK_TIM15_IRQHandler+0x2a>
  WRITE_REG(TIMx->SR, ~(TIM_SR_B2IF));
 8004106:	f46f 7380 	mvn.w	r3, #256	@ 0x100
    /* Nothing to do */
  }
  else
  {
    LL_TIM_ClearFlag_BRK2(TIM1);
    PWMC_OVP_Handler(&PWM_Handle_M1._Super, TIM1);
 800410a:	4805      	ldr	r0, [pc, #20]	@ (8004120 <TIM1_BRK_TIM15_IRQHandler+0x38>)
 800410c:	610b      	str	r3, [r1, #16]
 800410e:	f7fe fa7f 	bl	8002610 <PWMC_OVP_Handler>
  MC_RunMotorControlTasks();

  /* USER CODE BEGIN TIMx_BRK_M1_IRQn 1 */

  /* USER CODE END TIMx_BRK_M1_IRQn 1 */
}
 8004112:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  MC_RunMotorControlTasks();
 8004116:	f7fd baab 	b.w	8001670 <MC_RunMotorControlTasks>
 800411a:	bf00      	nop
 800411c:	40012c00 	.word	0x40012c00
 8004120:	2000005c 	.word	0x2000005c

08004124 <UASPEP_INIT>:
  * @brief  Initialization of the Hardware used for data transmission and reception.
  *
  * @param  pHandle Handler of the current instance of the UASPEP component
  */
void UASPEP_INIT(void *pHWHandle)
{
 8004124:	b430      	push	{r4, r5}
  ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_EIE);
 8004126:	6802      	ldr	r2, [r0, #0]
 8004128:	f102 0108 	add.w	r1, r2, #8
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800412c:	e851 3f00 	ldrex	r3, [r1]
 8004130:	f043 0301 	orr.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004134:	e841 3400 	strex	r4, r3, [r1]
 8004138:	2c00      	cmp	r4, #0
 800413a:	d1f7      	bne.n	800412c <UASPEP_INIT+0x8>
  * @retval None
  */
__STATIC_INLINE void LL_DMA_SetPeriphAddress(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphAddress)
{
  uint32_t dma_base_addr = (uint32_t)DMAx;
  WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CPAR, PeriphAddress);
 800413c:	68c1      	ldr	r1, [r0, #12]
 800413e:	4d19      	ldr	r5, [pc, #100]	@ (80041a4 <UASPEP_INIT+0x80>)
 8004140:	6843      	ldr	r3, [r0, #4]
 8004142:	5c6c      	ldrb	r4, [r5, r1]
 8004144:	4423      	add	r3, r4
    LL_USART_EnableIT_ERROR(pHandle->USARTx);

    /* Write the USART_RDR register address in the DMA control register to configure it as
     * the source of the transfer */
    //cstat !MISRAC2012-Rule-11.4
    LL_DMA_SetPeriphAddress(pHandle->rxDMA, pHandle->rxChannel, (uint32_t)&pHandle->USARTx->RDR);
 8004146:	f102 0124 	add.w	r1, r2, #36	@ 0x24
 800414a:	6099      	str	r1, [r3, #8]
  WRITE_REG(USARTx->ICR, USART_ICR_TCCF);
 800414c:	2340      	movs	r3, #64	@ 0x40
 800414e:	6213      	str	r3, [r2, #32]
  ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAR);
 8004150:	f102 0108 	add.w	r1, r2, #8
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004154:	e851 3f00 	ldrex	r3, [r1]
 8004158:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800415c:	e841 3400 	strex	r4, r3, [r1]
 8004160:	2c00      	cmp	r4, #0
 8004162:	d1f7      	bne.n	8004154 <UASPEP_INIT+0x30>
  WRITE_REG(USARTx->ICR, USART_ICR_TCCF);
 8004164:	2340      	movs	r3, #64	@ 0x40
 8004166:	6213      	str	r3, [r2, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004168:	e852 3f00 	ldrex	r3, [r2]
  ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_TCIE);
 800416c:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004170:	e842 3100 	strex	r1, r3, [r2]
 8004174:	2900      	cmp	r1, #0
 8004176:	d1f7      	bne.n	8004168 <UASPEP_INIT+0x44>
  ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAT);
 8004178:	f102 0108 	add.w	r1, r2, #8
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800417c:	e851 3f00 	ldrex	r3, [r1]
 8004180:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004184:	e841 3400 	strex	r4, r3, [r1]
 8004188:	2c00      	cmp	r4, #0
 800418a:	d1f7      	bne.n	800417c <UASPEP_INIT+0x58>
 800418c:	6901      	ldr	r1, [r0, #16]
 800418e:	6883      	ldr	r3, [r0, #8]
 8004190:	5c69      	ldrb	r1, [r5, r1]
 8004192:	440b      	add	r3, r1
    LL_DMA_SetPeriphAddress(pHandle->txDMA, pHandle->txChannel, (uint32_t)&pHandle->USARTx->TDR);
 8004194:	f102 0028 	add.w	r0, r2, #40	@ 0x28
  WRITE_REG(USARTx->ICR, USART_ICR_TCCF);
 8004198:	2140      	movs	r1, #64	@ 0x40
 800419a:	6098      	str	r0, [r3, #8]
}
 800419c:	bc30      	pop	{r4, r5}
 800419e:	6211      	str	r1, [r2, #32]
 80041a0:	4770      	bx	lr
 80041a2:	bf00      	nop
 80041a4:	0800a59c 	.word	0x0800a59c

080041a8 <UASPEP_CFG_TRANSMISSION>:
  return ((READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CCR,
 80041a8:	6903      	ldr	r3, [r0, #16]
 80041aa:	6880      	ldr	r0, [r0, #8]
  * @param  pHWHandle Hardware components chosen for communication
  * @param  data Data to be transmitted to controller
  * @param  length Length of the data to be transmitted
  */
void UASPEP_CFG_TRANSMISSION(void *pHWHandle, void *data, uint16_t length)
{
 80041ac:	b410      	push	{r4}
 80041ae:	4c0b      	ldr	r4, [pc, #44]	@ (80041dc <UASPEP_CFG_TRANSMISSION+0x34>)
 80041b0:	5ce3      	ldrb	r3, [r4, r3]
 80041b2:	58c4      	ldr	r4, [r0, r3]
                    DMA_CCR_EN) == (DMA_CCR_EN)) ? 1UL : 0UL);
 80041b4:	07e4      	lsls	r4, r4, #31
  return ((READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CCR,
 80041b6:	eb00 0c03 	add.w	ip, r0, r3
                    DMA_CCR_EN) == (DMA_CCR_EN)) ? 1UL : 0UL);
 80041ba:	d40c      	bmi.n	80041d6 <UASPEP_CFG_TRANSMISSION+0x2e>
  WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CMAR, MemoryAddress);
 80041bc:	f8cc 100c 	str.w	r1, [ip, #12]
  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CNDTR,
 80041c0:	f8dc 1004 	ldr.w	r1, [ip, #4]
 80041c4:	0c09      	lsrs	r1, r1, #16
 80041c6:	0409      	lsls	r1, r1, #16
 80041c8:	430a      	orrs	r2, r1
 80041ca:	f8cc 2004 	str.w	r2, [ip, #4]
  SET_BIT(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CCR, DMA_CCR_EN);
 80041ce:	58c2      	ldr	r2, [r0, r3]
 80041d0:	f042 0201 	orr.w	r2, r2, #1
 80041d4:	50c2      	str	r2, [r0, r3]
  }
  else
  {
    /* Nothing to do */
  }
}
 80041d6:	f85d 4b04 	ldr.w	r4, [sp], #4
 80041da:	4770      	bx	lr
 80041dc:	0800a59c 	.word	0x0800a59c

080041e0 <UASPEP_CFG_RECEPTION>:
  * @param  pHWHandle Hardware components chosen for communication
  * @param  buffer Buffer which will receive the communicated data
  * @param  length Length of the received data
  */
void UASPEP_CFG_RECEPTION(void *pHWHandle, void* buffer, uint16_t length)
{
 80041e0:	b430      	push	{r4, r5}
  CLEAR_BIT(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CCR, DMA_CCR_EN);
 80041e2:	68c3      	ldr	r3, [r0, #12]
 80041e4:	4d0b      	ldr	r5, [pc, #44]	@ (8004214 <UASPEP_CFG_RECEPTION+0x34>)
 80041e6:	6844      	ldr	r4, [r0, #4]
 80041e8:	5ce8      	ldrb	r0, [r5, r3]
 80041ea:	5823      	ldr	r3, [r4, r0]
 80041ec:	eb04 0c00 	add.w	ip, r4, r0
 80041f0:	f023 0301 	bic.w	r3, r3, #1
 80041f4:	5023      	str	r3, [r4, r0]
  WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CMAR, MemoryAddress);
 80041f6:	f8cc 100c 	str.w	r1, [ip, #12]
  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CNDTR,
 80041fa:	f8dc 3004 	ldr.w	r3, [ip, #4]
 80041fe:	0c1b      	lsrs	r3, r3, #16
 8004200:	041b      	lsls	r3, r3, #16
 8004202:	4313      	orrs	r3, r2
 8004204:	f8cc 3004 	str.w	r3, [ip, #4]
  SET_BIT(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CCR, DMA_CCR_EN);
 8004208:	5823      	ldr	r3, [r4, r0]
 800420a:	f043 0301 	orr.w	r3, r3, #1
 800420e:	5023      	str	r3, [r4, r0]
  //cstat !MISRAC2012-Rule-11.4 !MISRAC2012-Rule-11.6
  LL_DMA_SetMemoryAddress(pHandle->rxDMA, pHandle->rxChannel, (uint32_t)buffer);
  LL_DMA_SetDataLength(pHandle->rxDMA, pHandle->rxChannel, length);

  LL_DMA_EnableChannel(pHandle->rxDMA, pHandle->rxChannel);
}
 8004210:	bc30      	pop	{r4, r5}
 8004212:	4770      	bx	lr
 8004214:	0800a59c 	.word	0x0800a59c

08004218 <UASPEP_IDLE_ENABLE>:
  * @param  pHandle Handler of the current instance of the UASPEP component
  */
void UASPEP_IDLE_ENABLE(void *pHWHandle)
{
  UASPEP_Handle_t *pHandle = (UASPEP_Handle_t *)pHWHandle; //cstat !MISRAC2012-Rule-11.5
  LL_USART_ClearFlag_IDLE(pHandle->USARTx);
 8004218:	6802      	ldr	r2, [r0, #0]
  WRITE_REG(USARTx->ICR, USART_ICR_IDLECF);
 800421a:	2310      	movs	r3, #16
 800421c:	6213      	str	r3, [r2, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800421e:	e852 3f00 	ldrex	r3, [r2]
  ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 8004222:	f043 0310 	orr.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004226:	e842 3100 	strex	r1, r3, [r2]
 800422a:	2900      	cmp	r1, #0
 800422c:	d1f7      	bne.n	800421e <UASPEP_IDLE_ENABLE+0x6>
  LL_USART_EnableIT_IDLE(pHandle->USARTx);
}
 800422e:	4770      	bx	lr

08004230 <SystemInit>:

void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 8004230:	4a03      	ldr	r2, [pc, #12]	@ (8004240 <SystemInit+0x10>)
 8004232:	f8d2 3088 	ldr.w	r3, [r2, #136]	@ 0x88
 8004236:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 800423a:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  /* Configure the Vector Table location add offset address ------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 800423e:	4770      	bx	lr
 8004240:	e000ed00 	.word	0xe000ed00

08004244 <HAL_Init>:
#if (DATA_CACHE_ENABLE == 0U)
  __HAL_FLASH_DATA_CACHE_DISABLE();
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8004244:	4a0a      	ldr	r2, [pc, #40]	@ (8004270 <HAL_Init+0x2c>)
 8004246:	6813      	ldr	r3, [r2, #0]
 8004248:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
{
 800424c:	b510      	push	{r4, lr}
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800424e:	2003      	movs	r0, #3
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8004250:	6013      	str	r3, [r2, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8004252:	f000 fecd 	bl	8004ff0 <HAL_NVIC_SetPriorityGrouping>

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8004256:	2000      	movs	r0, #0
 8004258:	f7ff fedc 	bl	8004014 <HAL_InitTick>
 800425c:	b110      	cbz	r0, 8004264 <HAL_Init+0x20>
  {
    status = HAL_ERROR;
 800425e:	2401      	movs	r4, #1
  }

  /* Return function status */
  return status;

}
 8004260:	4620      	mov	r0, r4
 8004262:	bd10      	pop	{r4, pc}
 8004264:	4604      	mov	r4, r0
    HAL_MspInit();
 8004266:	f7ff fcb7 	bl	8003bd8 <HAL_MspInit>
}
 800426a:	4620      	mov	r0, r4
 800426c:	bd10      	pop	{r4, pc}
 800426e:	bf00      	nop
 8004270:	40022000 	.word	0x40022000

08004274 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 8004274:	4a03      	ldr	r2, [pc, #12]	@ (8004284 <HAL_IncTick+0x10>)
 8004276:	4904      	ldr	r1, [pc, #16]	@ (8004288 <HAL_IncTick+0x14>)
 8004278:	6813      	ldr	r3, [r2, #0]
 800427a:	6809      	ldr	r1, [r1, #0]
 800427c:	440b      	add	r3, r1
 800427e:	6013      	str	r3, [r2, #0]
}
 8004280:	4770      	bx	lr
 8004282:	bf00      	nop
 8004284:	200019cc 	.word	0x200019cc
 8004288:	20000478 	.word	0x20000478

0800428c <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 800428c:	4b01      	ldr	r3, [pc, #4]	@ (8004294 <HAL_GetTick+0x8>)
 800428e:	6818      	ldr	r0, [r3, #0]
}
 8004290:	4770      	bx	lr
 8004292:	bf00      	nop
 8004294:	200019cc 	.word	0x200019cc

08004298 <HAL_ADC_Init>:
  *         without  disabling the other ADCs.
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef *hadc)
{
 8004298:	b530      	push	{r4, r5, lr}
 800429a:	b083      	sub	sp, #12
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  uint32_t tmp_cfgr;
  uint32_t tmp_adc_is_conversion_on_going_regular;
  uint32_t tmp_adc_is_conversion_on_going_injected;
  __IO uint32_t wait_loop_index = 0UL;
 800429c:	2300      	movs	r3, #0
 800429e:	9301      	str	r3, [sp, #4]

  /* Check ADC handle */
  if (hadc == NULL)
 80042a0:	2800      	cmp	r0, #0
 80042a2:	f000 80ac 	beq.w	80043fe <HAL_ADC_Init+0x166>
  /* DISCEN and CONT bits cannot be set at the same time */
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));

  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if (hadc->State == HAL_ADC_STATE_RESET)
 80042a6:	6dc5      	ldr	r5, [r0, #92]	@ 0x5c
 80042a8:	4604      	mov	r4, r0
 80042aa:	2d00      	cmp	r5, #0
 80042ac:	f000 80ac 	beq.w	8004408 <HAL_ADC_Init+0x170>
    /* Initialize Lock */
    hadc->Lock = HAL_UNLOCKED;
  }

  /* - Exit from deep-power-down mode and ADC voltage regulator enable        */
  if (LL_ADC_IsDeepPowerDownEnabled(hadc->Instance) != 0UL)
 80042b0:	6822      	ldr	r2, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_DEEPPWD) == (ADC_CR_DEEPPWD)) ? 1UL : 0UL);
 80042b2:	6893      	ldr	r3, [r2, #8]
 80042b4:	009d      	lsls	r5, r3, #2
 80042b6:	d505      	bpl.n	80042c4 <HAL_ADC_Init+0x2c>
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
 80042b8:	6893      	ldr	r3, [r2, #8]
 80042ba:	f023 4320 	bic.w	r3, r3, #2684354560	@ 0xa0000000
 80042be:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
 80042c2:	6093      	str	r3, [r2, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 80042c4:	6893      	ldr	r3, [r2, #8]
 80042c6:	00d8      	lsls	r0, r3, #3
 80042c8:	d419      	bmi.n	80042fe <HAL_ADC_Init+0x66>
    LL_ADC_EnableInternalRegulator(hadc->Instance);

    /* Note: Variable divided by 2 to compensate partially              */
    /*       CPU processing cycles, scaling in us split to not          */
    /*       exceed 32 bits register capacity and handle low frequency. */
    wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 80042ca:	4b6b      	ldr	r3, [pc, #428]	@ (8004478 <HAL_ADC_Init+0x1e0>)
 80042cc:	486b      	ldr	r0, [pc, #428]	@ (800447c <HAL_ADC_Init+0x1e4>)
 80042ce:	681b      	ldr	r3, [r3, #0]
  MODIFY_REG(ADCx->CR,
 80042d0:	6891      	ldr	r1, [r2, #8]
 80042d2:	099b      	lsrs	r3, r3, #6
 80042d4:	fba0 0303 	umull	r0, r3, r0, r3
 80042d8:	f021 4110 	bic.w	r1, r1, #2415919104	@ 0x90000000
 80042dc:	099b      	lsrs	r3, r3, #6
 80042de:	f021 013f 	bic.w	r1, r1, #63	@ 0x3f
 80042e2:	3301      	adds	r3, #1
 80042e4:	005b      	lsls	r3, r3, #1
 80042e6:	f041 5180 	orr.w	r1, r1, #268435456	@ 0x10000000
 80042ea:	6091      	str	r1, [r2, #8]
 80042ec:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 80042ee:	9b01      	ldr	r3, [sp, #4]
 80042f0:	b12b      	cbz	r3, 80042fe <HAL_ADC_Init+0x66>
    {
      wait_loop_index--;
 80042f2:	9b01      	ldr	r3, [sp, #4]
 80042f4:	3b01      	subs	r3, #1
 80042f6:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 80042f8:	9b01      	ldr	r3, [sp, #4]
 80042fa:	2b00      	cmp	r3, #0
 80042fc:	d1f9      	bne.n	80042f2 <HAL_ADC_Init+0x5a>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 80042fe:	6893      	ldr	r3, [r2, #8]
 8004300:	00d9      	lsls	r1, r3, #3
 8004302:	d47f      	bmi.n	8004404 <HAL_ADC_Init+0x16c>
  /* or not ADC is coming from state reset (if any potential problem of       */
  /* clocking, voltage regulator would not be enabled).                       */
  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8004304:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 8004306:	f043 0310 	orr.w	r3, r3, #16
 800430a:	65e3      	str	r3, [r4, #92]	@ 0x5c

    /* Set ADC error code to ADC peripheral internal error */
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 800430c:	6e23      	ldr	r3, [r4, #96]	@ 0x60

    tmp_hal_status = HAL_ERROR;
 800430e:	2001      	movs	r0, #1
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8004310:	4303      	orrs	r3, r0
 8004312:	6623      	str	r3, [r4, #96]	@ 0x60
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8004314:	6893      	ldr	r3, [r2, #8]
 8004316:	f013 0f04 	tst.w	r3, #4
  /* correctly completed and if there is no conversion on going on regular    */
  /* group (ADC may already be enabled at this point if HAL_ADC_Init() is     */
  /* called to update a parameter on the fly).                                */
  tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);

  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 800431a:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 800431c:	d16b      	bne.n	80043f6 <HAL_ADC_Init+0x15e>
 800431e:	06db      	lsls	r3, r3, #27
 8004320:	d469      	bmi.n	80043f6 <HAL_ADC_Init+0x15e>
      && (tmp_adc_is_conversion_on_going_regular == 0UL)
     )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 8004322:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 8004324:	f423 7381 	bic.w	r3, r3, #258	@ 0x102
 8004328:	f043 0302 	orr.w	r3, r3, #2
 800432c:	65e3      	str	r3, [r4, #92]	@ 0x5c
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 800432e:	6893      	ldr	r3, [r2, #8]
 8004330:	07dd      	lsls	r5, r3, #31
 8004332:	d409      	bmi.n	8004348 <HAL_ADC_Init+0xb0>
 8004334:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
 8004338:	689b      	ldr	r3, [r3, #8]
 800433a:	f013 0f01 	tst.w	r3, #1
 800433e:	4b50      	ldr	r3, [pc, #320]	@ (8004480 <HAL_ADC_Init+0x1e8>)
 8004340:	689b      	ldr	r3, [r3, #8]
 8004342:	d101      	bne.n	8004348 <HAL_ADC_Init+0xb0>
 8004344:	07d9      	lsls	r1, r3, #31
 8004346:	d572      	bpl.n	800442e <HAL_ADC_Init+0x196>
    /*  - overrun                                  Init.Overrun               */
    /*  - discontinuous mode                       Init.DiscontinuousConvMode */
    /*  - discontinuous mode channel count         Init.NbrOfDiscConversion   */
    tmp_cfgr  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
                 hadc->Init.Overrun                                                     |
                 hadc->Init.DataAlign                                                   |
 8004348:	68e5      	ldr	r5, [r4, #12]
 800434a:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
                 hadc->Init.Resolution                                                  |
                 ADC_CFGR_REG_DISCONTINUOUS((uint32_t)hadc->Init.DiscontinuousConvMode));
 800434c:	f894 1024 	ldrb.w	r1, [r4, #36]	@ 0x24
                 hadc->Init.DataAlign                                                   |
 8004350:	432b      	orrs	r3, r5
 8004352:	68a5      	ldr	r5, [r4, #8]
 8004354:	432b      	orrs	r3, r5
    tmp_cfgr  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 8004356:	7f65      	ldrb	r5, [r4, #29]

    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8004358:	2901      	cmp	r1, #1
                 hadc->Init.DataAlign                                                   |
 800435a:	ea43 3345 	orr.w	r3, r3, r5, lsl #13
    tmp_cfgr  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 800435e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8004362:	d057      	beq.n	8004414 <HAL_ADC_Init+0x17c>
    /* Enable external trigger if trigger selection is different of software  */
    /* start.                                                                 */
    /* Note: This configuration keeps the hardware feature of parameter       */
    /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    /*       software start.                                                  */
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8004364:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 8004366:	b121      	cbz	r1, 8004372 <HAL_ADC_Init+0xda>
    {
      tmp_cfgr |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
                   | hadc->Init.ExternalTrigConvEdge
 8004368:	6b25      	ldr	r5, [r4, #48]	@ 0x30
      tmp_cfgr |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 800436a:	f401 7178 	and.w	r1, r1, #992	@ 0x3e0
                   | hadc->Init.ExternalTrigConvEdge
 800436e:	4329      	orrs	r1, r5
      tmp_cfgr |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 8004370:	430b      	orrs	r3, r1
                  );
    }

    /* Update Configuration Register CFGR */
    MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_1, tmp_cfgr);
 8004372:	68d5      	ldr	r5, [r2, #12]
 8004374:	4943      	ldr	r1, [pc, #268]	@ (8004484 <HAL_ADC_Init+0x1ec>)
 8004376:	4029      	ands	r1, r5
 8004378:	4319      	orrs	r1, r3
 800437a:	60d1      	str	r1, [r2, #12]

    /* Configuration of sampling mode */
    MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_BULB | ADC_CFGR2_SMPTRIG, hadc->Init.SamplingMode);
 800437c:	6913      	ldr	r3, [r2, #16]
 800437e:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 8004380:	f023 6340 	bic.w	r3, r3, #201326592	@ 0xc000000
 8004384:	430b      	orrs	r3, r1
 8004386:	6113      	str	r3, [r2, #16]
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8004388:	6893      	ldr	r3, [r2, #8]
 800438a:	071b      	lsls	r3, r3, #28
 800438c:	d424      	bmi.n	80043d8 <HAL_ADC_Init+0x140>
    {
      tmp_cfgr = (ADC_CFGR_DFSDM(hadc)                                            |
                   ADC_CFGR_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
                   ADC_CFGR_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests));

      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmp_cfgr);
 800438e:	68d1      	ldr	r1, [r2, #12]
                   ADC_CFGR_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests));
 8004390:	f894 3038 	ldrb.w	r3, [r4, #56]	@ 0x38
                   ADC_CFGR_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
 8004394:	7f25      	ldrb	r5, [r4, #28]
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmp_cfgr);
 8004396:	f421 4180 	bic.w	r1, r1, #16384	@ 0x4000
                   ADC_CFGR_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests));
 800439a:	005b      	lsls	r3, r3, #1
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmp_cfgr);
 800439c:	f021 0102 	bic.w	r1, r1, #2
      tmp_cfgr = (ADC_CFGR_DFSDM(hadc)                                            |
 80043a0:	ea43 3385 	orr.w	r3, r3, r5, lsl #14
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmp_cfgr);
 80043a4:	430b      	orrs	r3, r1

      if (hadc->Init.GainCompensation != 0UL)
 80043a6:	6921      	ldr	r1, [r4, #16]
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmp_cfgr);
 80043a8:	60d3      	str	r3, [r2, #12]
      {
        SET_BIT(hadc->Instance->CFGR2, ADC_CFGR2_GCOMP);
 80043aa:	6913      	ldr	r3, [r2, #16]
      if (hadc->Init.GainCompensation != 0UL)
 80043ac:	2900      	cmp	r1, #0
 80043ae:	d046      	beq.n	800443e <HAL_ADC_Init+0x1a6>
        SET_BIT(hadc->Instance->CFGR2, ADC_CFGR2_GCOMP);
 80043b0:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 80043b4:	6113      	str	r3, [r2, #16]
        MODIFY_REG(hadc->Instance->GCOMP, ADC_GCOMP_GCOMPCOEFF, hadc->Init.GainCompensation);
 80043b6:	f8d2 30c0 	ldr.w	r3, [r2, #192]	@ 0xc0
 80043ba:	f423 537f 	bic.w	r3, r3, #16320	@ 0x3fc0
 80043be:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
 80043c2:	430b      	orrs	r3, r1
 80043c4:	f8c2 30c0 	str.w	r3, [r2, #192]	@ 0xc0
      {
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_GCOMP);
        MODIFY_REG(hadc->Instance->GCOMP, ADC_GCOMP_GCOMPCOEFF, 0UL);
      }

      if (hadc->Init.OversamplingMode == ENABLE)
 80043c8:	f894 3040 	ldrb.w	r3, [r4, #64]	@ 0x40
 80043cc:	2b01      	cmp	r3, #1
 80043ce:	d042      	beq.n	8004456 <HAL_ADC_Init+0x1be>
                  );
      }
      else
      {
        /* Disable ADC oversampling scope on ADC group regular */
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE);
 80043d0:	6913      	ldr	r3, [r2, #16]
 80043d2:	f023 0301 	bic.w	r3, r3, #1
 80043d6:	6113      	str	r3, [r2, #16]
    /*   Note: Scan mode is not present by hardware on this device, but       */
    /*   emulated by software for alignment over all STM32 devices.           */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion".                                         */

    if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
 80043d8:	6963      	ldr	r3, [r4, #20]
 80043da:	2b01      	cmp	r3, #1
 80043dc:	d01f      	beq.n	800441e <HAL_ADC_Init+0x186>
      /* Set number of ranks in regular group sequencer */
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
    }
    else
    {
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
 80043de:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 80043e0:	f023 030f 	bic.w	r3, r3, #15
 80043e4:	6313      	str	r3, [r2, #48]	@ 0x30
    }

    /* Initialize the ADC state */
    /* Clear HAL_ADC_STATE_BUSY_INTERNAL bit, set HAL_ADC_STATE_READY bit */
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
 80043e6:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 80043e8:	f023 0303 	bic.w	r3, r3, #3
 80043ec:	f043 0301 	orr.w	r3, r3, #1
 80043f0:	65e3      	str	r3, [r4, #92]	@ 0x5c
    tmp_hal_status = HAL_ERROR;
  }

  /* Return function status */
  return tmp_hal_status;
}
 80043f2:	b003      	add	sp, #12
 80043f4:	bd30      	pop	{r4, r5, pc}
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 80043f6:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 80043f8:	f043 0310 	orr.w	r3, r3, #16
 80043fc:	65e3      	str	r3, [r4, #92]	@ 0x5c
    return HAL_ERROR;
 80043fe:	2001      	movs	r0, #1
}
 8004400:	b003      	add	sp, #12
 8004402:	bd30      	pop	{r4, r5, pc}
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8004404:	2000      	movs	r0, #0
 8004406:	e785      	b.n	8004314 <HAL_ADC_Init+0x7c>
    HAL_ADC_MspInit(hadc);
 8004408:	f7ff fc08 	bl	8003c1c <HAL_ADC_MspInit>
    ADC_CLEAR_ERRORCODE(hadc);
 800440c:	6625      	str	r5, [r4, #96]	@ 0x60
    hadc->Lock = HAL_UNLOCKED;
 800440e:	f884 5058 	strb.w	r5, [r4, #88]	@ 0x58
 8004412:	e74d      	b.n	80042b0 <HAL_ADC_Init+0x18>
      tmp_cfgr |= ADC_CFGR_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion);
 8004414:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 8004416:	3901      	subs	r1, #1
 8004418:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
 800441c:	e7a2      	b.n	8004364 <HAL_ADC_Init+0xcc>
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
 800441e:	6b11      	ldr	r1, [r2, #48]	@ 0x30
 8004420:	6a23      	ldr	r3, [r4, #32]
 8004422:	f021 010f 	bic.w	r1, r1, #15
 8004426:	3b01      	subs	r3, #1
 8004428:	430b      	orrs	r3, r1
 800442a:	6313      	str	r3, [r2, #48]	@ 0x30
 800442c:	e7db      	b.n	80043e6 <HAL_ADC_Init+0x14e>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_CKMODE | ADC_CCR_PRESC, CommonClock);
 800442e:	4916      	ldr	r1, [pc, #88]	@ (8004488 <HAL_ADC_Init+0x1f0>)
 8004430:	6865      	ldr	r5, [r4, #4]
 8004432:	688b      	ldr	r3, [r1, #8]
 8004434:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
 8004438:	432b      	orrs	r3, r5
 800443a:	608b      	str	r3, [r1, #8]
}
 800443c:	e784      	b.n	8004348 <HAL_ADC_Init+0xb0>
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_GCOMP);
 800443e:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8004442:	6113      	str	r3, [r2, #16]
        MODIFY_REG(hadc->Instance->GCOMP, ADC_GCOMP_GCOMPCOEFF, 0UL);
 8004444:	f8d2 30c0 	ldr.w	r3, [r2, #192]	@ 0xc0
 8004448:	f423 537f 	bic.w	r3, r3, #16320	@ 0x3fc0
 800444c:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
 8004450:	f8c2 30c0 	str.w	r3, [r2, #192]	@ 0xc0
 8004454:	e7b8      	b.n	80043c8 <HAL_ADC_Init+0x130>
        MODIFY_REG(hadc->Instance->CFGR2,
 8004456:	6911      	ldr	r1, [r2, #16]
 8004458:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 800445a:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
 800445c:	f421 61ff 	bic.w	r1, r1, #2040	@ 0x7f8
 8004460:	f021 0104 	bic.w	r1, r1, #4
 8004464:	432b      	orrs	r3, r5
 8004466:	430b      	orrs	r3, r1
 8004468:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
 800446a:	430b      	orrs	r3, r1
 800446c:	6d21      	ldr	r1, [r4, #80]	@ 0x50
 800446e:	430b      	orrs	r3, r1
 8004470:	f043 0301 	orr.w	r3, r3, #1
 8004474:	6113      	str	r3, [r2, #16]
 8004476:	e7af      	b.n	80043d8 <HAL_ADC_Init+0x140>
 8004478:	20000474 	.word	0x20000474
 800447c:	053e2d63 	.word	0x053e2d63
 8004480:	50000100 	.word	0x50000100
 8004484:	fff04007 	.word	0xfff04007
 8004488:	50000300 	.word	0x50000300

0800448c <HAL_ADC_ConfigChannel>:
  * @param hadc ADC handle
  * @param pConfig Structure of ADC channel assigned to ADC group regular.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef *hadc, const ADC_ChannelConfTypeDef *pConfig)
{
 800448c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  {
    assert_param(IS_ADC_DIFF_CHANNEL(hadc, pConfig->Channel));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 8004490:	f890 2058 	ldrb.w	r2, [r0, #88]	@ 0x58
{
 8004494:	b082      	sub	sp, #8
 8004496:	4603      	mov	r3, r0
  __HAL_LOCK(hadc);
 8004498:	2a01      	cmp	r2, #1
  __IO uint32_t wait_loop_index = 0UL;
 800449a:	f04f 0000 	mov.w	r0, #0
 800449e:	9001      	str	r0, [sp, #4]
  __HAL_LOCK(hadc);
 80044a0:	f000 812c 	beq.w	80046fc <HAL_ADC_ConfigChannel+0x270>
  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel rank                                                          */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 80044a4:	681a      	ldr	r2, [r3, #0]
  __HAL_LOCK(hadc);
 80044a6:	2001      	movs	r0, #1
 80044a8:	f883 0058 	strb.w	r0, [r3, #88]	@ 0x58
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 80044ac:	6894      	ldr	r4, [r2, #8]
 80044ae:	0764      	lsls	r4, r4, #29
 80044b0:	d455      	bmi.n	800455e <HAL_ADC_ConfigChannel+0xd2>
  {
    /* Set ADC group regular sequence: channel on the selected scan sequence rank */
    LL_ADC_REG_SetSequencerRanks(hadc->Instance, pConfig->Rank, pConfig->Channel);
 80044b2:	6848      	ldr	r0, [r1, #4]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1,
 80044b4:	ea4f 1e90 	mov.w	lr, r0, lsr #6
  MODIFY_REG(*preg,
 80044b8:	f000 0c1f 	and.w	ip, r0, #31
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1,
 80044bc:	f00e 0e0c 	and.w	lr, lr, #12
  MODIFY_REG(*preg,
 80044c0:	6808      	ldr	r0, [r1, #0]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1,
 80044c2:	f102 0430 	add.w	r4, r2, #48	@ 0x30
  MODIFY_REG(*preg,
 80044c6:	f3c0 6084 	ubfx	r0, r0, #26, #5
 80044ca:	f854 500e 	ldr.w	r5, [r4, lr]
 80044ce:	261f      	movs	r6, #31
 80044d0:	fa00 f00c 	lsl.w	r0, r0, ip
 80044d4:	fa06 fc0c 	lsl.w	ip, r6, ip
 80044d8:	ea25 0c0c 	bic.w	ip, r5, ip
 80044dc:	ea40 000c 	orr.w	r0, r0, ip
 80044e0:	f844 000e 	str.w	r0, [r4, lr]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 80044e4:	6890      	ldr	r0, [r2, #8]
 80044e6:	0747      	lsls	r7, r0, #29
 80044e8:	d543      	bpl.n	8004572 <HAL_ADC_ConfigChannel+0xe6>
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 80044ea:	6890      	ldr	r0, [r2, #8]
    {
      /* Manage specific case of sampling time 3.5 cycles replacing 2.5 cyles */
      if (pConfig->SamplingTime == ADC_SAMPLETIME_3CYCLES_5)
      {
        /* Set sampling time of the selected ADC channel */
        LL_ADC_SetChannelSamplingTime(hadc->Instance, pConfig->Channel, LL_ADC_SAMPLINGTIME_2CYCLES_5);
 80044ec:	6808      	ldr	r0, [r1, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 80044ee:	6894      	ldr	r4, [r2, #8]
 80044f0:	07e5      	lsls	r5, r4, #31
 80044f2:	d412      	bmi.n	800451a <HAL_ADC_ConfigChannel+0x8e>
    /* Parameters that can be updated only when ADC is disabled:                */
    /*  - Single or differential mode                                           */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
    {
      /* Set mode single-ended or differential input of the selected ADC channel */
      LL_ADC_SetChannelSingleDiff(hadc->Instance, pConfig->Channel, pConfig->SingleDiff);
 80044f4:	68ce      	ldr	r6, [r1, #12]
  MODIFY_REG(ADCx->DIFSEL,
 80044f6:	4cc0      	ldr	r4, [pc, #768]	@ (80047f8 <HAL_ADC_ConfigChannel+0x36c>)
 80044f8:	f8d2 50b0 	ldr.w	r5, [r2, #176]	@ 0xb0
 80044fc:	f006 0718 	and.w	r7, r6, #24
 8004500:	40fc      	lsrs	r4, r7
 8004502:	f3c0 0712 	ubfx	r7, r0, #0, #19
 8004506:	4004      	ands	r4, r0
 8004508:	ea25 0507 	bic.w	r5, r5, r7
 800450c:	432c      	orrs	r4, r5
 800450e:	f8c2 40b0 	str.w	r4, [r2, #176]	@ 0xb0

      /* Configuration of differential mode */
      if (pConfig->SingleDiff == ADC_DIFFERENTIAL_ENDED)
 8004512:	4cba      	ldr	r4, [pc, #744]	@ (80047fc <HAL_ADC_ConfigChannel+0x370>)
 8004514:	42a6      	cmp	r6, r4
 8004516:	f000 80a1 	beq.w	800465c <HAL_ADC_ConfigChannel+0x1d0>
    /* If internal channel selected, enable dedicated internal buffers and    */
    /* paths.                                                                 */
    /* Note: these internal measurement paths can be disabled using           */
    /* HAL_ADC_DeInit().                                                      */

    if (__LL_ADC_IS_CHANNEL_INTERNAL(pConfig->Channel))
 800451a:	49b9      	ldr	r1, [pc, #740]	@ (8004800 <HAL_ADC_ConfigChannel+0x374>)
 800451c:	4208      	tst	r0, r1
 800451e:	d01c      	beq.n	800455a <HAL_ADC_ConfigChannel+0xce>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL));
 8004520:	4cb8      	ldr	r4, [pc, #736]	@ (8004804 <HAL_ADC_ConfigChannel+0x378>)
    {
      tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));

      /* If the requested internal measurement path has already been enabled, */
      /* bypass the configuration processing.                                 */
      if (((pConfig->Channel == ADC_CHANNEL_TEMPSENSOR_ADC1) || (pConfig->Channel == ADC_CHANNEL_TEMPSENSOR_ADC5))
 8004522:	4db9      	ldr	r5, [pc, #740]	@ (8004808 <HAL_ADC_ConfigChannel+0x37c>)
 8004524:	68a1      	ldr	r1, [r4, #8]
 8004526:	42a8      	cmp	r0, r5
 8004528:	f001 76e0 	and.w	r6, r1, #29360128	@ 0x1c00000
 800452c:	d073      	beq.n	8004616 <HAL_ADC_ConfigChannel+0x18a>
 800452e:	4db7      	ldr	r5, [pc, #732]	@ (800480c <HAL_ADC_ConfigChannel+0x380>)
 8004530:	42a8      	cmp	r0, r5
 8004532:	d070      	beq.n	8004616 <HAL_ADC_ConfigChannel+0x18a>
          {
            wait_loop_index--;
          }
        }
      }
      else if ((pConfig->Channel == ADC_CHANNEL_VBAT)
 8004534:	4db6      	ldr	r5, [pc, #728]	@ (8004810 <HAL_ADC_ConfigChannel+0x384>)
 8004536:	42a8      	cmp	r0, r5
 8004538:	f000 80e4 	beq.w	8004704 <HAL_ADC_ConfigChannel+0x278>
        {
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
                                         LL_ADC_PATH_INTERNAL_VBAT | tmp_config_internal_channel);
        }
      }
      else if ((pConfig->Channel == ADC_CHANNEL_VREFINT)
 800453c:	4db5      	ldr	r5, [pc, #724]	@ (8004814 <HAL_ADC_ConfigChannel+0x388>)
 800453e:	42a8      	cmp	r0, r5
 8004540:	d10b      	bne.n	800455a <HAL_ADC_ConfigChannel+0xce>
               && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
 8004542:	0249      	lsls	r1, r1, #9
 8004544:	d409      	bmi.n	800455a <HAL_ADC_ConfigChannel+0xce>
      {
        if (ADC_VREFINT_INSTANCE(hadc))
 8004546:	49b4      	ldr	r1, [pc, #720]	@ (8004818 <HAL_ADC_ConfigChannel+0x38c>)
 8004548:	428a      	cmp	r2, r1
 800454a:	d006      	beq.n	800455a <HAL_ADC_ConfigChannel+0xce>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL, PathInternal);
 800454c:	68a2      	ldr	r2, [r4, #8]
 800454e:	f022 72e0 	bic.w	r2, r2, #29360128	@ 0x1c00000
 8004552:	4332      	orrs	r2, r6
 8004554:	f442 0280 	orr.w	r2, r2, #4194304	@ 0x400000
 8004558:	60a2      	str	r2, [r4, #8]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 800455a:	2000      	movs	r0, #0
 800455c:	e003      	b.n	8004566 <HAL_ADC_ConfigChannel+0xda>
  /* channel could be done on neither of the channel configuration structure  */
  /* parameters.                                                              */
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 800455e:	6dda      	ldr	r2, [r3, #92]	@ 0x5c
 8004560:	f042 0220 	orr.w	r2, r2, #32
 8004564:	65da      	str	r2, [r3, #92]	@ 0x5c

    tmp_hal_status = HAL_ERROR;
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8004566:	2200      	movs	r2, #0
 8004568:	f883 2058 	strb.w	r2, [r3, #88]	@ 0x58

  /* Return function status */
  return tmp_hal_status;
}
 800456c:	b002      	add	sp, #8
 800456e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8004572:	6894      	ldr	r4, [r2, #8]
        LL_ADC_SetChannelSamplingTime(hadc->Instance, pConfig->Channel, LL_ADC_SAMPLINGTIME_2CYCLES_5);
 8004574:	6808      	ldr	r0, [r1, #0]
 8004576:	0726      	lsls	r6, r4, #28
 8004578:	d4b9      	bmi.n	80044ee <HAL_ADC_ConfigChannel+0x62>
      if (pConfig->SamplingTime == ADC_SAMPLETIME_3CYCLES_5)
 800457a:	688d      	ldr	r5, [r1, #8]
  MODIFY_REG(*preg,
 800457c:	f3c0 5604 	ubfx	r6, r0, #20, #5
 8004580:	2407      	movs	r4, #7
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1,
 8004582:	0dc0      	lsrs	r0, r0, #23
  MODIFY_REG(*preg,
 8004584:	40b4      	lsls	r4, r6
 8004586:	f1b5 4f00 	cmp.w	r5, #2147483648	@ 0x80000000
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1,
 800458a:	f000 0004 	and.w	r0, r0, #4
  MODIFY_REG(*preg,
 800458e:	ea6f 0404 	mvn.w	r4, r4
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1,
 8004592:	f102 0714 	add.w	r7, r2, #20
 8004596:	f000 8100 	beq.w	800479a <HAL_ADC_ConfigChannel+0x30e>
  MODIFY_REG(*preg,
 800459a:	40b5      	lsls	r5, r6
 800459c:	583e      	ldr	r6, [r7, r0]
 800459e:	4034      	ands	r4, r6
 80045a0:	432c      	orrs	r4, r5
 80045a2:	503c      	str	r4, [r7, r0]
  MODIFY_REG(ADCx->SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);
 80045a4:	6950      	ldr	r0, [r2, #20]
 80045a6:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
 80045aa:	6150      	str	r0, [r2, #20]
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)pConfig->Offset);
 80045ac:	e9d1 7504 	ldrd	r7, r5, [r1, #16]
        LL_ADC_SetOffset(hadc->Instance, pConfig->OffsetNumber, pConfig->Channel, tmpOffsetShifted);
 80045b0:	6808      	ldr	r0, [r1, #0]
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)pConfig->Offset);
 80045b2:	68d6      	ldr	r6, [r2, #12]
      if (pConfig->OffsetNumber != ADC_OFFSET_NONE)
 80045b4:	2f04      	cmp	r7, #4
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80045b6:	f102 0460 	add.w	r4, r2, #96	@ 0x60
        LL_ADC_SetOffset(hadc->Instance, pConfig->OffsetNumber, pConfig->Channel, tmpOffsetShifted);
 80045ba:	4684      	mov	ip, r0
      if (pConfig->OffsetNumber != ADC_OFFSET_NONE)
 80045bc:	f000 80c5 	beq.w	800474a <HAL_ADC_ConfigChannel+0x2be>
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)pConfig->Offset);
 80045c0:	f3c6 06c1 	ubfx	r6, r6, #3, #2
 80045c4:	0076      	lsls	r6, r6, #1
  MODIFY_REG(*preg,
 80045c6:	f854 c027 	ldr.w	ip, [r4, r7, lsl #2]
 80045ca:	40b5      	lsls	r5, r6
 80045cc:	4e93      	ldr	r6, [pc, #588]	@ (800481c <HAL_ADC_ConfigChannel+0x390>)
 80045ce:	f000 40f8 	and.w	r0, r0, #2080374784	@ 0x7c000000
 80045d2:	ea0c 0606 	and.w	r6, ip, r6
 80045d6:	4306      	orrs	r6, r0
 80045d8:	4335      	orrs	r5, r6
 80045da:	f045 4500 	orr.w	r5, r5, #2147483648	@ 0x80000000
 80045de:	f844 5027 	str.w	r5, [r4, r7, lsl #2]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80045e2:	690d      	ldr	r5, [r1, #16]
  MODIFY_REG(*preg,
 80045e4:	698e      	ldr	r6, [r1, #24]
 80045e6:	f854 0025 	ldr.w	r0, [r4, r5, lsl #2]
 80045ea:	f020 7080 	bic.w	r0, r0, #16777216	@ 0x1000000
 80045ee:	4330      	orrs	r0, r6
 80045f0:	f844 0025 	str.w	r0, [r4, r5, lsl #2]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80045f4:	690e      	ldr	r6, [r1, #16]
        LL_ADC_SetOffsetSaturation(hadc->Instance, pConfig->OffsetNumber,
 80045f6:	7f0d      	ldrb	r5, [r1, #28]
  MODIFY_REG(*preg,
 80045f8:	f854 0026 	ldr.w	r0, [r4, r6, lsl #2]
 80045fc:	f1a5 0501 	sub.w	r5, r5, #1
 8004600:	fab5 f585 	clz	r5, r5
 8004604:	096d      	lsrs	r5, r5, #5
 8004606:	f020 7000 	bic.w	r0, r0, #33554432	@ 0x2000000
 800460a:	ea40 6045 	orr.w	r0, r0, r5, lsl #25
 800460e:	f844 0026 	str.w	r0, [r4, r6, lsl #2]
      LL_ADC_SetChannelSingleDiff(hadc->Instance, pConfig->Channel, pConfig->SingleDiff);
 8004612:	6808      	ldr	r0, [r1, #0]
}
 8004614:	e76b      	b.n	80044ee <HAL_ADC_ConfigChannel+0x62>
          && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
 8004616:	020c      	lsls	r4, r1, #8
 8004618:	d49f      	bmi.n	800455a <HAL_ADC_ConfigChannel+0xce>
        if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 800461a:	f1b2 4fa0 	cmp.w	r2, #1342177280	@ 0x50000000
 800461e:	d19c      	bne.n	800455a <HAL_ADC_ConfigChannel+0xce>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL, PathInternal);
 8004620:	4978      	ldr	r1, [pc, #480]	@ (8004804 <HAL_ADC_ConfigChannel+0x378>)
          wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 8004622:	487f      	ldr	r0, [pc, #508]	@ (8004820 <HAL_ADC_ConfigChannel+0x394>)
 8004624:	688a      	ldr	r2, [r1, #8]
 8004626:	f022 72e0 	bic.w	r2, r2, #29360128	@ 0x1c00000
 800462a:	4332      	orrs	r2, r6
 800462c:	f442 0200 	orr.w	r2, r2, #8388608	@ 0x800000
 8004630:	608a      	str	r2, [r1, #8]
 8004632:	6802      	ldr	r2, [r0, #0]
 8004634:	497b      	ldr	r1, [pc, #492]	@ (8004824 <HAL_ADC_ConfigChannel+0x398>)
 8004636:	0992      	lsrs	r2, r2, #6
 8004638:	fba1 1202 	umull	r1, r2, r1, r2
 800463c:	0992      	lsrs	r2, r2, #6
 800463e:	3201      	adds	r2, #1
 8004640:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8004644:	0092      	lsls	r2, r2, #2
 8004646:	9201      	str	r2, [sp, #4]
          while (wait_loop_index != 0UL)
 8004648:	9a01      	ldr	r2, [sp, #4]
 800464a:	2a00      	cmp	r2, #0
 800464c:	d085      	beq.n	800455a <HAL_ADC_ConfigChannel+0xce>
            wait_loop_index--;
 800464e:	9a01      	ldr	r2, [sp, #4]
 8004650:	3a01      	subs	r2, #1
 8004652:	9201      	str	r2, [sp, #4]
          while (wait_loop_index != 0UL)
 8004654:	9a01      	ldr	r2, [sp, #4]
 8004656:	2a00      	cmp	r2, #0
 8004658:	d1f9      	bne.n	800464e <HAL_ADC_ConfigChannel+0x1c2>
 800465a:	e77e      	b.n	800455a <HAL_ADC_ConfigChannel+0xce>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL(
 800465c:	2f00      	cmp	r7, #0
 800465e:	d060      	beq.n	8004722 <HAL_ADC_ConfigChannel+0x296>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004660:	fa90 f4a0 	rbit	r4, r0
  if (value == 0U)
 8004664:	2c00      	cmp	r4, #0
 8004666:	f000 80a0 	beq.w	80047aa <HAL_ADC_ConfigChannel+0x31e>
  return __builtin_clz(value);
 800466a:	fab4 f484 	clz	r4, r4
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 800466e:	3401      	adds	r4, #1
 8004670:	f004 041f 	and.w	r4, r4, #31
 8004674:	2c09      	cmp	r4, #9
 8004676:	f240 8098 	bls.w	80047aa <HAL_ADC_ConfigChannel+0x31e>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800467a:	fa90 f4a0 	rbit	r4, r0
  if (value == 0U)
 800467e:	2c00      	cmp	r4, #0
 8004680:	f000 8148 	beq.w	8004914 <HAL_ADC_ConfigChannel+0x488>
  return __builtin_clz(value);
 8004684:	fab4 f484 	clz	r4, r4
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL(
 8004688:	3401      	adds	r4, #1
 800468a:	06a4      	lsls	r4, r4, #26
 800468c:	f004 44f8 	and.w	r4, r4, #2080374784	@ 0x7c000000
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004690:	fa90 f5a0 	rbit	r5, r0
  if (value == 0U)
 8004694:	2d00      	cmp	r5, #0
 8004696:	f000 8142 	beq.w	800491e <HAL_ADC_ConfigChannel+0x492>
  return __builtin_clz(value);
 800469a:	fab5 f585 	clz	r5, r5
 800469e:	3501      	adds	r5, #1
 80046a0:	f005 051f 	and.w	r5, r5, #31
 80046a4:	2601      	movs	r6, #1
 80046a6:	fa06 f505 	lsl.w	r5, r6, r5
 80046aa:	432c      	orrs	r4, r5
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80046ac:	fa90 f0a0 	rbit	r0, r0
  if (value == 0U)
 80046b0:	2800      	cmp	r0, #0
 80046b2:	f000 8132 	beq.w	800491a <HAL_ADC_ConfigChannel+0x48e>
  return __builtin_clz(value);
 80046b6:	fab0 f080 	clz	r0, r0
 80046ba:	1c45      	adds	r5, r0, #1
 80046bc:	f005 051f 	and.w	r5, r5, #31
 80046c0:	2003      	movs	r0, #3
 80046c2:	f06f 061d 	mvn.w	r6, #29
 80046c6:	fb10 6005 	smlabb	r0, r0, r5, r6
 80046ca:	0500      	lsls	r0, r0, #20
 80046cc:	f040 7000 	orr.w	r0, r0, #33554432	@ 0x2000000
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 80046d0:	4320      	orrs	r0, r4
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1,
 80046d2:	0dc5      	lsrs	r5, r0, #23
  MODIFY_REG(*preg,
 80046d4:	688c      	ldr	r4, [r1, #8]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1,
 80046d6:	f005 0504 	and.w	r5, r5, #4
 80046da:	f102 0614 	add.w	r6, r2, #20
  MODIFY_REG(*preg,
 80046de:	f3c0 5004 	ubfx	r0, r0, #20, #5
 80046e2:	fa04 f700 	lsl.w	r7, r4, r0
 80046e6:	f04f 0c07 	mov.w	ip, #7
 80046ea:	5974      	ldr	r4, [r6, r5]
 80046ec:	fa0c f000 	lsl.w	r0, ip, r0
 80046f0:	ea24 0000 	bic.w	r0, r4, r0
 80046f4:	4338      	orrs	r0, r7
 80046f6:	5170      	str	r0, [r6, r5]
    if (__LL_ADC_IS_CHANNEL_INTERNAL(pConfig->Channel))
 80046f8:	6808      	ldr	r0, [r1, #0]
}
 80046fa:	e70e      	b.n	800451a <HAL_ADC_ConfigChannel+0x8e>
  __HAL_LOCK(hadc);
 80046fc:	2002      	movs	r0, #2
}
 80046fe:	b002      	add	sp, #8
 8004700:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
               && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 8004704:	01c8      	lsls	r0, r1, #7
 8004706:	f53f af28 	bmi.w	800455a <HAL_ADC_ConfigChannel+0xce>
        if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 800470a:	4943      	ldr	r1, [pc, #268]	@ (8004818 <HAL_ADC_ConfigChannel+0x38c>)
 800470c:	428a      	cmp	r2, r1
 800470e:	f43f af24 	beq.w	800455a <HAL_ADC_ConfigChannel+0xce>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL, PathInternal);
 8004712:	68a2      	ldr	r2, [r4, #8]
 8004714:	f022 72e0 	bic.w	r2, r2, #29360128	@ 0x1c00000
 8004718:	4332      	orrs	r2, r6
 800471a:	f042 7280 	orr.w	r2, r2, #16777216	@ 0x1000000
 800471e:	60a2      	str	r2, [r4, #8]
}
 8004720:	e71b      	b.n	800455a <HAL_ADC_ConfigChannel+0xce>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL(
 8004722:	0e80      	lsrs	r0, r0, #26
 8004724:	3001      	adds	r0, #1
 8004726:	f000 051f 	and.w	r5, r0, #31
 800472a:	2401      	movs	r4, #1
 800472c:	0680      	lsls	r0, r0, #26
 800472e:	f000 40f8 	and.w	r0, r0, #2080374784	@ 0x7c000000
 8004732:	40ac      	lsls	r4, r5
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8004734:	2d09      	cmp	r5, #9
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL(
 8004736:	ea44 0400 	orr.w	r4, r4, r0
 800473a:	eb05 0045 	add.w	r0, r5, r5, lsl #1
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 800473e:	d959      	bls.n	80047f4 <HAL_ADC_ConfigChannel+0x368>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL(
 8004740:	381e      	subs	r0, #30
 8004742:	0500      	lsls	r0, r0, #20
 8004744:	f040 7000 	orr.w	r0, r0, #33554432	@ 0x2000000
 8004748:	e7c2      	b.n	80046d0 <HAL_ADC_ConfigChannel+0x244>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 800474a:	6e15      	ldr	r5, [r2, #96]	@ 0x60
 800474c:	6e15      	ldr	r5, [r2, #96]	@ 0x60
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfig->Channel))
 800474e:	f3c0 0612 	ubfx	r6, r0, #0, #19
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 8004752:	f3c5 6584 	ubfx	r5, r5, #26, #5
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfig->Channel))
 8004756:	2e00      	cmp	r6, #0
 8004758:	d166      	bne.n	8004828 <HAL_ADC_ConfigChannel+0x39c>
 800475a:	f3c0 6084 	ubfx	r0, r0, #26, #5
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 800475e:	4285      	cmp	r5, r0
 8004760:	f000 80a8 	beq.w	80048b4 <HAL_ADC_ConfigChannel+0x428>
 8004764:	6e55      	ldr	r5, [r2, #100]	@ 0x64
 8004766:	6e55      	ldr	r5, [r2, #100]	@ 0x64
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 8004768:	f3c5 6584 	ubfx	r5, r5, #26, #5
 800476c:	4285      	cmp	r5, r0
 800476e:	f000 808c 	beq.w	800488a <HAL_ADC_ConfigChannel+0x3fe>
 8004772:	68a5      	ldr	r5, [r4, #8]
 8004774:	68a5      	ldr	r5, [r4, #8]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8004776:	f104 0708 	add.w	r7, r4, #8
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 800477a:	f3c5 6584 	ubfx	r5, r5, #26, #5
 800477e:	4285      	cmp	r5, r0
 8004780:	f000 80aa 	beq.w	80048d8 <HAL_ADC_ConfigChannel+0x44c>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8004784:	68e5      	ldr	r5, [r4, #12]
 8004786:	68e5      	ldr	r5, [r4, #12]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8004788:	f104 060c 	add.w	r6, r4, #12
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 800478c:	f3c5 6484 	ubfx	r4, r5, #26, #5
 8004790:	42a0      	cmp	r0, r4
 8004792:	f000 80b6 	beq.w	8004902 <HAL_ADC_ConfigChannel+0x476>
      LL_ADC_SetChannelSingleDiff(hadc->Instance, pConfig->Channel, pConfig->SingleDiff);
 8004796:	4660      	mov	r0, ip
 8004798:	e6a9      	b.n	80044ee <HAL_ADC_ConfigChannel+0x62>
  MODIFY_REG(*preg,
 800479a:	583d      	ldr	r5, [r7, r0]
 800479c:	402c      	ands	r4, r5
 800479e:	503c      	str	r4, [r7, r0]
  MODIFY_REG(ADCx->SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);
 80047a0:	6950      	ldr	r0, [r2, #20]
 80047a2:	f040 4000 	orr.w	r0, r0, #2147483648	@ 0x80000000
 80047a6:	6150      	str	r0, [r2, #20]
}
 80047a8:	e700      	b.n	80045ac <HAL_ADC_ConfigChannel+0x120>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80047aa:	fa90 f4a0 	rbit	r4, r0
  if (value == 0U)
 80047ae:	2c00      	cmp	r4, #0
 80047b0:	f000 80b9 	beq.w	8004926 <HAL_ADC_ConfigChannel+0x49a>
  return __builtin_clz(value);
 80047b4:	fab4 f484 	clz	r4, r4
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL(
 80047b8:	3401      	adds	r4, #1
 80047ba:	06a4      	lsls	r4, r4, #26
 80047bc:	f004 44f8 	and.w	r4, r4, #2080374784	@ 0x7c000000
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80047c0:	fa90 f5a0 	rbit	r5, r0
  if (value == 0U)
 80047c4:	2d00      	cmp	r5, #0
 80047c6:	f000 80ac 	beq.w	8004922 <HAL_ADC_ConfigChannel+0x496>
  return __builtin_clz(value);
 80047ca:	fab5 f585 	clz	r5, r5
 80047ce:	3501      	adds	r5, #1
 80047d0:	f005 051f 	and.w	r5, r5, #31
 80047d4:	2601      	movs	r6, #1
 80047d6:	fa06 f505 	lsl.w	r5, r6, r5
 80047da:	432c      	orrs	r4, r5
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80047dc:	fa90 f0a0 	rbit	r0, r0
  if (value == 0U)
 80047e0:	2800      	cmp	r0, #0
 80047e2:	f000 8094 	beq.w	800490e <HAL_ADC_ConfigChannel+0x482>
  return __builtin_clz(value);
 80047e6:	fab0 f080 	clz	r0, r0
 80047ea:	3001      	adds	r0, #1
 80047ec:	f000 001f 	and.w	r0, r0, #31
 80047f0:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80047f4:	0500      	lsls	r0, r0, #20
 80047f6:	e76b      	b.n	80046d0 <HAL_ADC_ConfigChannel+0x244>
 80047f8:	0007ffff 	.word	0x0007ffff
 80047fc:	407f0000 	.word	0x407f0000
 8004800:	80080000 	.word	0x80080000
 8004804:	50000300 	.word	0x50000300
 8004808:	c3210000 	.word	0xc3210000
 800480c:	90c00010 	.word	0x90c00010
 8004810:	c7520000 	.word	0xc7520000
 8004814:	cb840000 	.word	0xcb840000
 8004818:	50000100 	.word	0x50000100
 800481c:	03fff000 	.word	0x03fff000
 8004820:	20000474 	.word	0x20000474
 8004824:	053e2d63 	.word	0x053e2d63
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004828:	fa90 f6a0 	rbit	r6, r0
  if (value == 0U)
 800482c:	b11e      	cbz	r6, 8004836 <HAL_ADC_ConfigChannel+0x3aa>
  return __builtin_clz(value);
 800482e:	fab6 f686 	clz	r6, r6
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 8004832:	42b5      	cmp	r5, r6
 8004834:	d03e      	beq.n	80048b4 <HAL_ADC_ConfigChannel+0x428>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8004836:	6e55      	ldr	r5, [r2, #100]	@ 0x64
 8004838:	6e55      	ldr	r5, [r2, #100]	@ 0x64
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 800483a:	f3c5 6584 	ubfx	r5, r5, #26, #5
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800483e:	fa9c f6ac 	rbit	r6, ip
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8004842:	f104 0708 	add.w	r7, r4, #8
 8004846:	46be      	mov	lr, r7
  if (value == 0U)
 8004848:	b11e      	cbz	r6, 8004852 <HAL_ADC_ConfigChannel+0x3c6>
  return __builtin_clz(value);
 800484a:	fab6 f686 	clz	r6, r6
 800484e:	42ae      	cmp	r6, r5
 8004850:	d01d      	beq.n	800488e <HAL_ADC_ConfigChannel+0x402>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8004852:	68a5      	ldr	r5, [r4, #8]
 8004854:	68a5      	ldr	r5, [r4, #8]
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 8004856:	f3c5 6584 	ubfx	r5, r5, #26, #5
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800485a:	fa9c feac 	rbit	lr, ip
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 800485e:	f104 060c 	add.w	r6, r4, #12
 8004862:	46b0      	mov	r8, r6
  if (value == 0U)
 8004864:	f1be 0f00 	cmp.w	lr, #0
 8004868:	d003      	beq.n	8004872 <HAL_ADC_ConfigChannel+0x3e6>
  return __builtin_clz(value);
 800486a:	fabe fe8e 	clz	lr, lr
 800486e:	45ae      	cmp	lr, r5
 8004870:	d034      	beq.n	80048dc <HAL_ADC_ConfigChannel+0x450>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8004872:	68e5      	ldr	r5, [r4, #12]
 8004874:	68e4      	ldr	r4, [r4, #12]
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 8004876:	f3c4 6484 	ubfx	r4, r4, #26, #5
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800487a:	fa9c f5ac 	rbit	r5, ip
  if (value == 0U)
 800487e:	2d00      	cmp	r5, #0
 8004880:	f43f ae35 	beq.w	80044ee <HAL_ADC_ConfigChannel+0x62>
  return __builtin_clz(value);
 8004884:	fab5 f085 	clz	r0, r5
 8004888:	e782      	b.n	8004790 <HAL_ADC_ConfigChannel+0x304>
 800488a:	f104 0e08 	add.w	lr, r4, #8
  MODIFY_REG(*preg,
 800488e:	6e50      	ldr	r0, [r2, #100]	@ 0x64
 8004890:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
 8004894:	6650      	str	r0, [r2, #100]	@ 0x64
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfig->Channel))
 8004896:	f8d1 c000 	ldr.w	ip, [r1]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 800489a:	68a0      	ldr	r0, [r4, #8]
 800489c:	68a5      	ldr	r5, [r4, #8]
 800489e:	f3cc 0612 	ubfx	r6, ip, #0, #19
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80048a2:	4677      	mov	r7, lr
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 80048a4:	f3c5 6584 	ubfx	r5, r5, #26, #5
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfig->Channel))
 80048a8:	4660      	mov	r0, ip
 80048aa:	2e00      	cmp	r6, #0
 80048ac:	d1d5      	bne.n	800485a <HAL_ADC_ConfigChannel+0x3ce>
 80048ae:	f3cc 6084 	ubfx	r0, ip, #26, #5
 80048b2:	e764      	b.n	800477e <HAL_ADC_ConfigChannel+0x2f2>
  MODIFY_REG(*preg,
 80048b4:	6e10      	ldr	r0, [r2, #96]	@ 0x60
 80048b6:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
 80048ba:	6610      	str	r0, [r2, #96]	@ 0x60
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfig->Channel))
 80048bc:	f8d1 c000 	ldr.w	ip, [r1]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 80048c0:	6e50      	ldr	r0, [r2, #100]	@ 0x64
 80048c2:	6e55      	ldr	r5, [r2, #100]	@ 0x64
 80048c4:	f3cc 0612 	ubfx	r6, ip, #0, #19
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 80048c8:	f3c5 6584 	ubfx	r5, r5, #26, #5
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfig->Channel))
 80048cc:	4660      	mov	r0, ip
 80048ce:	2e00      	cmp	r6, #0
 80048d0:	d1b5      	bne.n	800483e <HAL_ADC_ConfigChannel+0x3b2>
 80048d2:	f3cc 6084 	ubfx	r0, ip, #26, #5
 80048d6:	e749      	b.n	800476c <HAL_ADC_ConfigChannel+0x2e0>
 80048d8:	f104 080c 	add.w	r8, r4, #12
  MODIFY_REG(*preg,
 80048dc:	6838      	ldr	r0, [r7, #0]
 80048de:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
 80048e2:	6038      	str	r0, [r7, #0]
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfig->Channel))
 80048e4:	f8d1 c000 	ldr.w	ip, [r1]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 80048e8:	68e0      	ldr	r0, [r4, #12]
 80048ea:	68e4      	ldr	r4, [r4, #12]
 80048ec:	f3cc 0512 	ubfx	r5, ip, #0, #19
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80048f0:	4646      	mov	r6, r8
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 80048f2:	f3c4 6484 	ubfx	r4, r4, #26, #5
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfig->Channel))
 80048f6:	4660      	mov	r0, ip
 80048f8:	2d00      	cmp	r5, #0
 80048fa:	d1be      	bne.n	800487a <HAL_ADC_ConfigChannel+0x3ee>
 80048fc:	f3cc 6084 	ubfx	r0, ip, #26, #5
 8004900:	e746      	b.n	8004790 <HAL_ADC_ConfigChannel+0x304>
  MODIFY_REG(*preg,
 8004902:	6830      	ldr	r0, [r6, #0]
 8004904:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
 8004908:	6030      	str	r0, [r6, #0]
      LL_ADC_SetChannelSingleDiff(hadc->Instance, pConfig->Channel, pConfig->SingleDiff);
 800490a:	6808      	ldr	r0, [r1, #0]
}
 800490c:	e5ef      	b.n	80044ee <HAL_ADC_ConfigChannel+0x62>
 800490e:	f44f 1040 	mov.w	r0, #3145728	@ 0x300000
 8004912:	e6dd      	b.n	80046d0 <HAL_ADC_ConfigChannel+0x244>
 8004914:	f04f 6480 	mov.w	r4, #67108864	@ 0x4000000
 8004918:	e6ba      	b.n	8004690 <HAL_ADC_ConfigChannel+0x204>
 800491a:	4804      	ldr	r0, [pc, #16]	@ (800492c <HAL_ADC_ConfigChannel+0x4a0>)
 800491c:	e6d8      	b.n	80046d0 <HAL_ADC_ConfigChannel+0x244>
 800491e:	2502      	movs	r5, #2
 8004920:	e6c3      	b.n	80046aa <HAL_ADC_ConfigChannel+0x21e>
 8004922:	2502      	movs	r5, #2
 8004924:	e759      	b.n	80047da <HAL_ADC_ConfigChannel+0x34e>
 8004926:	f04f 6480 	mov.w	r4, #67108864	@ 0x4000000
 800492a:	e749      	b.n	80047c0 <HAL_ADC_ConfigChannel+0x334>
 800492c:	fe500000 	.word	0xfe500000

08004930 <HAL_ADCEx_InjectedConfigChannel>:
  *         injected group.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_InjectedConfigChannel(ADC_HandleTypeDef *hadc,
                                                  const ADC_InjectionConfTypeDef *pConfigInjected)
{
 8004930:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  {
    assert_param(IS_ADC_DIFF_CHANNEL(hadc, pConfigInjected->InjectedChannel));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 8004934:	f890 3058 	ldrb.w	r3, [r0, #88]	@ 0x58
{
 8004938:	4602      	mov	r2, r0
 800493a:	b083      	sub	sp, #12
  __IO uint32_t wait_loop_index = 0;
 800493c:	2000      	movs	r0, #0
  __HAL_LOCK(hadc);
 800493e:	2b01      	cmp	r3, #1
  if (hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
 8004940:	6955      	ldr	r5, [r2, #20]
  __IO uint32_t wait_loop_index = 0;
 8004942:	9001      	str	r0, [sp, #4]
  __HAL_LOCK(hadc);
 8004944:	f000 8174 	beq.w	8004c30 <HAL_ADCEx_InjectedConfigChannel+0x300>
 8004948:	2301      	movs	r3, #1
 800494a:	f882 3058 	strb.w	r3, [r2, #88]	@ 0x58
    /*    related to each channel: channel rank sequence                    */
    /* Clear the old JSQx bits for the selected rank */
    tmp_jsqr_context_queue_being_built &= ~ADC_JSQR_RK(ADC_SQR3_SQ10, pConfigInjected->InjectedRank);

    /* Set the JSQx bits for the selected rank */
    tmp_jsqr_context_queue_being_built |= ADC_JSQR_RK(pConfigInjected->InjectedChannel, pConfigInjected->InjectedRank);
 800494e:	e9d1 4000 	ldrd	r4, r0, [r1]

    /* 4. End of context setting: if this is the last channel set, then write context
        into register JSQR and make it enter into queue                   */
    if (hadc->InjectionConfig.ChannelCount == 0U)
    {
      MODIFY_REG(hadc->Instance->JSQR, ADC_JSQR_FIELDS, hadc->InjectionConfig.ContextQueue);
 8004952:	6813      	ldr	r3, [r2, #0]
  if ((hadc->Init.ScanConvMode == ADC_SCAN_DISABLE)  ||
 8004954:	2d00      	cmp	r5, #0
 8004956:	d072      	beq.n	8004a3e <HAL_ADCEx_InjectedConfigChannel+0x10e>
      (pConfigInjected->InjectedNbrOfConversion == 1U))
 8004958:	6a0d      	ldr	r5, [r1, #32]
  if ((hadc->Init.ScanConvMode == ADC_SCAN_DISABLE)  ||
 800495a:	2d01      	cmp	r5, #1
 800495c:	d06f      	beq.n	8004a3e <HAL_ADCEx_InjectedConfigChannel+0x10e>
    if (hadc->InjectionConfig.ChannelCount == 0U)
 800495e:	6e97      	ldr	r7, [r2, #104]	@ 0x68
    tmp_jsqr_context_queue_being_built |= ADC_JSQR_RK(pConfigInjected->InjectedChannel, pConfigInjected->InjectedRank);
 8004960:	f000 001f 	and.w	r0, r0, #31
 8004964:	f3c4 6684 	ubfx	r6, r4, #26, #5
 8004968:	4086      	lsls	r6, r0
    if (hadc->InjectionConfig.ChannelCount == 0U)
 800496a:	2f00      	cmp	r7, #0
 800496c:	f040 811a 	bne.w	8004ba4 <HAL_ADCEx_InjectedConfigChannel+0x274>
      if (pConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
 8004970:	6a88      	ldr	r0, [r1, #40]	@ 0x28
        tmp_jsqr_context_queue_being_built = ((pConfigInjected->InjectedNbrOfConversion - 1U)
 8004972:	3d01      	subs	r5, #1
      if (pConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
 8004974:	2800      	cmp	r0, #0
 8004976:	f000 8217 	beq.w	8004da8 <HAL_ADCEx_InjectedConfigChannel+0x478>
        tmp_jsqr_context_queue_being_built = ((pConfigInjected->InjectedNbrOfConversion - 1U)
 800497a:	6acf      	ldr	r7, [r1, #44]	@ 0x2c
                                              | (pConfigInjected->ExternalTrigInjecConv & ADC_JSQR_JEXTSEL)
 800497c:	f000 007c 	and.w	r0, r0, #124	@ 0x7c
 8004980:	4328      	orrs	r0, r5
        tmp_jsqr_context_queue_being_built = ((pConfigInjected->InjectedNbrOfConversion - 1U)
 8004982:	4338      	orrs	r0, r7
    hadc->InjectionConfig.ContextQueue |= tmp_jsqr_context_queue_being_built;
 8004984:	4330      	orrs	r0, r6
 8004986:	e9c2 0519 	strd	r0, r5, [r2, #100]	@ 0x64
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 800498a:	6898      	ldr	r0, [r3, #8]
 800498c:	0700      	lsls	r0, r0, #28
 800498e:	d410      	bmi.n	80049b2 <HAL_ADCEx_InjectedConfigChannel+0x82>
  if (LL_ADC_INJ_IsConversionOngoing(hadc->Instance) == 0UL)
  {
    /* If auto-injected mode is disabled: no constraint                       */
    if (pConfigInjected->AutoInjectedConv == DISABLE)
    {
      MODIFY_REG(hadc->Instance->CFGR,
 8004990:	f891 0026 	ldrb.w	r0, [r1, #38]	@ 0x26
    if (pConfigInjected->AutoInjectedConv == DISABLE)
 8004994:	f891 5025 	ldrb.w	r5, [r1, #37]	@ 0x25
      MODIFY_REG(hadc->Instance->CFGR,
 8004998:	0540      	lsls	r0, r0, #21
    if (pConfigInjected->AutoInjectedConv == DISABLE)
 800499a:	2d00      	cmp	r5, #0
 800499c:	f040 80f7 	bne.w	8004b8e <HAL_ADCEx_InjectedConfigChannel+0x25e>
      MODIFY_REG(hadc->Instance->CFGR,
 80049a0:	68dd      	ldr	r5, [r3, #12]
 80049a2:	f891 6024 	ldrb.w	r6, [r1, #36]	@ 0x24
 80049a6:	f425 1540 	bic.w	r5, r5, #3145728	@ 0x300000
 80049aa:	ea40 5006 	orr.w	r0, r0, r6, lsl #20
 80049ae:	4328      	orrs	r0, r5
 80049b0:	60d8      	str	r0, [r3, #12]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 80049b2:	6898      	ldr	r0, [r3, #8]
 80049b4:	f010 0004 	ands.w	r0, r0, #4
 80049b8:	d057      	beq.n	8004a6a <HAL_ADCEx_InjectedConfigChannel+0x13a>
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 80049ba:	6898      	ldr	r0, [r3, #8]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 80049bc:	2000      	movs	r0, #0
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 80049be:	689d      	ldr	r5, [r3, #8]
 80049c0:	07ee      	lsls	r6, r5, #31
 80049c2:	d414      	bmi.n	80049ee <HAL_ADCEx_InjectedConfigChannel+0xbe>
  /* Parameters that can be updated only when ADC is disabled:                */
  /*  - Single or differential mode                                           */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
  {
    /* Set mode single-ended or differential input of the selected ADC channel */
    LL_ADC_SetChannelSingleDiff(hadc->Instance, pConfigInjected->InjectedChannel, pConfigInjected->InjectedSingleDiff);
 80049c4:	68cf      	ldr	r7, [r1, #12]
  MODIFY_REG(ADCx->DIFSEL,
 80049c6:	4da4      	ldr	r5, [pc, #656]	@ (8004c58 <HAL_ADCEx_InjectedConfigChannel+0x328>)
 80049c8:	f8d3 60b0 	ldr.w	r6, [r3, #176]	@ 0xb0
 80049cc:	f007 0c18 	and.w	ip, r7, #24
 80049d0:	fa25 f50c 	lsr.w	r5, r5, ip
 80049d4:	f3c4 0e12 	ubfx	lr, r4, #0, #19
 80049d8:	4025      	ands	r5, r4
 80049da:	ea26 0c0e 	bic.w	ip, r6, lr
 80049de:	ea45 050c 	orr.w	r5, r5, ip
 80049e2:	f8c3 50b0 	str.w	r5, [r3, #176]	@ 0xb0

    /* Configuration of differential mode */
    /* Note: ADC channel number masked with value "0x1F" to ensure shift value within 32 bits range */
    if (pConfigInjected->InjectedSingleDiff == ADC_DIFFERENTIAL_ENDED)
 80049e6:	4d9d      	ldr	r5, [pc, #628]	@ (8004c5c <HAL_ADCEx_InjectedConfigChannel+0x32c>)
 80049e8:	42af      	cmp	r7, r5
 80049ea:	f000 80f6 	beq.w	8004bda <HAL_ADCEx_InjectedConfigChannel+0x2aa>
  /* internal measurement paths enable: If internal channel selected,       */
  /* enable dedicated internal buffers and path.                            */
  /* Note: these internal measurement paths can be disabled using           */
  /* HAL_ADC_DeInit().                                                      */

  if (__LL_ADC_IS_CHANNEL_INTERNAL(pConfigInjected->InjectedChannel))
 80049ee:	499c      	ldr	r1, [pc, #624]	@ (8004c60 <HAL_ADCEx_InjectedConfigChannel+0x330>)
 80049f0:	420c      	tst	r4, r1
 80049f2:	d01e      	beq.n	8004a32 <HAL_ADCEx_InjectedConfigChannel+0x102>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL));
 80049f4:	4e9b      	ldr	r6, [pc, #620]	@ (8004c64 <HAL_ADCEx_InjectedConfigChannel+0x334>)
  {
    tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));

    /* If the requested internal measurement path has already been enabled,   */
    /* bypass the configuration processing.                                   */
    if (((pConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR_ADC1)
 80049f6:	4d9c      	ldr	r5, [pc, #624]	@ (8004c68 <HAL_ADCEx_InjectedConfigChannel+0x338>)
 80049f8:	68b1      	ldr	r1, [r6, #8]
 80049fa:	42ac      	cmp	r4, r5
 80049fc:	f001 77e0 	and.w	r7, r1, #29360128	@ 0x1c00000
 8004a00:	f000 809f 	beq.w	8004b42 <HAL_ADCEx_InjectedConfigChannel+0x212>
         || (pConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR_ADC5))
 8004a04:	4d99      	ldr	r5, [pc, #612]	@ (8004c6c <HAL_ADCEx_InjectedConfigChannel+0x33c>)
 8004a06:	42ac      	cmp	r4, r5
 8004a08:	f000 809b 	beq.w	8004b42 <HAL_ADCEx_InjectedConfigChannel+0x212>
        {
          wait_loop_index--;
        }
      }
    }
    else if ((pConfigInjected->InjectedChannel == ADC_CHANNEL_VBAT)
 8004a0c:	4d98      	ldr	r5, [pc, #608]	@ (8004c70 <HAL_ADCEx_InjectedConfigChannel+0x340>)
 8004a0e:	42ac      	cmp	r4, r5
 8004a10:	f000 8112 	beq.w	8004c38 <HAL_ADCEx_InjectedConfigChannel+0x308>
      {
        LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
                                       LL_ADC_PATH_INTERNAL_VBAT | tmp_config_internal_channel);
      }
    }
    else if ((pConfigInjected->InjectedChannel == ADC_CHANNEL_VREFINT)
 8004a14:	4d97      	ldr	r5, [pc, #604]	@ (8004c74 <HAL_ADCEx_InjectedConfigChannel+0x344>)
 8004a16:	42ac      	cmp	r4, r5
 8004a18:	d10b      	bne.n	8004a32 <HAL_ADCEx_InjectedConfigChannel+0x102>
             && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
 8004a1a:	0249      	lsls	r1, r1, #9
 8004a1c:	d409      	bmi.n	8004a32 <HAL_ADCEx_InjectedConfigChannel+0x102>
    {
      if (ADC_VREFINT_INSTANCE(hadc))
 8004a1e:	4996      	ldr	r1, [pc, #600]	@ (8004c78 <HAL_ADCEx_InjectedConfigChannel+0x348>)
 8004a20:	428b      	cmp	r3, r1
 8004a22:	d006      	beq.n	8004a32 <HAL_ADCEx_InjectedConfigChannel+0x102>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL, PathInternal);
 8004a24:	68b3      	ldr	r3, [r6, #8]
 8004a26:	f023 73e0 	bic.w	r3, r3, #29360128	@ 0x1c00000
 8004a2a:	433b      	orrs	r3, r7
 8004a2c:	f443 0380 	orr.w	r3, r3, #4194304	@ 0x400000
 8004a30:	60b3      	str	r3, [r6, #8]
      /* nothing to do */
    }
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8004a32:	2300      	movs	r3, #0
 8004a34:	f882 3058 	strb.w	r3, [r2, #88]	@ 0x58

  /* Return function status */
  return tmp_hal_status;
}
 8004a38:	b003      	add	sp, #12
 8004a3a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if (pConfigInjected->InjectedRank == ADC_INJECTED_RANK_1)
 8004a3e:	2809      	cmp	r0, #9
 8004a40:	d1a3      	bne.n	800498a <HAL_ADCEx_InjectedConfigChannel+0x5a>
      if (pConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
 8004a42:	6a88      	ldr	r0, [r1, #40]	@ 0x28
        tmp_jsqr_context_queue_being_built = (ADC_JSQR_RK(pConfigInjected->InjectedChannel, ADC_INJECTED_RANK_1)
 8004a44:	0c65      	lsrs	r5, r4, #17
 8004a46:	f405 5578 	and.w	r5, r5, #15872	@ 0x3e00
      if (pConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
 8004a4a:	b120      	cbz	r0, 8004a56 <HAL_ADCEx_InjectedConfigChannel+0x126>
        tmp_jsqr_context_queue_being_built = (ADC_JSQR_RK(pConfigInjected->InjectedChannel, ADC_INJECTED_RANK_1)
 8004a4c:	6ace      	ldr	r6, [r1, #44]	@ 0x2c
                                              | (pConfigInjected->ExternalTrigInjecConv & ADC_JSQR_JEXTSEL)
 8004a4e:	f000 007c 	and.w	r0, r0, #124	@ 0x7c
        tmp_jsqr_context_queue_being_built = (ADC_JSQR_RK(pConfigInjected->InjectedChannel, ADC_INJECTED_RANK_1)
 8004a52:	4330      	orrs	r0, r6
 8004a54:	4305      	orrs	r5, r0
      MODIFY_REG(hadc->Instance->JSQR, ADC_JSQR_FIELDS, tmp_jsqr_context_queue_being_built);
 8004a56:	6cd8      	ldr	r0, [r3, #76]	@ 0x4c
 8004a58:	4e88      	ldr	r6, [pc, #544]	@ (8004c7c <HAL_ADCEx_InjectedConfigChannel+0x34c>)
 8004a5a:	4030      	ands	r0, r6
 8004a5c:	4328      	orrs	r0, r5
 8004a5e:	64d8      	str	r0, [r3, #76]	@ 0x4c
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8004a60:	6898      	ldr	r0, [r3, #8]
      hadc->InjectionConfig.ContextQueue = tmp_jsqr_context_queue_being_built;
 8004a62:	6655      	str	r5, [r2, #100]	@ 0x64
 8004a64:	0700      	lsls	r0, r0, #28
 8004a66:	d4a4      	bmi.n	80049b2 <HAL_ADCEx_InjectedConfigChannel+0x82>
 8004a68:	e792      	b.n	8004990 <HAL_ADCEx_InjectedConfigChannel+0x60>
 8004a6a:	689d      	ldr	r5, [r3, #8]
 8004a6c:	072f      	lsls	r7, r5, #28
 8004a6e:	d4a6      	bmi.n	80049be <HAL_ADCEx_InjectedConfigChannel+0x8e>
    if ((pConfigInjected->ExternalTrigInjecConv == ADC_INJECTED_SOFTWARE_START)
 8004a70:	6a8d      	ldr	r5, [r1, #40]	@ 0x28
    if (pConfigInjected->AutoInjectedConv == DISABLE)
 8004a72:	f891 0025 	ldrb.w	r0, [r1, #37]	@ 0x25
    if ((pConfigInjected->ExternalTrigInjecConv == ADC_INJECTED_SOFTWARE_START)
 8004a76:	2d00      	cmp	r5, #0
 8004a78:	f040 80a6 	bne.w	8004bc8 <HAL_ADCEx_InjectedConfigChannel+0x298>
      if (pConfigInjected->AutoInjectedConv == ENABLE)
 8004a7c:	2801      	cmp	r0, #1
        SET_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO);
 8004a7e:	68d8      	ldr	r0, [r3, #12]
      if (pConfigInjected->AutoInjectedConv == ENABLE)
 8004a80:	f000 8194 	beq.w	8004dac <HAL_ADCEx_InjectedConfigChannel+0x47c>
        CLEAR_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO);
 8004a84:	f020 7000 	bic.w	r0, r0, #33554432	@ 0x2000000
 8004a88:	60d8      	str	r0, [r3, #12]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8004a8a:	2000      	movs	r0, #0
    if (pConfigInjected->InjecOversamplingMode == ENABLE)
 8004a8c:	f891 5030 	ldrb.w	r5, [r1, #48]	@ 0x30
 8004a90:	2d01      	cmp	r5, #1
 8004a92:	f000 817e 	beq.w	8004d92 <HAL_ADCEx_InjectedConfigChannel+0x462>
      CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_JOVSE);
 8004a96:	691d      	ldr	r5, [r3, #16]
 8004a98:	f025 0502 	bic.w	r5, r5, #2
 8004a9c:	611d      	str	r5, [r3, #16]
    if (pConfigInjected->InjectedSamplingTime == ADC_SAMPLETIME_3CYCLES_5)
 8004a9e:	688e      	ldr	r6, [r1, #8]
  MODIFY_REG(*preg,
 8004aa0:	f3c4 5704 	ubfx	r7, r4, #20, #5
 8004aa4:	2507      	movs	r5, #7
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1,
 8004aa6:	0de4      	lsrs	r4, r4, #23
  MODIFY_REG(*preg,
 8004aa8:	40bd      	lsls	r5, r7
 8004aaa:	f1b6 4f00 	cmp.w	r6, #2147483648	@ 0x80000000
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1,
 8004aae:	f004 0404 	and.w	r4, r4, #4
  MODIFY_REG(*preg,
 8004ab2:	ea6f 0505 	mvn.w	r5, r5
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1,
 8004ab6:	f103 0c14 	add.w	ip, r3, #20
 8004aba:	f000 8160 	beq.w	8004d7e <HAL_ADCEx_InjectedConfigChannel+0x44e>
  MODIFY_REG(*preg,
 8004abe:	40be      	lsls	r6, r7
 8004ac0:	f85c 7004 	ldr.w	r7, [ip, r4]
 8004ac4:	403d      	ands	r5, r7
 8004ac6:	4335      	orrs	r5, r6
 8004ac8:	f84c 5004 	str.w	r5, [ip, r4]
  MODIFY_REG(ADCx->SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);
 8004acc:	695c      	ldr	r4, [r3, #20]
 8004ace:	f024 4400 	bic.w	r4, r4, #2147483648	@ 0x80000000
 8004ad2:	615c      	str	r4, [r3, #20]
    if (pConfigInjected->InjectedOffsetNumber != ADC_OFFSET_NONE)
 8004ad4:	f8d1 c010 	ldr.w	ip, [r1, #16]
      LL_ADC_SetOffset(hadc->Instance, pConfigInjected->InjectedOffsetNumber, pConfigInjected->InjectedChannel,
 8004ad8:	680c      	ldr	r4, [r1, #0]
    tmp_offset_shifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, pConfigInjected->InjectedOffset);
 8004ada:	694e      	ldr	r6, [r1, #20]
 8004adc:	68df      	ldr	r7, [r3, #12]
    if (pConfigInjected->InjectedOffsetNumber != ADC_OFFSET_NONE)
 8004ade:	f1bc 0f04 	cmp.w	ip, #4
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8004ae2:	f103 0560 	add.w	r5, r3, #96	@ 0x60
      LL_ADC_SetOffset(hadc->Instance, pConfigInjected->InjectedOffsetNumber, pConfigInjected->InjectedChannel,
 8004ae6:	46a6      	mov	lr, r4
    if (pConfigInjected->InjectedOffsetNumber != ADC_OFFSET_NONE)
 8004ae8:	f000 8109 	beq.w	8004cfe <HAL_ADCEx_InjectedConfigChannel+0x3ce>
    tmp_offset_shifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, pConfigInjected->InjectedOffset);
 8004aec:	f3c7 07c1 	ubfx	r7, r7, #3, #2
 8004af0:	007f      	lsls	r7, r7, #1
  MODIFY_REG(*preg,
 8004af2:	f855 e02c 	ldr.w	lr, [r5, ip, lsl #2]
 8004af6:	40be      	lsls	r6, r7
 8004af8:	4f61      	ldr	r7, [pc, #388]	@ (8004c80 <HAL_ADCEx_InjectedConfigChannel+0x350>)
 8004afa:	f004 44f8 	and.w	r4, r4, #2080374784	@ 0x7c000000
 8004afe:	ea0e 0707 	and.w	r7, lr, r7
 8004b02:	4327      	orrs	r7, r4
 8004b04:	433e      	orrs	r6, r7
 8004b06:	f046 4600 	orr.w	r6, r6, #2147483648	@ 0x80000000
 8004b0a:	f845 602c 	str.w	r6, [r5, ip, lsl #2]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8004b0e:	690f      	ldr	r7, [r1, #16]
  MODIFY_REG(*preg,
 8004b10:	698e      	ldr	r6, [r1, #24]
 8004b12:	f855 4027 	ldr.w	r4, [r5, r7, lsl #2]
 8004b16:	f024 7480 	bic.w	r4, r4, #16777216	@ 0x1000000
 8004b1a:	4334      	orrs	r4, r6
 8004b1c:	f845 4027 	str.w	r4, [r5, r7, lsl #2]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8004b20:	690f      	ldr	r7, [r1, #16]
      LL_ADC_SetOffsetSaturation(hadc->Instance, pConfigInjected->InjectedOffsetNumber,
 8004b22:	7f0e      	ldrb	r6, [r1, #28]
  MODIFY_REG(*preg,
 8004b24:	f855 4027 	ldr.w	r4, [r5, r7, lsl #2]
 8004b28:	f1a6 0601 	sub.w	r6, r6, #1
 8004b2c:	fab6 f686 	clz	r6, r6
 8004b30:	0976      	lsrs	r6, r6, #5
 8004b32:	f024 7400 	bic.w	r4, r4, #33554432	@ 0x2000000
 8004b36:	ea44 6446 	orr.w	r4, r4, r6, lsl #25
 8004b3a:	f845 4027 	str.w	r4, [r5, r7, lsl #2]
    LL_ADC_SetChannelSingleDiff(hadc->Instance, pConfigInjected->InjectedChannel, pConfigInjected->InjectedSingleDiff);
 8004b3e:	680c      	ldr	r4, [r1, #0]
}
 8004b40:	e73d      	b.n	80049be <HAL_ADCEx_InjectedConfigChannel+0x8e>
        && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
 8004b42:	020d      	lsls	r5, r1, #8
 8004b44:	f53f af75 	bmi.w	8004a32 <HAL_ADCEx_InjectedConfigChannel+0x102>
      if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 8004b48:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 8004b4c:	f47f af71 	bne.w	8004a32 <HAL_ADCEx_InjectedConfigChannel+0x102>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL, PathInternal);
 8004b50:	4944      	ldr	r1, [pc, #272]	@ (8004c64 <HAL_ADCEx_InjectedConfigChannel+0x334>)
                           * (((SystemCoreClock / (100000UL * 2UL)) + 1UL) + 1UL));
 8004b52:	4c4c      	ldr	r4, [pc, #304]	@ (8004c84 <HAL_ADCEx_InjectedConfigChannel+0x354>)
 8004b54:	688b      	ldr	r3, [r1, #8]
 8004b56:	f023 73e0 	bic.w	r3, r3, #29360128	@ 0x1c00000
 8004b5a:	433b      	orrs	r3, r7
 8004b5c:	f443 0300 	orr.w	r3, r3, #8388608	@ 0x800000
 8004b60:	608b      	str	r3, [r1, #8]
 8004b62:	6823      	ldr	r3, [r4, #0]
 8004b64:	4948      	ldr	r1, [pc, #288]	@ (8004c88 <HAL_ADCEx_InjectedConfigChannel+0x358>)
 8004b66:	099b      	lsrs	r3, r3, #6
 8004b68:	fba1 1303 	umull	r1, r3, r1, r3
 8004b6c:	099b      	lsrs	r3, r3, #6
 8004b6e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8004b72:	009b      	lsls	r3, r3, #2
 8004b74:	3318      	adds	r3, #24
        wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL)
 8004b76:	9301      	str	r3, [sp, #4]
        while (wait_loop_index != 0UL)
 8004b78:	9b01      	ldr	r3, [sp, #4]
 8004b7a:	2b00      	cmp	r3, #0
 8004b7c:	f43f af59 	beq.w	8004a32 <HAL_ADCEx_InjectedConfigChannel+0x102>
          wait_loop_index--;
 8004b80:	9b01      	ldr	r3, [sp, #4]
 8004b82:	3b01      	subs	r3, #1
 8004b84:	9301      	str	r3, [sp, #4]
        while (wait_loop_index != 0UL)
 8004b86:	9b01      	ldr	r3, [sp, #4]
 8004b88:	2b00      	cmp	r3, #0
 8004b8a:	d1f9      	bne.n	8004b80 <HAL_ADCEx_InjectedConfigChannel+0x250>
 8004b8c:	e751      	b.n	8004a32 <HAL_ADCEx_InjectedConfigChannel+0x102>
      MODIFY_REG(hadc->Instance->CFGR,
 8004b8e:	68dd      	ldr	r5, [r3, #12]
 8004b90:	f425 1540 	bic.w	r5, r5, #3145728	@ 0x300000
 8004b94:	4328      	orrs	r0, r5
 8004b96:	60d8      	str	r0, [r3, #12]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8004b98:	6898      	ldr	r0, [r3, #8]
 8004b9a:	f010 0004 	ands.w	r0, r0, #4
 8004b9e:	f43f af64 	beq.w	8004a6a <HAL_ADCEx_InjectedConfigChannel+0x13a>
 8004ba2:	e70a      	b.n	80049ba <HAL_ADCEx_InjectedConfigChannel+0x8a>
    hadc->InjectionConfig.ContextQueue |= tmp_jsqr_context_queue_being_built;
 8004ba4:	6e55      	ldr	r5, [r2, #100]	@ 0x64
    hadc->InjectionConfig.ChannelCount--;
 8004ba6:	3f01      	subs	r7, #1
    hadc->InjectionConfig.ContextQueue |= tmp_jsqr_context_queue_being_built;
 8004ba8:	4335      	orrs	r5, r6
    hadc->InjectionConfig.ChannelCount--;
 8004baa:	6697      	str	r7, [r2, #104]	@ 0x68
    hadc->InjectionConfig.ContextQueue |= tmp_jsqr_context_queue_being_built;
 8004bac:	6655      	str	r5, [r2, #100]	@ 0x64
    if (hadc->InjectionConfig.ChannelCount == 0U)
 8004bae:	2f00      	cmp	r7, #0
 8004bb0:	f47f aeeb 	bne.w	800498a <HAL_ADCEx_InjectedConfigChannel+0x5a>
      MODIFY_REG(hadc->Instance->JSQR, ADC_JSQR_FIELDS, hadc->InjectionConfig.ContextQueue);
 8004bb4:	6cd8      	ldr	r0, [r3, #76]	@ 0x4c
 8004bb6:	4e31      	ldr	r6, [pc, #196]	@ (8004c7c <HAL_ADCEx_InjectedConfigChannel+0x34c>)
 8004bb8:	4030      	ands	r0, r6
 8004bba:	4328      	orrs	r0, r5
 8004bbc:	64d8      	str	r0, [r3, #76]	@ 0x4c
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8004bbe:	6898      	ldr	r0, [r3, #8]
 8004bc0:	0700      	lsls	r0, r0, #28
 8004bc2:	f53f aef6 	bmi.w	80049b2 <HAL_ADCEx_InjectedConfigChannel+0x82>
 8004bc6:	e6e3      	b.n	8004990 <HAL_ADCEx_InjectedConfigChannel+0x60>
        || (pConfigInjected->ExternalTrigInjecConvEdge == ADC_EXTERNALTRIGINJECCONV_EDGE_NONE))
 8004bc8:	6acd      	ldr	r5, [r1, #44]	@ 0x2c
 8004bca:	2d00      	cmp	r5, #0
 8004bcc:	f43f af56 	beq.w	8004a7c <HAL_ADCEx_InjectedConfigChannel+0x14c>
      if (pConfigInjected->AutoInjectedConv == ENABLE)
 8004bd0:	2801      	cmp	r0, #1
 8004bd2:	f000 810d 	beq.w	8004df0 <HAL_ADCEx_InjectedConfigChannel+0x4c0>
        CLEAR_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO);
 8004bd6:	68d8      	ldr	r0, [r3, #12]
 8004bd8:	e754      	b.n	8004a84 <HAL_ADCEx_InjectedConfigChannel+0x154>
                                    (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL(
 8004bda:	f1be 0f00 	cmp.w	lr, #0
 8004bde:	d155      	bne.n	8004c8c <HAL_ADCEx_InjectedConfigChannel+0x35c>
 8004be0:	0ea4      	lsrs	r4, r4, #26
 8004be2:	3401      	adds	r4, #1
 8004be4:	f004 061f 	and.w	r6, r4, #31
 8004be8:	2501      	movs	r5, #1
 8004bea:	06a4      	lsls	r4, r4, #26
 8004bec:	f004 44f8 	and.w	r4, r4, #2080374784	@ 0x7c000000
 8004bf0:	40b5      	lsls	r5, r6
      LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8004bf2:	2e09      	cmp	r6, #9
                                    (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL(
 8004bf4:	ea45 0504 	orr.w	r5, r5, r4
 8004bf8:	eb06 0446 	add.w	r4, r6, r6, lsl #1
      LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8004bfc:	f200 80f3 	bhi.w	8004de6 <HAL_ADCEx_InjectedConfigChannel+0x4b6>
                                    (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL(
 8004c00:	0524      	lsls	r4, r4, #20
      LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8004c02:	432c      	orrs	r4, r5
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1,
 8004c04:	0de6      	lsrs	r6, r4, #23
  MODIFY_REG(*preg,
 8004c06:	688d      	ldr	r5, [r1, #8]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1,
 8004c08:	f006 0604 	and.w	r6, r6, #4
 8004c0c:	f103 0714 	add.w	r7, r3, #20
  MODIFY_REG(*preg,
 8004c10:	f3c4 5404 	ubfx	r4, r4, #20, #5
 8004c14:	fa05 fc04 	lsl.w	ip, r5, r4
 8004c18:	f04f 0e07 	mov.w	lr, #7
 8004c1c:	59bd      	ldr	r5, [r7, r6]
 8004c1e:	fa0e f404 	lsl.w	r4, lr, r4
 8004c22:	ea25 0404 	bic.w	r4, r5, r4
 8004c26:	ea44 040c 	orr.w	r4, r4, ip
 8004c2a:	51bc      	str	r4, [r7, r6]
  if (__LL_ADC_IS_CHANNEL_INTERNAL(pConfigInjected->InjectedChannel))
 8004c2c:	680c      	ldr	r4, [r1, #0]
}
 8004c2e:	e6de      	b.n	80049ee <HAL_ADCEx_InjectedConfigChannel+0xbe>
  __HAL_LOCK(hadc);
 8004c30:	2002      	movs	r0, #2
}
 8004c32:	b003      	add	sp, #12
 8004c34:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
             && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 8004c38:	01cc      	lsls	r4, r1, #7
 8004c3a:	f53f aefa 	bmi.w	8004a32 <HAL_ADCEx_InjectedConfigChannel+0x102>
      if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 8004c3e:	490e      	ldr	r1, [pc, #56]	@ (8004c78 <HAL_ADCEx_InjectedConfigChannel+0x348>)
 8004c40:	428b      	cmp	r3, r1
 8004c42:	f43f aef6 	beq.w	8004a32 <HAL_ADCEx_InjectedConfigChannel+0x102>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL, PathInternal);
 8004c46:	68b3      	ldr	r3, [r6, #8]
 8004c48:	f023 73e0 	bic.w	r3, r3, #29360128	@ 0x1c00000
 8004c4c:	433b      	orrs	r3, r7
 8004c4e:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8004c52:	60b3      	str	r3, [r6, #8]
}
 8004c54:	e6ed      	b.n	8004a32 <HAL_ADCEx_InjectedConfigChannel+0x102>
 8004c56:	bf00      	nop
 8004c58:	0007ffff 	.word	0x0007ffff
 8004c5c:	407f0000 	.word	0x407f0000
 8004c60:	80080000 	.word	0x80080000
 8004c64:	50000300 	.word	0x50000300
 8004c68:	c3210000 	.word	0xc3210000
 8004c6c:	90c00010 	.word	0x90c00010
 8004c70:	c7520000 	.word	0xc7520000
 8004c74:	cb840000 	.word	0xcb840000
 8004c78:	50000100 	.word	0x50000100
 8004c7c:	04104000 	.word	0x04104000
 8004c80:	03fff000 	.word	0x03fff000
 8004c84:	20000474 	.word	0x20000474
 8004c88:	053e2d63 	.word	0x053e2d63
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004c8c:	fa94 f5a4 	rbit	r5, r4
  if (value == 0U)
 8004c90:	2d00      	cmp	r5, #0
 8004c92:	f000 80b2 	beq.w	8004dfa <HAL_ADCEx_InjectedConfigChannel+0x4ca>
  return __builtin_clz(value);
 8004c96:	fab5 f585 	clz	r5, r5
      LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8004c9a:	3501      	adds	r5, #1
 8004c9c:	f005 051f 	and.w	r5, r5, #31
 8004ca0:	2d09      	cmp	r5, #9
 8004ca2:	f240 80aa 	bls.w	8004dfa <HAL_ADCEx_InjectedConfigChannel+0x4ca>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004ca6:	fa94 f5a4 	rbit	r5, r4
  if (value == 0U)
 8004caa:	2d00      	cmp	r5, #0
 8004cac:	f000 8111 	beq.w	8004ed2 <HAL_ADCEx_InjectedConfigChannel+0x5a2>
  return __builtin_clz(value);
 8004cb0:	fab5 f585 	clz	r5, r5
                                    (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL(
 8004cb4:	3501      	adds	r5, #1
 8004cb6:	06ad      	lsls	r5, r5, #26
 8004cb8:	f005 45f8 	and.w	r5, r5, #2080374784	@ 0x7c000000
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004cbc:	fa94 f6a4 	rbit	r6, r4
  if (value == 0U)
 8004cc0:	2e00      	cmp	r6, #0
 8004cc2:	f000 8104 	beq.w	8004ece <HAL_ADCEx_InjectedConfigChannel+0x59e>
  return __builtin_clz(value);
 8004cc6:	fab6 f686 	clz	r6, r6
 8004cca:	3601      	adds	r6, #1
 8004ccc:	f006 061f 	and.w	r6, r6, #31
 8004cd0:	2701      	movs	r7, #1
 8004cd2:	fa07 f606 	lsl.w	r6, r7, r6
 8004cd6:	4335      	orrs	r5, r6
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004cd8:	fa94 f4a4 	rbit	r4, r4
  if (value == 0U)
 8004cdc:	2c00      	cmp	r4, #0
 8004cde:	f000 80fe 	beq.w	8004ede <HAL_ADCEx_InjectedConfigChannel+0x5ae>
  return __builtin_clz(value);
 8004ce2:	fab4 f484 	clz	r4, r4
 8004ce6:	1c66      	adds	r6, r4, #1
 8004ce8:	f006 061f 	and.w	r6, r6, #31
 8004cec:	2403      	movs	r4, #3
 8004cee:	f06f 071d 	mvn.w	r7, #29
 8004cf2:	fb14 7406 	smlabb	r4, r4, r6, r7
 8004cf6:	0524      	lsls	r4, r4, #20
 8004cf8:	f044 7400 	orr.w	r4, r4, #33554432	@ 0x2000000
 8004cfc:	e781      	b.n	8004c02 <HAL_ADCEx_InjectedConfigChannel+0x2d2>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8004cfe:	6e1e      	ldr	r6, [r3, #96]	@ 0x60
 8004d00:	6e1e      	ldr	r6, [r3, #96]	@ 0x60
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfigInjected->InjectedChannel))
 8004d02:	f3c4 0712 	ubfx	r7, r4, #0, #19
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 8004d06:	f3c6 6684 	ubfx	r6, r6, #26, #5
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfigInjected->InjectedChannel))
 8004d0a:	2f00      	cmp	r7, #0
 8004d0c:	d052      	beq.n	8004db4 <HAL_ADCEx_InjectedConfigChannel+0x484>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004d0e:	fa94 f7a4 	rbit	r7, r4
  if (value == 0U)
 8004d12:	b127      	cbz	r7, 8004d1e <HAL_ADCEx_InjectedConfigChannel+0x3ee>
  return __builtin_clz(value);
 8004d14:	fab7 f787 	clz	r7, r7
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 8004d18:	42be      	cmp	r6, r7
 8004d1a:	f000 80a7 	beq.w	8004e6c <HAL_ADCEx_InjectedConfigChannel+0x53c>
 8004d1e:	6e5e      	ldr	r6, [r3, #100]	@ 0x64
 8004d20:	6e5e      	ldr	r6, [r3, #100]	@ 0x64
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 8004d22:	f3c6 6684 	ubfx	r6, r6, #26, #5
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004d26:	fa9e f7ae 	rbit	r7, lr
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8004d2a:	f105 0c08 	add.w	ip, r5, #8
 8004d2e:	46e0      	mov	r8, ip
  if (value == 0U)
 8004d30:	b127      	cbz	r7, 8004d3c <HAL_ADCEx_InjectedConfigChannel+0x40c>
  return __builtin_clz(value);
 8004d32:	fab7 f787 	clz	r7, r7
 8004d36:	42b7      	cmp	r7, r6
 8004d38:	f000 8084 	beq.w	8004e44 <HAL_ADCEx_InjectedConfigChannel+0x514>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8004d3c:	68ae      	ldr	r6, [r5, #8]
 8004d3e:	68ae      	ldr	r6, [r5, #8]
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 8004d40:	f3c6 6684 	ubfx	r6, r6, #26, #5
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004d44:	fa9e f8ae 	rbit	r8, lr
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8004d48:	f105 070c 	add.w	r7, r5, #12
 8004d4c:	46b9      	mov	r9, r7
  if (value == 0U)
 8004d4e:	f1b8 0f00 	cmp.w	r8, #0
 8004d52:	d004      	beq.n	8004d5e <HAL_ADCEx_InjectedConfigChannel+0x42e>
  return __builtin_clz(value);
 8004d54:	fab8 f888 	clz	r8, r8
 8004d58:	45b0      	cmp	r8, r6
 8004d5a:	f000 809c 	beq.w	8004e96 <HAL_ADCEx_InjectedConfigChannel+0x566>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8004d5e:	68ee      	ldr	r6, [r5, #12]
 8004d60:	68ed      	ldr	r5, [r5, #12]
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 8004d62:	f3c5 6584 	ubfx	r5, r5, #26, #5
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004d66:	fa9e f6ae 	rbit	r6, lr
  if (value == 0U)
 8004d6a:	2e00      	cmp	r6, #0
 8004d6c:	f43f ae27 	beq.w	80049be <HAL_ADCEx_InjectedConfigChannel+0x8e>
  return __builtin_clz(value);
 8004d70:	fab6 f486 	clz	r4, r6
 8004d74:	42ac      	cmp	r4, r5
 8004d76:	f000 80a4 	beq.w	8004ec2 <HAL_ADCEx_InjectedConfigChannel+0x592>
    LL_ADC_SetChannelSingleDiff(hadc->Instance, pConfigInjected->InjectedChannel, pConfigInjected->InjectedSingleDiff);
 8004d7a:	4674      	mov	r4, lr
 8004d7c:	e61f      	b.n	80049be <HAL_ADCEx_InjectedConfigChannel+0x8e>
  MODIFY_REG(*preg,
 8004d7e:	f85c 6004 	ldr.w	r6, [ip, r4]
 8004d82:	4035      	ands	r5, r6
 8004d84:	f84c 5004 	str.w	r5, [ip, r4]
  MODIFY_REG(ADCx->SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);
 8004d88:	695c      	ldr	r4, [r3, #20]
 8004d8a:	f044 4400 	orr.w	r4, r4, #2147483648	@ 0x80000000
 8004d8e:	615c      	str	r4, [r3, #20]
}
 8004d90:	e6a0      	b.n	8004ad4 <HAL_ADCEx_InjectedConfigChannel+0x1a4>
      MODIFY_REG(hadc->Instance->CFGR2,
 8004d92:	e9d1 570d 	ldrd	r5, r7, [r1, #52]	@ 0x34
 8004d96:	691e      	ldr	r6, [r3, #16]
 8004d98:	433d      	orrs	r5, r7
 8004d9a:	f426 76ff 	bic.w	r6, r6, #510	@ 0x1fe
 8004d9e:	4335      	orrs	r5, r6
 8004da0:	f045 0502 	orr.w	r5, r5, #2
 8004da4:	611d      	str	r5, [r3, #16]
 8004da6:	e67a      	b.n	8004a9e <HAL_ADCEx_InjectedConfigChannel+0x16e>
        tmp_jsqr_context_queue_being_built = ((pConfigInjected->InjectedNbrOfConversion - 1U));
 8004da8:	4628      	mov	r0, r5
 8004daa:	e5eb      	b.n	8004984 <HAL_ADCEx_InjectedConfigChannel+0x54>
        SET_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO);
 8004dac:	f040 7000 	orr.w	r0, r0, #33554432	@ 0x2000000
 8004db0:	60d8      	str	r0, [r3, #12]
 8004db2:	e66a      	b.n	8004a8a <HAL_ADCEx_InjectedConfigChannel+0x15a>
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfigInjected->InjectedChannel))
 8004db4:	f3c4 6484 	ubfx	r4, r4, #26, #5
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 8004db8:	42a6      	cmp	r6, r4
 8004dba:	d057      	beq.n	8004e6c <HAL_ADCEx_InjectedConfigChannel+0x53c>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8004dbc:	6e5e      	ldr	r6, [r3, #100]	@ 0x64
 8004dbe:	6e5e      	ldr	r6, [r3, #100]	@ 0x64
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 8004dc0:	f3c6 6684 	ubfx	r6, r6, #26, #5
 8004dc4:	42a6      	cmp	r6, r4
 8004dc6:	d03b      	beq.n	8004e40 <HAL_ADCEx_InjectedConfigChannel+0x510>
 8004dc8:	68ae      	ldr	r6, [r5, #8]
 8004dca:	68ae      	ldr	r6, [r5, #8]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8004dcc:	f105 0c08 	add.w	ip, r5, #8
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 8004dd0:	f3c6 6684 	ubfx	r6, r6, #26, #5
 8004dd4:	42a6      	cmp	r6, r4
 8004dd6:	d05c      	beq.n	8004e92 <HAL_ADCEx_InjectedConfigChannel+0x562>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8004dd8:	68ee      	ldr	r6, [r5, #12]
 8004dda:	68ee      	ldr	r6, [r5, #12]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8004ddc:	f105 070c 	add.w	r7, r5, #12
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 8004de0:	f3c6 6584 	ubfx	r5, r6, #26, #5
 8004de4:	e7c6      	b.n	8004d74 <HAL_ADCEx_InjectedConfigChannel+0x444>
                                    (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL(
 8004de6:	3c1e      	subs	r4, #30
 8004de8:	0524      	lsls	r4, r4, #20
 8004dea:	f044 7400 	orr.w	r4, r4, #33554432	@ 0x2000000
 8004dee:	e708      	b.n	8004c02 <HAL_ADCEx_InjectedConfigChannel+0x2d2>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8004df0:	6dd5      	ldr	r5, [r2, #92]	@ 0x5c
 8004df2:	f045 0520 	orr.w	r5, r5, #32
 8004df6:	65d5      	str	r5, [r2, #92]	@ 0x5c
        tmp_hal_status = HAL_ERROR;
 8004df8:	e648      	b.n	8004a8c <HAL_ADCEx_InjectedConfigChannel+0x15c>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004dfa:	fa94 f5a4 	rbit	r5, r4
  if (value == 0U)
 8004dfe:	2d00      	cmp	r5, #0
 8004e00:	d071      	beq.n	8004ee6 <HAL_ADCEx_InjectedConfigChannel+0x5b6>
  return __builtin_clz(value);
 8004e02:	fab5 f585 	clz	r5, r5
                                    (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL(
 8004e06:	3501      	adds	r5, #1
 8004e08:	06ad      	lsls	r5, r5, #26
 8004e0a:	f005 45f8 	and.w	r5, r5, #2080374784	@ 0x7c000000
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004e0e:	fa94 f6a4 	rbit	r6, r4
  if (value == 0U)
 8004e12:	2e00      	cmp	r6, #0
 8004e14:	d065      	beq.n	8004ee2 <HAL_ADCEx_InjectedConfigChannel+0x5b2>
  return __builtin_clz(value);
 8004e16:	fab6 f686 	clz	r6, r6
 8004e1a:	3601      	adds	r6, #1
 8004e1c:	f006 061f 	and.w	r6, r6, #31
 8004e20:	2701      	movs	r7, #1
 8004e22:	fa07 f606 	lsl.w	r6, r7, r6
 8004e26:	4335      	orrs	r5, r6
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004e28:	fa94 f4a4 	rbit	r4, r4
  if (value == 0U)
 8004e2c:	2c00      	cmp	r4, #0
 8004e2e:	d053      	beq.n	8004ed8 <HAL_ADCEx_InjectedConfigChannel+0x5a8>
  return __builtin_clz(value);
 8004e30:	fab4 f484 	clz	r4, r4
 8004e34:	3401      	adds	r4, #1
 8004e36:	f004 041f 	and.w	r4, r4, #31
 8004e3a:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 8004e3e:	e6df      	b.n	8004c00 <HAL_ADCEx_InjectedConfigChannel+0x2d0>
 8004e40:	f105 0808 	add.w	r8, r5, #8
  MODIFY_REG(*preg,
 8004e44:	6e5c      	ldr	r4, [r3, #100]	@ 0x64
 8004e46:	f024 4400 	bic.w	r4, r4, #2147483648	@ 0x80000000
 8004e4a:	665c      	str	r4, [r3, #100]	@ 0x64
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfigInjected->InjectedChannel))
 8004e4c:	f8d1 e000 	ldr.w	lr, [r1]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8004e50:	68ac      	ldr	r4, [r5, #8]
 8004e52:	68ae      	ldr	r6, [r5, #8]
 8004e54:	f3ce 0712 	ubfx	r7, lr, #0, #19
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8004e58:	46c4      	mov	ip, r8
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 8004e5a:	f3c6 6684 	ubfx	r6, r6, #26, #5
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfigInjected->InjectedChannel))
 8004e5e:	4674      	mov	r4, lr
 8004e60:	2f00      	cmp	r7, #0
 8004e62:	f47f af6f 	bne.w	8004d44 <HAL_ADCEx_InjectedConfigChannel+0x414>
 8004e66:	f3ce 6484 	ubfx	r4, lr, #26, #5
 8004e6a:	e7b3      	b.n	8004dd4 <HAL_ADCEx_InjectedConfigChannel+0x4a4>
  MODIFY_REG(*preg,
 8004e6c:	6e1c      	ldr	r4, [r3, #96]	@ 0x60
 8004e6e:	f024 4400 	bic.w	r4, r4, #2147483648	@ 0x80000000
 8004e72:	661c      	str	r4, [r3, #96]	@ 0x60
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfigInjected->InjectedChannel))
 8004e74:	f8d1 e000 	ldr.w	lr, [r1]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8004e78:	6e5c      	ldr	r4, [r3, #100]	@ 0x64
 8004e7a:	6e5e      	ldr	r6, [r3, #100]	@ 0x64
 8004e7c:	f3ce 0712 	ubfx	r7, lr, #0, #19
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 8004e80:	f3c6 6684 	ubfx	r6, r6, #26, #5
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfigInjected->InjectedChannel))
 8004e84:	4674      	mov	r4, lr
 8004e86:	2f00      	cmp	r7, #0
 8004e88:	f47f af4d 	bne.w	8004d26 <HAL_ADCEx_InjectedConfigChannel+0x3f6>
 8004e8c:	f3ce 6484 	ubfx	r4, lr, #26, #5
 8004e90:	e798      	b.n	8004dc4 <HAL_ADCEx_InjectedConfigChannel+0x494>
 8004e92:	f105 090c 	add.w	r9, r5, #12
  MODIFY_REG(*preg,
 8004e96:	f8dc 4000 	ldr.w	r4, [ip]
 8004e9a:	f024 4400 	bic.w	r4, r4, #2147483648	@ 0x80000000
 8004e9e:	f8cc 4000 	str.w	r4, [ip]
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfigInjected->InjectedChannel))
 8004ea2:	f8d1 e000 	ldr.w	lr, [r1]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8004ea6:	68ec      	ldr	r4, [r5, #12]
 8004ea8:	68ed      	ldr	r5, [r5, #12]
 8004eaa:	f3ce 0612 	ubfx	r6, lr, #0, #19
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8004eae:	464f      	mov	r7, r9
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 8004eb0:	f3c5 6584 	ubfx	r5, r5, #26, #5
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(pConfigInjected->InjectedChannel))
 8004eb4:	4674      	mov	r4, lr
 8004eb6:	2e00      	cmp	r6, #0
 8004eb8:	f47f af55 	bne.w	8004d66 <HAL_ADCEx_InjectedConfigChannel+0x436>
 8004ebc:	f3ce 6484 	ubfx	r4, lr, #26, #5
 8004ec0:	e758      	b.n	8004d74 <HAL_ADCEx_InjectedConfigChannel+0x444>
  MODIFY_REG(*preg,
 8004ec2:	683c      	ldr	r4, [r7, #0]
 8004ec4:	f024 4400 	bic.w	r4, r4, #2147483648	@ 0x80000000
 8004ec8:	603c      	str	r4, [r7, #0]
    LL_ADC_SetChannelSingleDiff(hadc->Instance, pConfigInjected->InjectedChannel, pConfigInjected->InjectedSingleDiff);
 8004eca:	680c      	ldr	r4, [r1, #0]
}
 8004ecc:	e577      	b.n	80049be <HAL_ADCEx_InjectedConfigChannel+0x8e>
 8004ece:	2602      	movs	r6, #2
 8004ed0:	e701      	b.n	8004cd6 <HAL_ADCEx_InjectedConfigChannel+0x3a6>
 8004ed2:	f04f 6580 	mov.w	r5, #67108864	@ 0x4000000
 8004ed6:	e6f1      	b.n	8004cbc <HAL_ADCEx_InjectedConfigChannel+0x38c>
 8004ed8:	f44f 1440 	mov.w	r4, #3145728	@ 0x300000
 8004edc:	e691      	b.n	8004c02 <HAL_ADCEx_InjectedConfigChannel+0x2d2>
 8004ede:	4c03      	ldr	r4, [pc, #12]	@ (8004eec <HAL_ADCEx_InjectedConfigChannel+0x5bc>)
 8004ee0:	e68f      	b.n	8004c02 <HAL_ADCEx_InjectedConfigChannel+0x2d2>
 8004ee2:	2602      	movs	r6, #2
 8004ee4:	e79f      	b.n	8004e26 <HAL_ADCEx_InjectedConfigChannel+0x4f6>
 8004ee6:	f04f 6580 	mov.w	r5, #67108864	@ 0x4000000
 8004eea:	e790      	b.n	8004e0e <HAL_ADCEx_InjectedConfigChannel+0x4de>
 8004eec:	fe500000 	.word	0xfe500000

08004ef0 <HAL_ADCEx_MultiModeConfigChannel>:
  * @param hadc Master ADC handle
  * @param pMultimode Structure of ADC multimode configuration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_MultiModeConfigChannel(ADC_HandleTypeDef *hadc, const ADC_MultiModeTypeDef *pMultimode)
{
 8004ef0:	b4f0      	push	{r4, r5, r6, r7}
    assert_param(IS_ADC_DMA_ACCESS_MULTIMODE(pMultimode->DMAAccessMode));
    assert_param(IS_ADC_SAMPLING_DELAY(pMultimode->TwoSamplingDelay));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 8004ef2:	f890 2058 	ldrb.w	r2, [r0, #88]	@ 0x58
  if (pMultimode->Mode != ADC_MODE_INDEPENDENT)
 8004ef6:	680d      	ldr	r5, [r1, #0]
  __HAL_LOCK(hadc);
 8004ef8:	2a01      	cmp	r2, #1
{
 8004efa:	b09c      	sub	sp, #112	@ 0x70
  __HAL_LOCK(hadc);
 8004efc:	d042      	beq.n	8004f84 <HAL_ADCEx_MultiModeConfigChannel+0x94>

  /* Temporary handle minimum initialization */
  __HAL_ADC_RESET_HANDLE_STATE(&tmp_hadc_slave);
  ADC_CLEAR_ERRORCODE(&tmp_hadc_slave);

  ADC_MULTI_SLAVE(hadc, &tmp_hadc_slave);
 8004efe:	6804      	ldr	r4, [r0, #0]
 8004f00:	4603      	mov	r3, r0
  __HAL_ADC_RESET_HANDLE_STATE(&tmp_hadc_slave);
 8004f02:	2200      	movs	r2, #0
  __HAL_LOCK(hadc);
 8004f04:	2001      	movs	r0, #1
  ADC_MULTI_SLAVE(hadc, &tmp_hadc_slave);
 8004f06:	f1b4 4fa0 	cmp.w	r4, #1342177280	@ 0x50000000
  __HAL_ADC_RESET_HANDLE_STATE(&tmp_hadc_slave);
 8004f0a:	9218      	str	r2, [sp, #96]	@ 0x60
  __HAL_LOCK(hadc);
 8004f0c:	f883 0058 	strb.w	r0, [r3, #88]	@ 0x58
  ADC_CLEAR_ERRORCODE(&tmp_hadc_slave);
 8004f10:	9219      	str	r2, [sp, #100]	@ 0x64
  ADC_MULTI_SLAVE(hadc, &tmp_hadc_slave);
 8004f12:	d008      	beq.n	8004f26 <HAL_ADCEx_MultiModeConfigChannel+0x36>

  if (tmp_hadc_slave.Instance == NULL)
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8004f14:	6dd9      	ldr	r1, [r3, #92]	@ 0x5c

    /* Process unlocked */
    __HAL_UNLOCK(hadc);
 8004f16:	f883 2058 	strb.w	r2, [r3, #88]	@ 0x58
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8004f1a:	f041 0120 	orr.w	r1, r1, #32
 8004f1e:	65d9      	str	r1, [r3, #92]	@ 0x5c
  /* Process unlocked */
  __HAL_UNLOCK(hadc);

  /* Return function status */
  return tmp_hal_status;
}
 8004f20:	b01c      	add	sp, #112	@ 0x70
 8004f22:	bcf0      	pop	{r4, r5, r6, r7}
 8004f24:	4770      	bx	lr
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8004f26:	4a23      	ldr	r2, [pc, #140]	@ (8004fb4 <HAL_ADCEx_MultiModeConfigChannel+0xc4>)
 8004f28:	6890      	ldr	r0, [r2, #8]
 8004f2a:	0740      	lsls	r0, r0, #29
 8004f2c:	d50b      	bpl.n	8004f46 <HAL_ADCEx_MultiModeConfigChannel+0x56>
 8004f2e:	68a2      	ldr	r2, [r4, #8]
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8004f30:	6dda      	ldr	r2, [r3, #92]	@ 0x5c
 8004f32:	f042 0220 	orr.w	r2, r2, #32
    tmp_hal_status = HAL_ERROR;
 8004f36:	2001      	movs	r0, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8004f38:	65da      	str	r2, [r3, #92]	@ 0x5c
  __HAL_UNLOCK(hadc);
 8004f3a:	2200      	movs	r2, #0
 8004f3c:	f883 2058 	strb.w	r2, [r3, #88]	@ 0x58
}
 8004f40:	b01c      	add	sp, #112	@ 0x70
 8004f42:	bcf0      	pop	{r4, r5, r6, r7}
 8004f44:	4770      	bx	lr
 8004f46:	68a0      	ldr	r0, [r4, #8]
 8004f48:	0746      	lsls	r6, r0, #29
 8004f4a:	d4f1      	bmi.n	8004f30 <HAL_ADCEx_MultiModeConfigChannel+0x40>
    if (pMultimode->Mode != ADC_MODE_INDEPENDENT)
 8004f4c:	b1f5      	cbz	r5, 8004f8c <HAL_ADCEx_MultiModeConfigChannel+0x9c>
      MODIFY_REG(tmpADC_Common->CCR, ADC_CCR_MDMA | ADC_CCR_DMACFG,
 8004f4e:	4e1a      	ldr	r6, [pc, #104]	@ (8004fb8 <HAL_ADCEx_MultiModeConfigChannel+0xc8>)
 8004f50:	684f      	ldr	r7, [r1, #4]
 8004f52:	68b0      	ldr	r0, [r6, #8]
 8004f54:	f893 c038 	ldrb.w	ip, [r3, #56]	@ 0x38
 8004f58:	f420 4060 	bic.w	r0, r0, #57344	@ 0xe000
 8004f5c:	4338      	orrs	r0, r7
 8004f5e:	ea40 304c 	orr.w	r0, r0, ip, lsl #13
 8004f62:	60b0      	str	r0, [r6, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8004f64:	68a0      	ldr	r0, [r4, #8]
 8004f66:	6892      	ldr	r2, [r2, #8]
 8004f68:	07c0      	lsls	r0, r0, #31
 8004f6a:	d420      	bmi.n	8004fae <HAL_ADCEx_MultiModeConfigChannel+0xbe>
 8004f6c:	07d7      	lsls	r7, r2, #31
 8004f6e:	d41e      	bmi.n	8004fae <HAL_ADCEx_MultiModeConfigChannel+0xbe>
        MODIFY_REG(tmpADC_Common->CCR,
 8004f70:	68b0      	ldr	r0, [r6, #8]
 8004f72:	688a      	ldr	r2, [r1, #8]
 8004f74:	f420 6171 	bic.w	r1, r0, #3856	@ 0xf10
 8004f78:	432a      	orrs	r2, r5
 8004f7a:	f021 010f 	bic.w	r1, r1, #15
 8004f7e:	430a      	orrs	r2, r1
 8004f80:	60b2      	str	r2, [r6, #8]
 8004f82:	e014      	b.n	8004fae <HAL_ADCEx_MultiModeConfigChannel+0xbe>
  __HAL_LOCK(hadc);
 8004f84:	2002      	movs	r0, #2
}
 8004f86:	b01c      	add	sp, #112	@ 0x70
 8004f88:	bcf0      	pop	{r4, r5, r6, r7}
 8004f8a:	4770      	bx	lr
      CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_MDMA | ADC_CCR_DMACFG);
 8004f8c:	480a      	ldr	r0, [pc, #40]	@ (8004fb8 <HAL_ADCEx_MultiModeConfigChannel+0xc8>)
 8004f8e:	6881      	ldr	r1, [r0, #8]
 8004f90:	f421 4160 	bic.w	r1, r1, #57344	@ 0xe000
 8004f94:	6081      	str	r1, [r0, #8]
 8004f96:	68a1      	ldr	r1, [r4, #8]
 8004f98:	6892      	ldr	r2, [r2, #8]
 8004f9a:	07cd      	lsls	r5, r1, #31
 8004f9c:	d407      	bmi.n	8004fae <HAL_ADCEx_MultiModeConfigChannel+0xbe>
 8004f9e:	07d4      	lsls	r4, r2, #31
 8004fa0:	d405      	bmi.n	8004fae <HAL_ADCEx_MultiModeConfigChannel+0xbe>
        CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DUAL | ADC_CCR_DELAY);
 8004fa2:	6882      	ldr	r2, [r0, #8]
 8004fa4:	f422 6271 	bic.w	r2, r2, #3856	@ 0xf10
 8004fa8:	f022 020f 	bic.w	r2, r2, #15
 8004fac:	6082      	str	r2, [r0, #8]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8004fae:	2000      	movs	r0, #0
 8004fb0:	e7c3      	b.n	8004f3a <HAL_ADCEx_MultiModeConfigChannel+0x4a>
 8004fb2:	bf00      	nop
 8004fb4:	50000100 	.word	0x50000100
 8004fb8:	50000300 	.word	0x50000300

08004fbc <HAL_CORDIC_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CORDIC_Init(CORDIC_HandleTypeDef *hcordic)
{
  /* Check the CORDIC handle allocation */
  if (hcordic == NULL)
 8004fbc:	b1b0      	cbz	r0, 8004fec <HAL_CORDIC_Init+0x30>
{
 8004fbe:	b510      	push	{r4, lr}

    /* Initialize the low level hardware */
    hcordic->MspInitCallback(hcordic);
  }
#else
  if (hcordic->State == HAL_CORDIC_STATE_RESET)
 8004fc0:	f890 3021 	ldrb.w	r3, [r0, #33]	@ 0x21
 8004fc4:	4604      	mov	r4, r0
 8004fc6:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 8004fca:	b153      	cbz	r3, 8004fe2 <HAL_CORDIC_Init+0x26>
    HAL_CORDIC_MspInit(hcordic);
  }
#endif /* (USE_HAL_CORDIC_REGISTER_CALLBACKS) */

  /* Set CORDIC error code to none */
  hcordic->ErrorCode = HAL_CORDIC_ERROR_NONE;
 8004fcc:	2000      	movs	r0, #0

  /* Reset DMADirection */
  hcordic->DMADirection = CORDIC_DMA_DIR_NONE;

  /* Change CORDIC peripheral state */
  hcordic->State = HAL_CORDIC_STATE_READY;
 8004fce:	2301      	movs	r3, #1
  hcordic->ErrorCode = HAL_CORDIC_ERROR_NONE;
 8004fd0:	6260      	str	r0, [r4, #36]	@ 0x24
  hcordic->State = HAL_CORDIC_STATE_READY;
 8004fd2:	f884 3021 	strb.w	r3, [r4, #33]	@ 0x21
  hcordic->pInBuff = NULL;
 8004fd6:	e9c4 0001 	strd	r0, r0, [r4, #4]
  hcordic->NbCalcToOrder = 0U;
 8004fda:	e9c4 0003 	strd	r0, r0, [r4, #12]
  hcordic->DMADirection = CORDIC_DMA_DIR_NONE;
 8004fde:	6160      	str	r0, [r4, #20]

  /* Return function status */
  return HAL_OK;
}
 8004fe0:	bd10      	pop	{r4, pc}
    hcordic->Lock = HAL_UNLOCKED;
 8004fe2:	f880 2020 	strb.w	r2, [r0, #32]
    HAL_CORDIC_MspInit(hcordic);
 8004fe6:	f7fe fe71 	bl	8003ccc <HAL_CORDIC_MspInit>
 8004fea:	e7ef      	b.n	8004fcc <HAL_CORDIC_Init+0x10>
    return HAL_ERROR;
 8004fec:	2001      	movs	r0, #1
}
 8004fee:	4770      	bx	lr

08004ff0 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8004ff0:	4907      	ldr	r1, [pc, #28]	@ (8005010 <HAL_NVIC_SetPriorityGrouping+0x20>)
 8004ff2:	68ca      	ldr	r2, [r1, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8004ff4:	0203      	lsls	r3, r0, #8
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8004ff6:	f64f 00ff 	movw	r0, #63743	@ 0xf8ff
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8004ffa:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8004ffe:	4002      	ands	r2, r0
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8005000:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8005002:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 8005006:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
  SCB->AIRCR =  reg_value;
 800500a:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 800500c:	4770      	bx	lr
 800500e:	bf00      	nop
 8005010:	e000ed00 	.word	0xe000ed00

08005014 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8005014:	4b1b      	ldr	r3, [pc, #108]	@ (8005084 <HAL_NVIC_SetPriority+0x70>)
 8005016:	68db      	ldr	r3, [r3, #12]
 8005018:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800501c:	b500      	push	{lr}
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800501e:	f1c3 0e07 	rsb	lr, r3, #7
 8005022:	f1be 0f04 	cmp.w	lr, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8005026:	f103 0c04 	add.w	ip, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800502a:	bf28      	it	cs
 800502c:	f04f 0e04 	movcs.w	lr, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8005030:	f1bc 0f06 	cmp.w	ip, #6
 8005034:	d91c      	bls.n	8005070 <HAL_NVIC_SetPriority+0x5c>
 8005036:	f1a3 0c03 	sub.w	ip, r3, #3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800503a:	f04f 33ff 	mov.w	r3, #4294967295
 800503e:	fa03 f30c 	lsl.w	r3, r3, ip
 8005042:	ea22 0203 	bic.w	r2, r2, r3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8005046:	f04f 33ff 	mov.w	r3, #4294967295
 800504a:	fa03 f30e 	lsl.w	r3, r3, lr
 800504e:	ea21 0303 	bic.w	r3, r1, r3
 8005052:	fa03 f30c 	lsl.w	r3, r3, ip
 8005056:	4313      	orrs	r3, r2
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8005058:	011b      	lsls	r3, r3, #4
  if ((int32_t)(IRQn) >= 0)
 800505a:	2800      	cmp	r0, #0
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800505c:	b2db      	uxtb	r3, r3
  if ((int32_t)(IRQn) >= 0)
 800505e:	db0a      	blt.n	8005076 <HAL_NVIC_SetPriority+0x62>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8005060:	f100 4060 	add.w	r0, r0, #3758096384	@ 0xe0000000
 8005064:	f500 4061 	add.w	r0, r0, #57600	@ 0xe100
 8005068:	f880 3300 	strb.w	r3, [r0, #768]	@ 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 800506c:	f85d fb04 	ldr.w	pc, [sp], #4
 8005070:	2200      	movs	r2, #0
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8005072:	4694      	mov	ip, r2
 8005074:	e7e7      	b.n	8005046 <HAL_NVIC_SetPriority+0x32>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8005076:	4a04      	ldr	r2, [pc, #16]	@ (8005088 <HAL_NVIC_SetPriority+0x74>)
 8005078:	f000 000f 	and.w	r0, r0, #15
 800507c:	4402      	add	r2, r0
 800507e:	7613      	strb	r3, [r2, #24]
 8005080:	f85d fb04 	ldr.w	pc, [sp], #4
 8005084:	e000ed00 	.word	0xe000ed00
 8005088:	e000ecfc 	.word	0xe000ecfc

0800508c <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 800508c:	2800      	cmp	r0, #0
 800508e:	db07      	blt.n	80050a0 <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8005090:	4a04      	ldr	r2, [pc, #16]	@ (80050a4 <HAL_NVIC_EnableIRQ+0x18>)
 8005092:	0941      	lsrs	r1, r0, #5
 8005094:	2301      	movs	r3, #1
 8005096:	f000 001f 	and.w	r0, r0, #31
 800509a:	4083      	lsls	r3, r0
 800509c:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 80050a0:	4770      	bx	lr
 80050a2:	bf00      	nop
 80050a4:	e000e100 	.word	0xe000e100

080050a8 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 80050a8:	3801      	subs	r0, #1
 80050aa:	f1b0 7f80 	cmp.w	r0, #16777216	@ 0x1000000
 80050ae:	d301      	bcc.n	80050b4 <HAL_SYSTICK_Config+0xc>
  {
    return (1UL);                                                   /* Reload value impossible */
 80050b0:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 80050b2:	4770      	bx	lr
{
 80050b4:	b410      	push	{r4}
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80050b6:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80050ba:	4c07      	ldr	r4, [pc, #28]	@ (80050d8 <HAL_SYSTICK_Config+0x30>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80050bc:	6158      	str	r0, [r3, #20]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80050be:	f04f 0cf0 	mov.w	ip, #240	@ 0xf0
 80050c2:	f884 c023 	strb.w	ip, [r4, #35]	@ 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80050c6:	2200      	movs	r2, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80050c8:	2107      	movs	r1, #7
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 80050ca:	4610      	mov	r0, r2
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80050cc:	619a      	str	r2, [r3, #24]
}
 80050ce:	f85d 4b04 	ldr.w	r4, [sp], #4
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80050d2:	6119      	str	r1, [r3, #16]
 80050d4:	4770      	bx	lr
 80050d6:	bf00      	nop
 80050d8:	e000ed00 	.word	0xe000ed00

080050dc <HAL_DAC_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DAC_Init(DAC_HandleTypeDef *hdac)
{
  /* Check the DAC peripheral handle */
  if (hdac == NULL)
 80050dc:	b188      	cbz	r0, 8005102 <HAL_DAC_Init+0x26>
{
 80050de:	b510      	push	{r4, lr}
    return HAL_ERROR;
  }
  /* Check the parameters */
  assert_param(IS_DAC_ALL_INSTANCE(hdac->Instance));

  if (hdac->State == HAL_DAC_STATE_RESET)
 80050e0:	7903      	ldrb	r3, [r0, #4]
 80050e2:	4604      	mov	r4, r0
 80050e4:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 80050e8:	b13b      	cbz	r3, 80050fa <HAL_DAC_Init+0x1e>

  /* Initialize the DAC state*/
  hdac->State = HAL_DAC_STATE_BUSY;

  /* Set DAC error code to none */
  hdac->ErrorCode = HAL_DAC_ERROR_NONE;
 80050ea:	2300      	movs	r3, #0
  hdac->State = HAL_DAC_STATE_BUSY;
 80050ec:	2102      	movs	r1, #2

  /* Initialize the DAC state*/
  hdac->State = HAL_DAC_STATE_READY;
 80050ee:	2201      	movs	r2, #1
  hdac->State = HAL_DAC_STATE_BUSY;
 80050f0:	7121      	strb	r1, [r4, #4]
  hdac->ErrorCode = HAL_DAC_ERROR_NONE;
 80050f2:	6123      	str	r3, [r4, #16]
  hdac->State = HAL_DAC_STATE_READY;
 80050f4:	7122      	strb	r2, [r4, #4]

  /* Return function status */
  return HAL_OK;
 80050f6:	4618      	mov	r0, r3
}
 80050f8:	bd10      	pop	{r4, pc}
    hdac->Lock = HAL_UNLOCKED;
 80050fa:	7142      	strb	r2, [r0, #5]
    HAL_DAC_MspInit(hdac);
 80050fc:	f7fe fdfe 	bl	8003cfc <HAL_DAC_MspInit>
 8005100:	e7f3      	b.n	80050ea <HAL_DAC_Init+0xe>
    return HAL_ERROR;
 8005102:	2001      	movs	r0, #1
}
 8005104:	4770      	bx	lr
 8005106:	bf00      	nop

08005108 <HAL_DAC_DMAUnderrunCallbackCh1>:
  * @brief  DMA underrun DAC callback for channel1.
  * @param  hdac pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval None
  */
__weak void HAL_DAC_DMAUnderrunCallbackCh1(DAC_HandleTypeDef *hdac)
 8005108:	4770      	bx	lr
 800510a:	bf00      	nop

0800510c <HAL_DAC_IRQHandler>:
  uint32_t itsource = hdac->Instance->CR;
 800510c:	6803      	ldr	r3, [r0, #0]
{
 800510e:	b570      	push	{r4, r5, r6, lr}
  uint32_t itsource = hdac->Instance->CR;
 8005110:	681d      	ldr	r5, [r3, #0]
  uint32_t itflag   = hdac->Instance->SR;
 8005112:	6b5e      	ldr	r6, [r3, #52]	@ 0x34
  if ((itsource & DAC_IT_DMAUDR1) == DAC_IT_DMAUDR1)
 8005114:	04aa      	lsls	r2, r5, #18
{
 8005116:	4604      	mov	r4, r0
  if ((itsource & DAC_IT_DMAUDR1) == DAC_IT_DMAUDR1)
 8005118:	d501      	bpl.n	800511e <HAL_DAC_IRQHandler+0x12>
    if ((itflag & DAC_FLAG_DMAUDR1) == DAC_FLAG_DMAUDR1)
 800511a:	04b1      	lsls	r1, r6, #18
 800511c:	d417      	bmi.n	800514e <HAL_DAC_IRQHandler+0x42>
  if ((itsource & DAC_IT_DMAUDR2) == DAC_IT_DMAUDR2)
 800511e:	00aa      	lsls	r2, r5, #2
 8005120:	d501      	bpl.n	8005126 <HAL_DAC_IRQHandler+0x1a>
    if ((itflag & DAC_FLAG_DMAUDR2) == DAC_FLAG_DMAUDR2)
 8005122:	00b3      	lsls	r3, r6, #2
 8005124:	d400      	bmi.n	8005128 <HAL_DAC_IRQHandler+0x1c>
}
 8005126:	bd70      	pop	{r4, r5, r6, pc}
      hdac->State = HAL_DAC_STATE_ERROR;
 8005128:	2304      	movs	r3, #4
 800512a:	7123      	strb	r3, [r4, #4]
      SET_BIT(hdac->ErrorCode, HAL_DAC_ERROR_DMAUNDERRUNCH2);
 800512c:	6922      	ldr	r2, [r4, #16]
      __HAL_DAC_CLEAR_FLAG(hdac, DAC_FLAG_DMAUDR2);
 800512e:	6823      	ldr	r3, [r4, #0]
      SET_BIT(hdac->ErrorCode, HAL_DAC_ERROR_DMAUNDERRUNCH2);
 8005130:	f042 0202 	orr.w	r2, r2, #2
      __HAL_DAC_CLEAR_FLAG(hdac, DAC_FLAG_DMAUDR2);
 8005134:	f04f 5100 	mov.w	r1, #536870912	@ 0x20000000
      SET_BIT(hdac->ErrorCode, HAL_DAC_ERROR_DMAUNDERRUNCH2);
 8005138:	6122      	str	r2, [r4, #16]
      __HAL_DAC_CLEAR_FLAG(hdac, DAC_FLAG_DMAUDR2);
 800513a:	6359      	str	r1, [r3, #52]	@ 0x34
      __HAL_DAC_DISABLE_IT(hdac, DAC_CR_DMAEN2);
 800513c:	681a      	ldr	r2, [r3, #0]
 800513e:	f022 5280 	bic.w	r2, r2, #268435456	@ 0x10000000
      HAL_DACEx_DMAUnderrunCallbackCh2(hdac);
 8005142:	4620      	mov	r0, r4
      __HAL_DAC_DISABLE_IT(hdac, DAC_CR_DMAEN2);
 8005144:	601a      	str	r2, [r3, #0]
}
 8005146:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      HAL_DACEx_DMAUnderrunCallbackCh2(hdac);
 800514a:	f000 b909 	b.w	8005360 <HAL_DACEx_DMAUnderrunCallbackCh2>
      hdac->State = HAL_DAC_STATE_ERROR;
 800514e:	2204      	movs	r2, #4
 8005150:	7102      	strb	r2, [r0, #4]
      SET_BIT(hdac->ErrorCode, HAL_DAC_ERROR_DMAUNDERRUNCH1);
 8005152:	6902      	ldr	r2, [r0, #16]
 8005154:	f042 0201 	orr.w	r2, r2, #1
 8005158:	6102      	str	r2, [r0, #16]
      __HAL_DAC_CLEAR_FLAG(hdac, DAC_FLAG_DMAUDR1);
 800515a:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 800515e:	635a      	str	r2, [r3, #52]	@ 0x34
      __HAL_DAC_DISABLE_IT(hdac, DAC_CR_DMAEN1);
 8005160:	681a      	ldr	r2, [r3, #0]
 8005162:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
 8005166:	601a      	str	r2, [r3, #0]
      HAL_DAC_DMAUnderrunCallbackCh1(hdac);
 8005168:	f7ff ffce 	bl	8005108 <HAL_DAC_DMAUnderrunCallbackCh1>
 800516c:	e7d7      	b.n	800511e <HAL_DAC_IRQHandler+0x12>
 800516e:	bf00      	nop

08005170 <HAL_DAC_ConfigChannel>:
  uint32_t tickstart;
  uint32_t hclkfreq;
  uint32_t connectOnChip;

  /* Check the DAC peripheral handle and channel configuration struct */
  if ((hdac == NULL) || (sConfig == NULL))
 8005170:	2800      	cmp	r0, #0
 8005172:	f000 80ce 	beq.w	8005312 <HAL_DAC_ConfigChannel+0x1a2>
{
 8005176:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800517a:	460f      	mov	r7, r1
  if ((hdac == NULL) || (sConfig == NULL))
 800517c:	2900      	cmp	r1, #0
 800517e:	f000 80ca 	beq.w	8005316 <HAL_DAC_ConfigChannel+0x1a6>
  assert_param(IS_DAC_CHANNEL(hdac->Instance, Channel));
  assert_param(IS_FUNCTIONAL_STATE(sConfig->DAC_DMADoubleDataMode));
  assert_param(IS_FUNCTIONAL_STATE(sConfig->DAC_SignedFormat));

  /* Process locked */
  __HAL_LOCK(hdac);
 8005182:	7943      	ldrb	r3, [r0, #5]
  if ((sConfig->DAC_SampleAndHold) == DAC_SAMPLEANDHOLD_ENABLE)
 8005184:	6889      	ldr	r1, [r1, #8]
  __HAL_LOCK(hdac);
 8005186:	2b01      	cmp	r3, #1
 8005188:	4606      	mov	r6, r0
 800518a:	f000 80d3 	beq.w	8005334 <HAL_DAC_ConfigChannel+0x1c4>
 800518e:	2301      	movs	r3, #1
 8005190:	7143      	strb	r3, [r0, #5]

  /* Change DAC state */
  hdac->State = HAL_DAC_STATE_BUSY;

  /* Sample and hold configuration */
  if (sConfig->DAC_SampleAndHold == DAC_SAMPLEANDHOLD_ENABLE)
 8005192:	2904      	cmp	r1, #4
  hdac->State = HAL_DAC_STATE_BUSY;
 8005194:	f04f 0302 	mov.w	r3, #2
 8005198:	4614      	mov	r4, r2
 800519a:	7103      	strb	r3, [r0, #4]
  if (sConfig->DAC_SampleAndHold == DAC_SAMPLEANDHOLD_ENABLE)
 800519c:	d07b      	beq.n	8005296 <HAL_DAC_ConfigChannel+0x126>

  if (sConfig->DAC_UserTrimming == DAC_TRIMMING_USER)
    /* USER TRIMMING */
  {
    /* Get the DAC CCR value */
    tmpreg1 = hdac->Instance->CCR;
 800519e:	6803      	ldr	r3, [r0, #0]
    MODIFY_REG(hdac->Instance->SHHR, DAC_SHHR_THOLD1 << (Channel & 0x10UL),
 80051a0:	f002 0410 	and.w	r4, r2, #16
  if (sConfig->DAC_UserTrimming == DAC_TRIMMING_USER)
 80051a4:	69fa      	ldr	r2, [r7, #28]
 80051a6:	2a01      	cmp	r2, #1
 80051a8:	d108      	bne.n	80051bc <HAL_DAC_ConfigChannel+0x4c>
    tmpreg1 = hdac->Instance->CCR;
 80051aa:	6b98      	ldr	r0, [r3, #56]	@ 0x38
    /* Clear trimming value */
    tmpreg1 &= ~(((uint32_t)(DAC_CCR_OTRIM1)) << (Channel & 0x10UL));
    /* Configure for the selected trimming offset */
    tmpreg2 = sConfig->DAC_TrimmingValue;
    /* Calculate CCR register value depending on DAC_Channel */
    tmpreg1 |= tmpreg2 << (Channel & 0x10UL);
 80051ac:	6a3a      	ldr	r2, [r7, #32]
    tmpreg1 &= ~(((uint32_t)(DAC_CCR_OTRIM1)) << (Channel & 0x10UL));
 80051ae:	251f      	movs	r5, #31
 80051b0:	40a5      	lsls	r5, r4
    tmpreg1 |= tmpreg2 << (Channel & 0x10UL);
 80051b2:	40a2      	lsls	r2, r4
    tmpreg1 &= ~(((uint32_t)(DAC_CCR_OTRIM1)) << (Channel & 0x10UL));
 80051b4:	ea20 0005 	bic.w	r0, r0, r5
    tmpreg1 |= tmpreg2 << (Channel & 0x10UL);
 80051b8:	4302      	orrs	r2, r0
    /* Write to DAC CCR */
    hdac->Instance->CCR = tmpreg1;
 80051ba:	639a      	str	r2, [r3, #56]	@ 0x38
  /* Clear DAC_MCR_MODEx bits */
  tmpreg1 &= ~(((uint32_t)(DAC_MCR_MODE1)) << (Channel & 0x10UL));
  /* Configure for the selected DAC channel: mode, buffer output & on chip peripheral connect */


  if (sConfig->DAC_ConnectOnChipPeripheral == DAC_CHIPCONNECT_EXTERNAL)
 80051bc:	69bd      	ldr	r5, [r7, #24]
  tmpreg1 = hdac->Instance->MCR;
 80051be:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
  {
    connectOnChip = DAC_MCR_MODE1_0;
  }
  else /* (sConfig->DAC_ConnectOnChipPeripheral == DAC_CHIPCONNECT_BOTH) */
  {
    if (sConfig->DAC_OutputBuffer == DAC_OUTPUTBUFFER_ENABLE)
 80051c0:	f8d7 8014 	ldr.w	r8, [r7, #20]
  tmpreg1 &= ~(((uint32_t)(DAC_MCR_MODE1)) << (Channel & 0x10UL));
 80051c4:	2007      	movs	r0, #7
  if (sConfig->DAC_ConnectOnChipPeripheral == DAC_CHIPCONNECT_EXTERNAL)
 80051c6:	2d01      	cmp	r5, #1
  tmpreg1 &= ~(((uint32_t)(DAC_MCR_MODE1)) << (Channel & 0x10UL));
 80051c8:	fa00 f004 	lsl.w	r0, r0, r4
  if (sConfig->DAC_ConnectOnChipPeripheral == DAC_CHIPCONNECT_EXTERNAL)
 80051cc:	f000 809e 	beq.w	800530c <HAL_DAC_ConfigChannel+0x19c>
  else if (sConfig->DAC_ConnectOnChipPeripheral == DAC_CHIPCONNECT_INTERNAL)
 80051d0:	2d02      	cmp	r5, #2
 80051d2:	f000 80a3 	beq.w	800531c <HAL_DAC_ConfigChannel+0x1ac>
    if (sConfig->DAC_OutputBuffer == DAC_OUTPUTBUFFER_ENABLE)
 80051d6:	fab8 fc88 	clz	ip, r8
 80051da:	ea4f 1c5c 	mov.w	ip, ip, lsr #5
  }
  tmpreg2 = (sConfig->DAC_SampleAndHold | sConfig->DAC_OutputBuffer | connectOnChip);
  /* Clear DAC_MCR_DMADOUBLEx */
  tmpreg1 &= ~(((uint32_t)(DAC_MCR_DMADOUBLE1)) << (Channel & 0x10UL));
  /* Configure for the selected DAC channel: DMA double data mode */
  tmpreg2 |= (sConfig->DAC_DMADoubleDataMode == ENABLE) ? DAC_MCR_DMADOUBLE1 : 0UL;
 80051de:	793d      	ldrb	r5, [r7, #4]
  /* Clear DAC_MCR_SINFORMATx */
  tmpreg1 &= ~(((uint32_t)(DAC_MCR_SINFORMAT1)) << (Channel & 0x10UL));
  /* Configure for the selected DAC channel: Signed format */
  tmpreg2 |= (sConfig->DAC_SignedFormat == ENABLE) ? DAC_MCR_SINFORMAT1 : 0UL;
 80051e0:	f897 e005 	ldrb.w	lr, [r7, #5]
  tmpreg2 |= (sConfig->DAC_DMADoubleDataMode == ENABLE) ? DAC_MCR_DMADOUBLE1 : 0UL;
 80051e4:	f1a5 0501 	sub.w	r5, r5, #1
 80051e8:	fab5 f585 	clz	r5, r5
  tmpreg2 |= (sConfig->DAC_SignedFormat == ENABLE) ? DAC_MCR_SINFORMAT1 : 0UL;
 80051ec:	f1ae 0e01 	sub.w	lr, lr, #1
  tmpreg2 |= (sConfig->DAC_DMADoubleDataMode == ENABLE) ? DAC_MCR_DMADOUBLE1 : 0UL;
 80051f0:	096d      	lsrs	r5, r5, #5
  tmpreg2 |= (sConfig->DAC_SignedFormat == ENABLE) ? DAC_MCR_SINFORMAT1 : 0UL;
 80051f2:	fabe fe8e 	clz	lr, lr
  tmpreg2 |= (sConfig->DAC_DMADoubleDataMode == ENABLE) ? DAC_MCR_DMADOUBLE1 : 0UL;
 80051f6:	022d      	lsls	r5, r5, #8
  tmpreg2 |= (sConfig->DAC_SignedFormat == ENABLE) ? DAC_MCR_SINFORMAT1 : 0UL;
 80051f8:	ea4f 1e5e 	mov.w	lr, lr, lsr #5
 80051fc:	ea45 254e 	orr.w	r5, r5, lr, lsl #9
 8005200:	ea45 0508 	orr.w	r5, r5, r8
 8005204:	430d      	orrs	r5, r1
  tmpreg1 &= ~(((uint32_t)(DAC_MCR_DMADOUBLE1)) << (Channel & 0x10UL));
 8005206:	f44f 7180 	mov.w	r1, #256	@ 0x100
 800520a:	40a1      	lsls	r1, r4
 800520c:	4301      	orrs	r1, r0
 800520e:	ea22 0801 	bic.w	r8, r2, r1
  tmpreg1 &= ~(((uint32_t)(DAC_MCR_SINFORMAT1)) << (Channel & 0x10UL));
 8005212:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8005216:	40a2      	lsls	r2, r4
 8005218:	ea28 0802 	bic.w	r8, r8, r2
  /* Clear DAC_MCR_HFSEL bits */
  tmpreg1 &= ~(DAC_MCR_HFSEL);
  /* Configure for both DAC channels: high frequency mode */
  if (DAC_HIGH_FREQUENCY_INTERFACE_MODE_AUTOMATIC == sConfig->DAC_HighFrequency)
 800521c:	683a      	ldr	r2, [r7, #0]
 800521e:	2a02      	cmp	r2, #2
  tmpreg2 |= (sConfig->DAC_SignedFormat == ENABLE) ? DAC_MCR_SINFORMAT1 : 0UL;
 8005220:	ea45 050c 	orr.w	r5, r5, ip
  tmpreg1 &= ~(DAC_MCR_HFSEL);
 8005224:	f428 4840 	bic.w	r8, r8, #49152	@ 0xc000
  if (DAC_HIGH_FREQUENCY_INTERFACE_MODE_AUTOMATIC == sConfig->DAC_HighFrequency)
 8005228:	d07b      	beq.n	8005322 <HAL_DAC_ConfigChannel+0x1b2>
      tmpreg1 |= DAC_HIGH_FREQUENCY_INTERFACE_MODE_DISABLE;
    }
  }
  else
  {
    tmpreg1 |= sConfig->DAC_HighFrequency;
 800522a:	ea48 0802 	orr.w	r8, r8, r2
  }
  /* Calculate MCR register value depending on DAC_Channel */
  tmpreg1 |= tmpreg2 << (Channel & 0x10UL);
 800522e:	40a5      	lsls	r5, r4
 8005230:	ea45 0508 	orr.w	r5, r5, r8
  /* Write to DAC MCR */
  hdac->Instance->MCR = tmpreg1;
 8005234:	63dd      	str	r5, [r3, #60]	@ 0x3c

  /* DAC in normal operating mode hence clear DAC_CR_CENx bit */
  CLEAR_BIT(hdac->Instance->CR, DAC_CR_CEN1 << (Channel & 0x10UL));
 8005236:	681a      	ldr	r2, [r3, #0]
 8005238:	f44f 4180 	mov.w	r1, #16384	@ 0x4000
 800523c:	40a1      	lsls	r1, r4
 800523e:	ea22 0201 	bic.w	r2, r2, r1
 8005242:	601a      	str	r2, [r3, #0]
  /* Disable wave generation */
  CLEAR_BIT(hdac->Instance->CR, (DAC_CR_WAVE1 << (Channel & 0x10UL)));

  /* Set STRSTTRIGSELx and STINCTRIGSELx bits according to DAC_Trigger & DAC_Trigger2 values */
  tmpreg2 = ((sConfig->DAC_Trigger & DAC_CR_TSEL1) >> DAC_CR_TSEL1_Pos) << DAC_STMODR_STRSTTRIGSEL1_Pos;
  tmpreg2 |= ((sConfig->DAC_Trigger2 & DAC_CR_TSEL1) >> DAC_CR_TSEL1_Pos) << DAC_STMODR_STINCTRIGSEL1_Pos;
 8005244:	e9d7 1203 	ldrd	r1, r2, [r7, #12]
  tmpreg1 = hdac->Instance->CR;
 8005248:	681d      	ldr	r5, [r3, #0]
  tmpreg1 &= ~(((uint32_t)(DAC_CR_MAMP1 | DAC_CR_WAVE1 | DAC_CR_TSEL1 | DAC_CR_TEN1)) << (Channel & 0x10UL));
 800524a:	f640 70fe 	movw	r0, #4094	@ 0xffe
 800524e:	40a0      	lsls	r0, r4
 8005250:	ea25 0500 	bic.w	r5, r5, r0
  tmpreg1 |= tmpreg2 << (Channel & 0x10UL);
 8005254:	fa01 f004 	lsl.w	r0, r1, r4
 8005258:	4328      	orrs	r0, r5
  tmpreg2 |= ((sConfig->DAC_Trigger2 & DAC_CR_TSEL1) >> DAC_CR_TSEL1_Pos) << DAC_STMODR_STINCTRIGSEL1_Pos;
 800525a:	0192      	lsls	r2, r2, #6
  hdac->Instance->CR = tmpreg1;
 800525c:	6018      	str	r0, [r3, #0]
  tmpreg2 = ((sConfig->DAC_Trigger & DAC_CR_TSEL1) >> DAC_CR_TSEL1_Pos) << DAC_STMODR_STRSTTRIGSEL1_Pos;
 800525e:	f3c1 0183 	ubfx	r1, r1, #2, #4
  tmpreg2 |= ((sConfig->DAC_Trigger2 & DAC_CR_TSEL1) >> DAC_CR_TSEL1_Pos) << DAC_STMODR_STINCTRIGSEL1_Pos;
 8005262:	f402 6270 	and.w	r2, r2, #3840	@ 0xf00
 8005266:	430a      	orrs	r2, r1
  /* Modify STMODR register value depending on DAC_Channel */
  MODIFY_REG(hdac->Instance->STMODR, (DAC_STMODR_STINCTRIGSEL1 | DAC_STMODR_STRSTTRIGSEL1)
 8005268:	f640 700f 	movw	r0, #3855	@ 0xf0f
  CLEAR_BIT(hdac->Instance->CR, (DAC_CR_WAVE1 << (Channel & 0x10UL)));
 800526c:	6819      	ldr	r1, [r3, #0]
 800526e:	25c0      	movs	r5, #192	@ 0xc0
  MODIFY_REG(hdac->Instance->STMODR, (DAC_STMODR_STINCTRIGSEL1 | DAC_STMODR_STRSTTRIGSEL1)
 8005270:	40a0      	lsls	r0, r4
 8005272:	40a2      	lsls	r2, r4
  CLEAR_BIT(hdac->Instance->CR, (DAC_CR_WAVE1 << (Channel & 0x10UL)));
 8005274:	fa05 f404 	lsl.w	r4, r5, r4
 8005278:	ea21 0104 	bic.w	r1, r1, r4
 800527c:	6019      	str	r1, [r3, #0]
  MODIFY_REG(hdac->Instance->STMODR, (DAC_STMODR_STINCTRIGSEL1 | DAC_STMODR_STRSTTRIGSEL1)
 800527e:	6e19      	ldr	r1, [r3, #96]	@ 0x60
 8005280:	ea21 0100 	bic.w	r1, r1, r0
             << (Channel & 0x10UL), tmpreg2 << (Channel & 0x10UL));
  /* Change DAC state */
  hdac->State = HAL_DAC_STATE_READY;

  /* Process unlocked */
  __HAL_UNLOCK(hdac);
 8005284:	2400      	movs	r4, #0
  MODIFY_REG(hdac->Instance->STMODR, (DAC_STMODR_STINCTRIGSEL1 | DAC_STMODR_STRSTTRIGSEL1)
 8005286:	430a      	orrs	r2, r1
  hdac->State = HAL_DAC_STATE_READY;
 8005288:	2101      	movs	r1, #1
  MODIFY_REG(hdac->Instance->STMODR, (DAC_STMODR_STINCTRIGSEL1 | DAC_STMODR_STRSTTRIGSEL1)
 800528a:	661a      	str	r2, [r3, #96]	@ 0x60

  /* Return function status */
  return status;
 800528c:	4620      	mov	r0, r4
  hdac->State = HAL_DAC_STATE_READY;
 800528e:	7131      	strb	r1, [r6, #4]
  __HAL_UNLOCK(hdac);
 8005290:	7174      	strb	r4, [r6, #5]
}
 8005292:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    tickstart = HAL_GetTick();
 8005296:	f7fe fff9 	bl	800428c <HAL_GetTick>
      while (((hdac->Instance->SR) & DAC_SR_BWST1) != 0UL)
 800529a:	6833      	ldr	r3, [r6, #0]
    tickstart = HAL_GetTick();
 800529c:	4605      	mov	r5, r0
      while (((hdac->Instance->SR) & DAC_SR_BWST1) != 0UL)
 800529e:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
    if (Channel == DAC_CHANNEL_1)
 80052a0:	b154      	cbz	r4, 80052b8 <HAL_DAC_ConfigChannel+0x148>
 80052a2:	e018      	b.n	80052d6 <HAL_DAC_ConfigChannel+0x166>
        if ((HAL_GetTick() - tickstart) > TIMEOUT_DAC_CALIBCONFIG)
 80052a4:	f7fe fff2 	bl	800428c <HAL_GetTick>
 80052a8:	1b40      	subs	r0, r0, r5
 80052aa:	2801      	cmp	r0, #1
          if (((hdac->Instance->SR) & DAC_SR_BWST1) != 0UL)
 80052ac:	6833      	ldr	r3, [r6, #0]
        if ((HAL_GetTick() - tickstart) > TIMEOUT_DAC_CALIBCONFIG)
 80052ae:	d902      	bls.n	80052b6 <HAL_DAC_ConfigChannel+0x146>
          if (((hdac->Instance->SR) & DAC_SR_BWST1) != 0UL)
 80052b0:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 80052b2:	0411      	lsls	r1, r2, #16
 80052b4:	d448      	bmi.n	8005348 <HAL_DAC_ConfigChannel+0x1d8>
      while (((hdac->Instance->SR) & DAC_SR_BWST1) != 0UL)
 80052b6:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 80052b8:	0412      	lsls	r2, r2, #16
 80052ba:	d4f3      	bmi.n	80052a4 <HAL_DAC_ConfigChannel+0x134>
      hdac->Instance->SHSR1 = sConfig->DAC_SampleAndHoldConfig.DAC_SampleTime;
 80052bc:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80052be:	641a      	str	r2, [r3, #64]	@ 0x40
 80052c0:	e00d      	b.n	80052de <HAL_DAC_ConfigChannel+0x16e>
        if ((HAL_GetTick() - tickstart) > TIMEOUT_DAC_CALIBCONFIG)
 80052c2:	f7fe ffe3 	bl	800428c <HAL_GetTick>
 80052c6:	1b40      	subs	r0, r0, r5
 80052c8:	2801      	cmp	r0, #1
          if (((hdac->Instance->SR) & DAC_SR_BWST2) != 0UL)
 80052ca:	6833      	ldr	r3, [r6, #0]
        if ((HAL_GetTick() - tickstart) > TIMEOUT_DAC_CALIBCONFIG)
 80052cc:	d902      	bls.n	80052d4 <HAL_DAC_ConfigChannel+0x164>
          if (((hdac->Instance->SR) & DAC_SR_BWST2) != 0UL)
 80052ce:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 80052d0:	2a00      	cmp	r2, #0
 80052d2:	db39      	blt.n	8005348 <HAL_DAC_ConfigChannel+0x1d8>
      while (((hdac->Instance->SR) & DAC_SR_BWST2) != 0UL)
 80052d4:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 80052d6:	2a00      	cmp	r2, #0
 80052d8:	dbf3      	blt.n	80052c2 <HAL_DAC_ConfigChannel+0x152>
      hdac->Instance->SHSR2 = sConfig->DAC_SampleAndHoldConfig.DAC_SampleTime;
 80052da:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80052dc:	645a      	str	r2, [r3, #68]	@ 0x44
    MODIFY_REG(hdac->Instance->SHHR, DAC_SHHR_THOLD1 << (Channel & 0x10UL),
 80052de:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
 80052e0:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 80052e2:	f004 0410 	and.w	r4, r4, #16
 80052e6:	f240 30ff 	movw	r0, #1023	@ 0x3ff
 80052ea:	40a0      	lsls	r0, r4
 80052ec:	40a1      	lsls	r1, r4
 80052ee:	ea22 0200 	bic.w	r2, r2, r0
 80052f2:	430a      	orrs	r2, r1
 80052f4:	649a      	str	r2, [r3, #72]	@ 0x48
    MODIFY_REG(hdac->Instance->SHRR, DAC_SHRR_TREFRESH1 << (Channel & 0x10UL),
 80052f6:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 80052f8:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 80052fa:	20ff      	movs	r0, #255	@ 0xff
 80052fc:	40a0      	lsls	r0, r4
 80052fe:	40a1      	lsls	r1, r4
 8005300:	ea22 0200 	bic.w	r2, r2, r0
 8005304:	430a      	orrs	r2, r1
 8005306:	64da      	str	r2, [r3, #76]	@ 0x4c
  tmpreg2 = (sConfig->DAC_SampleAndHold | sConfig->DAC_OutputBuffer | connectOnChip);
 8005308:	68b9      	ldr	r1, [r7, #8]
 800530a:	e74b      	b.n	80051a4 <HAL_DAC_ConfigChannel+0x34>
    connectOnChip = 0x00000000UL;
 800530c:	f04f 0c00 	mov.w	ip, #0
 8005310:	e765      	b.n	80051de <HAL_DAC_ConfigChannel+0x6e>
    return HAL_ERROR;
 8005312:	2001      	movs	r0, #1
}
 8005314:	4770      	bx	lr
    return HAL_ERROR;
 8005316:	2001      	movs	r0, #1
}
 8005318:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    connectOnChip = DAC_MCR_MODE1_0;
 800531c:	f04f 0c01 	mov.w	ip, #1
 8005320:	e75d      	b.n	80051de <HAL_DAC_ConfigChannel+0x6e>
    hclkfreq = HAL_RCC_GetHCLKFreq();
 8005322:	f000 fdb5 	bl	8005e90 <HAL_RCC_GetHCLKFreq>
    if (hclkfreq > HFSEL_ENABLE_THRESHOLD_160MHZ)
 8005326:	4b0c      	ldr	r3, [pc, #48]	@ (8005358 <HAL_DAC_ConfigChannel+0x1e8>)
 8005328:	4298      	cmp	r0, r3
 800532a:	d905      	bls.n	8005338 <HAL_DAC_ConfigChannel+0x1c8>
  hdac->Instance->MCR = tmpreg1;
 800532c:	6833      	ldr	r3, [r6, #0]
      tmpreg1 |= DAC_HIGH_FREQUENCY_INTERFACE_MODE_ABOVE_160MHZ;
 800532e:	f448 4800 	orr.w	r8, r8, #32768	@ 0x8000
 8005332:	e77c      	b.n	800522e <HAL_DAC_ConfigChannel+0xbe>
  __HAL_LOCK(hdac);
 8005334:	2002      	movs	r0, #2
 8005336:	e7ac      	b.n	8005292 <HAL_DAC_ConfigChannel+0x122>
    else if (hclkfreq > HFSEL_ENABLE_THRESHOLD_80MHZ)
 8005338:	4a08      	ldr	r2, [pc, #32]	@ (800535c <HAL_DAC_ConfigChannel+0x1ec>)
  hdac->Instance->MCR = tmpreg1;
 800533a:	6833      	ldr	r3, [r6, #0]
    else if (hclkfreq > HFSEL_ENABLE_THRESHOLD_80MHZ)
 800533c:	4290      	cmp	r0, r2
 800533e:	f67f af76 	bls.w	800522e <HAL_DAC_ConfigChannel+0xbe>
      tmpreg1 |= DAC_HIGH_FREQUENCY_INTERFACE_MODE_ABOVE_80MHZ;
 8005342:	f448 4880 	orr.w	r8, r8, #16384	@ 0x4000
 8005346:	e772      	b.n	800522e <HAL_DAC_ConfigChannel+0xbe>
            SET_BIT(hdac->ErrorCode, HAL_DAC_ERROR_TIMEOUT);
 8005348:	6933      	ldr	r3, [r6, #16]
            hdac->State = HAL_DAC_STATE_TIMEOUT;
 800534a:	2203      	movs	r2, #3
            SET_BIT(hdac->ErrorCode, HAL_DAC_ERROR_TIMEOUT);
 800534c:	f043 0308 	orr.w	r3, r3, #8
 8005350:	6133      	str	r3, [r6, #16]
            return HAL_TIMEOUT;
 8005352:	2003      	movs	r0, #3
            hdac->State = HAL_DAC_STATE_TIMEOUT;
 8005354:	7132      	strb	r2, [r6, #4]
            return HAL_TIMEOUT;
 8005356:	e79c      	b.n	8005292 <HAL_DAC_ConfigChannel+0x122>
 8005358:	09896800 	.word	0x09896800
 800535c:	04c4b400 	.word	0x04c4b400

08005360 <HAL_DACEx_DMAUnderrunCallbackCh2>:
  * @brief  DMA underrun DAC callback for Channel2.
  * @param  hdac pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval None
  */
__weak void HAL_DACEx_DMAUnderrunCallbackCh2(DAC_HandleTypeDef *hdac)
 8005360:	4770      	bx	lr
 8005362:	bf00      	nop

08005364 <HAL_DMA_Init>:
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
  uint32_t tmp;

  /* Check the DMA handle allocation */
  if (hdma == NULL)
 8005364:	2800      	cmp	r0, #0
 8005366:	d076      	beq.n	8005456 <HAL_DMA_Init+0xf2>
{
 8005368:	b4f0      	push	{r4, r5, r6, r7}
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));

  assert_param(IS_DMA_ALL_REQUEST(hdma->Init.Request));

  /* Compute the channel index */
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 800536a:	4a3c      	ldr	r2, [pc, #240]	@ (800545c <HAL_DMA_Init+0xf8>)
 800536c:	6804      	ldr	r4, [r0, #0]
 800536e:	4294      	cmp	r4, r2
 8005370:	4603      	mov	r3, r0
 8005372:	d95c      	bls.n	800542e <HAL_DMA_Init+0xca>
    hdma->DmaBaseAddress = DMA1;
  }
  else
  {
    /* DMA2 */
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2;
 8005374:	493a      	ldr	r1, [pc, #232]	@ (8005460 <HAL_DMA_Init+0xfc>)
 8005376:	4a3b      	ldr	r2, [pc, #236]	@ (8005464 <HAL_DMA_Init+0x100>)
    hdma->DmaBaseAddress = DMA2;
 8005378:	483b      	ldr	r0, [pc, #236]	@ (8005468 <HAL_DMA_Init+0x104>)
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2;
 800537a:	4421      	add	r1, r4
 800537c:	fba2 2101 	umull	r2, r1, r2, r1
 8005380:	0909      	lsrs	r1, r1, #4
 8005382:	0089      	lsls	r1, r1, #2
  }

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 8005384:	2202      	movs	r2, #2
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  |
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   |
                      DMA_CCR_DIR   | DMA_CCR_MEM2MEM));

  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 8005386:	689d      	ldr	r5, [r3, #8]
  hdma->State = HAL_DMA_STATE_BUSY;
 8005388:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25
  tmp |=  hdma->Init.Direction        |
 800538c:	68da      	ldr	r2, [r3, #12]
#else
    DMAMUX1_ChannelBase = DMAMUX1_Channel7;
#endif /* STM32G4x1xx) */
  }
  dmamux_base_addr = (uint32_t)DMAMUX1_ChannelBase;
  channel_number = (((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U;
 800538e:	4e35      	ldr	r6, [pc, #212]	@ (8005464 <HAL_DMA_Init+0x100>)
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
 8005390:	4f36      	ldr	r7, [pc, #216]	@ (800546c <HAL_DMA_Init+0x108>)
 8005392:	e9c3 0110 	strd	r0, r1, [r3, #64]	@ 0x40
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8005396:	6918      	ldr	r0, [r3, #16]
  tmp |=  hdma->Init.Direction        |
 8005398:	432a      	orrs	r2, r5
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800539a:	4302      	orrs	r2, r0
 800539c:	6958      	ldr	r0, [r3, #20]
 800539e:	4302      	orrs	r2, r0
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 80053a0:	6998      	ldr	r0, [r3, #24]
 80053a2:	4302      	orrs	r2, r0
  tmp = hdma->Instance->CCR;
 80053a4:	6820      	ldr	r0, [r4, #0]
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  |
 80053a6:	f420 4cff 	bic.w	ip, r0, #32640	@ 0x7f80
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 80053aa:	69d8      	ldr	r0, [r3, #28]
 80053ac:	4302      	orrs	r2, r0
  channel_number = (((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U;
 80053ae:	b2e0      	uxtb	r0, r4
 80053b0:	3808      	subs	r0, #8
 80053b2:	fba6 6000 	umull	r6, r0, r6, r0
          hdma->Init.Mode                | hdma->Init.Priority;
 80053b6:	6a1e      	ldr	r6, [r3, #32]
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  |
 80053b8:	f02c 0c70 	bic.w	ip, ip, #112	@ 0x70
          hdma->Init.Mode                | hdma->Init.Priority;
 80053bc:	4332      	orrs	r2, r6
  tmp |=  hdma->Init.Direction        |
 80053be:	ea42 020c 	orr.w	r2, r2, ip
  hdma->Instance->CCR = tmp;
 80053c2:	6022      	str	r2, [r4, #0]
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
 80053c4:	4e25      	ldr	r6, [pc, #148]	@ (800545c <HAL_DMA_Init+0xf8>)
 80053c6:	4a2a      	ldr	r2, [pc, #168]	@ (8005470 <HAL_DMA_Init+0x10c>)
  hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)(uint32_t)(dmamux_base_addr + ((hdma->ChannelIndex >> 2U) * ((uint32_t)DMAMUX1_Channel1 - (uint32_t)DMAMUX1_Channel0)));
  hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 80053c8:	f3c0 1004 	ubfx	r0, r0, #4, #5
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
 80053cc:	42b4      	cmp	r4, r6
 80053ce:	bf98      	it	ls
 80053d0:	463a      	movls	r2, r7
  hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 80053d2:	f206 4679 	addw	r6, r6, #1145	@ 0x479
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 80053d6:	2401      	movs	r4, #1
 80053d8:	fa04 f000 	lsl.w	r0, r4, r0
  hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 80053dc:	64de      	str	r6, [r3, #76]	@ 0x4c
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 80053de:	f5b5 4f80 	cmp.w	r5, #16384	@ 0x4000
  hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)(uint32_t)(dmamux_base_addr + ((hdma->ChannelIndex >> 2U) * ((uint32_t)DMAMUX1_Channel1 - (uint32_t)DMAMUX1_Channel0)));
 80053e2:	eb01 0602 	add.w	r6, r1, r2
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 80053e6:	6518      	str	r0, [r3, #80]	@ 0x50
  hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)(uint32_t)(dmamux_base_addr + ((hdma->ChannelIndex >> 2U) * ((uint32_t)DMAMUX1_Channel1 - (uint32_t)DMAMUX1_Channel0)));
 80053e8:	649e      	str	r6, [r3, #72]	@ 0x48
 80053ea:	ea4f 0191 	mov.w	r1, r1, lsr #2
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 80053ee:	d027      	beq.n	8005440 <HAL_DMA_Init+0xdc>
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 80053f0:	685e      	ldr	r6, [r3, #4]
 80053f2:	b2f5      	uxtb	r5, r6
  if (((hdma->Init.Request >  0U) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 80053f4:	3e01      	subs	r6, #1
 80053f6:	2e03      	cmp	r6, #3
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 80053f8:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 80053fc:	f8c7 0084 	str.w	r0, [r7, #132]	@ 0x84
  if (((hdma->Init.Request >  0U) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 8005400:	d824      	bhi.n	800544c <HAL_DMA_Init+0xe8>
static void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma)
{
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;

  /* DMA Channels are connected to DMAMUX1 request generator blocks*/
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 8005402:	4a1c      	ldr	r2, [pc, #112]	@ (8005474 <HAL_DMA_Init+0x110>)

  hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 8005404:	481c      	ldr	r0, [pc, #112]	@ (8005478 <HAL_DMA_Init+0x114>)
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 8005406:	442a      	add	r2, r5
 8005408:	0092      	lsls	r2, r2, #2

  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x1FU);
 800540a:	3d01      	subs	r5, #1
 800540c:	40ac      	lsls	r4, r5
    hdma->DMAmuxRequestGen->RGCR = 0U;
 800540e:	2100      	movs	r1, #0
  hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 8005410:	e9c3 2015 	strd	r2, r0, [r3, #84]	@ 0x54
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x1FU);
 8005414:	65dc      	str	r4, [r3, #92]	@ 0x5c
    hdma->DMAmuxRequestGen->RGCR = 0U;
 8005416:	6011      	str	r1, [r2, #0]
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8005418:	4a18      	ldr	r2, [pc, #96]	@ (800547c <HAL_DMA_Init+0x118>)
 800541a:	6454      	str	r4, [r2, #68]	@ 0x44
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800541c:	2000      	movs	r0, #0
  hdma->State  = HAL_DMA_STATE_READY;
 800541e:	2201      	movs	r2, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8005420:	63d8      	str	r0, [r3, #60]	@ 0x3c
  hdma->Lock = HAL_UNLOCKED;
 8005422:	f883 0024 	strb.w	r0, [r3, #36]	@ 0x24
  hdma->State  = HAL_DMA_STATE_READY;
 8005426:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25
}
 800542a:	bcf0      	pop	{r4, r5, r6, r7}
 800542c:	4770      	bx	lr
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
 800542e:	4914      	ldr	r1, [pc, #80]	@ (8005480 <HAL_DMA_Init+0x11c>)
 8005430:	4a0c      	ldr	r2, [pc, #48]	@ (8005464 <HAL_DMA_Init+0x100>)
    hdma->DmaBaseAddress = DMA1;
 8005432:	4814      	ldr	r0, [pc, #80]	@ (8005484 <HAL_DMA_Init+0x120>)
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
 8005434:	4421      	add	r1, r4
 8005436:	fba2 2101 	umull	r2, r1, r2, r1
 800543a:	0909      	lsrs	r1, r1, #4
 800543c:	0089      	lsls	r1, r1, #2
    hdma->DmaBaseAddress = DMA1;
 800543e:	e7a1      	b.n	8005384 <HAL_DMA_Init+0x20>
    hdma->Init.Request = DMA_REQUEST_MEM2MEM;
 8005440:	2400      	movs	r4, #0
 8005442:	605c      	str	r4, [r3, #4]
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 8005444:	f842 4021 	str.w	r4, [r2, r1, lsl #2]
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8005448:	f8c7 0084 	str.w	r0, [r7, #132]	@ 0x84
    hdma->DMAmuxRequestGen = 0U;
 800544c:	2200      	movs	r2, #0
 800544e:	e9c3 2215 	strd	r2, r2, [r3, #84]	@ 0x54
    hdma->DMAmuxRequestGenStatusMask = 0U;
 8005452:	65da      	str	r2, [r3, #92]	@ 0x5c
 8005454:	e7e2      	b.n	800541c <HAL_DMA_Init+0xb8>
    return HAL_ERROR;
 8005456:	2001      	movs	r0, #1
}
 8005458:	4770      	bx	lr
 800545a:	bf00      	nop
 800545c:	40020407 	.word	0x40020407
 8005460:	bffdfbf8 	.word	0xbffdfbf8
 8005464:	cccccccd 	.word	0xcccccccd
 8005468:	40020400 	.word	0x40020400
 800546c:	40020800 	.word	0x40020800
 8005470:	40020820 	.word	0x40020820
 8005474:	1000823f 	.word	0x1000823f
 8005478:	40020940 	.word	0x40020940
 800547c:	40020900 	.word	0x40020900
 8005480:	bffdfff8 	.word	0xbffdfff8
 8005484:	40020000 	.word	0x40020000

08005488 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8005488:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0U)
 800548c:	680c      	ldr	r4, [r1, #0]
{
 800548e:	b085      	sub	sp, #20
  while (((GPIO_Init->Pin) >> position) != 0U)
 8005490:	2c00      	cmp	r4, #0
 8005492:	f000 8089 	beq.w	80055a8 <HAL_GPIO_Init+0x120>
  uint32_t position = 0x00U;
 8005496:	2300      	movs	r3, #0
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 8005498:	f04f 0b01 	mov.w	fp, #1
 800549c:	fa0b fe03 	lsl.w	lr, fp, r3

    if (iocurrent != 0x00u)
 80054a0:	ea1e 0a04 	ands.w	sl, lr, r4
 80054a4:	d07b      	beq.n	800559e <HAL_GPIO_Init+0x116>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) ||
 80054a6:	684d      	ldr	r5, [r1, #4]
 80054a8:	f005 0203 	and.w	r2, r5, #3
 80054ac:	ea4f 0c43 	mov.w	ip, r3, lsl #1
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 80054b0:	2603      	movs	r6, #3
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) ||
 80054b2:	f102 38ff 	add.w	r8, r2, #4294967295
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 80054b6:	fa06 f70c 	lsl.w	r7, r6, ip
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) ||
 80054ba:	f1b8 0f01 	cmp.w	r8, #1
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 80054be:	ea6f 0707 	mvn.w	r7, r7
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) ||
 80054c2:	d974      	bls.n	80055ae <HAL_GPIO_Init+0x126>
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
        GPIOx->OTYPER = temp;
      }

      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 80054c4:	2a03      	cmp	r2, #3
 80054c6:	f040 80b0 	bne.w	800562a <HAL_GPIO_Init+0x1a2>
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80054ca:	fa02 f20c 	lsl.w	r2, r2, ip
      temp = GPIOx->MODER;
 80054ce:	f8d0 c000 	ldr.w	ip, [r0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 80054d2:	ea0c 0707 	and.w	r7, ip, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80054d6:	433a      	orrs	r2, r7
      GPIOx->MODER = temp;

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 80054d8:	f415 3f40 	tst.w	r5, #196608	@ 0x30000
      GPIOx->MODER = temp;
 80054dc:	6002      	str	r2, [r0, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 80054de:	d05e      	beq.n	800559e <HAL_GPIO_Init+0x116>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80054e0:	4f66      	ldr	r7, [pc, #408]	@ (800567c <HAL_GPIO_Init+0x1f4>)
 80054e2:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 80054e4:	f042 0201 	orr.w	r2, r2, #1
 80054e8:	663a      	str	r2, [r7, #96]	@ 0x60
 80054ea:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 80054ec:	f002 0201 	and.w	r2, r2, #1
 80054f0:	9203      	str	r2, [sp, #12]
 80054f2:	9a03      	ldr	r2, [sp, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
 80054f4:	f023 0203 	bic.w	r2, r3, #3
 80054f8:	f102 4280 	add.w	r2, r2, #1073741824	@ 0x40000000
 80054fc:	f502 3280 	add.w	r2, r2, #65536	@ 0x10000
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 8005500:	f003 0c03 	and.w	ip, r3, #3
        temp = SYSCFG->EXTICR[position >> 2U];
 8005504:	6897      	ldr	r7, [r2, #8]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 8005506:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 800550a:	260f      	movs	r6, #15
 800550c:	fa06 fe0c 	lsl.w	lr, r6, ip
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8005510:	f1b0 4f90 	cmp.w	r0, #1207959552	@ 0x48000000
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 8005514:	ea27 070e 	bic.w	r7, r7, lr
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8005518:	d01d      	beq.n	8005556 <HAL_GPIO_Init+0xce>
 800551a:	4e59      	ldr	r6, [pc, #356]	@ (8005680 <HAL_GPIO_Init+0x1f8>)
 800551c:	42b0      	cmp	r0, r6
 800551e:	f000 8097 	beq.w	8005650 <HAL_GPIO_Init+0x1c8>
 8005522:	4e58      	ldr	r6, [pc, #352]	@ (8005684 <HAL_GPIO_Init+0x1fc>)
 8005524:	42b0      	cmp	r0, r6
 8005526:	f000 809a 	beq.w	800565e <HAL_GPIO_Init+0x1d6>
 800552a:	f8df e160 	ldr.w	lr, [pc, #352]	@ 800568c <HAL_GPIO_Init+0x204>
 800552e:	4570      	cmp	r0, lr
 8005530:	f000 8087 	beq.w	8005642 <HAL_GPIO_Init+0x1ba>
 8005534:	f8df e158 	ldr.w	lr, [pc, #344]	@ 8005690 <HAL_GPIO_Init+0x208>
 8005538:	4570      	cmp	r0, lr
 800553a:	f000 8097 	beq.w	800566c <HAL_GPIO_Init+0x1e4>
 800553e:	f8df e154 	ldr.w	lr, [pc, #340]	@ 8005694 <HAL_GPIO_Init+0x20c>
 8005542:	4570      	cmp	r0, lr
 8005544:	bf0c      	ite	eq
 8005546:	f04f 0e05 	moveq.w	lr, #5
 800554a:	f04f 0e06 	movne.w	lr, #6
 800554e:	fa0e fc0c 	lsl.w	ip, lr, ip
 8005552:	ea47 070c 	orr.w	r7, r7, ip
        SYSCFG->EXTICR[position >> 2U] = temp;
 8005556:	6097      	str	r7, [r2, #8]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8005558:	4a4b      	ldr	r2, [pc, #300]	@ (8005688 <HAL_GPIO_Init+0x200>)
 800555a:	6892      	ldr	r2, [r2, #8]
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 800555c:	02ee      	lsls	r6, r5, #11
        temp &= ~(iocurrent);
 800555e:	ea6f 070a 	mvn.w	r7, sl
        {
          temp |= iocurrent;
        }
        EXTI->RTSR1 = temp;
 8005562:	4e49      	ldr	r6, [pc, #292]	@ (8005688 <HAL_GPIO_Init+0x200>)
        temp &= ~(iocurrent);
 8005564:	bf54      	ite	pl
 8005566:	403a      	andpl	r2, r7
          temp |= iocurrent;
 8005568:	ea4a 0202 	orrmi.w	r2, sl, r2
        EXTI->RTSR1 = temp;
 800556c:	60b2      	str	r2, [r6, #8]

        temp = EXTI->FTSR1;
 800556e:	68f2      	ldr	r2, [r6, #12]
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 8005570:	02ae      	lsls	r6, r5, #10
        {
          temp |= iocurrent;
        }
        EXTI->FTSR1 = temp;
 8005572:	4e45      	ldr	r6, [pc, #276]	@ (8005688 <HAL_GPIO_Init+0x200>)
        temp &= ~(iocurrent);
 8005574:	bf54      	ite	pl
 8005576:	403a      	andpl	r2, r7
          temp |= iocurrent;
 8005578:	ea4a 0202 	orrmi.w	r2, sl, r2
        EXTI->FTSR1 = temp;
 800557c:	60f2      	str	r2, [r6, #12]

        temp = EXTI->EMR1;
 800557e:	6872      	ldr	r2, [r6, #4]
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 8005580:	03ae      	lsls	r6, r5, #14
        {
          temp |= iocurrent;
        }
        EXTI->EMR1 = temp;
 8005582:	4e41      	ldr	r6, [pc, #260]	@ (8005688 <HAL_GPIO_Init+0x200>)
        temp &= ~(iocurrent);
 8005584:	bf54      	ite	pl
 8005586:	403a      	andpl	r2, r7
          temp |= iocurrent;
 8005588:	ea4a 0202 	orrmi.w	r2, sl, r2
        EXTI->EMR1 = temp;
 800558c:	6072      	str	r2, [r6, #4]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 800558e:	6832      	ldr	r2, [r6, #0]
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 8005590:	03ed      	lsls	r5, r5, #15
        {
          temp |= iocurrent;
        }
        EXTI->IMR1 = temp;
 8005592:	4d3d      	ldr	r5, [pc, #244]	@ (8005688 <HAL_GPIO_Init+0x200>)
        temp &= ~(iocurrent);
 8005594:	bf54      	ite	pl
 8005596:	403a      	andpl	r2, r7
          temp |= iocurrent;
 8005598:	ea4a 0202 	orrmi.w	r2, sl, r2
        EXTI->IMR1 = temp;
 800559c:	602a      	str	r2, [r5, #0]
      }
    }

    position++;
 800559e:	3301      	adds	r3, #1
  while (((GPIO_Init->Pin) >> position) != 0U)
 80055a0:	fa34 f203 	lsrs.w	r2, r4, r3
 80055a4:	f47f af7a 	bne.w	800549c <HAL_GPIO_Init+0x14>
  }
}
 80055a8:	b005      	add	sp, #20
 80055aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp = GPIOx->OSPEEDR;
 80055ae:	f8d0 9008 	ldr.w	r9, [r0, #8]
        temp |= (GPIO_Init->Speed << (position * 2U));
 80055b2:	68ce      	ldr	r6, [r1, #12]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 80055b4:	ea09 0907 	and.w	r9, r9, r7
        temp |= (GPIO_Init->Speed << (position * 2U));
 80055b8:	fa06 f80c 	lsl.w	r8, r6, ip
 80055bc:	ea48 0809 	orr.w	r8, r8, r9
        GPIOx->OSPEEDR = temp;
 80055c0:	f8c0 8008 	str.w	r8, [r0, #8]
        temp = GPIOx->OTYPER;
 80055c4:	f8d0 8004 	ldr.w	r8, [r0, #4]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 80055c8:	688e      	ldr	r6, [r1, #8]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 80055ca:	ea28 080e 	bic.w	r8, r8, lr
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 80055ce:	f3c5 1e00 	ubfx	lr, r5, #4, #1
 80055d2:	fa0e fe03 	lsl.w	lr, lr, r3
 80055d6:	ea4e 0e08 	orr.w	lr, lr, r8
        GPIOx->OTYPER = temp;
 80055da:	f8c0 e004 	str.w	lr, [r0, #4]
        temp = GPIOx->PUPDR;
 80055de:	f8d0 800c 	ldr.w	r8, [r0, #12]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 80055e2:	fa06 fe0c 	lsl.w	lr, r6, ip
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 80055e6:	ea08 0807 	and.w	r8, r8, r7
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 80055ea:	ea4e 0e08 	orr.w	lr, lr, r8
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 80055ee:	2a02      	cmp	r2, #2
        GPIOx->PUPDR = temp;
 80055f0:	f8c0 e00c 	str.w	lr, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 80055f4:	f47f af69 	bne.w	80054ca <HAL_GPIO_Init+0x42>
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 80055f8:	690e      	ldr	r6, [r1, #16]
        temp = GPIOx->AFR[position >> 3U];
 80055fa:	ea4f 08d3 	mov.w	r8, r3, lsr #3
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 80055fe:	f003 0e07 	and.w	lr, r3, #7
 8005602:	eb00 0888 	add.w	r8, r0, r8, lsl #2
 8005606:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 800560a:	fa06 f60e 	lsl.w	r6, r6, lr
        temp = GPIOx->AFR[position >> 3U];
 800560e:	f8d8 9020 	ldr.w	r9, [r8, #32]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 8005612:	9601      	str	r6, [sp, #4]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 8005614:	260f      	movs	r6, #15
 8005616:	fa06 fe0e 	lsl.w	lr, r6, lr
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 800561a:	9e01      	ldr	r6, [sp, #4]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 800561c:	ea29 090e 	bic.w	r9, r9, lr
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 8005620:	ea46 0e09 	orr.w	lr, r6, r9
        GPIOx->AFR[position >> 3U] = temp;
 8005624:	f8c8 e020 	str.w	lr, [r8, #32]
 8005628:	e74f      	b.n	80054ca <HAL_GPIO_Init+0x42>
        temp = GPIOx->PUPDR;
 800562a:	f8d0 800c 	ldr.w	r8, [r0, #12]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 800562e:	688e      	ldr	r6, [r1, #8]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8005630:	ea08 0807 	and.w	r8, r8, r7
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 8005634:	fa06 fe0c 	lsl.w	lr, r6, ip
 8005638:	ea4e 0e08 	orr.w	lr, lr, r8
        GPIOx->PUPDR = temp;
 800563c:	f8c0 e00c 	str.w	lr, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8005640:	e743      	b.n	80054ca <HAL_GPIO_Init+0x42>
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8005642:	f04f 0e03 	mov.w	lr, #3
 8005646:	fa0e fc0c 	lsl.w	ip, lr, ip
 800564a:	ea47 070c 	orr.w	r7, r7, ip
 800564e:	e782      	b.n	8005556 <HAL_GPIO_Init+0xce>
 8005650:	f04f 0e01 	mov.w	lr, #1
 8005654:	fa0e fc0c 	lsl.w	ip, lr, ip
 8005658:	ea47 070c 	orr.w	r7, r7, ip
 800565c:	e77b      	b.n	8005556 <HAL_GPIO_Init+0xce>
 800565e:	f04f 0e02 	mov.w	lr, #2
 8005662:	fa0e fc0c 	lsl.w	ip, lr, ip
 8005666:	ea47 070c 	orr.w	r7, r7, ip
 800566a:	e774      	b.n	8005556 <HAL_GPIO_Init+0xce>
 800566c:	f04f 0e04 	mov.w	lr, #4
 8005670:	fa0e fc0c 	lsl.w	ip, lr, ip
 8005674:	ea47 070c 	orr.w	r7, r7, ip
 8005678:	e76d      	b.n	8005556 <HAL_GPIO_Init+0xce>
 800567a:	bf00      	nop
 800567c:	40021000 	.word	0x40021000
 8005680:	48000400 	.word	0x48000400
 8005684:	48000800 	.word	0x48000800
 8005688:	40010400 	.word	0x40010400
 800568c:	48000c00 	.word	0x48000c00
 8005690:	48001000 	.word	0x48001000
 8005694:	48001400 	.word	0x48001400

08005698 <HAL_PWREx_ControlVoltageScaling>:
  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));

  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1_BOOST)
  {
    /* If current range is range 2 */
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8005698:	4a35      	ldr	r2, [pc, #212]	@ (8005770 <HAL_PWREx_ControlVoltageScaling+0xd8>)
 800569a:	6813      	ldr	r3, [r2, #0]
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1_BOOST)
 800569c:	b960      	cbnz	r0, 80056b8 <HAL_PWREx_ControlVoltageScaling+0x20>
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 800569e:	f403 63c0 	and.w	r3, r3, #1536	@ 0x600
 80056a2:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
    {
      /* Make sure Range 1 Boost is enabled */
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
 80056a6:	f8d2 3080 	ldr.w	r3, [r2, #128]	@ 0x80
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 80056aa:	d01b      	beq.n	80056e4 <HAL_PWREx_ControlVoltageScaling+0x4c>
    }
    /* If current range is range 1 normal or boost mode */
    else
    {
      /* Enable Range 1 Boost (no issue if bit already reset) */
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
 80056ac:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 80056b0:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
    MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
    /* No need to wait for VOSF to be cleared for this transition */
    /* PWR_CR5_R1MODE bit setting has no effect in Range 2        */
  }

  return HAL_OK;
 80056b4:	2000      	movs	r0, #0
}
 80056b6:	4770      	bx	lr
  else if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
 80056b8:	f5b0 7f00 	cmp.w	r0, #512	@ 0x200
 80056bc:	d006      	beq.n	80056cc <HAL_PWREx_ControlVoltageScaling+0x34>
    MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
 80056be:	f423 63c0 	bic.w	r3, r3, #1536	@ 0x600
 80056c2:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 80056c6:	6013      	str	r3, [r2, #0]
  return HAL_OK;
 80056c8:	2000      	movs	r0, #0
}
 80056ca:	4770      	bx	lr
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 80056cc:	f403 63c0 	and.w	r3, r3, #1536	@ 0x600
 80056d0:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
 80056d4:	f8d2 3080 	ldr.w	r3, [r2, #128]	@ 0x80
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 80056d8:	d029      	beq.n	800572e <HAL_PWREx_ControlVoltageScaling+0x96>
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
 80056da:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 80056de:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
 80056e2:	e7f1      	b.n	80056c8 <HAL_PWREx_ControlVoltageScaling+0x30>
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
 80056e4:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 80056e8:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 80056ec:	6813      	ldr	r3, [r2, #0]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 80056ee:	4821      	ldr	r0, [pc, #132]	@ (8005774 <HAL_PWREx_ControlVoltageScaling+0xdc>)
 80056f0:	4921      	ldr	r1, [pc, #132]	@ (8005778 <HAL_PWREx_ControlVoltageScaling+0xe0>)
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 80056f2:	f423 63c0 	bic.w	r3, r3, #1536	@ 0x600
 80056f6:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 80056fa:	6013      	str	r3, [r2, #0]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 80056fc:	6803      	ldr	r3, [r0, #0]
 80056fe:	2032      	movs	r0, #50	@ 0x32
 8005700:	fb00 f303 	mul.w	r3, r0, r3
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8005704:	6950      	ldr	r0, [r2, #20]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 8005706:	fba1 1303 	umull	r1, r3, r1, r3
 800570a:	0c9b      	lsrs	r3, r3, #18
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 800570c:	0540      	lsls	r0, r0, #21
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 800570e:	f103 0301 	add.w	r3, r3, #1
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8005712:	d506      	bpl.n	8005722 <HAL_PWREx_ControlVoltageScaling+0x8a>
 8005714:	e000      	b.n	8005718 <HAL_PWREx_ControlVoltageScaling+0x80>
 8005716:	b123      	cbz	r3, 8005722 <HAL_PWREx_ControlVoltageScaling+0x8a>
 8005718:	6951      	ldr	r1, [r2, #20]
 800571a:	0549      	lsls	r1, r1, #21
        wait_loop_index--;
 800571c:	f103 33ff 	add.w	r3, r3, #4294967295
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8005720:	d4f9      	bmi.n	8005716 <HAL_PWREx_ControlVoltageScaling+0x7e>
      if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
 8005722:	4b13      	ldr	r3, [pc, #76]	@ (8005770 <HAL_PWREx_ControlVoltageScaling+0xd8>)
 8005724:	695b      	ldr	r3, [r3, #20]
 8005726:	055b      	lsls	r3, r3, #21
 8005728:	d5ce      	bpl.n	80056c8 <HAL_PWREx_ControlVoltageScaling+0x30>
        return HAL_TIMEOUT;
 800572a:	2003      	movs	r0, #3
 800572c:	4770      	bx	lr
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
 800572e:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8005732:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 8005736:	6813      	ldr	r3, [r2, #0]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 8005738:	480e      	ldr	r0, [pc, #56]	@ (8005774 <HAL_PWREx_ControlVoltageScaling+0xdc>)
 800573a:	490f      	ldr	r1, [pc, #60]	@ (8005778 <HAL_PWREx_ControlVoltageScaling+0xe0>)
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 800573c:	f423 63c0 	bic.w	r3, r3, #1536	@ 0x600
 8005740:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8005744:	6013      	str	r3, [r2, #0]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 8005746:	6803      	ldr	r3, [r0, #0]
 8005748:	2032      	movs	r0, #50	@ 0x32
 800574a:	fb00 f303 	mul.w	r3, r0, r3
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 800574e:	6950      	ldr	r0, [r2, #20]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 8005750:	fba1 1303 	umull	r1, r3, r1, r3
 8005754:	0c9b      	lsrs	r3, r3, #18
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8005756:	0540      	lsls	r0, r0, #21
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 8005758:	f103 0301 	add.w	r3, r3, #1
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 800575c:	d5e1      	bpl.n	8005722 <HAL_PWREx_ControlVoltageScaling+0x8a>
 800575e:	e001      	b.n	8005764 <HAL_PWREx_ControlVoltageScaling+0xcc>
 8005760:	2b00      	cmp	r3, #0
 8005762:	d0de      	beq.n	8005722 <HAL_PWREx_ControlVoltageScaling+0x8a>
 8005764:	6951      	ldr	r1, [r2, #20]
 8005766:	0549      	lsls	r1, r1, #21
        wait_loop_index--;
 8005768:	f103 33ff 	add.w	r3, r3, #4294967295
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 800576c:	d5d9      	bpl.n	8005722 <HAL_PWREx_ControlVoltageScaling+0x8a>
 800576e:	e7f7      	b.n	8005760 <HAL_PWREx_ControlVoltageScaling+0xc8>
 8005770:	40007000 	.word	0x40007000
 8005774:	20000474 	.word	0x20000474
 8005778:	431bde83 	.word	0x431bde83

0800577c <HAL_PWREx_DisableUCPDDeadBattery>:
  * @retval None
  */
void HAL_PWREx_DisableUCPDDeadBattery(void)
{
  /* Write 1 to disable the USB Type-C dead battery pull-down behavior */
  SET_BIT(PWR->CR3, PWR_CR3_UCPD_DBDIS);
 800577c:	4a02      	ldr	r2, [pc, #8]	@ (8005788 <HAL_PWREx_DisableUCPDDeadBattery+0xc>)
 800577e:	6893      	ldr	r3, [r2, #8]
 8005780:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8005784:	6093      	str	r3, [r2, #8]
}
 8005786:	4770      	bx	lr
 8005788:	40007000 	.word	0x40007000

0800578c <HAL_RCC_OscConfig>:
  uint32_t tickstart;
  uint32_t temp_sysclksrc;
  uint32_t temp_pllckcfg;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 800578c:	2800      	cmp	r0, #0
 800578e:	f000 81bd 	beq.w	8005b0c <HAL_RCC_OscConfig+0x380>
{
 8005792:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8005796:	6803      	ldr	r3, [r0, #0]
 8005798:	07d9      	lsls	r1, r3, #31
{
 800579a:	b082      	sub	sp, #8
 800579c:	4604      	mov	r4, r0
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800579e:	d512      	bpl.n	80057c6 <HAL_RCC_OscConfig+0x3a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 80057a0:	49a6      	ldr	r1, [pc, #664]	@ (8005a3c <HAL_RCC_OscConfig+0x2b0>)
 80057a2:	688a      	ldr	r2, [r1, #8]
    temp_pllckcfg = __HAL_RCC_GET_PLL_OSCSOURCE();
 80057a4:	68c9      	ldr	r1, [r1, #12]
    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 80057a6:	f002 020c 	and.w	r2, r2, #12

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if (((temp_sysclksrc == RCC_CFGR_SWS_PLL) && (temp_pllckcfg == RCC_PLLSOURCE_HSE)) || (temp_sysclksrc == RCC_CFGR_SWS_HSE))
 80057aa:	2a0c      	cmp	r2, #12
 80057ac:	f000 80d0 	beq.w	8005950 <HAL_RCC_OscConfig+0x1c4>
 80057b0:	2a08      	cmp	r2, #8
 80057b2:	f040 80d2 	bne.w	800595a <HAL_RCC_OscConfig+0x1ce>
    {
      if ((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80057b6:	4aa1      	ldr	r2, [pc, #644]	@ (8005a3c <HAL_RCC_OscConfig+0x2b0>)
 80057b8:	6812      	ldr	r2, [r2, #0]
 80057ba:	0392      	lsls	r2, r2, #14
 80057bc:	d503      	bpl.n	80057c6 <HAL_RCC_OscConfig+0x3a>
 80057be:	6862      	ldr	r2, [r4, #4]
 80057c0:	2a00      	cmp	r2, #0
 80057c2:	f000 8137 	beq.w	8005a34 <HAL_RCC_OscConfig+0x2a8>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80057c6:	079a      	lsls	r2, r3, #30
 80057c8:	d522      	bpl.n	8005810 <HAL_RCC_OscConfig+0x84>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 80057ca:	4a9c      	ldr	r2, [pc, #624]	@ (8005a3c <HAL_RCC_OscConfig+0x2b0>)
 80057cc:	6893      	ldr	r3, [r2, #8]
    temp_pllckcfg = __HAL_RCC_GET_PLL_OSCSOURCE();
 80057ce:	68d2      	ldr	r2, [r2, #12]
    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 80057d0:	f003 030c 	and.w	r3, r3, #12
    if (((temp_sysclksrc == RCC_CFGR_SWS_PLL) && (temp_pllckcfg == RCC_PLLSOURCE_HSI)) || (temp_sysclksrc == RCC_CFGR_SWS_HSI))
 80057d4:	2b0c      	cmp	r3, #12
 80057d6:	f000 80f8 	beq.w	80059ca <HAL_RCC_OscConfig+0x23e>
 80057da:	2b04      	cmp	r3, #4
 80057dc:	f040 80fa 	bne.w	80059d4 <HAL_RCC_OscConfig+0x248>
    {
      /* When HSI is used as system clock it will not be disabled */
      if ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 80057e0:	4b96      	ldr	r3, [pc, #600]	@ (8005a3c <HAL_RCC_OscConfig+0x2b0>)
 80057e2:	681b      	ldr	r3, [r3, #0]
 80057e4:	055b      	lsls	r3, r3, #21
 80057e6:	d503      	bpl.n	80057f0 <HAL_RCC_OscConfig+0x64>
 80057e8:	68e3      	ldr	r3, [r4, #12]
 80057ea:	2b00      	cmp	r3, #0
 80057ec:	f000 8122 	beq.w	8005a34 <HAL_RCC_OscConfig+0x2a8>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80057f0:	4a92      	ldr	r2, [pc, #584]	@ (8005a3c <HAL_RCC_OscConfig+0x2b0>)
 80057f2:	6920      	ldr	r0, [r4, #16]
 80057f4:	6853      	ldr	r3, [r2, #4]

        /* Adapt Systick interrupt period */
        if (HAL_InitTick(uwTickPrio) != HAL_OK)
 80057f6:	4992      	ldr	r1, [pc, #584]	@ (8005a40 <HAL_RCC_OscConfig+0x2b4>)
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80057f8:	f023 43fe 	bic.w	r3, r3, #2130706432	@ 0x7f000000
 80057fc:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 8005800:	6053      	str	r3, [r2, #4]
        if (HAL_InitTick(uwTickPrio) != HAL_OK)
 8005802:	6808      	ldr	r0, [r1, #0]
 8005804:	f7fe fc06 	bl	8004014 <HAL_InitTick>
 8005808:	2800      	cmp	r0, #0
 800580a:	f040 8113 	bne.w	8005a34 <HAL_RCC_OscConfig+0x2a8>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800580e:	6823      	ldr	r3, [r4, #0]
 8005810:	071a      	lsls	r2, r3, #28
 8005812:	d519      	bpl.n	8005848 <HAL_RCC_OscConfig+0xbc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8005814:	6963      	ldr	r3, [r4, #20]
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8005816:	4d89      	ldr	r5, [pc, #548]	@ (8005a3c <HAL_RCC_OscConfig+0x2b0>)
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8005818:	2b00      	cmp	r3, #0
 800581a:	f000 80c2 	beq.w	80059a2 <HAL_RCC_OscConfig+0x216>
      __HAL_RCC_LSI_ENABLE();
 800581e:	f8d5 3094 	ldr.w	r3, [r5, #148]	@ 0x94
 8005822:	f043 0301 	orr.w	r3, r3, #1
 8005826:	f8c5 3094 	str.w	r3, [r5, #148]	@ 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800582a:	f7fe fd2f 	bl	800428c <HAL_GetTick>
 800582e:	4606      	mov	r6, r0

      /* Wait till LSI is ready */
      while (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 8005830:	e005      	b.n	800583e <HAL_RCC_OscConfig+0xb2>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8005832:	f7fe fd2b 	bl	800428c <HAL_GetTick>
 8005836:	1b80      	subs	r0, r0, r6
 8005838:	2802      	cmp	r0, #2
 800583a:	f200 8117 	bhi.w	8005a6c <HAL_RCC_OscConfig+0x2e0>
      while (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 800583e:	f8d5 3094 	ldr.w	r3, [r5, #148]	@ 0x94
 8005842:	079b      	lsls	r3, r3, #30
 8005844:	d5f5      	bpl.n	8005832 <HAL_RCC_OscConfig+0xa6>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8005846:	6823      	ldr	r3, [r4, #0]
 8005848:	075d      	lsls	r5, r3, #29
 800584a:	d541      	bpl.n	80058d0 <HAL_RCC_OscConfig+0x144>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain if necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED() != 0U)
 800584c:	4b7b      	ldr	r3, [pc, #492]	@ (8005a3c <HAL_RCC_OscConfig+0x2b0>)
 800584e:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 8005850:	00d0      	lsls	r0, r2, #3
 8005852:	f100 810f 	bmi.w	8005a74 <HAL_RCC_OscConfig+0x2e8>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8005856:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 8005858:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
 800585c:	659a      	str	r2, [r3, #88]	@ 0x58
 800585e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8005860:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8005864:	9301      	str	r3, [sp, #4]
 8005866:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8005868:	2501      	movs	r5, #1
    }

    if (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 800586a:	4e76      	ldr	r6, [pc, #472]	@ (8005a44 <HAL_RCC_OscConfig+0x2b8>)
 800586c:	6833      	ldr	r3, [r6, #0]
 800586e:	05d9      	lsls	r1, r3, #23
 8005870:	f140 812e 	bpl.w	8005ad0 <HAL_RCC_OscConfig+0x344>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8005874:	68a3      	ldr	r3, [r4, #8]
 8005876:	2b01      	cmp	r3, #1
 8005878:	f000 80fe 	beq.w	8005a78 <HAL_RCC_OscConfig+0x2ec>
 800587c:	2b05      	cmp	r3, #5
 800587e:	f000 8184 	beq.w	8005b8a <HAL_RCC_OscConfig+0x3fe>
 8005882:	4e6e      	ldr	r6, [pc, #440]	@ (8005a3c <HAL_RCC_OscConfig+0x2b0>)
 8005884:	f8d6 2090 	ldr.w	r2, [r6, #144]	@ 0x90
 8005888:	f022 0201 	bic.w	r2, r2, #1
 800588c:	f8c6 2090 	str.w	r2, [r6, #144]	@ 0x90
 8005890:	f8d6 2090 	ldr.w	r2, [r6, #144]	@ 0x90
 8005894:	f022 0204 	bic.w	r2, r2, #4
 8005898:	f8c6 2090 	str.w	r2, [r6, #144]	@ 0x90

    /* Check the LSE State */
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 800589c:	2b00      	cmp	r3, #0
 800589e:	f040 80f2 	bne.w	8005a86 <HAL_RCC_OscConfig+0x2fa>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80058a2:	f7fe fcf3 	bl	800428c <HAL_GetTick>

      /* Wait till LSE is disabled */
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80058a6:	f241 3888 	movw	r8, #5000	@ 0x1388
      tickstart = HAL_GetTick();
 80058aa:	4607      	mov	r7, r0
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 80058ac:	e005      	b.n	80058ba <HAL_RCC_OscConfig+0x12e>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80058ae:	f7fe fced 	bl	800428c <HAL_GetTick>
 80058b2:	1bc0      	subs	r0, r0, r7
 80058b4:	4540      	cmp	r0, r8
 80058b6:	f200 80d9 	bhi.w	8005a6c <HAL_RCC_OscConfig+0x2e0>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 80058ba:	f8d6 3090 	ldr.w	r3, [r6, #144]	@ 0x90
 80058be:	0799      	lsls	r1, r3, #30
 80058c0:	d4f5      	bmi.n	80058ae <HAL_RCC_OscConfig+0x122>
        }
      }
    }

    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
 80058c2:	b125      	cbz	r5, 80058ce <HAL_RCC_OscConfig+0x142>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 80058c4:	4a5d      	ldr	r2, [pc, #372]	@ (8005a3c <HAL_RCC_OscConfig+0x2b0>)
 80058c6:	6d93      	ldr	r3, [r2, #88]	@ 0x58
 80058c8:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 80058cc:	6593      	str	r3, [r2, #88]	@ 0x58
    }
  }

  /*------------------------------ HSI48 Configuration -----------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 80058ce:	6823      	ldr	r3, [r4, #0]
 80058d0:	069a      	lsls	r2, r3, #26
 80058d2:	d518      	bpl.n	8005906 <HAL_RCC_OscConfig+0x17a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

    /* Check the HSI48 State */
    if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 80058d4:	69a3      	ldr	r3, [r4, #24]
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
 80058d6:	4d59      	ldr	r5, [pc, #356]	@ (8005a3c <HAL_RCC_OscConfig+0x2b0>)
    if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 80058d8:	2b00      	cmp	r3, #0
 80058da:	f000 80e5 	beq.w	8005aa8 <HAL_RCC_OscConfig+0x31c>
      __HAL_RCC_HSI48_ENABLE();
 80058de:	f8d5 3098 	ldr.w	r3, [r5, #152]	@ 0x98
 80058e2:	f043 0301 	orr.w	r3, r3, #1
 80058e6:	f8c5 3098 	str.w	r3, [r5, #152]	@ 0x98

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80058ea:	f7fe fccf 	bl	800428c <HAL_GetTick>
 80058ee:	4606      	mov	r6, r0

      /* Wait till HSI48 is ready */
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
 80058f0:	e005      	b.n	80058fe <HAL_RCC_OscConfig+0x172>
      {
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 80058f2:	f7fe fccb 	bl	800428c <HAL_GetTick>
 80058f6:	1b80      	subs	r0, r0, r6
 80058f8:	2802      	cmp	r0, #2
 80058fa:	f200 80b7 	bhi.w	8005a6c <HAL_RCC_OscConfig+0x2e0>
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
 80058fe:	f8d5 3098 	ldr.w	r3, [r5, #152]	@ 0x98
 8005902:	079b      	lsls	r3, r3, #30
 8005904:	d5f5      	bpl.n	80058f2 <HAL_RCC_OscConfig+0x166>

  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));

  if (RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 8005906:	69e3      	ldr	r3, [r4, #28]
 8005908:	b1f3      	cbz	r3, 8005948 <HAL_RCC_OscConfig+0x1bc>
  {
    /* Check if the PLL is used as system clock or not */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 800590a:	4d4c      	ldr	r5, [pc, #304]	@ (8005a3c <HAL_RCC_OscConfig+0x2b0>)
 800590c:	68aa      	ldr	r2, [r5, #8]
 800590e:	f002 020c 	and.w	r2, r2, #12
 8005912:	2a0c      	cmp	r2, #12
 8005914:	f000 8147 	beq.w	8005ba6 <HAL_RCC_OscConfig+0x41a>
    {
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8005918:	2b02      	cmp	r3, #2
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800591a:	682b      	ldr	r3, [r5, #0]
 800591c:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
 8005920:	602b      	str	r3, [r5, #0]
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8005922:	f000 80f5 	beq.w	8005b10 <HAL_RCC_OscConfig+0x384>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8005926:	f7fe fcb1 	bl	800428c <HAL_GetTick>
 800592a:	4604      	mov	r4, r0

        /* Wait till PLL is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 800592c:	e005      	b.n	800593a <HAL_RCC_OscConfig+0x1ae>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800592e:	f7fe fcad 	bl	800428c <HAL_GetTick>
 8005932:	1b00      	subs	r0, r0, r4
 8005934:	2802      	cmp	r0, #2
 8005936:	f200 8099 	bhi.w	8005a6c <HAL_RCC_OscConfig+0x2e0>
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 800593a:	682b      	ldr	r3, [r5, #0]
 800593c:	019b      	lsls	r3, r3, #6
 800593e:	d4f6      	bmi.n	800592e <HAL_RCC_OscConfig+0x1a2>
            return HAL_TIMEOUT;
          }
        }

        /* Unselect PLL clock source and disable outputs to save power */
        RCC->PLLCFGR &= ~(RCC_PLLCFGR_PLLSRC | RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_ADCCLK);
 8005940:	68ea      	ldr	r2, [r5, #12]
 8005942:	4b41      	ldr	r3, [pc, #260]	@ (8005a48 <HAL_RCC_OscConfig+0x2bc>)
 8005944:	4013      	ands	r3, r2
 8005946:	60eb      	str	r3, [r5, #12]
      }
    }
  }
  }

  return HAL_OK;
 8005948:	2000      	movs	r0, #0
}
 800594a:	b002      	add	sp, #8
 800594c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    temp_pllckcfg = __HAL_RCC_GET_PLL_OSCSOURCE();
 8005950:	f001 0103 	and.w	r1, r1, #3
    if (((temp_sysclksrc == RCC_CFGR_SWS_PLL) && (temp_pllckcfg == RCC_PLLSOURCE_HSE)) || (temp_sysclksrc == RCC_CFGR_SWS_HSE))
 8005954:	2903      	cmp	r1, #3
 8005956:	f43f af2e 	beq.w	80057b6 <HAL_RCC_OscConfig+0x2a>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800595a:	6863      	ldr	r3, [r4, #4]
 800595c:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8005960:	d055      	beq.n	8005a0e <HAL_RCC_OscConfig+0x282>
 8005962:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 8005966:	f000 80c4 	beq.w	8005af2 <HAL_RCC_OscConfig+0x366>
 800596a:	4d34      	ldr	r5, [pc, #208]	@ (8005a3c <HAL_RCC_OscConfig+0x2b0>)
 800596c:	682a      	ldr	r2, [r5, #0]
 800596e:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 8005972:	602a      	str	r2, [r5, #0]
 8005974:	682a      	ldr	r2, [r5, #0]
 8005976:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
 800597a:	602a      	str	r2, [r5, #0]
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 800597c:	2b00      	cmp	r3, #0
 800597e:	d14b      	bne.n	8005a18 <HAL_RCC_OscConfig+0x28c>
        tickstart = HAL_GetTick();
 8005980:	f7fe fc84 	bl	800428c <HAL_GetTick>
 8005984:	4606      	mov	r6, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 8005986:	e004      	b.n	8005992 <HAL_RCC_OscConfig+0x206>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8005988:	f7fe fc80 	bl	800428c <HAL_GetTick>
 800598c:	1b80      	subs	r0, r0, r6
 800598e:	2864      	cmp	r0, #100	@ 0x64
 8005990:	d86c      	bhi.n	8005a6c <HAL_RCC_OscConfig+0x2e0>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 8005992:	682b      	ldr	r3, [r5, #0]
 8005994:	0399      	lsls	r1, r3, #14
 8005996:	d4f7      	bmi.n	8005988 <HAL_RCC_OscConfig+0x1fc>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8005998:	6823      	ldr	r3, [r4, #0]
 800599a:	079a      	lsls	r2, r3, #30
 800599c:	f57f af38 	bpl.w	8005810 <HAL_RCC_OscConfig+0x84>
 80059a0:	e713      	b.n	80057ca <HAL_RCC_OscConfig+0x3e>
      __HAL_RCC_LSI_DISABLE();
 80059a2:	f8d5 3094 	ldr.w	r3, [r5, #148]	@ 0x94
 80059a6:	f023 0301 	bic.w	r3, r3, #1
 80059aa:	f8c5 3094 	str.w	r3, [r5, #148]	@ 0x94
      tickstart = HAL_GetTick();
 80059ae:	f7fe fc6d 	bl	800428c <HAL_GetTick>
 80059b2:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 80059b4:	e004      	b.n	80059c0 <HAL_RCC_OscConfig+0x234>
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 80059b6:	f7fe fc69 	bl	800428c <HAL_GetTick>
 80059ba:	1b80      	subs	r0, r0, r6
 80059bc:	2802      	cmp	r0, #2
 80059be:	d855      	bhi.n	8005a6c <HAL_RCC_OscConfig+0x2e0>
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 80059c0:	f8d5 3094 	ldr.w	r3, [r5, #148]	@ 0x94
 80059c4:	079f      	lsls	r7, r3, #30
 80059c6:	d4f6      	bmi.n	80059b6 <HAL_RCC_OscConfig+0x22a>
 80059c8:	e73d      	b.n	8005846 <HAL_RCC_OscConfig+0xba>
    temp_pllckcfg = __HAL_RCC_GET_PLL_OSCSOURCE();
 80059ca:	f002 0203 	and.w	r2, r2, #3
    if (((temp_sysclksrc == RCC_CFGR_SWS_PLL) && (temp_pllckcfg == RCC_PLLSOURCE_HSI)) || (temp_sysclksrc == RCC_CFGR_SWS_HSI))
 80059ce:	2a02      	cmp	r2, #2
 80059d0:	f43f af06 	beq.w	80057e0 <HAL_RCC_OscConfig+0x54>
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 80059d4:	68e3      	ldr	r3, [r4, #12]
        __HAL_RCC_HSI_ENABLE();
 80059d6:	4d19      	ldr	r5, [pc, #100]	@ (8005a3c <HAL_RCC_OscConfig+0x2b0>)
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 80059d8:	2b00      	cmp	r3, #0
 80059da:	d037      	beq.n	8005a4c <HAL_RCC_OscConfig+0x2c0>
        __HAL_RCC_HSI_ENABLE();
 80059dc:	682b      	ldr	r3, [r5, #0]
 80059de:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 80059e2:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 80059e4:	f7fe fc52 	bl	800428c <HAL_GetTick>
 80059e8:	4606      	mov	r6, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 80059ea:	e004      	b.n	80059f6 <HAL_RCC_OscConfig+0x26a>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 80059ec:	f7fe fc4e 	bl	800428c <HAL_GetTick>
 80059f0:	1b80      	subs	r0, r0, r6
 80059f2:	2802      	cmp	r0, #2
 80059f4:	d83a      	bhi.n	8005a6c <HAL_RCC_OscConfig+0x2e0>
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 80059f6:	682b      	ldr	r3, [r5, #0]
 80059f8:	055f      	lsls	r7, r3, #21
 80059fa:	d5f7      	bpl.n	80059ec <HAL_RCC_OscConfig+0x260>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80059fc:	686b      	ldr	r3, [r5, #4]
 80059fe:	6922      	ldr	r2, [r4, #16]
 8005a00:	f023 43fe 	bic.w	r3, r3, #2130706432	@ 0x7f000000
 8005a04:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8005a08:	606b      	str	r3, [r5, #4]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8005a0a:	6823      	ldr	r3, [r4, #0]
 8005a0c:	e700      	b.n	8005810 <HAL_RCC_OscConfig+0x84>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8005a0e:	4a0b      	ldr	r2, [pc, #44]	@ (8005a3c <HAL_RCC_OscConfig+0x2b0>)
 8005a10:	6813      	ldr	r3, [r2, #0]
 8005a12:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8005a16:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8005a18:	f7fe fc38 	bl	800428c <HAL_GetTick>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8005a1c:	4e07      	ldr	r6, [pc, #28]	@ (8005a3c <HAL_RCC_OscConfig+0x2b0>)
        tickstart = HAL_GetTick();
 8005a1e:	4605      	mov	r5, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8005a20:	e004      	b.n	8005a2c <HAL_RCC_OscConfig+0x2a0>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8005a22:	f7fe fc33 	bl	800428c <HAL_GetTick>
 8005a26:	1b40      	subs	r0, r0, r5
 8005a28:	2864      	cmp	r0, #100	@ 0x64
 8005a2a:	d81f      	bhi.n	8005a6c <HAL_RCC_OscConfig+0x2e0>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8005a2c:	6833      	ldr	r3, [r6, #0]
 8005a2e:	039f      	lsls	r7, r3, #14
 8005a30:	d5f7      	bpl.n	8005a22 <HAL_RCC_OscConfig+0x296>
 8005a32:	e7b1      	b.n	8005998 <HAL_RCC_OscConfig+0x20c>
    return HAL_ERROR;
 8005a34:	2001      	movs	r0, #1
}
 8005a36:	b002      	add	sp, #8
 8005a38:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005a3c:	40021000 	.word	0x40021000
 8005a40:	2000047c 	.word	0x2000047c
 8005a44:	40007000 	.word	0x40007000
 8005a48:	feeefffc 	.word	0xfeeefffc
        __HAL_RCC_HSI_DISABLE();
 8005a4c:	682b      	ldr	r3, [r5, #0]
 8005a4e:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8005a52:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8005a54:	f7fe fc1a 	bl	800428c <HAL_GetTick>
 8005a58:	4606      	mov	r6, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 8005a5a:	682b      	ldr	r3, [r5, #0]
 8005a5c:	0559      	lsls	r1, r3, #21
 8005a5e:	f57f aed6 	bpl.w	800580e <HAL_RCC_OscConfig+0x82>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8005a62:	f7fe fc13 	bl	800428c <HAL_GetTick>
 8005a66:	1b80      	subs	r0, r0, r6
 8005a68:	2802      	cmp	r0, #2
 8005a6a:	d9f6      	bls.n	8005a5a <HAL_RCC_OscConfig+0x2ce>
            return HAL_TIMEOUT;
 8005a6c:	2003      	movs	r0, #3
}
 8005a6e:	b002      	add	sp, #8
 8005a70:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    FlagStatus       pwrclkchanged = RESET;
 8005a74:	2500      	movs	r5, #0
 8005a76:	e6f8      	b.n	800586a <HAL_RCC_OscConfig+0xde>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8005a78:	4a65      	ldr	r2, [pc, #404]	@ (8005c10 <HAL_RCC_OscConfig+0x484>)
 8005a7a:	f8d2 3090 	ldr.w	r3, [r2, #144]	@ 0x90
 8005a7e:	f043 0301 	orr.w	r3, r3, #1
 8005a82:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
      tickstart = HAL_GetTick();
 8005a86:	f7fe fc01 	bl	800428c <HAL_GetTick>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8005a8a:	4f61      	ldr	r7, [pc, #388]	@ (8005c10 <HAL_RCC_OscConfig+0x484>)
      tickstart = HAL_GetTick();
 8005a8c:	4606      	mov	r6, r0
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8005a8e:	f241 3888 	movw	r8, #5000	@ 0x1388
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8005a92:	e004      	b.n	8005a9e <HAL_RCC_OscConfig+0x312>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8005a94:	f7fe fbfa 	bl	800428c <HAL_GetTick>
 8005a98:	1b80      	subs	r0, r0, r6
 8005a9a:	4540      	cmp	r0, r8
 8005a9c:	d8e6      	bhi.n	8005a6c <HAL_RCC_OscConfig+0x2e0>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8005a9e:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8005aa2:	079b      	lsls	r3, r3, #30
 8005aa4:	d5f6      	bpl.n	8005a94 <HAL_RCC_OscConfig+0x308>
 8005aa6:	e70c      	b.n	80058c2 <HAL_RCC_OscConfig+0x136>
      __HAL_RCC_HSI48_DISABLE();
 8005aa8:	f8d5 3098 	ldr.w	r3, [r5, #152]	@ 0x98
 8005aac:	f023 0301 	bic.w	r3, r3, #1
 8005ab0:	f8c5 3098 	str.w	r3, [r5, #152]	@ 0x98
      tickstart = HAL_GetTick();
 8005ab4:	f7fe fbea 	bl	800428c <HAL_GetTick>
 8005ab8:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
 8005aba:	e004      	b.n	8005ac6 <HAL_RCC_OscConfig+0x33a>
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8005abc:	f7fe fbe6 	bl	800428c <HAL_GetTick>
 8005ac0:	1b80      	subs	r0, r0, r6
 8005ac2:	2802      	cmp	r0, #2
 8005ac4:	d8d2      	bhi.n	8005a6c <HAL_RCC_OscConfig+0x2e0>
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
 8005ac6:	f8d5 3098 	ldr.w	r3, [r5, #152]	@ 0x98
 8005aca:	079f      	lsls	r7, r3, #30
 8005acc:	d4f6      	bmi.n	8005abc <HAL_RCC_OscConfig+0x330>
 8005ace:	e71a      	b.n	8005906 <HAL_RCC_OscConfig+0x17a>
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8005ad0:	6833      	ldr	r3, [r6, #0]
 8005ad2:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8005ad6:	6033      	str	r3, [r6, #0]
      tickstart = HAL_GetTick();
 8005ad8:	f7fe fbd8 	bl	800428c <HAL_GetTick>
 8005adc:	4607      	mov	r7, r0
      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8005ade:	6833      	ldr	r3, [r6, #0]
 8005ae0:	05da      	lsls	r2, r3, #23
 8005ae2:	f53f aec7 	bmi.w	8005874 <HAL_RCC_OscConfig+0xe8>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8005ae6:	f7fe fbd1 	bl	800428c <HAL_GetTick>
 8005aea:	1bc0      	subs	r0, r0, r7
 8005aec:	2802      	cmp	r0, #2
 8005aee:	d9f6      	bls.n	8005ade <HAL_RCC_OscConfig+0x352>
 8005af0:	e7bc      	b.n	8005a6c <HAL_RCC_OscConfig+0x2e0>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8005af2:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 8005af6:	f5a3 333c 	sub.w	r3, r3, #192512	@ 0x2f000
 8005afa:	681a      	ldr	r2, [r3, #0]
 8005afc:	f442 2280 	orr.w	r2, r2, #262144	@ 0x40000
 8005b00:	601a      	str	r2, [r3, #0]
 8005b02:	681a      	ldr	r2, [r3, #0]
 8005b04:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 8005b08:	601a      	str	r2, [r3, #0]
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8005b0a:	e785      	b.n	8005a18 <HAL_RCC_OscConfig+0x28c>
    return HAL_ERROR;
 8005b0c:	2001      	movs	r0, #1
}
 8005b0e:	4770      	bx	lr
        tickstart = HAL_GetTick();
 8005b10:	f7fe fbbc 	bl	800428c <HAL_GetTick>
 8005b14:	4606      	mov	r6, r0
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8005b16:	e004      	b.n	8005b22 <HAL_RCC_OscConfig+0x396>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8005b18:	f7fe fbb8 	bl	800428c <HAL_GetTick>
 8005b1c:	1b80      	subs	r0, r0, r6
 8005b1e:	2802      	cmp	r0, #2
 8005b20:	d8a4      	bhi.n	8005a6c <HAL_RCC_OscConfig+0x2e0>
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8005b22:	682b      	ldr	r3, [r5, #0]
 8005b24:	0199      	lsls	r1, r3, #6
 8005b26:	d4f7      	bmi.n	8005b18 <HAL_RCC_OscConfig+0x38c>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8005b28:	68e9      	ldr	r1, [r5, #12]
 8005b2a:	4b3a      	ldr	r3, [pc, #232]	@ (8005c14 <HAL_RCC_OscConfig+0x488>)
 8005b2c:	6a22      	ldr	r2, [r4, #32]
 8005b2e:	6a60      	ldr	r0, [r4, #36]	@ 0x24
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8005b30:	4e37      	ldr	r6, [pc, #220]	@ (8005c10 <HAL_RCC_OscConfig+0x484>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8005b32:	400b      	ands	r3, r1
 8005b34:	4313      	orrs	r3, r2
 8005b36:	e9d4 120a 	ldrd	r1, r2, [r4, #40]	@ 0x28
 8005b3a:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8005b3e:	ea43 63c2 	orr.w	r3, r3, r2, lsl #27
 8005b42:	e9d4 120c 	ldrd	r1, r2, [r4, #48]	@ 0x30
 8005b46:	3801      	subs	r0, #1
 8005b48:	0849      	lsrs	r1, r1, #1
 8005b4a:	ea43 1300 	orr.w	r3, r3, r0, lsl #4
 8005b4e:	3901      	subs	r1, #1
 8005b50:	0852      	lsrs	r2, r2, #1
 8005b52:	ea43 5341 	orr.w	r3, r3, r1, lsl #21
 8005b56:	3a01      	subs	r2, #1
 8005b58:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 8005b5c:	60eb      	str	r3, [r5, #12]
        __HAL_RCC_PLL_ENABLE();
 8005b5e:	682b      	ldr	r3, [r5, #0]
 8005b60:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8005b64:	602b      	str	r3, [r5, #0]
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8005b66:	68eb      	ldr	r3, [r5, #12]
 8005b68:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8005b6c:	60eb      	str	r3, [r5, #12]
        tickstart = HAL_GetTick();
 8005b6e:	f7fe fb8d 	bl	800428c <HAL_GetTick>
 8005b72:	4604      	mov	r4, r0
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8005b74:	e005      	b.n	8005b82 <HAL_RCC_OscConfig+0x3f6>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8005b76:	f7fe fb89 	bl	800428c <HAL_GetTick>
 8005b7a:	1b00      	subs	r0, r0, r4
 8005b7c:	2802      	cmp	r0, #2
 8005b7e:	f63f af75 	bhi.w	8005a6c <HAL_RCC_OscConfig+0x2e0>
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8005b82:	6833      	ldr	r3, [r6, #0]
 8005b84:	019a      	lsls	r2, r3, #6
 8005b86:	d5f6      	bpl.n	8005b76 <HAL_RCC_OscConfig+0x3ea>
 8005b88:	e6de      	b.n	8005948 <HAL_RCC_OscConfig+0x1bc>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8005b8a:	4b21      	ldr	r3, [pc, #132]	@ (8005c10 <HAL_RCC_OscConfig+0x484>)
 8005b8c:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
 8005b90:	f042 0204 	orr.w	r2, r2, #4
 8005b94:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
 8005b98:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
 8005b9c:	f042 0201 	orr.w	r2, r2, #1
 8005ba0:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8005ba4:	e76f      	b.n	8005a86 <HAL_RCC_OscConfig+0x2fa>
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 8005ba6:	2b01      	cmp	r3, #1
 8005ba8:	f43f af44 	beq.w	8005a34 <HAL_RCC_OscConfig+0x2a8>
      temp_pllckcfg = RCC->PLLCFGR;
 8005bac:	68eb      	ldr	r3, [r5, #12]
      if((READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8005bae:	6a22      	ldr	r2, [r4, #32]
 8005bb0:	f003 0103 	and.w	r1, r3, #3
 8005bb4:	4291      	cmp	r1, r2
 8005bb6:	f47f af3d 	bne.w	8005a34 <HAL_RCC_OscConfig+0x2a8>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLM) != (((RCC_OscInitStruct->PLL.PLLM) - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 8005bba:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 8005bbc:	f003 02f0 	and.w	r2, r3, #240	@ 0xf0
 8005bc0:	3901      	subs	r1, #1
      if((READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8005bc2:	ebb2 1f01 	cmp.w	r2, r1, lsl #4
 8005bc6:	f47f af35 	bne.w	8005a34 <HAL_RCC_OscConfig+0x2a8>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLN) != ((RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos)) ||
 8005bca:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 8005bcc:	f403 42fe 	and.w	r2, r3, #32512	@ 0x7f00
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLM) != (((RCC_OscInitStruct->PLL.PLLM) - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 8005bd0:	ebb2 2f01 	cmp.w	r2, r1, lsl #8
 8005bd4:	f47f af2e 	bne.w	8005a34 <HAL_RCC_OscConfig+0x2a8>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLPDIV) != ((RCC_OscInitStruct->PLL.PLLP) << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 8005bd8:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 8005bda:	f003 4278 	and.w	r2, r3, #4160749568	@ 0xf8000000
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLN) != ((RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos)) ||
 8005bde:	ebb2 6fc1 	cmp.w	r2, r1, lsl #27
 8005be2:	f47f af27 	bne.w	8005a34 <HAL_RCC_OscConfig+0x2a8>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLQ) != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 8005be6:	6b22      	ldr	r2, [r4, #48]	@ 0x30
 8005be8:	0852      	lsrs	r2, r2, #1
 8005bea:	f403 01c0 	and.w	r1, r3, #6291456	@ 0x600000
 8005bee:	3a01      	subs	r2, #1
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLPDIV) != ((RCC_OscInitStruct->PLL.PLLP) << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 8005bf0:	ebb1 5f42 	cmp.w	r1, r2, lsl #21
 8005bf4:	f47f af1e 	bne.w	8005a34 <HAL_RCC_OscConfig+0x2a8>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLR) != ((((RCC_OscInitStruct->PLL.PLLR) >> 1U) - 1U) << RCC_PLLCFGR_PLLR_Pos)))
 8005bf8:	6b62      	ldr	r2, [r4, #52]	@ 0x34
 8005bfa:	0852      	lsrs	r2, r2, #1
 8005bfc:	f003 63c0 	and.w	r3, r3, #100663296	@ 0x6000000
 8005c00:	3a01      	subs	r2, #1
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLQ) != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 8005c02:	ebb3 6f42 	cmp.w	r3, r2, lsl #25
 8005c06:	bf14      	ite	ne
 8005c08:	2001      	movne	r0, #1
 8005c0a:	2000      	moveq	r0, #0
 8005c0c:	e69d      	b.n	800594a <HAL_RCC_OscConfig+0x1be>
 8005c0e:	bf00      	nop
 8005c10:	40021000 	.word	0x40021000
 8005c14:	019f800c 	.word	0x019f800c

08005c18 <HAL_RCC_GetSysClockFreq>:
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t pllvco, pllsource, pllr, pllm;
  uint32_t sysclockfreq;

  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)
 8005c18:	4b18      	ldr	r3, [pc, #96]	@ (8005c7c <HAL_RCC_GetSysClockFreq+0x64>)
 8005c1a:	689a      	ldr	r2, [r3, #8]
 8005c1c:	f002 020c 	and.w	r2, r2, #12
 8005c20:	2a04      	cmp	r2, #4
 8005c22:	d026      	beq.n	8005c72 <HAL_RCC_GetSysClockFreq+0x5a>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
  }
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)
 8005c24:	689a      	ldr	r2, [r3, #8]
 8005c26:	f002 020c 	and.w	r2, r2, #12
 8005c2a:	2a08      	cmp	r2, #8
 8005c2c:	d023      	beq.n	8005c76 <HAL_RCC_GetSysClockFreq+0x5e>
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
  }
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
 8005c2e:	689a      	ldr	r2, [r3, #8]
 8005c30:	f002 020c 	and.w	r2, r2, #12
 8005c34:	2a0c      	cmp	r2, #12
 8005c36:	d001      	beq.n	8005c3c <HAL_RCC_GetSysClockFreq+0x24>
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
    sysclockfreq = pllvco/pllr;
  }
  else
  {
    sysclockfreq = 0U;
 8005c38:	2000      	movs	r0, #0
  }

  return sysclockfreq;
}
 8005c3a:	4770      	bx	lr
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8005c3c:	68d9      	ldr	r1, [r3, #12]
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8005c3e:	68da      	ldr	r2, [r3, #12]
      pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8005c40:	68d8      	ldr	r0, [r3, #12]
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8005c42:	f001 0103 	and.w	r1, r1, #3
    switch (pllsource)
 8005c46:	2903      	cmp	r1, #3
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8005c48:	f3c2 1203 	ubfx	r2, r2, #4, #4
      pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8005c4c:	f3c0 2006 	ubfx	r0, r0, #8, #7
      pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8005c50:	bf0c      	ite	eq
 8005c52:	4b0b      	ldreq	r3, [pc, #44]	@ (8005c80 <HAL_RCC_GetSysClockFreq+0x68>)
      pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8005c54:	4b0b      	ldrne	r3, [pc, #44]	@ (8005c84 <HAL_RCC_GetSysClockFreq+0x6c>)
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8005c56:	3201      	adds	r2, #1
      pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8005c58:	fbb3 f3f2 	udiv	r3, r3, r2
 8005c5c:	fb03 f000 	mul.w	r0, r3, r0
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8005c60:	4b06      	ldr	r3, [pc, #24]	@ (8005c7c <HAL_RCC_GetSysClockFreq+0x64>)
 8005c62:	68db      	ldr	r3, [r3, #12]
 8005c64:	f3c3 6341 	ubfx	r3, r3, #25, #2
 8005c68:	3301      	adds	r3, #1
 8005c6a:	005b      	lsls	r3, r3, #1
    sysclockfreq = pllvco/pllr;
 8005c6c:	fbb0 f0f3 	udiv	r0, r0, r3
  return sysclockfreq;
 8005c70:	4770      	bx	lr
    sysclockfreq = HSI_VALUE;
 8005c72:	4804      	ldr	r0, [pc, #16]	@ (8005c84 <HAL_RCC_GetSysClockFreq+0x6c>)
 8005c74:	4770      	bx	lr
    sysclockfreq = HSE_VALUE;
 8005c76:	4802      	ldr	r0, [pc, #8]	@ (8005c80 <HAL_RCC_GetSysClockFreq+0x68>)
 8005c78:	4770      	bx	lr
 8005c7a:	bf00      	nop
 8005c7c:	40021000 	.word	0x40021000
 8005c80:	016e3600 	.word	0x016e3600
 8005c84:	00f42400 	.word	0x00f42400

08005c88 <HAL_RCC_ClockConfig>:
  if (RCC_ClkInitStruct == NULL)
 8005c88:	2800      	cmp	r0, #0
 8005c8a:	f000 80ee 	beq.w	8005e6a <HAL_RCC_ClockConfig+0x1e2>
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8005c8e:	4a78      	ldr	r2, [pc, #480]	@ (8005e70 <HAL_RCC_ClockConfig+0x1e8>)
{
 8005c90:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8005c94:	6813      	ldr	r3, [r2, #0]
 8005c96:	f003 030f 	and.w	r3, r3, #15
 8005c9a:	428b      	cmp	r3, r1
 8005c9c:	460d      	mov	r5, r1
 8005c9e:	4604      	mov	r4, r0
 8005ca0:	d20c      	bcs.n	8005cbc <HAL_RCC_ClockConfig+0x34>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8005ca2:	6813      	ldr	r3, [r2, #0]
 8005ca4:	f023 030f 	bic.w	r3, r3, #15
 8005ca8:	430b      	orrs	r3, r1
 8005caa:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8005cac:	6813      	ldr	r3, [r2, #0]
 8005cae:	f003 030f 	and.w	r3, r3, #15
 8005cb2:	428b      	cmp	r3, r1
 8005cb4:	d002      	beq.n	8005cbc <HAL_RCC_ClockConfig+0x34>
    return HAL_ERROR;
 8005cb6:	2001      	movs	r0, #1
}
 8005cb8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8005cbc:	6823      	ldr	r3, [r4, #0]
 8005cbe:	07df      	lsls	r7, r3, #31
 8005cc0:	d569      	bpl.n	8005d96 <HAL_RCC_ClockConfig+0x10e>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8005cc2:	6867      	ldr	r7, [r4, #4]
 8005cc4:	2f03      	cmp	r7, #3
 8005cc6:	f000 80a0 	beq.w	8005e0a <HAL_RCC_ClockConfig+0x182>
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8005cca:	4b6a      	ldr	r3, [pc, #424]	@ (8005e74 <HAL_RCC_ClockConfig+0x1ec>)
      if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8005ccc:	2f02      	cmp	r7, #2
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8005cce:	681b      	ldr	r3, [r3, #0]
      if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8005cd0:	f000 8097 	beq.w	8005e02 <HAL_RCC_ClockConfig+0x17a>
        if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8005cd4:	055b      	lsls	r3, r3, #21
 8005cd6:	d5ee      	bpl.n	8005cb6 <HAL_RCC_ClockConfig+0x2e>
      pllfreq = HAL_RCC_GetSysClockFreq();
 8005cd8:	f7ff ff9e 	bl	8005c18 <HAL_RCC_GetSysClockFreq>
      if(pllfreq > 80000000U)
 8005cdc:	4b66      	ldr	r3, [pc, #408]	@ (8005e78 <HAL_RCC_ClockConfig+0x1f0>)
 8005cde:	4298      	cmp	r0, r3
 8005ce0:	f240 80c0 	bls.w	8005e64 <HAL_RCC_ClockConfig+0x1dc>
          MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
 8005ce4:	4a63      	ldr	r2, [pc, #396]	@ (8005e74 <HAL_RCC_ClockConfig+0x1ec>)
 8005ce6:	6893      	ldr	r3, [r2, #8]
 8005ce8:	f023 03f0 	bic.w	r3, r3, #240	@ 0xf0
 8005cec:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8005cf0:	6093      	str	r3, [r2, #8]
        hpre = RCC_SYSCLK_DIV2;
 8005cf2:	f04f 0980 	mov.w	r9, #128	@ 0x80
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8005cf6:	4e5f      	ldr	r6, [pc, #380]	@ (8005e74 <HAL_RCC_ClockConfig+0x1ec>)
 8005cf8:	68b3      	ldr	r3, [r6, #8]
 8005cfa:	f023 0303 	bic.w	r3, r3, #3
 8005cfe:	433b      	orrs	r3, r7
 8005d00:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 8005d02:	f7fe fac3 	bl	800428c <HAL_GetTick>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8005d06:	f241 3888 	movw	r8, #5000	@ 0x1388
    tickstart = HAL_GetTick();
 8005d0a:	4607      	mov	r7, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8005d0c:	e004      	b.n	8005d18 <HAL_RCC_ClockConfig+0x90>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8005d0e:	f7fe fabd 	bl	800428c <HAL_GetTick>
 8005d12:	1bc0      	subs	r0, r0, r7
 8005d14:	4540      	cmp	r0, r8
 8005d16:	d871      	bhi.n	8005dfc <HAL_RCC_ClockConfig+0x174>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8005d18:	68b3      	ldr	r3, [r6, #8]
 8005d1a:	6862      	ldr	r2, [r4, #4]
 8005d1c:	f003 030c 	and.w	r3, r3, #12
 8005d20:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8005d24:	d1f3      	bne.n	8005d0e <HAL_RCC_ClockConfig+0x86>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8005d26:	6823      	ldr	r3, [r4, #0]
 8005d28:	079f      	lsls	r7, r3, #30
 8005d2a:	d436      	bmi.n	8005d9a <HAL_RCC_ClockConfig+0x112>
    if(hpre == RCC_SYSCLK_DIV2)
 8005d2c:	f1b9 0f00 	cmp.w	r9, #0
 8005d30:	d003      	beq.n	8005d3a <HAL_RCC_ClockConfig+0xb2>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV1);
 8005d32:	68b3      	ldr	r3, [r6, #8]
 8005d34:	f023 03f0 	bic.w	r3, r3, #240	@ 0xf0
 8005d38:	60b3      	str	r3, [r6, #8]
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8005d3a:	4e4d      	ldr	r6, [pc, #308]	@ (8005e70 <HAL_RCC_ClockConfig+0x1e8>)
 8005d3c:	6833      	ldr	r3, [r6, #0]
 8005d3e:	f003 030f 	and.w	r3, r3, #15
 8005d42:	42ab      	cmp	r3, r5
 8005d44:	d846      	bhi.n	8005dd4 <HAL_RCC_ClockConfig+0x14c>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8005d46:	6823      	ldr	r3, [r4, #0]
 8005d48:	075a      	lsls	r2, r3, #29
 8005d4a:	d506      	bpl.n	8005d5a <HAL_RCC_ClockConfig+0xd2>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8005d4c:	4949      	ldr	r1, [pc, #292]	@ (8005e74 <HAL_RCC_ClockConfig+0x1ec>)
 8005d4e:	68e0      	ldr	r0, [r4, #12]
 8005d50:	688a      	ldr	r2, [r1, #8]
 8005d52:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 8005d56:	4302      	orrs	r2, r0
 8005d58:	608a      	str	r2, [r1, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8005d5a:	071b      	lsls	r3, r3, #28
 8005d5c:	d507      	bpl.n	8005d6e <HAL_RCC_ClockConfig+0xe6>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8005d5e:	4a45      	ldr	r2, [pc, #276]	@ (8005e74 <HAL_RCC_ClockConfig+0x1ec>)
 8005d60:	6921      	ldr	r1, [r4, #16]
 8005d62:	6893      	ldr	r3, [r2, #8]
 8005d64:	f423 5360 	bic.w	r3, r3, #14336	@ 0x3800
 8005d68:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8005d6c:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 8005d6e:	f7ff ff53 	bl	8005c18 <HAL_RCC_GetSysClockFreq>
 8005d72:	4a40      	ldr	r2, [pc, #256]	@ (8005e74 <HAL_RCC_ClockConfig+0x1ec>)
 8005d74:	4c41      	ldr	r4, [pc, #260]	@ (8005e7c <HAL_RCC_ClockConfig+0x1f4>)
 8005d76:	6892      	ldr	r2, [r2, #8]
 8005d78:	4941      	ldr	r1, [pc, #260]	@ (8005e80 <HAL_RCC_ClockConfig+0x1f8>)
 8005d7a:	f3c2 1203 	ubfx	r2, r2, #4, #4
 8005d7e:	4603      	mov	r3, r0
 8005d80:	5ca2      	ldrb	r2, [r4, r2]
  return HAL_InitTick(uwTickPrio);
 8005d82:	4840      	ldr	r0, [pc, #256]	@ (8005e84 <HAL_RCC_ClockConfig+0x1fc>)
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 8005d84:	f002 021f 	and.w	r2, r2, #31
 8005d88:	40d3      	lsrs	r3, r2
 8005d8a:	600b      	str	r3, [r1, #0]
  return HAL_InitTick(uwTickPrio);
 8005d8c:	6800      	ldr	r0, [r0, #0]
}
 8005d8e:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  return HAL_InitTick(uwTickPrio);
 8005d92:	f7fe b93f 	b.w	8004014 <HAL_InitTick>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8005d96:	079e      	lsls	r6, r3, #30
 8005d98:	d5cf      	bpl.n	8005d3a <HAL_RCC_ClockConfig+0xb2>
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8005d9a:	0758      	lsls	r0, r3, #29
 8005d9c:	d504      	bpl.n	8005da8 <HAL_RCC_ClockConfig+0x120>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 8005d9e:	4935      	ldr	r1, [pc, #212]	@ (8005e74 <HAL_RCC_ClockConfig+0x1ec>)
 8005da0:	688a      	ldr	r2, [r1, #8]
 8005da2:	f442 62e0 	orr.w	r2, r2, #1792	@ 0x700
 8005da6:	608a      	str	r2, [r1, #8]
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8005da8:	0719      	lsls	r1, r3, #28
 8005daa:	d506      	bpl.n	8005dba <HAL_RCC_ClockConfig+0x132>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, RCC_HCLK_DIV16);
 8005dac:	4a31      	ldr	r2, [pc, #196]	@ (8005e74 <HAL_RCC_ClockConfig+0x1ec>)
 8005dae:	6893      	ldr	r3, [r2, #8]
 8005db0:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
 8005db4:	f443 63e0 	orr.w	r3, r3, #1792	@ 0x700
 8005db8:	6093      	str	r3, [r2, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8005dba:	4a2e      	ldr	r2, [pc, #184]	@ (8005e74 <HAL_RCC_ClockConfig+0x1ec>)
 8005dbc:	68a1      	ldr	r1, [r4, #8]
 8005dbe:	6893      	ldr	r3, [r2, #8]
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8005dc0:	4e2b      	ldr	r6, [pc, #172]	@ (8005e70 <HAL_RCC_ClockConfig+0x1e8>)
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8005dc2:	f023 03f0 	bic.w	r3, r3, #240	@ 0xf0
 8005dc6:	430b      	orrs	r3, r1
 8005dc8:	6093      	str	r3, [r2, #8]
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8005dca:	6833      	ldr	r3, [r6, #0]
 8005dcc:	f003 030f 	and.w	r3, r3, #15
 8005dd0:	42ab      	cmp	r3, r5
 8005dd2:	d9b8      	bls.n	8005d46 <HAL_RCC_ClockConfig+0xbe>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8005dd4:	6833      	ldr	r3, [r6, #0]
 8005dd6:	f023 030f 	bic.w	r3, r3, #15
 8005dda:	432b      	orrs	r3, r5
 8005ddc:	6033      	str	r3, [r6, #0]
    tickstart = HAL_GetTick();
 8005dde:	f7fe fa55 	bl	800428c <HAL_GetTick>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8005de2:	f241 3888 	movw	r8, #5000	@ 0x1388
    tickstart = HAL_GetTick();
 8005de6:	4607      	mov	r7, r0
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 8005de8:	6833      	ldr	r3, [r6, #0]
 8005dea:	f003 030f 	and.w	r3, r3, #15
 8005dee:	42ab      	cmp	r3, r5
 8005df0:	d0a9      	beq.n	8005d46 <HAL_RCC_ClockConfig+0xbe>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8005df2:	f7fe fa4b 	bl	800428c <HAL_GetTick>
 8005df6:	1bc0      	subs	r0, r0, r7
 8005df8:	4540      	cmp	r0, r8
 8005dfa:	d9f5      	bls.n	8005de8 <HAL_RCC_ClockConfig+0x160>
        return HAL_TIMEOUT;
 8005dfc:	2003      	movs	r0, #3
}
 8005dfe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8005e02:	039a      	lsls	r2, r3, #14
 8005e04:	f53f af68 	bmi.w	8005cd8 <HAL_RCC_ClockConfig+0x50>
 8005e08:	e755      	b.n	8005cb6 <HAL_RCC_ClockConfig+0x2e>
      if (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8005e0a:	4a1a      	ldr	r2, [pc, #104]	@ (8005e74 <HAL_RCC_ClockConfig+0x1ec>)
 8005e0c:	6811      	ldr	r1, [r2, #0]
 8005e0e:	0188      	lsls	r0, r1, #6
 8005e10:	f57f af51 	bpl.w	8005cb6 <HAL_RCC_ClockConfig+0x2e>
  uint32_t sysclockfreq;

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE/ PLLM) * PLLN
     SYSCLK = PLL_VCO / PLLR
   */
  pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8005e14:	68d0      	ldr	r0, [r2, #12]
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8005e16:	68d1      	ldr	r1, [r2, #12]
    pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
    break;

  case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
  default:
    pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8005e18:	68d2      	ldr	r2, [r2, #12]
      if(pllfreq > 80000000U)
 8005e1a:	4e17      	ldr	r6, [pc, #92]	@ (8005e78 <HAL_RCC_ClockConfig+0x1f0>)
  pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8005e1c:	f000 0003 	and.w	r0, r0, #3
  switch (pllsource)
 8005e20:	2803      	cmp	r0, #3
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8005e22:	f3c1 1103 	ubfx	r1, r1, #4, #4
    pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8005e26:	bf0c      	ite	eq
 8005e28:	4817      	ldreq	r0, [pc, #92]	@ (8005e88 <HAL_RCC_ClockConfig+0x200>)
    pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8005e2a:	4818      	ldrne	r0, [pc, #96]	@ (8005e8c <HAL_RCC_ClockConfig+0x204>)
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8005e2c:	3101      	adds	r1, #1
    pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8005e2e:	fbb0 f1f1 	udiv	r1, r0, r1
    break;
  }

  pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8005e32:	4810      	ldr	r0, [pc, #64]	@ (8005e74 <HAL_RCC_ClockConfig+0x1ec>)
    pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8005e34:	f3c2 2206 	ubfx	r2, r2, #8, #7
 8005e38:	fb01 f202 	mul.w	r2, r1, r2
  pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8005e3c:	68c1      	ldr	r1, [r0, #12]
 8005e3e:	f3c1 6141 	ubfx	r1, r1, #25, #2
 8005e42:	3101      	adds	r1, #1
 8005e44:	0049      	lsls	r1, r1, #1
  sysclockfreq = pllvco/pllr;
 8005e46:	fbb2 f2f1 	udiv	r2, r2, r1
      if(pllfreq > 80000000U)
 8005e4a:	42b2      	cmp	r2, r6
 8005e4c:	d90a      	bls.n	8005e64 <HAL_RCC_ClockConfig+0x1dc>
        if (((READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) == RCC_SYSCLK_DIV1)) ||
 8005e4e:	6882      	ldr	r2, [r0, #8]
 8005e50:	f012 0ff0 	tst.w	r2, #240	@ 0xf0
 8005e54:	f43f af46 	beq.w	8005ce4 <HAL_RCC_ClockConfig+0x5c>
 8005e58:	0799      	lsls	r1, r3, #30
 8005e5a:	d503      	bpl.n	8005e64 <HAL_RCC_ClockConfig+0x1dc>
            (((((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK) &&
 8005e5c:	68a3      	ldr	r3, [r4, #8]
 8005e5e:	2b00      	cmp	r3, #0
 8005e60:	f43f af40 	beq.w	8005ce4 <HAL_RCC_ClockConfig+0x5c>
  uint32_t hpre = RCC_SYSCLK_DIV1;
 8005e64:	f04f 0900 	mov.w	r9, #0
 8005e68:	e745      	b.n	8005cf6 <HAL_RCC_ClockConfig+0x6e>
    return HAL_ERROR;
 8005e6a:	2001      	movs	r0, #1
}
 8005e6c:	4770      	bx	lr
 8005e6e:	bf00      	nop
 8005e70:	40022000 	.word	0x40022000
 8005e74:	40021000 	.word	0x40021000
 8005e78:	04c4b400 	.word	0x04c4b400
 8005e7c:	0800a5ac 	.word	0x0800a5ac
 8005e80:	20000474 	.word	0x20000474
 8005e84:	2000047c 	.word	0x2000047c
 8005e88:	016e3600 	.word	0x016e3600
 8005e8c:	00f42400 	.word	0x00f42400

08005e90 <HAL_RCC_GetHCLKFreq>:
  return SystemCoreClock;
 8005e90:	4b01      	ldr	r3, [pc, #4]	@ (8005e98 <HAL_RCC_GetHCLKFreq+0x8>)
}
 8005e92:	6818      	ldr	r0, [r3, #0]
 8005e94:	4770      	bx	lr
 8005e96:	bf00      	nop
 8005e98:	20000474 	.word	0x20000474

08005e9c <HAL_RCC_GetPCLK1Freq>:
  return (HAL_RCC_GetHCLKFreq() >> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos] & 0x1FU));
 8005e9c:	4b05      	ldr	r3, [pc, #20]	@ (8005eb4 <HAL_RCC_GetPCLK1Freq+0x18>)
 8005e9e:	4a06      	ldr	r2, [pc, #24]	@ (8005eb8 <HAL_RCC_GetPCLK1Freq+0x1c>)
 8005ea0:	689b      	ldr	r3, [r3, #8]
  return SystemCoreClock;
 8005ea2:	4906      	ldr	r1, [pc, #24]	@ (8005ebc <HAL_RCC_GetPCLK1Freq+0x20>)
  return (HAL_RCC_GetHCLKFreq() >> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos] & 0x1FU));
 8005ea4:	f3c3 2302 	ubfx	r3, r3, #8, #3
 8005ea8:	6808      	ldr	r0, [r1, #0]
 8005eaa:	5cd3      	ldrb	r3, [r2, r3]
 8005eac:	f003 031f 	and.w	r3, r3, #31
}
 8005eb0:	40d8      	lsrs	r0, r3
 8005eb2:	4770      	bx	lr
 8005eb4:	40021000 	.word	0x40021000
 8005eb8:	0800a5a4 	.word	0x0800a5a4
 8005ebc:	20000474 	.word	0x20000474

08005ec0 <HAL_RCC_GetPCLK2Freq>:
  return (HAL_RCC_GetHCLKFreq()>> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos] & 0x1FU));
 8005ec0:	4b05      	ldr	r3, [pc, #20]	@ (8005ed8 <HAL_RCC_GetPCLK2Freq+0x18>)
 8005ec2:	4a06      	ldr	r2, [pc, #24]	@ (8005edc <HAL_RCC_GetPCLK2Freq+0x1c>)
 8005ec4:	689b      	ldr	r3, [r3, #8]
  return SystemCoreClock;
 8005ec6:	4906      	ldr	r1, [pc, #24]	@ (8005ee0 <HAL_RCC_GetPCLK2Freq+0x20>)
  return (HAL_RCC_GetHCLKFreq()>> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos] & 0x1FU));
 8005ec8:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 8005ecc:	6808      	ldr	r0, [r1, #0]
 8005ece:	5cd3      	ldrb	r3, [r2, r3]
 8005ed0:	f003 031f 	and.w	r3, r3, #31
}
 8005ed4:	40d8      	lsrs	r0, r3
 8005ed6:	4770      	bx	lr
 8005ed8:	40021000 	.word	0x40021000
 8005edc:	0800a5a4 	.word	0x0800a5a4
 8005ee0:	20000474 	.word	0x20000474

08005ee4 <HAL_RCC_GetClockConfig>:
  RCC_ClkInitStruct->SYSCLKSource = READ_BIT(RCC->CFGR, RCC_CFGR_SW);
 8005ee4:	4b0e      	ldr	r3, [pc, #56]	@ (8005f20 <HAL_RCC_GetClockConfig+0x3c>)
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 8005ee6:	220f      	movs	r2, #15
 8005ee8:	6002      	str	r2, [r0, #0]
  RCC_ClkInitStruct->SYSCLKSource = READ_BIT(RCC->CFGR, RCC_CFGR_SW);
 8005eea:	689a      	ldr	r2, [r3, #8]
 8005eec:	f002 0203 	and.w	r2, r2, #3
 8005ef0:	6042      	str	r2, [r0, #4]
  RCC_ClkInitStruct->AHBCLKDivider = READ_BIT(RCC->CFGR, RCC_CFGR_HPRE);
 8005ef2:	689a      	ldr	r2, [r3, #8]
 8005ef4:	f002 02f0 	and.w	r2, r2, #240	@ 0xf0
 8005ef8:	6082      	str	r2, [r0, #8]
  RCC_ClkInitStruct->APB1CLKDivider = READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1);
 8005efa:	689a      	ldr	r2, [r3, #8]
 8005efc:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
 8005f00:	60c2      	str	r2, [r0, #12]
  RCC_ClkInitStruct->APB2CLKDivider = (READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> 3U);
 8005f02:	689b      	ldr	r3, [r3, #8]
 8005f04:	08db      	lsrs	r3, r3, #3
{
 8005f06:	b410      	push	{r4}
  RCC_ClkInitStruct->APB2CLKDivider = (READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> 3U);
 8005f08:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
  *pFLatency = __HAL_FLASH_GET_LATENCY();
 8005f0c:	4c05      	ldr	r4, [pc, #20]	@ (8005f24 <HAL_RCC_GetClockConfig+0x40>)
  RCC_ClkInitStruct->APB2CLKDivider = (READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> 3U);
 8005f0e:	6103      	str	r3, [r0, #16]
  *pFLatency = __HAL_FLASH_GET_LATENCY();
 8005f10:	6823      	ldr	r3, [r4, #0]
}
 8005f12:	f85d 4b04 	ldr.w	r4, [sp], #4
  *pFLatency = __HAL_FLASH_GET_LATENCY();
 8005f16:	f003 030f 	and.w	r3, r3, #15
 8005f1a:	600b      	str	r3, [r1, #0]
}
 8005f1c:	4770      	bx	lr
 8005f1e:	bf00      	nop
 8005f20:	40021000 	.word	0x40021000
 8005f24:	40022000 	.word	0x40022000

08005f28 <HAL_RCC_EnableCSS>:
  SET_BIT(RCC->CR, RCC_CR_CSSON) ;
 8005f28:	4a02      	ldr	r2, [pc, #8]	@ (8005f34 <HAL_RCC_EnableCSS+0xc>)
 8005f2a:	6813      	ldr	r3, [r2, #0]
 8005f2c:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 8005f30:	6013      	str	r3, [r2, #0]
}
 8005f32:	4770      	bx	lr
 8005f34:	40021000 	.word	0x40021000

08005f38 <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8005f38:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- RTC clock source configuration ----------------------*/
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8005f3c:	6803      	ldr	r3, [r0, #0]
{
 8005f3e:	4604      	mov	r4, r0
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8005f40:	f413 2000 	ands.w	r0, r3, #524288	@ 0x80000
{
 8005f44:	b082      	sub	sp, #8
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8005f46:	d052      	beq.n	8005fee <HAL_RCCEx_PeriphCLKConfig+0xb6>
    
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8005f48:	4ba1      	ldr	r3, [pc, #644]	@ (80061d0 <HAL_RCCEx_PeriphCLKConfig+0x298>)
 8005f4a:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 8005f4c:	00d5      	lsls	r5, r2, #3
 8005f4e:	f140 8108 	bpl.w	8006162 <HAL_RCCEx_PeriphCLKConfig+0x22a>
    FlagStatus       pwrclkchanged = RESET;
 8005f52:	2700      	movs	r7, #0
      __HAL_RCC_PWR_CLK_ENABLE();
      pwrclkchanged = SET;
    }
      
    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8005f54:	4d9f      	ldr	r5, [pc, #636]	@ (80061d4 <HAL_RCCEx_PeriphCLKConfig+0x29c>)
 8005f56:	682b      	ldr	r3, [r5, #0]
 8005f58:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8005f5c:	602b      	str	r3, [r5, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 8005f5e:	f7fe f995 	bl	800428c <HAL_GetTick>
 8005f62:	4606      	mov	r6, r0

    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 8005f64:	e005      	b.n	8005f72 <HAL_RCCEx_PeriphCLKConfig+0x3a>
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8005f66:	f7fe f991 	bl	800428c <HAL_GetTick>
 8005f6a:	1b83      	subs	r3, r0, r6
 8005f6c:	2b02      	cmp	r3, #2
 8005f6e:	f200 8103 	bhi.w	8006178 <HAL_RCCEx_PeriphCLKConfig+0x240>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 8005f72:	682b      	ldr	r3, [r5, #0]
 8005f74:	05d8      	lsls	r0, r3, #23
 8005f76:	d5f6      	bpl.n	8005f66 <HAL_RCCEx_PeriphCLKConfig+0x2e>
    }

    if(ret == HAL_OK)
    { 
      /* Reset the Backup domain only if the RTC Clock source selection is modified from default */
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 8005f78:	4d95      	ldr	r5, [pc, #596]	@ (80061d0 <HAL_RCCEx_PeriphCLKConfig+0x298>)
      
      if((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
 8005f7a:	6c22      	ldr	r2, [r4, #64]	@ 0x40
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 8005f7c:	f8d5 3090 	ldr.w	r3, [r5, #144]	@ 0x90
      if((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
 8005f80:	f413 7340 	ands.w	r3, r3, #768	@ 0x300
 8005f84:	d026      	beq.n	8005fd4 <HAL_RCCEx_PeriphCLKConfig+0x9c>
 8005f86:	4293      	cmp	r3, r2
 8005f88:	d024      	beq.n	8005fd4 <HAL_RCCEx_PeriphCLKConfig+0x9c>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8005f8a:	f8d5 1090 	ldr.w	r1, [r5, #144]	@ 0x90
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
 8005f8e:	f8d5 3090 	ldr.w	r3, [r5, #144]	@ 0x90
 8005f92:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8005f96:	f8c5 3090 	str.w	r3, [r5, #144]	@ 0x90
        __HAL_RCC_BACKUPRESET_RELEASE();
 8005f9a:	f8d5 3090 	ldr.w	r3, [r5, #144]	@ 0x90
 8005f9e:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8005fa2:	f8c5 3090 	str.w	r3, [r5, #144]	@ 0x90
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8005fa6:	f421 7340 	bic.w	r3, r1, #768	@ 0x300
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpregister;
      }

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 8005faa:	07c9      	lsls	r1, r1, #31
        RCC->BDCR = tmpregister;
 8005fac:	f8c5 3090 	str.w	r3, [r5, #144]	@ 0x90
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 8005fb0:	d510      	bpl.n	8005fd4 <HAL_RCCEx_PeriphCLKConfig+0x9c>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8005fb2:	f7fe f96b 	bl	800428c <HAL_GetTick>

        /* Wait till LSE is ready */
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
        {
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8005fb6:	f241 3888 	movw	r8, #5000	@ 0x1388
        tickstart = HAL_GetTick();
 8005fba:	4606      	mov	r6, r0
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8005fbc:	e005      	b.n	8005fca <HAL_RCCEx_PeriphCLKConfig+0x92>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8005fbe:	f7fe f965 	bl	800428c <HAL_GetTick>
 8005fc2:	1b80      	subs	r0, r0, r6
 8005fc4:	4540      	cmp	r0, r8
 8005fc6:	f200 80d7 	bhi.w	8006178 <HAL_RCCEx_PeriphCLKConfig+0x240>
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8005fca:	f8d5 3090 	ldr.w	r3, [r5, #144]	@ 0x90
 8005fce:	079b      	lsls	r3, r3, #30
 8005fd0:	d5f5      	bpl.n	8005fbe <HAL_RCCEx_PeriphCLKConfig+0x86>
      }
      
      if(ret == HAL_OK)
      {
        /* Apply new RTC clock source selection */
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8005fd2:	6c22      	ldr	r2, [r4, #64]	@ 0x40
 8005fd4:	497e      	ldr	r1, [pc, #504]	@ (80061d0 <HAL_RCCEx_PeriphCLKConfig+0x298>)
 8005fd6:	f8d1 3090 	ldr.w	r3, [r1, #144]	@ 0x90
 8005fda:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8005fde:	4313      	orrs	r3, r2
 8005fe0:	f8c1 3090 	str.w	r3, [r1, #144]	@ 0x90
      __HAL_RCC_PWR_CLK_DISABLE();
    }
  }

  /*-------------------------- USART1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8005fe4:	6823      	ldr	r3, [r4, #0]
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
 8005fe6:	2000      	movs	r0, #0
    if(pwrclkchanged == SET)
 8005fe8:	2f00      	cmp	r7, #0
 8005fea:	f040 80ca 	bne.w	8006182 <HAL_RCCEx_PeriphCLKConfig+0x24a>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8005fee:	07de      	lsls	r6, r3, #31
 8005ff0:	d508      	bpl.n	8006004 <HAL_RCCEx_PeriphCLKConfig+0xcc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8005ff2:	4977      	ldr	r1, [pc, #476]	@ (80061d0 <HAL_RCCEx_PeriphCLKConfig+0x298>)
 8005ff4:	6865      	ldr	r5, [r4, #4]
 8005ff6:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8005ffa:	f022 0203 	bic.w	r2, r2, #3
 8005ffe:	432a      	orrs	r2, r5
 8006000:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
  }

  /*-------------------------- USART2 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8006004:	079d      	lsls	r5, r3, #30
 8006006:	d508      	bpl.n	800601a <HAL_RCCEx_PeriphCLKConfig+0xe2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8006008:	4971      	ldr	r1, [pc, #452]	@ (80061d0 <HAL_RCCEx_PeriphCLKConfig+0x298>)
 800600a:	68a5      	ldr	r5, [r4, #8]
 800600c:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8006010:	f022 020c 	bic.w	r2, r2, #12
 8006014:	432a      	orrs	r2, r5
 8006016:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
  }

#if defined(USART3)

  /*-------------------------- USART3 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 800601a:	0759      	lsls	r1, r3, #29
 800601c:	d508      	bpl.n	8006030 <HAL_RCCEx_PeriphCLKConfig+0xf8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 800601e:	496c      	ldr	r1, [pc, #432]	@ (80061d0 <HAL_RCCEx_PeriphCLKConfig+0x298>)
 8006020:	68e5      	ldr	r5, [r4, #12]
 8006022:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8006026:	f022 0230 	bic.w	r2, r2, #48	@ 0x30
 800602a:	432a      	orrs	r2, r5
 800602c:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88

#endif /* USART3 */

#if defined(UART4)
  /*-------------------------- UART4 clock source configuration --------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 8006030:	071a      	lsls	r2, r3, #28
 8006032:	d508      	bpl.n	8006046 <HAL_RCCEx_PeriphCLKConfig+0x10e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 8006034:	4966      	ldr	r1, [pc, #408]	@ (80061d0 <HAL_RCCEx_PeriphCLKConfig+0x298>)
 8006036:	6925      	ldr	r5, [r4, #16]
 8006038:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 800603c:	f022 02c0 	bic.w	r2, r2, #192	@ 0xc0
 8006040:	432a      	orrs	r2, r5
 8006042:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
  }

#endif /* UART5 */

  /*-------------------------- LPUART1 clock source configuration ------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8006046:	069f      	lsls	r7, r3, #26
 8006048:	d508      	bpl.n	800605c <HAL_RCCEx_PeriphCLKConfig+0x124>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 800604a:	4961      	ldr	r1, [pc, #388]	@ (80061d0 <HAL_RCCEx_PeriphCLKConfig+0x298>)
 800604c:	6965      	ldr	r5, [r4, #20]
 800604e:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8006052:	f422 6240 	bic.w	r2, r2, #3072	@ 0xc00
 8006056:	432a      	orrs	r2, r5
 8006058:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
  }

  /*-------------------------- I2C1 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 800605c:	065e      	lsls	r6, r3, #25
 800605e:	d508      	bpl.n	8006072 <HAL_RCCEx_PeriphCLKConfig+0x13a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8006060:	495b      	ldr	r1, [pc, #364]	@ (80061d0 <HAL_RCCEx_PeriphCLKConfig+0x298>)
 8006062:	69a5      	ldr	r5, [r4, #24]
 8006064:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8006068:	f422 5240 	bic.w	r2, r2, #12288	@ 0x3000
 800606c:	432a      	orrs	r2, r5
 800606e:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
  }

  /*-------------------------- I2C2 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8006072:	061d      	lsls	r5, r3, #24
 8006074:	d508      	bpl.n	8006088 <HAL_RCCEx_PeriphCLKConfig+0x150>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 8006076:	4956      	ldr	r1, [pc, #344]	@ (80061d0 <HAL_RCCEx_PeriphCLKConfig+0x298>)
 8006078:	69e5      	ldr	r5, [r4, #28]
 800607a:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 800607e:	f422 4240 	bic.w	r2, r2, #49152	@ 0xc000
 8006082:	432a      	orrs	r2, r5
 8006084:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
  }
#if defined(I2C3)

  /*-------------------------- I2C3 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8006088:	05d9      	lsls	r1, r3, #23
 800608a:	d508      	bpl.n	800609e <HAL_RCCEx_PeriphCLKConfig+0x166>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 800608c:	4950      	ldr	r1, [pc, #320]	@ (80061d0 <HAL_RCCEx_PeriphCLKConfig+0x298>)
 800608e:	6a25      	ldr	r5, [r4, #32]
 8006090:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8006094:	f422 3240 	bic.w	r2, r2, #196608	@ 0x30000
 8006098:	432a      	orrs	r2, r5
 800609a:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
  }

#endif /* I2C4 */

  /*-------------------------- LPTIM1 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 800609e:	059a      	lsls	r2, r3, #22
 80060a0:	d508      	bpl.n	80060b4 <HAL_RCCEx_PeriphCLKConfig+0x17c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LPTIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 80060a2:	494b      	ldr	r1, [pc, #300]	@ (80061d0 <HAL_RCCEx_PeriphCLKConfig+0x298>)
 80060a4:	6a65      	ldr	r5, [r4, #36]	@ 0x24
 80060a6:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 80060aa:	f422 2240 	bic.w	r2, r2, #786432	@ 0xc0000
 80060ae:	432a      	orrs	r2, r5
 80060b0:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
  }

#if defined(SAI1) 
  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
 80060b4:	055f      	lsls	r7, r3, #21
 80060b6:	d50b      	bpl.n	80060d0 <HAL_RCCEx_PeriphCLKConfig+0x198>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    /* Configure the SAI1 interface clock source */
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 80060b8:	4945      	ldr	r1, [pc, #276]	@ (80061d0 <HAL_RCCEx_PeriphCLKConfig+0x298>)
 80060ba:	6aa5      	ldr	r5, [r4, #40]	@ 0x28
 80060bc:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 80060c0:	f422 1240 	bic.w	r2, r2, #3145728	@ 0x300000
 80060c4:	432a      	orrs	r2, r5
    
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLL)
 80060c6:	f5b5 1f80 	cmp.w	r5, #1048576	@ 0x100000
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 80060ca:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLL)
 80060ce:	d05e      	beq.n	800618e <HAL_RCCEx_PeriphCLKConfig+0x256>

#endif /* SAI1 */

#if defined(SPI_I2S_SUPPORT)
  /*-------------------------- I2S clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S)
 80060d0:	051e      	lsls	r6, r3, #20
 80060d2:	d50b      	bpl.n	80060ec <HAL_RCCEx_PeriphCLKConfig+0x1b4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));

    /* Configure the I2S interface clock source */
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 80060d4:	493e      	ldr	r1, [pc, #248]	@ (80061d0 <HAL_RCCEx_PeriphCLKConfig+0x298>)
 80060d6:	6ae5      	ldr	r5, [r4, #44]	@ 0x2c
 80060d8:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 80060dc:	f422 0240 	bic.w	r2, r2, #12582912	@ 0xc00000
 80060e0:	432a      	orrs	r2, r5
    
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLL)
 80060e2:	f5b5 0f80 	cmp.w	r5, #4194304	@ 0x400000
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 80060e6:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLL)
 80060ea:	d055      	beq.n	8006198 <HAL_RCCEx_PeriphCLKConfig+0x260>

#endif /* SPI_I2S_SUPPORT */

#if defined(FDCAN1)
  /*-------------------------- FDCAN clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
 80060ec:	04dd      	lsls	r5, r3, #19
 80060ee:	d50b      	bpl.n	8006108 <HAL_RCCEx_PeriphCLKConfig+0x1d0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FDCANCLKSOURCE(PeriphClkInit->FdcanClockSelection));

    /* Configure the FDCAN interface clock source */
    __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
 80060f0:	4937      	ldr	r1, [pc, #220]	@ (80061d0 <HAL_RCCEx_PeriphCLKConfig+0x298>)
 80060f2:	6b25      	ldr	r5, [r4, #48]	@ 0x30
 80060f4:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 80060f8:	f022 7240 	bic.w	r2, r2, #50331648	@ 0x3000000
 80060fc:	432a      	orrs	r2, r5
    
    if(PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_PLL)
 80060fe:	f1b5 7f80 	cmp.w	r5, #16777216	@ 0x1000000
    __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
 8006102:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
    if(PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_PLL)
 8006106:	d04c      	beq.n	80061a2 <HAL_RCCEx_PeriphCLKConfig+0x26a>
#endif /* FDCAN1 */

#if defined(USB)

  /*-------------------------- USB clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 8006108:	0499      	lsls	r1, r3, #18
 800610a:	d50b      	bpl.n	8006124 <HAL_RCCEx_PeriphCLKConfig+0x1ec>
  {
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 800610c:	4930      	ldr	r1, [pc, #192]	@ (80061d0 <HAL_RCCEx_PeriphCLKConfig+0x298>)
 800610e:	6b65      	ldr	r5, [r4, #52]	@ 0x34
 8006110:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8006114:	f022 6240 	bic.w	r2, r2, #201326592	@ 0xc000000
 8006118:	432a      	orrs	r2, r5

    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 800611a:	f1b5 6f00 	cmp.w	r5, #134217728	@ 0x8000000
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 800611e:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 8006122:	d043      	beq.n	80061ac <HAL_RCCEx_PeriphCLKConfig+0x274>
  }

#endif /* USB */

  /*-------------------------- RNG clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 8006124:	045a      	lsls	r2, r3, #17
 8006126:	d50b      	bpl.n	8006140 <HAL_RCCEx_PeriphCLKConfig+0x208>
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8006128:	4929      	ldr	r1, [pc, #164]	@ (80061d0 <HAL_RCCEx_PeriphCLKConfig+0x298>)
 800612a:	6ba5      	ldr	r5, [r4, #56]	@ 0x38
 800612c:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8006130:	f022 6240 	bic.w	r2, r2, #201326592	@ 0xc000000
 8006134:	432a      	orrs	r2, r5

    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 8006136:	f1b5 6f00 	cmp.w	r5, #134217728	@ 0x8000000
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 800613a:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 800613e:	d03a      	beq.n	80061b6 <HAL_RCCEx_PeriphCLKConfig+0x27e>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
    }
  }

  /*-------------------------- ADC12 clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC12) == RCC_PERIPHCLK_ADC12)
 8006140:	041b      	lsls	r3, r3, #16
 8006142:	d50b      	bpl.n	800615c <HAL_RCCEx_PeriphCLKConfig+0x224>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADC12CLKSOURCE(PeriphClkInit->Adc12ClockSelection));

    /* Configure the ADC12 interface clock source */
    __HAL_RCC_ADC12_CONFIG(PeriphClkInit->Adc12ClockSelection);
 8006144:	4a22      	ldr	r2, [pc, #136]	@ (80061d0 <HAL_RCCEx_PeriphCLKConfig+0x298>)
 8006146:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
 8006148:	f8d2 3088 	ldr.w	r3, [r2, #136]	@ 0x88
 800614c:	f023 5340 	bic.w	r3, r3, #805306368	@ 0x30000000
 8006150:	430b      	orrs	r3, r1
    
    if(PeriphClkInit->Adc12ClockSelection == RCC_ADC12CLKSOURCE_PLL)
 8006152:	f1b1 5f80 	cmp.w	r1, #268435456	@ 0x10000000
    __HAL_RCC_ADC12_CONFIG(PeriphClkInit->Adc12ClockSelection);
 8006156:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
    if(PeriphClkInit->Adc12ClockSelection == RCC_ADC12CLKSOURCE_PLL)
 800615a:	d031      	beq.n	80061c0 <HAL_RCCEx_PeriphCLKConfig+0x288>
  }

#endif /* QUADSPI */

  return status;
}
 800615c:	b002      	add	sp, #8
 800615e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_PWR_CLK_ENABLE();
 8006162:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 8006164:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
 8006168:	659a      	str	r2, [r3, #88]	@ 0x58
 800616a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800616c:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8006170:	9301      	str	r3, [sp, #4]
 8006172:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8006174:	2701      	movs	r7, #1
 8006176:	e6ed      	b.n	8005f54 <HAL_RCCEx_PeriphCLKConfig+0x1c>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8006178:	6823      	ldr	r3, [r4, #0]
        status = ret;
 800617a:	2003      	movs	r0, #3
    if(pwrclkchanged == SET)
 800617c:	2f00      	cmp	r7, #0
 800617e:	f43f af36 	beq.w	8005fee <HAL_RCCEx_PeriphCLKConfig+0xb6>
      __HAL_RCC_PWR_CLK_DISABLE();
 8006182:	4913      	ldr	r1, [pc, #76]	@ (80061d0 <HAL_RCCEx_PeriphCLKConfig+0x298>)
 8006184:	6d8a      	ldr	r2, [r1, #88]	@ 0x58
 8006186:	f022 5280 	bic.w	r2, r2, #268435456	@ 0x10000000
 800618a:	658a      	str	r2, [r1, #88]	@ 0x58
 800618c:	e72f      	b.n	8005fee <HAL_RCCEx_PeriphCLKConfig+0xb6>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 800618e:	68ca      	ldr	r2, [r1, #12]
 8006190:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
 8006194:	60ca      	str	r2, [r1, #12]
 8006196:	e79b      	b.n	80060d0 <HAL_RCCEx_PeriphCLKConfig+0x198>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8006198:	68ca      	ldr	r2, [r1, #12]
 800619a:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
 800619e:	60ca      	str	r2, [r1, #12]
 80061a0:	e7a4      	b.n	80060ec <HAL_RCCEx_PeriphCLKConfig+0x1b4>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 80061a2:	68ca      	ldr	r2, [r1, #12]
 80061a4:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
 80061a8:	60ca      	str	r2, [r1, #12]
 80061aa:	e7ad      	b.n	8006108 <HAL_RCCEx_PeriphCLKConfig+0x1d0>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 80061ac:	68ca      	ldr	r2, [r1, #12]
 80061ae:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
 80061b2:	60ca      	str	r2, [r1, #12]
 80061b4:	e7b6      	b.n	8006124 <HAL_RCCEx_PeriphCLKConfig+0x1ec>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 80061b6:	68ca      	ldr	r2, [r1, #12]
 80061b8:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
 80061bc:	60ca      	str	r2, [r1, #12]
 80061be:	e7bf      	b.n	8006140 <HAL_RCCEx_PeriphCLKConfig+0x208>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
 80061c0:	68d3      	ldr	r3, [r2, #12]
 80061c2:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 80061c6:	60d3      	str	r3, [r2, #12]
}
 80061c8:	b002      	add	sp, #8
 80061ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80061ce:	bf00      	nop
 80061d0:	40021000 	.word	0x40021000
 80061d4:	40007000 	.word	0x40007000

080061d8 <TIM_OC1_SetConfig>:
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80061d8:	6a03      	ldr	r3, [r0, #32]

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 80061da:	6a02      	ldr	r2, [r0, #32]
 80061dc:	f022 0201 	bic.w	r2, r2, #1
 80061e0:	6202      	str	r2, [r0, #32]
{
 80061e2:	b470      	push	{r4, r5, r6}

  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80061e4:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 80061e6:	6982      	ldr	r2, [r0, #24]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 80061e8:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 80061ea:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 80061ee:	f022 0273 	bic.w	r2, r2, #115	@ 0x73
  tmpccmrx |= OC_Config->OCMode;
 80061f2:	432a      	orrs	r2, r5

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 80061f4:	688d      	ldr	r5, [r1, #8]
  tmpccer &= ~TIM_CCER_CC1P;
 80061f6:	f023 0302 	bic.w	r3, r3, #2
  tmpccer |= OC_Config->OCPolarity;
 80061fa:	432b      	orrs	r3, r5

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 80061fc:	4d13      	ldr	r5, [pc, #76]	@ (800624c <TIM_OC1_SetConfig+0x74>)
 80061fe:	42a8      	cmp	r0, r5
 8006200:	d00f      	beq.n	8006222 <TIM_OC1_SetConfig+0x4a>
 8006202:	f505 6500 	add.w	r5, r5, #2048	@ 0x800
 8006206:	42a8      	cmp	r0, r5
 8006208:	d00b      	beq.n	8006222 <TIM_OC1_SetConfig+0x4a>
 800620a:	f505 6540 	add.w	r5, r5, #3072	@ 0xc00
 800620e:	42a8      	cmp	r0, r5
 8006210:	d007      	beq.n	8006222 <TIM_OC1_SetConfig+0x4a>
 8006212:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 8006216:	42a8      	cmp	r0, r5
 8006218:	d003      	beq.n	8006222 <TIM_OC1_SetConfig+0x4a>
 800621a:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 800621e:	42a8      	cmp	r0, r5
 8006220:	d10d      	bne.n	800623e <TIM_OC1_SetConfig+0x66>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 8006222:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC1NP;
 8006224:	f023 0308 	bic.w	r3, r3, #8
    tmpccer |= OC_Config->OCNPolarity;
 8006228:	432b      	orrs	r3, r5
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 800622a:	e9d1 6505 	ldrd	r6, r5, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS1N;
 800622e:	f424 7440 	bic.w	r4, r4, #768	@ 0x300
    tmpcr2 |= OC_Config->OCNIdleState;
 8006232:	ea46 0c05 	orr.w	ip, r6, r5
    tmpccer &= ~TIM_CCER_CC1NE;
 8006236:	f023 0304 	bic.w	r3, r3, #4
    tmpcr2 |= OC_Config->OCNIdleState;
 800623a:	ea4c 0404 	orr.w	r4, ip, r4

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 800623e:	6849      	ldr	r1, [r1, #4]
  TIMx->CR2 = tmpcr2;
 8006240:	6044      	str	r4, [r0, #4]
  TIMx->CCMR1 = tmpccmrx;
 8006242:	6182      	str	r2, [r0, #24]

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
}
 8006244:	bc70      	pop	{r4, r5, r6}
  TIMx->CCR1 = OC_Config->Pulse;
 8006246:	6341      	str	r1, [r0, #52]	@ 0x34
  TIMx->CCER = tmpccer;
 8006248:	6203      	str	r3, [r0, #32]
}
 800624a:	4770      	bx	lr
 800624c:	40012c00 	.word	0x40012c00

08006250 <TIM_OC3_SetConfig>:
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8006250:	6a03      	ldr	r3, [r0, #32]

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8006252:	6a02      	ldr	r2, [r0, #32]
 8006254:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
 8006258:	6202      	str	r2, [r0, #32]
{
 800625a:	b470      	push	{r4, r5, r6}

  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800625c:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 800625e:	69c2      	ldr	r2, [r0, #28]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
  tmpccmrx &= ~TIM_CCMR2_CC3S;
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8006260:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8006262:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 8006266:	f022 0273 	bic.w	r2, r2, #115	@ 0x73
  tmpccmrx |= OC_Config->OCMode;
 800626a:	432a      	orrs	r2, r5

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
 800626c:	688d      	ldr	r5, [r1, #8]
  tmpccer &= ~TIM_CCER_CC3P;
 800626e:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
  tmpccer |= (OC_Config->OCPolarity << 8U);
 8006272:	ea43 2305 	orr.w	r3, r3, r5, lsl #8

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 8006276:	4d14      	ldr	r5, [pc, #80]	@ (80062c8 <TIM_OC3_SetConfig+0x78>)
 8006278:	42a8      	cmp	r0, r5
 800627a:	d00f      	beq.n	800629c <TIM_OC3_SetConfig+0x4c>
 800627c:	f505 6500 	add.w	r5, r5, #2048	@ 0x800
 8006280:	42a8      	cmp	r0, r5
 8006282:	d00b      	beq.n	800629c <TIM_OC3_SetConfig+0x4c>
    tmpccer |= (OC_Config->OCNPolarity << 8U);
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8006284:	4d11      	ldr	r5, [pc, #68]	@ (80062cc <TIM_OC3_SetConfig+0x7c>)
 8006286:	42a8      	cmp	r0, r5
 8006288:	d00f      	beq.n	80062aa <TIM_OC3_SetConfig+0x5a>
 800628a:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 800628e:	42a8      	cmp	r0, r5
 8006290:	d00b      	beq.n	80062aa <TIM_OC3_SetConfig+0x5a>
 8006292:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 8006296:	42a8      	cmp	r0, r5
 8006298:	d10f      	bne.n	80062ba <TIM_OC3_SetConfig+0x6a>
 800629a:	e006      	b.n	80062aa <TIM_OC3_SetConfig+0x5a>
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 800629c:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC3NP;
 800629e:	f423 6300 	bic.w	r3, r3, #2048	@ 0x800
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 80062a2:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    tmpccer &= ~TIM_CCER_CC3NE;
 80062a6:	f423 6380 	bic.w	r3, r3, #1024	@ 0x400
    tmpcr2 &= ~TIM_CR2_OIS3;
    tmpcr2 &= ~TIM_CR2_OIS3N;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 80062aa:	e9d1 6505 	ldrd	r6, r5, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS3N;
 80062ae:	f424 5440 	bic.w	r4, r4, #12288	@ 0x3000
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 80062b2:	ea46 0c05 	orr.w	ip, r6, r5
 80062b6:	ea44 140c 	orr.w	r4, r4, ip, lsl #4

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 80062ba:	6849      	ldr	r1, [r1, #4]
  TIMx->CR2 = tmpcr2;
 80062bc:	6044      	str	r4, [r0, #4]
  TIMx->CCMR2 = tmpccmrx;
 80062be:	61c2      	str	r2, [r0, #28]

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
}
 80062c0:	bc70      	pop	{r4, r5, r6}
  TIMx->CCR3 = OC_Config->Pulse;
 80062c2:	63c1      	str	r1, [r0, #60]	@ 0x3c
  TIMx->CCER = tmpccer;
 80062c4:	6203      	str	r3, [r0, #32]
}
 80062c6:	4770      	bx	lr
 80062c8:	40012c00 	.word	0x40012c00
 80062cc:	40014000 	.word	0x40014000

080062d0 <TIM_OC4_SetConfig>:
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80062d0:	6a03      	ldr	r3, [r0, #32]

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 80062d2:	6a02      	ldr	r2, [r0, #32]
 80062d4:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
 80062d8:	6202      	str	r2, [r0, #32]
{
 80062da:	b470      	push	{r4, r5, r6}

  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80062dc:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 80062de:	69c2      	ldr	r2, [r0, #28]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
  tmpccmrx &= ~TIM_CCMR2_CC4S;

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80062e0:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 80062e2:	f022 7280 	bic.w	r2, r2, #16777216	@ 0x1000000
 80062e6:	f422 42e6 	bic.w	r2, r2, #29440	@ 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80062ea:	ea42 2205 	orr.w	r2, r2, r5, lsl #8

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 80062ee:	688d      	ldr	r5, [r1, #8]
  tmpccer &= ~TIM_CCER_CC4P;
 80062f0:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
  tmpccer |= (OC_Config->OCPolarity << 12U);
 80062f4:	ea43 3305 	orr.w	r3, r3, r5, lsl #12

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_4))
 80062f8:	4d14      	ldr	r5, [pc, #80]	@ (800634c <TIM_OC4_SetConfig+0x7c>)
 80062fa:	42a8      	cmp	r0, r5
 80062fc:	d00f      	beq.n	800631e <TIM_OC4_SetConfig+0x4e>
 80062fe:	f505 6500 	add.w	r5, r5, #2048	@ 0x800
 8006302:	42a8      	cmp	r0, r5
 8006304:	d00b      	beq.n	800631e <TIM_OC4_SetConfig+0x4e>
    tmpccer |= (OC_Config->OCNPolarity << 12U);
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC4NE;
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8006306:	4d12      	ldr	r5, [pc, #72]	@ (8006350 <TIM_OC4_SetConfig+0x80>)
 8006308:	42a8      	cmp	r0, r5
 800630a:	d00f      	beq.n	800632c <TIM_OC4_SetConfig+0x5c>
 800630c:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 8006310:	42a8      	cmp	r0, r5
 8006312:	d00b      	beq.n	800632c <TIM_OC4_SetConfig+0x5c>
 8006314:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 8006318:	42a8      	cmp	r0, r5
 800631a:	d10f      	bne.n	800633c <TIM_OC4_SetConfig+0x6c>
 800631c:	e006      	b.n	800632c <TIM_OC4_SetConfig+0x5c>
    tmpccer |= (OC_Config->OCNPolarity << 12U);
 800631e:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC4NP;
 8006320:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
    tmpccer |= (OC_Config->OCNPolarity << 12U);
 8006324:	ea43 3305 	orr.w	r3, r3, r5, lsl #12
    tmpccer &= ~TIM_CCER_CC4NE;
 8006328:	f423 4380 	bic.w	r3, r3, #16384	@ 0x4000
    tmpcr2 &= ~TIM_CR2_OIS4N;

    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 6U);
 800632c:	e9d1 6505 	ldrd	r6, r5, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS4N;
 8006330:	f424 4440 	bic.w	r4, r4, #49152	@ 0xc000
    tmpcr2 |= (OC_Config->OCNIdleState << 6U);
 8006334:	ea46 0c05 	orr.w	ip, r6, r5
 8006338:	ea44 148c 	orr.w	r4, r4, ip, lsl #6

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 800633c:	6849      	ldr	r1, [r1, #4]
  TIMx->CR2 = tmpcr2;
 800633e:	6044      	str	r4, [r0, #4]
  TIMx->CCMR2 = tmpccmrx;
 8006340:	61c2      	str	r2, [r0, #28]

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
}
 8006342:	bc70      	pop	{r4, r5, r6}
  TIMx->CCR4 = OC_Config->Pulse;
 8006344:	6401      	str	r1, [r0, #64]	@ 0x40
  TIMx->CCER = tmpccer;
 8006346:	6203      	str	r3, [r0, #32]
}
 8006348:	4770      	bx	lr
 800634a:	bf00      	nop
 800634c:	40012c00 	.word	0x40012c00
 8006350:	40014000 	.word	0x40014000

08006354 <HAL_TIM_Base_MspInit>:
}
 8006354:	4770      	bx	lr
 8006356:	bf00      	nop

08006358 <HAL_TIM_Base_Init>:
  if (htim == NULL)
 8006358:	2800      	cmp	r0, #0
 800635a:	d075      	beq.n	8006448 <HAL_TIM_Base_Init+0xf0>
{
 800635c:	b570      	push	{r4, r5, r6, lr}
  if (htim->State == HAL_TIM_STATE_RESET)
 800635e:	f890 303d 	ldrb.w	r3, [r0, #61]	@ 0x3d
 8006362:	4604      	mov	r4, r0
 8006364:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 8006368:	2b00      	cmp	r3, #0
 800636a:	d068      	beq.n	800643e <HAL_TIM_Base_Init+0xe6>
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 800636c:	6823      	ldr	r3, [r4, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800636e:	4e37      	ldr	r6, [pc, #220]	@ (800644c <HAL_TIM_Base_Init+0xf4>)
  TIMx->PSC = Structure->Prescaler;
 8006370:	6861      	ldr	r1, [r4, #4]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8006372:	68e0      	ldr	r0, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8006374:	69a5      	ldr	r5, [r4, #24]
  htim->State = HAL_TIM_STATE_BUSY;
 8006376:	2202      	movs	r2, #2
 8006378:	f884 203d 	strb.w	r2, [r4, #61]	@ 0x3d
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800637c:	42b3      	cmp	r3, r6
  tmpcr1 = TIMx->CR1;
 800637e:	681a      	ldr	r2, [r3, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8006380:	d04c      	beq.n	800641c <HAL_TIM_Base_Init+0xc4>
 8006382:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8006386:	d017      	beq.n	80063b8 <HAL_TIM_Base_Init+0x60>
 8006388:	f5a6 3694 	sub.w	r6, r6, #75776	@ 0x12800
 800638c:	42b3      	cmp	r3, r6
 800638e:	d013      	beq.n	80063b8 <HAL_TIM_Base_Init+0x60>
 8006390:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
 8006394:	42b3      	cmp	r3, r6
 8006396:	d00f      	beq.n	80063b8 <HAL_TIM_Base_Init+0x60>
 8006398:	f506 3696 	add.w	r6, r6, #76800	@ 0x12c00
 800639c:	42b3      	cmp	r3, r6
 800639e:	d03d      	beq.n	800641c <HAL_TIM_Base_Init+0xc4>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 80063a0:	4e2b      	ldr	r6, [pc, #172]	@ (8006450 <HAL_TIM_Base_Init+0xf8>)
 80063a2:	42b3      	cmp	r3, r6
 80063a4:	d03e      	beq.n	8006424 <HAL_TIM_Base_Init+0xcc>
 80063a6:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
 80063aa:	42b3      	cmp	r3, r6
 80063ac:	d03a      	beq.n	8006424 <HAL_TIM_Base_Init+0xcc>
 80063ae:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
 80063b2:	42b3      	cmp	r3, r6
 80063b4:	d108      	bne.n	80063c8 <HAL_TIM_Base_Init+0x70>
 80063b6:	e035      	b.n	8006424 <HAL_TIM_Base_Init+0xcc>
    tmpcr1 |= Structure->CounterMode;
 80063b8:	68a6      	ldr	r6, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80063ba:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
    tmpcr1 |= Structure->CounterMode;
 80063be:	4332      	orrs	r2, r6
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80063c0:	6926      	ldr	r6, [r4, #16]
    tmpcr1 &= ~TIM_CR1_CKD;
 80063c2:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80063c6:	4332      	orrs	r2, r6
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80063c8:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 80063cc:	432a      	orrs	r2, r5
  TIMx->CR1 = tmpcr1;
 80063ce:	601a      	str	r2, [r3, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 80063d0:	62d8      	str	r0, [r3, #44]	@ 0x2c
  TIMx->PSC = Structure->Prescaler;
 80063d2:	6299      	str	r1, [r3, #40]	@ 0x28
  TIMx->EGR = TIM_EGR_UG;
 80063d4:	2201      	movs	r2, #1
 80063d6:	615a      	str	r2, [r3, #20]
  if (HAL_IS_BIT_SET(TIMx->SR, TIM_FLAG_UPDATE))
 80063d8:	691a      	ldr	r2, [r3, #16]
 80063da:	07d2      	lsls	r2, r2, #31
 80063dc:	d503      	bpl.n	80063e6 <HAL_TIM_Base_Init+0x8e>
    CLEAR_BIT(TIMx->SR, TIM_FLAG_UPDATE);
 80063de:	691a      	ldr	r2, [r3, #16]
 80063e0:	f022 0201 	bic.w	r2, r2, #1
 80063e4:	611a      	str	r2, [r3, #16]
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 80063e6:	2301      	movs	r3, #1
 80063e8:	f884 3048 	strb.w	r3, [r4, #72]	@ 0x48
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 80063ec:	f884 303e 	strb.w	r3, [r4, #62]	@ 0x3e
 80063f0:	f884 303f 	strb.w	r3, [r4, #63]	@ 0x3f
 80063f4:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
 80063f8:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
 80063fc:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 8006400:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8006404:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
 8006408:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
 800640c:	f884 3046 	strb.w	r3, [r4, #70]	@ 0x46
 8006410:	f884 3047 	strb.w	r3, [r4, #71]	@ 0x47
  htim->State = HAL_TIM_STATE_READY;
 8006414:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  return HAL_OK;
 8006418:	2000      	movs	r0, #0
}
 800641a:	bd70      	pop	{r4, r5, r6, pc}
    tmpcr1 |= Structure->CounterMode;
 800641c:	68a6      	ldr	r6, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800641e:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
    tmpcr1 |= Structure->CounterMode;
 8006422:	4332      	orrs	r2, r6
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8006424:	6926      	ldr	r6, [r4, #16]
    tmpcr1 &= ~TIM_CR1_CKD;
 8006426:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800642a:	4332      	orrs	r2, r6
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800642c:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 8006430:	432a      	orrs	r2, r5
  TIMx->CR1 = tmpcr1;
 8006432:	601a      	str	r2, [r3, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8006434:	62d8      	str	r0, [r3, #44]	@ 0x2c
  TIMx->PSC = Structure->Prescaler;
 8006436:	6299      	str	r1, [r3, #40]	@ 0x28
    TIMx->RCR = Structure->RepetitionCounter;
 8006438:	6962      	ldr	r2, [r4, #20]
 800643a:	631a      	str	r2, [r3, #48]	@ 0x30
 800643c:	e7ca      	b.n	80063d4 <HAL_TIM_Base_Init+0x7c>
    htim->Lock = HAL_UNLOCKED;
 800643e:	f880 203c 	strb.w	r2, [r0, #60]	@ 0x3c
    HAL_TIM_Base_MspInit(htim);
 8006442:	f7ff ff87 	bl	8006354 <HAL_TIM_Base_MspInit>
 8006446:	e791      	b.n	800636c <HAL_TIM_Base_Init+0x14>
    return HAL_ERROR;
 8006448:	2001      	movs	r0, #1
}
 800644a:	4770      	bx	lr
 800644c:	40012c00 	.word	0x40012c00
 8006450:	40014000 	.word	0x40014000

08006454 <HAL_TIM_Base_Start_IT>:
  if (htim->State != HAL_TIM_STATE_READY)
 8006454:	f890 303d 	ldrb.w	r3, [r0, #61]	@ 0x3d
 8006458:	2b01      	cmp	r3, #1
 800645a:	d122      	bne.n	80064a2 <HAL_TIM_Base_Start_IT+0x4e>
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 800645c:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800645e:	4916      	ldr	r1, [pc, #88]	@ (80064b8 <HAL_TIM_Base_Start_IT+0x64>)
  htim->State = HAL_TIM_STATE_BUSY;
 8006460:	2202      	movs	r2, #2
 8006462:	f880 203d 	strb.w	r2, [r0, #61]	@ 0x3d
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8006466:	68da      	ldr	r2, [r3, #12]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8006468:	428b      	cmp	r3, r1
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 800646a:	f042 0201 	orr.w	r2, r2, #1
 800646e:	60da      	str	r2, [r3, #12]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8006470:	d019      	beq.n	80064a6 <HAL_TIM_Base_Start_IT+0x52>
 8006472:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8006476:	d016      	beq.n	80064a6 <HAL_TIM_Base_Start_IT+0x52>
 8006478:	4a10      	ldr	r2, [pc, #64]	@ (80064bc <HAL_TIM_Base_Start_IT+0x68>)
 800647a:	4293      	cmp	r3, r2
 800647c:	d013      	beq.n	80064a6 <HAL_TIM_Base_Start_IT+0x52>
 800647e:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8006482:	4293      	cmp	r3, r2
 8006484:	d00f      	beq.n	80064a6 <HAL_TIM_Base_Start_IT+0x52>
 8006486:	f502 3296 	add.w	r2, r2, #76800	@ 0x12c00
 800648a:	4293      	cmp	r3, r2
 800648c:	d00b      	beq.n	80064a6 <HAL_TIM_Base_Start_IT+0x52>
 800648e:	f502 6240 	add.w	r2, r2, #3072	@ 0xc00
 8006492:	4293      	cmp	r3, r2
 8006494:	d007      	beq.n	80064a6 <HAL_TIM_Base_Start_IT+0x52>
      __HAL_TIM_ENABLE(htim);
 8006496:	681a      	ldr	r2, [r3, #0]
 8006498:	f042 0201 	orr.w	r2, r2, #1
 800649c:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 800649e:	2000      	movs	r0, #0
 80064a0:	4770      	bx	lr
    return HAL_ERROR;
 80064a2:	2001      	movs	r0, #1
}
 80064a4:	4770      	bx	lr
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 80064a6:	6899      	ldr	r1, [r3, #8]
 80064a8:	4a05      	ldr	r2, [pc, #20]	@ (80064c0 <HAL_TIM_Base_Start_IT+0x6c>)
 80064aa:	400a      	ands	r2, r1
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 80064ac:	2a06      	cmp	r2, #6
 80064ae:	d0f6      	beq.n	800649e <HAL_TIM_Base_Start_IT+0x4a>
 80064b0:	f5b2 3f80 	cmp.w	r2, #65536	@ 0x10000
 80064b4:	d1ef      	bne.n	8006496 <HAL_TIM_Base_Start_IT+0x42>
 80064b6:	e7f2      	b.n	800649e <HAL_TIM_Base_Start_IT+0x4a>
 80064b8:	40012c00 	.word	0x40012c00
 80064bc:	40000400 	.word	0x40000400
 80064c0:	00010007 	.word	0x00010007

080064c4 <HAL_TIM_PWM_Init>:
  if (htim == NULL)
 80064c4:	2800      	cmp	r0, #0
 80064c6:	d075      	beq.n	80065b4 <HAL_TIM_PWM_Init+0xf0>
{
 80064c8:	b570      	push	{r4, r5, r6, lr}
  if (htim->State == HAL_TIM_STATE_RESET)
 80064ca:	f890 303d 	ldrb.w	r3, [r0, #61]	@ 0x3d
 80064ce:	4604      	mov	r4, r0
 80064d0:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 80064d4:	2b00      	cmp	r3, #0
 80064d6:	d068      	beq.n	80065aa <HAL_TIM_PWM_Init+0xe6>
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 80064d8:	6823      	ldr	r3, [r4, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80064da:	4e37      	ldr	r6, [pc, #220]	@ (80065b8 <HAL_TIM_PWM_Init+0xf4>)
  TIMx->PSC = Structure->Prescaler;
 80064dc:	6861      	ldr	r1, [r4, #4]
  TIMx->ARR = (uint32_t)Structure->Period ;
 80064de:	68e0      	ldr	r0, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80064e0:	69a5      	ldr	r5, [r4, #24]
  htim->State = HAL_TIM_STATE_BUSY;
 80064e2:	2202      	movs	r2, #2
 80064e4:	f884 203d 	strb.w	r2, [r4, #61]	@ 0x3d
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80064e8:	42b3      	cmp	r3, r6
  tmpcr1 = TIMx->CR1;
 80064ea:	681a      	ldr	r2, [r3, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80064ec:	d04c      	beq.n	8006588 <HAL_TIM_PWM_Init+0xc4>
 80064ee:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 80064f2:	d017      	beq.n	8006524 <HAL_TIM_PWM_Init+0x60>
 80064f4:	f5a6 3694 	sub.w	r6, r6, #75776	@ 0x12800
 80064f8:	42b3      	cmp	r3, r6
 80064fa:	d013      	beq.n	8006524 <HAL_TIM_PWM_Init+0x60>
 80064fc:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
 8006500:	42b3      	cmp	r3, r6
 8006502:	d00f      	beq.n	8006524 <HAL_TIM_PWM_Init+0x60>
 8006504:	f506 3696 	add.w	r6, r6, #76800	@ 0x12c00
 8006508:	42b3      	cmp	r3, r6
 800650a:	d03d      	beq.n	8006588 <HAL_TIM_PWM_Init+0xc4>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800650c:	4e2b      	ldr	r6, [pc, #172]	@ (80065bc <HAL_TIM_PWM_Init+0xf8>)
 800650e:	42b3      	cmp	r3, r6
 8006510:	d03e      	beq.n	8006590 <HAL_TIM_PWM_Init+0xcc>
 8006512:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
 8006516:	42b3      	cmp	r3, r6
 8006518:	d03a      	beq.n	8006590 <HAL_TIM_PWM_Init+0xcc>
 800651a:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
 800651e:	42b3      	cmp	r3, r6
 8006520:	d108      	bne.n	8006534 <HAL_TIM_PWM_Init+0x70>
 8006522:	e035      	b.n	8006590 <HAL_TIM_PWM_Init+0xcc>
    tmpcr1 |= Structure->CounterMode;
 8006524:	68a6      	ldr	r6, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8006526:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
    tmpcr1 |= Structure->CounterMode;
 800652a:	4332      	orrs	r2, r6
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800652c:	6926      	ldr	r6, [r4, #16]
    tmpcr1 &= ~TIM_CR1_CKD;
 800652e:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8006532:	4332      	orrs	r2, r6
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8006534:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 8006538:	432a      	orrs	r2, r5
  TIMx->CR1 = tmpcr1;
 800653a:	601a      	str	r2, [r3, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 800653c:	62d8      	str	r0, [r3, #44]	@ 0x2c
  TIMx->PSC = Structure->Prescaler;
 800653e:	6299      	str	r1, [r3, #40]	@ 0x28
  TIMx->EGR = TIM_EGR_UG;
 8006540:	2201      	movs	r2, #1
 8006542:	615a      	str	r2, [r3, #20]
  if (HAL_IS_BIT_SET(TIMx->SR, TIM_FLAG_UPDATE))
 8006544:	691a      	ldr	r2, [r3, #16]
 8006546:	07d2      	lsls	r2, r2, #31
 8006548:	d503      	bpl.n	8006552 <HAL_TIM_PWM_Init+0x8e>
    CLEAR_BIT(TIMx->SR, TIM_FLAG_UPDATE);
 800654a:	691a      	ldr	r2, [r3, #16]
 800654c:	f022 0201 	bic.w	r2, r2, #1
 8006550:	611a      	str	r2, [r3, #16]
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8006552:	2301      	movs	r3, #1
 8006554:	f884 3048 	strb.w	r3, [r4, #72]	@ 0x48
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8006558:	f884 303e 	strb.w	r3, [r4, #62]	@ 0x3e
 800655c:	f884 303f 	strb.w	r3, [r4, #63]	@ 0x3f
 8006560:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
 8006564:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
 8006568:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 800656c:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8006570:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
 8006574:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
 8006578:	f884 3046 	strb.w	r3, [r4, #70]	@ 0x46
 800657c:	f884 3047 	strb.w	r3, [r4, #71]	@ 0x47
  htim->State = HAL_TIM_STATE_READY;
 8006580:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  return HAL_OK;
 8006584:	2000      	movs	r0, #0
}
 8006586:	bd70      	pop	{r4, r5, r6, pc}
    tmpcr1 |= Structure->CounterMode;
 8006588:	68a6      	ldr	r6, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800658a:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
    tmpcr1 |= Structure->CounterMode;
 800658e:	4332      	orrs	r2, r6
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8006590:	6926      	ldr	r6, [r4, #16]
    tmpcr1 &= ~TIM_CR1_CKD;
 8006592:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8006596:	4332      	orrs	r2, r6
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8006598:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 800659c:	432a      	orrs	r2, r5
  TIMx->CR1 = tmpcr1;
 800659e:	601a      	str	r2, [r3, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 80065a0:	62d8      	str	r0, [r3, #44]	@ 0x2c
  TIMx->PSC = Structure->Prescaler;
 80065a2:	6299      	str	r1, [r3, #40]	@ 0x28
    TIMx->RCR = Structure->RepetitionCounter;
 80065a4:	6962      	ldr	r2, [r4, #20]
 80065a6:	631a      	str	r2, [r3, #48]	@ 0x30
 80065a8:	e7ca      	b.n	8006540 <HAL_TIM_PWM_Init+0x7c>
    htim->Lock = HAL_UNLOCKED;
 80065aa:	f880 203c 	strb.w	r2, [r0, #60]	@ 0x3c
    HAL_TIM_PWM_MspInit(htim);
 80065ae:	f7fd fbdf 	bl	8003d70 <HAL_TIM_PWM_MspInit>
 80065b2:	e791      	b.n	80064d8 <HAL_TIM_PWM_Init+0x14>
    return HAL_ERROR;
 80065b4:	2001      	movs	r0, #1
}
 80065b6:	4770      	bx	lr
 80065b8:	40012c00 	.word	0x40012c00
 80065bc:	40014000 	.word	0x40014000

080065c0 <HAL_TIM_Encoder_Init>:
  if (htim == NULL)
 80065c0:	2800      	cmp	r0, #0
 80065c2:	f000 8099 	beq.w	80066f8 <HAL_TIM_Encoder_Init+0x138>
{
 80065c6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (htim->State == HAL_TIM_STATE_RESET)
 80065c8:	f890 303d 	ldrb.w	r3, [r0, #61]	@ 0x3d
 80065cc:	460d      	mov	r5, r1
 80065ce:	4604      	mov	r4, r0
 80065d0:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 80065d4:	2b00      	cmp	r3, #0
 80065d6:	f000 808a 	beq.w	80066ee <HAL_TIM_Encoder_Init+0x12e>
  htim->Instance->SMCR &= ~(TIM_SMCR_SMS | TIM_SMCR_ECE);
 80065da:	6823      	ldr	r3, [r4, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80065dc:	4f47      	ldr	r7, [pc, #284]	@ (80066fc <HAL_TIM_Encoder_Init+0x13c>)
  TIMx->PSC = Structure->Prescaler;
 80065de:	6861      	ldr	r1, [r4, #4]
  TIMx->ARR = (uint32_t)Structure->Period ;
 80065e0:	68e0      	ldr	r0, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80065e2:	69a6      	ldr	r6, [r4, #24]
  htim->State = HAL_TIM_STATE_BUSY;
 80065e4:	2202      	movs	r2, #2
 80065e6:	f884 203d 	strb.w	r2, [r4, #61]	@ 0x3d
  htim->Instance->SMCR &= ~(TIM_SMCR_SMS | TIM_SMCR_ECE);
 80065ea:	689a      	ldr	r2, [r3, #8]
 80065ec:	f422 32a0 	bic.w	r2, r2, #81920	@ 0x14000
 80065f0:	f022 0207 	bic.w	r2, r2, #7
 80065f4:	609a      	str	r2, [r3, #8]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80065f6:	42bb      	cmp	r3, r7
  tmpcr1 = TIMx->CR1;
 80065f8:	681a      	ldr	r2, [r3, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80065fa:	d067      	beq.n	80066cc <HAL_TIM_Encoder_Init+0x10c>
 80065fc:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8006600:	d017      	beq.n	8006632 <HAL_TIM_Encoder_Init+0x72>
 8006602:	f5a7 3794 	sub.w	r7, r7, #75776	@ 0x12800
 8006606:	42bb      	cmp	r3, r7
 8006608:	d013      	beq.n	8006632 <HAL_TIM_Encoder_Init+0x72>
 800660a:	f507 6780 	add.w	r7, r7, #1024	@ 0x400
 800660e:	42bb      	cmp	r3, r7
 8006610:	d00f      	beq.n	8006632 <HAL_TIM_Encoder_Init+0x72>
 8006612:	f507 3796 	add.w	r7, r7, #76800	@ 0x12c00
 8006616:	42bb      	cmp	r3, r7
 8006618:	d058      	beq.n	80066cc <HAL_TIM_Encoder_Init+0x10c>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800661a:	4f39      	ldr	r7, [pc, #228]	@ (8006700 <HAL_TIM_Encoder_Init+0x140>)
 800661c:	42bb      	cmp	r3, r7
 800661e:	d059      	beq.n	80066d4 <HAL_TIM_Encoder_Init+0x114>
 8006620:	f507 6780 	add.w	r7, r7, #1024	@ 0x400
 8006624:	42bb      	cmp	r3, r7
 8006626:	d055      	beq.n	80066d4 <HAL_TIM_Encoder_Init+0x114>
 8006628:	f507 6780 	add.w	r7, r7, #1024	@ 0x400
 800662c:	42bb      	cmp	r3, r7
 800662e:	d108      	bne.n	8006642 <HAL_TIM_Encoder_Init+0x82>
 8006630:	e050      	b.n	80066d4 <HAL_TIM_Encoder_Init+0x114>
    tmpcr1 |= Structure->CounterMode;
 8006632:	68a7      	ldr	r7, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8006634:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
    tmpcr1 |= Structure->CounterMode;
 8006638:	433a      	orrs	r2, r7
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800663a:	6927      	ldr	r7, [r4, #16]
    tmpcr1 &= ~TIM_CR1_CKD;
 800663c:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8006640:	433a      	orrs	r2, r7
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8006642:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 8006646:	4332      	orrs	r2, r6
  TIMx->CR1 = tmpcr1;
 8006648:	601a      	str	r2, [r3, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 800664a:	62d8      	str	r0, [r3, #44]	@ 0x2c
  TIMx->PSC = Structure->Prescaler;
 800664c:	6299      	str	r1, [r3, #40]	@ 0x28
  TIMx->EGR = TIM_EGR_UG;
 800664e:	2201      	movs	r2, #1
 8006650:	615a      	str	r2, [r3, #20]
  if (HAL_IS_BIT_SET(TIMx->SR, TIM_FLAG_UPDATE))
 8006652:	691a      	ldr	r2, [r3, #16]
 8006654:	07d2      	lsls	r2, r2, #31
 8006656:	d503      	bpl.n	8006660 <HAL_TIM_Encoder_Init+0xa0>
    CLEAR_BIT(TIMx->SR, TIM_FLAG_UPDATE);
 8006658:	691a      	ldr	r2, [r3, #16]
 800665a:	f022 0201 	bic.w	r2, r2, #1
 800665e:	611a      	str	r2, [r3, #16]
  tmpsmcr = htim->Instance->SMCR;
 8006660:	689e      	ldr	r6, [r3, #8]
  tmpccmr1 = htim->Instance->CCMR1;
 8006662:	699a      	ldr	r2, [r3, #24]
  tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
 8006664:	69a8      	ldr	r0, [r5, #24]
 8006666:	68a9      	ldr	r1, [r5, #8]
  tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
 8006668:	6a2f      	ldr	r7, [r5, #32]
  tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
 800666a:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
 800666e:	f022 0203 	bic.w	r2, r2, #3
  tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
 8006672:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
 8006676:	4311      	orrs	r1, r2
  tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
 8006678:	692a      	ldr	r2, [r5, #16]
  tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8U);
 800667a:	69e8      	ldr	r0, [r5, #28]
  tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
 800667c:	0112      	lsls	r2, r2, #4
 800667e:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 8006682:	68e8      	ldr	r0, [r5, #12]
  tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
 8006684:	f421 417c 	bic.w	r1, r1, #64512	@ 0xfc00
  tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
 8006688:	4302      	orrs	r2, r0
  tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
 800668a:	f021 01fc 	bic.w	r1, r1, #252	@ 0xfc
  tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
 800668e:	ea42 3207 	orr.w	r2, r2, r7, lsl #12
  tmpccer = htim->Instance->CCER;
 8006692:	6a18      	ldr	r0, [r3, #32]
  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
 8006694:	696f      	ldr	r7, [r5, #20]
  tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
 8006696:	430a      	orrs	r2, r1
  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
 8006698:	6869      	ldr	r1, [r5, #4]
  tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
 800669a:	f020 00aa 	bic.w	r0, r0, #170	@ 0xaa
  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
 800669e:	ea41 1107 	orr.w	r1, r1, r7, lsl #4
 80066a2:	4308      	orrs	r0, r1
  tmpsmcr |= sConfig->EncoderMode;
 80066a4:	6829      	ldr	r1, [r5, #0]
 80066a6:	430e      	orrs	r6, r1
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 80066a8:	2101      	movs	r1, #1
  htim->Instance->SMCR = tmpsmcr;
 80066aa:	609e      	str	r6, [r3, #8]
  htim->Instance->CCMR1 = tmpccmr1;
 80066ac:	619a      	str	r2, [r3, #24]
  htim->Instance->CCER = tmpccer;
 80066ae:	6218      	str	r0, [r3, #32]
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 80066b0:	f884 1048 	strb.w	r1, [r4, #72]	@ 0x48
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 80066b4:	f884 103e 	strb.w	r1, [r4, #62]	@ 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 80066b8:	f884 103f 	strb.w	r1, [r4, #63]	@ 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 80066bc:	f884 1044 	strb.w	r1, [r4, #68]	@ 0x44
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 80066c0:	f884 1045 	strb.w	r1, [r4, #69]	@ 0x45
  htim->State = HAL_TIM_STATE_READY;
 80066c4:	f884 103d 	strb.w	r1, [r4, #61]	@ 0x3d
  return HAL_OK;
 80066c8:	2000      	movs	r0, #0
}
 80066ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    tmpcr1 |= Structure->CounterMode;
 80066cc:	68a7      	ldr	r7, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80066ce:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
    tmpcr1 |= Structure->CounterMode;
 80066d2:	433a      	orrs	r2, r7
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80066d4:	6927      	ldr	r7, [r4, #16]
    tmpcr1 &= ~TIM_CR1_CKD;
 80066d6:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80066da:	433a      	orrs	r2, r7
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80066dc:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 80066e0:	4332      	orrs	r2, r6
  TIMx->CR1 = tmpcr1;
 80066e2:	601a      	str	r2, [r3, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 80066e4:	62d8      	str	r0, [r3, #44]	@ 0x2c
  TIMx->PSC = Structure->Prescaler;
 80066e6:	6299      	str	r1, [r3, #40]	@ 0x28
    TIMx->RCR = Structure->RepetitionCounter;
 80066e8:	6962      	ldr	r2, [r4, #20]
 80066ea:	631a      	str	r2, [r3, #48]	@ 0x30
 80066ec:	e7af      	b.n	800664e <HAL_TIM_Encoder_Init+0x8e>
    htim->Lock = HAL_UNLOCKED;
 80066ee:	f880 203c 	strb.w	r2, [r0, #60]	@ 0x3c
    HAL_TIM_Encoder_MspInit(htim);
 80066f2:	f7fd fb77 	bl	8003de4 <HAL_TIM_Encoder_MspInit>
 80066f6:	e770      	b.n	80065da <HAL_TIM_Encoder_Init+0x1a>
    return HAL_ERROR;
 80066f8:	2001      	movs	r0, #1
}
 80066fa:	4770      	bx	lr
 80066fc:	40012c00 	.word	0x40012c00
 8006700:	40014000 	.word	0x40014000

08006704 <HAL_TIM_OC_DelayElapsedCallback>:
__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
 8006704:	4770      	bx	lr
 8006706:	bf00      	nop

08006708 <HAL_TIM_IC_CaptureCallback>:
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
 8006708:	4770      	bx	lr
 800670a:	bf00      	nop

0800670c <HAL_TIM_PWM_PulseFinishedCallback>:
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
 800670c:	4770      	bx	lr
 800670e:	bf00      	nop

08006710 <HAL_TIM_TriggerCallback>:
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
 8006710:	4770      	bx	lr
 8006712:	bf00      	nop

08006714 <HAL_TIM_IRQHandler>:
{
 8006714:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t itsource = htim->Instance->DIER;
 8006716:	6803      	ldr	r3, [r0, #0]
 8006718:	68de      	ldr	r6, [r3, #12]
  uint32_t itflag   = htim->Instance->SR;
 800671a:	691c      	ldr	r4, [r3, #16]
  if ((itflag & (TIM_FLAG_CC1)) == (TIM_FLAG_CC1))
 800671c:	07a1      	lsls	r1, r4, #30
{
 800671e:	4605      	mov	r5, r0
  if ((itflag & (TIM_FLAG_CC1)) == (TIM_FLAG_CC1))
 8006720:	d501      	bpl.n	8006726 <HAL_TIM_IRQHandler+0x12>
    if ((itsource & (TIM_IT_CC1)) == (TIM_IT_CC1))
 8006722:	07b2      	lsls	r2, r6, #30
 8006724:	d46e      	bmi.n	8006804 <HAL_TIM_IRQHandler+0xf0>
  if ((itflag & (TIM_FLAG_CC2)) == (TIM_FLAG_CC2))
 8006726:	0760      	lsls	r0, r4, #29
 8006728:	d501      	bpl.n	800672e <HAL_TIM_IRQHandler+0x1a>
    if ((itsource & (TIM_IT_CC2)) == (TIM_IT_CC2))
 800672a:	0771      	lsls	r1, r6, #29
 800672c:	d457      	bmi.n	80067de <HAL_TIM_IRQHandler+0xca>
  if ((itflag & (TIM_FLAG_CC3)) == (TIM_FLAG_CC3))
 800672e:	0722      	lsls	r2, r4, #28
 8006730:	d501      	bpl.n	8006736 <HAL_TIM_IRQHandler+0x22>
    if ((itsource & (TIM_IT_CC3)) == (TIM_IT_CC3))
 8006732:	0733      	lsls	r3, r6, #28
 8006734:	d440      	bmi.n	80067b8 <HAL_TIM_IRQHandler+0xa4>
  if ((itflag & (TIM_FLAG_CC4)) == (TIM_FLAG_CC4))
 8006736:	06e1      	lsls	r1, r4, #27
 8006738:	d501      	bpl.n	800673e <HAL_TIM_IRQHandler+0x2a>
    if ((itsource & (TIM_IT_CC4)) == (TIM_IT_CC4))
 800673a:	06f2      	lsls	r2, r6, #27
 800673c:	d428      	bmi.n	8006790 <HAL_TIM_IRQHandler+0x7c>
  if ((itflag & (TIM_FLAG_UPDATE)) == (TIM_FLAG_UPDATE))
 800673e:	07e3      	lsls	r3, r4, #31
 8006740:	d501      	bpl.n	8006746 <HAL_TIM_IRQHandler+0x32>
    if ((itsource & (TIM_IT_UPDATE)) == (TIM_IT_UPDATE))
 8006742:	07f7      	lsls	r7, r6, #31
 8006744:	d47c      	bmi.n	8006840 <HAL_TIM_IRQHandler+0x12c>
  if (((itflag & (TIM_FLAG_BREAK)) == (TIM_FLAG_BREAK)) || \
 8006746:	f414 5f02 	tst.w	r4, #8320	@ 0x2080
  if ((itflag & (TIM_FLAG_BREAK2)) == (TIM_FLAG_BREAK2))
 800674a:	f404 7780 	and.w	r7, r4, #256	@ 0x100
  if (((itflag & (TIM_FLAG_BREAK)) == (TIM_FLAG_BREAK)) || \
 800674e:	d069      	beq.n	8006824 <HAL_TIM_IRQHandler+0x110>
    if ((itsource & (TIM_IT_BREAK)) == (TIM_IT_BREAK))
 8006750:	0630      	lsls	r0, r6, #24
 8006752:	d47d      	bmi.n	8006850 <HAL_TIM_IRQHandler+0x13c>
  if ((itflag & (TIM_FLAG_TRIGGER)) == (TIM_FLAG_TRIGGER))
 8006754:	0662      	lsls	r2, r4, #25
 8006756:	d502      	bpl.n	800675e <HAL_TIM_IRQHandler+0x4a>
    if ((itsource & (TIM_IT_TRIGGER)) == (TIM_IT_TRIGGER))
 8006758:	0673      	lsls	r3, r6, #25
 800675a:	f100 808b 	bmi.w	8006874 <HAL_TIM_IRQHandler+0x160>
  if ((itflag & (TIM_FLAG_COM)) == (TIM_FLAG_COM))
 800675e:	06a7      	lsls	r7, r4, #26
 8006760:	d502      	bpl.n	8006768 <HAL_TIM_IRQHandler+0x54>
    if ((itsource & (TIM_IT_COM)) == (TIM_IT_COM))
 8006762:	06b0      	lsls	r0, r6, #26
 8006764:	f100 808e 	bmi.w	8006884 <HAL_TIM_IRQHandler+0x170>
  if ((itflag & (TIM_FLAG_IDX)) == (TIM_FLAG_IDX))
 8006768:	02e1      	lsls	r1, r4, #11
 800676a:	d502      	bpl.n	8006772 <HAL_TIM_IRQHandler+0x5e>
    if ((itsource & (TIM_IT_IDX)) == (TIM_IT_IDX))
 800676c:	02f2      	lsls	r2, r6, #11
 800676e:	f100 8091 	bmi.w	8006894 <HAL_TIM_IRQHandler+0x180>
  if ((itflag & (TIM_FLAG_DIR)) == (TIM_FLAG_DIR))
 8006772:	02a3      	lsls	r3, r4, #10
 8006774:	d502      	bpl.n	800677c <HAL_TIM_IRQHandler+0x68>
    if ((itsource & (TIM_IT_DIR)) == (TIM_IT_DIR))
 8006776:	02b7      	lsls	r7, r6, #10
 8006778:	f100 8094 	bmi.w	80068a4 <HAL_TIM_IRQHandler+0x190>
  if ((itflag & (TIM_FLAG_IERR)) == (TIM_FLAG_IERR))
 800677c:	0260      	lsls	r0, r4, #9
 800677e:	d502      	bpl.n	8006786 <HAL_TIM_IRQHandler+0x72>
    if ((itsource & (TIM_IT_IERR)) == (TIM_IT_IERR))
 8006780:	0271      	lsls	r1, r6, #9
 8006782:	f100 8097 	bmi.w	80068b4 <HAL_TIM_IRQHandler+0x1a0>
  if ((itflag & (TIM_FLAG_TERR)) == (TIM_FLAG_TERR))
 8006786:	0222      	lsls	r2, r4, #8
 8006788:	d501      	bpl.n	800678e <HAL_TIM_IRQHandler+0x7a>
    if ((itsource & (TIM_IT_TERR)) == (TIM_IT_TERR))
 800678a:	0233      	lsls	r3, r6, #8
 800678c:	d44f      	bmi.n	800682e <HAL_TIM_IRQHandler+0x11a>
}
 800678e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC4);
 8006790:	682b      	ldr	r3, [r5, #0]
 8006792:	f06f 0210 	mvn.w	r2, #16
 8006796:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8006798:	2208      	movs	r2, #8
 800679a:	772a      	strb	r2, [r5, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 800679c:	69db      	ldr	r3, [r3, #28]
 800679e:	f413 7f40 	tst.w	r3, #768	@ 0x300
        HAL_TIM_IC_CaptureCallback(htim);
 80067a2:	4628      	mov	r0, r5
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 80067a4:	f040 8097 	bne.w	80068d6 <HAL_TIM_IRQHandler+0x1c2>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80067a8:	f7ff ffac 	bl	8006704 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 80067ac:	4628      	mov	r0, r5
 80067ae:	f7ff ffad 	bl	800670c <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80067b2:	2300      	movs	r3, #0
 80067b4:	772b      	strb	r3, [r5, #28]
 80067b6:	e7c2      	b.n	800673e <HAL_TIM_IRQHandler+0x2a>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC3);
 80067b8:	682b      	ldr	r3, [r5, #0]
 80067ba:	f06f 0208 	mvn.w	r2, #8
 80067be:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 80067c0:	2204      	movs	r2, #4
 80067c2:	772a      	strb	r2, [r5, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 80067c4:	69db      	ldr	r3, [r3, #28]
 80067c6:	079f      	lsls	r7, r3, #30
        HAL_TIM_IC_CaptureCallback(htim);
 80067c8:	4628      	mov	r0, r5
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 80067ca:	f040 8081 	bne.w	80068d0 <HAL_TIM_IRQHandler+0x1bc>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80067ce:	f7ff ff99 	bl	8006704 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 80067d2:	4628      	mov	r0, r5
 80067d4:	f7ff ff9a 	bl	800670c <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80067d8:	2300      	movs	r3, #0
 80067da:	772b      	strb	r3, [r5, #28]
 80067dc:	e7ab      	b.n	8006736 <HAL_TIM_IRQHandler+0x22>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC2);
 80067de:	682b      	ldr	r3, [r5, #0]
 80067e0:	f06f 0204 	mvn.w	r2, #4
 80067e4:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 80067e6:	2202      	movs	r2, #2
 80067e8:	772a      	strb	r2, [r5, #28]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 80067ea:	699b      	ldr	r3, [r3, #24]
 80067ec:	f413 7f40 	tst.w	r3, #768	@ 0x300
        HAL_TIM_IC_CaptureCallback(htim);
 80067f0:	4628      	mov	r0, r5
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 80067f2:	d16a      	bne.n	80068ca <HAL_TIM_IRQHandler+0x1b6>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80067f4:	f7ff ff86 	bl	8006704 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 80067f8:	4628      	mov	r0, r5
 80067fa:	f7ff ff87 	bl	800670c <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80067fe:	2300      	movs	r3, #0
 8006800:	772b      	strb	r3, [r5, #28]
 8006802:	e794      	b.n	800672e <HAL_TIM_IRQHandler+0x1a>
        __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC1);
 8006804:	f06f 0202 	mvn.w	r2, #2
 8006808:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 800680a:	2201      	movs	r2, #1
 800680c:	7702      	strb	r2, [r0, #28]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 800680e:	699b      	ldr	r3, [r3, #24]
 8006810:	079f      	lsls	r7, r3, #30
 8006812:	d157      	bne.n	80068c4 <HAL_TIM_IRQHandler+0x1b0>
          HAL_TIM_OC_DelayElapsedCallback(htim);
 8006814:	f7ff ff76 	bl	8006704 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8006818:	4628      	mov	r0, r5
 800681a:	f7ff ff77 	bl	800670c <HAL_TIM_PWM_PulseFinishedCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800681e:	2300      	movs	r3, #0
 8006820:	772b      	strb	r3, [r5, #28]
 8006822:	e780      	b.n	8006726 <HAL_TIM_IRQHandler+0x12>
  if ((itflag & (TIM_FLAG_BREAK2)) == (TIM_FLAG_BREAK2))
 8006824:	2f00      	cmp	r7, #0
 8006826:	d095      	beq.n	8006754 <HAL_TIM_IRQHandler+0x40>
    if ((itsource & (TIM_IT_BREAK)) == (TIM_IT_BREAK))
 8006828:	0631      	lsls	r1, r6, #24
 800682a:	d41b      	bmi.n	8006864 <HAL_TIM_IRQHandler+0x150>
 800682c:	e792      	b.n	8006754 <HAL_TIM_IRQHandler+0x40>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_TERR);
 800682e:	682b      	ldr	r3, [r5, #0]
 8006830:	f46f 0200 	mvn.w	r2, #8388608	@ 0x800000
 8006834:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_TransitionErrorCallback(htim);
 8006836:	4628      	mov	r0, r5
}
 8006838:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      HAL_TIMEx_TransitionErrorCallback(htim);
 800683c:	f000 ba7a 	b.w	8006d34 <HAL_TIMEx_TransitionErrorCallback>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_UPDATE);
 8006840:	682b      	ldr	r3, [r5, #0]
 8006842:	f06f 0201 	mvn.w	r2, #1
 8006846:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 8006848:	4628      	mov	r0, r5
 800684a:	f7fa fca1 	bl	8001190 <HAL_TIM_PeriodElapsedCallback>
 800684e:	e77a      	b.n	8006746 <HAL_TIM_IRQHandler+0x32>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK | TIM_FLAG_SYSTEM_BREAK);
 8006850:	682b      	ldr	r3, [r5, #0]
 8006852:	f46f 5202 	mvn.w	r2, #8320	@ 0x2080
 8006856:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 8006858:	4628      	mov	r0, r5
 800685a:	f000 fa61 	bl	8006d20 <HAL_TIMEx_BreakCallback>
  if ((itflag & (TIM_FLAG_BREAK2)) == (TIM_FLAG_BREAK2))
 800685e:	2f00      	cmp	r7, #0
 8006860:	f43f af78 	beq.w	8006754 <HAL_TIM_IRQHandler+0x40>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 8006864:	682b      	ldr	r3, [r5, #0]
 8006866:	f46f 7280 	mvn.w	r2, #256	@ 0x100
 800686a:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_Break2Callback(htim);
 800686c:	4628      	mov	r0, r5
 800686e:	f000 fa59 	bl	8006d24 <HAL_TIMEx_Break2Callback>
 8006872:	e76f      	b.n	8006754 <HAL_TIM_IRQHandler+0x40>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_TRIGGER);
 8006874:	682b      	ldr	r3, [r5, #0]
 8006876:	f06f 0240 	mvn.w	r2, #64	@ 0x40
 800687a:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 800687c:	4628      	mov	r0, r5
 800687e:	f7ff ff47 	bl	8006710 <HAL_TIM_TriggerCallback>
 8006882:	e76c      	b.n	800675e <HAL_TIM_IRQHandler+0x4a>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_COM);
 8006884:	682b      	ldr	r3, [r5, #0]
 8006886:	f06f 0220 	mvn.w	r2, #32
 800688a:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_CommutCallback(htim);
 800688c:	4628      	mov	r0, r5
 800688e:	f000 fa45 	bl	8006d1c <HAL_TIMEx_CommutCallback>
 8006892:	e769      	b.n	8006768 <HAL_TIM_IRQHandler+0x54>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_IDX);
 8006894:	682b      	ldr	r3, [r5, #0]
 8006896:	f46f 1280 	mvn.w	r2, #1048576	@ 0x100000
 800689a:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_EncoderIndexCallback(htim);
 800689c:	4628      	mov	r0, r5
 800689e:	f000 fa43 	bl	8006d28 <HAL_TIMEx_EncoderIndexCallback>
 80068a2:	e766      	b.n	8006772 <HAL_TIM_IRQHandler+0x5e>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_DIR);
 80068a4:	682b      	ldr	r3, [r5, #0]
 80068a6:	f46f 1200 	mvn.w	r2, #2097152	@ 0x200000
 80068aa:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_DirectionChangeCallback(htim);
 80068ac:	4628      	mov	r0, r5
 80068ae:	f000 fa3d 	bl	8006d2c <HAL_TIMEx_DirectionChangeCallback>
 80068b2:	e763      	b.n	800677c <HAL_TIM_IRQHandler+0x68>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_IERR);
 80068b4:	682b      	ldr	r3, [r5, #0]
 80068b6:	f46f 0280 	mvn.w	r2, #4194304	@ 0x400000
 80068ba:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_IndexErrorCallback(htim);
 80068bc:	4628      	mov	r0, r5
 80068be:	f000 fa37 	bl	8006d30 <HAL_TIMEx_IndexErrorCallback>
 80068c2:	e760      	b.n	8006786 <HAL_TIM_IRQHandler+0x72>
          HAL_TIM_IC_CaptureCallback(htim);
 80068c4:	f7ff ff20 	bl	8006708 <HAL_TIM_IC_CaptureCallback>
 80068c8:	e7a9      	b.n	800681e <HAL_TIM_IRQHandler+0x10a>
        HAL_TIM_IC_CaptureCallback(htim);
 80068ca:	f7ff ff1d 	bl	8006708 <HAL_TIM_IC_CaptureCallback>
 80068ce:	e796      	b.n	80067fe <HAL_TIM_IRQHandler+0xea>
        HAL_TIM_IC_CaptureCallback(htim);
 80068d0:	f7ff ff1a 	bl	8006708 <HAL_TIM_IC_CaptureCallback>
 80068d4:	e780      	b.n	80067d8 <HAL_TIM_IRQHandler+0xc4>
        HAL_TIM_IC_CaptureCallback(htim);
 80068d6:	f7ff ff17 	bl	8006708 <HAL_TIM_IC_CaptureCallback>
 80068da:	e76a      	b.n	80067b2 <HAL_TIM_IRQHandler+0x9e>

080068dc <TIM_OC2_SetConfig>:
  tmpccer = TIMx->CCER;
 80068dc:	6a03      	ldr	r3, [r0, #32]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 80068de:	6a02      	ldr	r2, [r0, #32]
 80068e0:	f022 0210 	bic.w	r2, r2, #16
 80068e4:	6202      	str	r2, [r0, #32]
{
 80068e6:	b470      	push	{r4, r5, r6}
  tmpcr2 =  TIMx->CR2;
 80068e8:	6844      	ldr	r4, [r0, #4]
  tmpccmrx = TIMx->CCMR1;
 80068ea:	6982      	ldr	r2, [r0, #24]
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80068ec:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 80068ee:	f022 7280 	bic.w	r2, r2, #16777216	@ 0x1000000
 80068f2:	f422 42e6 	bic.w	r2, r2, #29440	@ 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80068f6:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
  tmpccer |= (OC_Config->OCPolarity << 4U);
 80068fa:	688d      	ldr	r5, [r1, #8]
  tmpccer &= ~TIM_CCER_CC2P;
 80068fc:	f023 0320 	bic.w	r3, r3, #32
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8006900:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 8006904:	4d14      	ldr	r5, [pc, #80]	@ (8006958 <TIM_OC2_SetConfig+0x7c>)
 8006906:	42a8      	cmp	r0, r5
 8006908:	d00f      	beq.n	800692a <TIM_OC2_SetConfig+0x4e>
 800690a:	f505 6500 	add.w	r5, r5, #2048	@ 0x800
 800690e:	42a8      	cmp	r0, r5
 8006910:	d00b      	beq.n	800692a <TIM_OC2_SetConfig+0x4e>
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8006912:	4d12      	ldr	r5, [pc, #72]	@ (800695c <TIM_OC2_SetConfig+0x80>)
 8006914:	42a8      	cmp	r0, r5
 8006916:	d00f      	beq.n	8006938 <TIM_OC2_SetConfig+0x5c>
 8006918:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 800691c:	42a8      	cmp	r0, r5
 800691e:	d00b      	beq.n	8006938 <TIM_OC2_SetConfig+0x5c>
 8006920:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 8006924:	42a8      	cmp	r0, r5
 8006926:	d10f      	bne.n	8006948 <TIM_OC2_SetConfig+0x6c>
 8006928:	e006      	b.n	8006938 <TIM_OC2_SetConfig+0x5c>
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 800692a:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC2NP;
 800692c:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8006930:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
    tmpccer &= ~TIM_CCER_CC2NE;
 8006934:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8006938:	e9d1 6505 	ldrd	r6, r5, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS2N;
 800693c:	f424 6440 	bic.w	r4, r4, #3072	@ 0xc00
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8006940:	ea46 0c05 	orr.w	ip, r6, r5
 8006944:	ea44 048c 	orr.w	r4, r4, ip, lsl #2
  TIMx->CCR2 = OC_Config->Pulse;
 8006948:	6849      	ldr	r1, [r1, #4]
  TIMx->CR2 = tmpcr2;
 800694a:	6044      	str	r4, [r0, #4]
  TIMx->CCMR1 = tmpccmrx;
 800694c:	6182      	str	r2, [r0, #24]
}
 800694e:	bc70      	pop	{r4, r5, r6}
  TIMx->CCR2 = OC_Config->Pulse;
 8006950:	6381      	str	r1, [r0, #56]	@ 0x38
  TIMx->CCER = tmpccer;
 8006952:	6203      	str	r3, [r0, #32]
}
 8006954:	4770      	bx	lr
 8006956:	bf00      	nop
 8006958:	40012c00 	.word	0x40012c00
 800695c:	40014000 	.word	0x40014000

08006960 <HAL_TIM_PWM_ConfigChannel>:
  __HAL_LOCK(htim);
 8006960:	f890 303c 	ldrb.w	r3, [r0, #60]	@ 0x3c
 8006964:	2b01      	cmp	r3, #1
 8006966:	f000 80dc 	beq.w	8006b22 <HAL_TIM_PWM_ConfigChannel+0x1c2>
 800696a:	2301      	movs	r3, #1
{
 800696c:	b570      	push	{r4, r5, r6, lr}
 800696e:	4604      	mov	r4, r0
 8006970:	460d      	mov	r5, r1
  __HAL_LOCK(htim);
 8006972:	f880 303c 	strb.w	r3, [r0, #60]	@ 0x3c
  switch (Channel)
 8006976:	2a14      	cmp	r2, #20
 8006978:	d80c      	bhi.n	8006994 <HAL_TIM_PWM_ConfigChannel+0x34>
 800697a:	e8df f002 	tbb	[pc, r2]
 800697e:	0b4f      	.short	0x0b4f
 8006980:	0b630b0b 	.word	0x0b630b0b
 8006984:	0b740b0b 	.word	0x0b740b0b
 8006988:	0b840b0b 	.word	0x0b840b0b
 800698c:	0b950b0b 	.word	0x0b950b0b
 8006990:	0b0b      	.short	0x0b0b
 8006992:	10          	.byte	0x10
 8006993:	00          	.byte	0x00
  __HAL_UNLOCK(htim);
 8006994:	2300      	movs	r3, #0
 8006996:	f884 303c 	strb.w	r3, [r4, #60]	@ 0x3c
  switch (Channel)
 800699a:	2001      	movs	r0, #1
}
 800699c:	bd70      	pop	{r4, r5, r6, pc}
      TIM_OC6_SetConfig(htim->Instance, sConfig);
 800699e:	6803      	ldr	r3, [r0, #0]
  tmpccmrx = TIMx->CCMR3;

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80069a0:	682e      	ldr	r6, [r5, #0]
  tmpccer = TIMx->CCER;
 80069a2:	6a1a      	ldr	r2, [r3, #32]
  TIMx->CCER &= ~TIM_CCER_CC6E;
 80069a4:	6a19      	ldr	r1, [r3, #32]
 80069a6:	f421 1180 	bic.w	r1, r1, #1048576	@ 0x100000
 80069aa:	6219      	str	r1, [r3, #32]
  tmpcr2 =  TIMx->CR2;
 80069ac:	6858      	ldr	r0, [r3, #4]
  tmpccmrx = TIMx->CCMR3;
 80069ae:	6d19      	ldr	r1, [r3, #80]	@ 0x50
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
 80069b0:	f021 7180 	bic.w	r1, r1, #16777216	@ 0x1000000
 80069b4:	f421 41e0 	bic.w	r1, r1, #28672	@ 0x7000
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80069b8:	ea41 2106 	orr.w	r1, r1, r6, lsl #8

  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 20U);
 80069bc:	68ae      	ldr	r6, [r5, #8]
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 80069be:	f422 1200 	bic.w	r2, r2, #2097152	@ 0x200000
  tmpccer |= (OC_Config->OCPolarity << 20U);
 80069c2:	ea42 5206 	orr.w	r2, r2, r6, lsl #20

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 80069c6:	4e58      	ldr	r6, [pc, #352]	@ (8006b28 <HAL_TIM_PWM_ConfigChannel+0x1c8>)
 80069c8:	42b3      	cmp	r3, r6
 80069ca:	d00f      	beq.n	80069ec <HAL_TIM_PWM_ConfigChannel+0x8c>
 80069cc:	f506 6600 	add.w	r6, r6, #2048	@ 0x800
 80069d0:	42b3      	cmp	r3, r6
 80069d2:	d00b      	beq.n	80069ec <HAL_TIM_PWM_ConfigChannel+0x8c>
 80069d4:	f506 6640 	add.w	r6, r6, #3072	@ 0xc00
 80069d8:	42b3      	cmp	r3, r6
 80069da:	d007      	beq.n	80069ec <HAL_TIM_PWM_ConfigChannel+0x8c>
 80069dc:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
 80069e0:	42b3      	cmp	r3, r6
 80069e2:	d003      	beq.n	80069ec <HAL_TIM_PWM_ConfigChannel+0x8c>
 80069e4:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
 80069e8:	42b3      	cmp	r3, r6
 80069ea:	d104      	bne.n	80069f6 <HAL_TIM_PWM_ConfigChannel+0x96>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS6;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
 80069ec:	696e      	ldr	r6, [r5, #20]
    tmpcr2 &= ~TIM_CR2_OIS6;
 80069ee:	f420 2080 	bic.w	r0, r0, #262144	@ 0x40000
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
 80069f2:	ea40 2086 	orr.w	r0, r0, r6, lsl #10
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 80069f6:	6058      	str	r0, [r3, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 80069f8:	6519      	str	r1, [r3, #80]	@ 0x50

  /* Set the Capture Compare Register value */
  TIMx->CCR6 = OC_Config->Pulse;
 80069fa:	6869      	ldr	r1, [r5, #4]
 80069fc:	64d9      	str	r1, [r3, #76]	@ 0x4c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80069fe:	621a      	str	r2, [r3, #32]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 8006a00:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
 8006a02:	6929      	ldr	r1, [r5, #16]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 8006a04:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 8006a08:	651a      	str	r2, [r3, #80]	@ 0x50
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
 8006a0a:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 8006a0c:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 8006a10:	651a      	str	r2, [r3, #80]	@ 0x50
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
 8006a12:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 8006a14:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8006a18:	651a      	str	r2, [r3, #80]	@ 0x50
      break;
 8006a1a:	e00e      	b.n	8006a3a <HAL_TIM_PWM_ConfigChannel+0xda>
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 8006a1c:	6800      	ldr	r0, [r0, #0]
 8006a1e:	f7ff fbdb 	bl	80061d8 <TIM_OC1_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 8006a22:	6983      	ldr	r3, [r0, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 8006a24:	692a      	ldr	r2, [r5, #16]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 8006a26:	f043 0308 	orr.w	r3, r3, #8
 8006a2a:	6183      	str	r3, [r0, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 8006a2c:	6983      	ldr	r3, [r0, #24]
 8006a2e:	f023 0304 	bic.w	r3, r3, #4
 8006a32:	6183      	str	r3, [r0, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 8006a34:	6983      	ldr	r3, [r0, #24]
 8006a36:	4313      	orrs	r3, r2
 8006a38:	6183      	str	r3, [r0, #24]
  __HAL_UNLOCK(htim);
 8006a3a:	2300      	movs	r3, #0
 8006a3c:	f884 303c 	strb.w	r3, [r4, #60]	@ 0x3c
  HAL_StatusTypeDef status = HAL_OK;
 8006a40:	2000      	movs	r0, #0
}
 8006a42:	bd70      	pop	{r4, r5, r6, pc}
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 8006a44:	6800      	ldr	r0, [r0, #0]
 8006a46:	f7ff ff49 	bl	80068dc <TIM_OC2_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 8006a4a:	6983      	ldr	r3, [r0, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 8006a4c:	692a      	ldr	r2, [r5, #16]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 8006a4e:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
 8006a52:	6183      	str	r3, [r0, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 8006a54:	6983      	ldr	r3, [r0, #24]
 8006a56:	f423 6380 	bic.w	r3, r3, #1024	@ 0x400
 8006a5a:	6183      	str	r3, [r0, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 8006a5c:	6983      	ldr	r3, [r0, #24]
 8006a5e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8006a62:	6183      	str	r3, [r0, #24]
      break;
 8006a64:	e7e9      	b.n	8006a3a <HAL_TIM_PWM_ConfigChannel+0xda>
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 8006a66:	6800      	ldr	r0, [r0, #0]
 8006a68:	f7ff fbf2 	bl	8006250 <TIM_OC3_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 8006a6c:	69c3      	ldr	r3, [r0, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 8006a6e:	692a      	ldr	r2, [r5, #16]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 8006a70:	f043 0308 	orr.w	r3, r3, #8
 8006a74:	61c3      	str	r3, [r0, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 8006a76:	69c3      	ldr	r3, [r0, #28]
 8006a78:	f023 0304 	bic.w	r3, r3, #4
 8006a7c:	61c3      	str	r3, [r0, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 8006a7e:	69c3      	ldr	r3, [r0, #28]
 8006a80:	4313      	orrs	r3, r2
 8006a82:	61c3      	str	r3, [r0, #28]
      break;
 8006a84:	e7d9      	b.n	8006a3a <HAL_TIM_PWM_ConfigChannel+0xda>
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 8006a86:	6800      	ldr	r0, [r0, #0]
 8006a88:	f7ff fc22 	bl	80062d0 <TIM_OC4_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 8006a8c:	69c3      	ldr	r3, [r0, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 8006a8e:	692a      	ldr	r2, [r5, #16]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 8006a90:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
 8006a94:	61c3      	str	r3, [r0, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 8006a96:	69c3      	ldr	r3, [r0, #28]
 8006a98:	f423 6380 	bic.w	r3, r3, #1024	@ 0x400
 8006a9c:	61c3      	str	r3, [r0, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 8006a9e:	69c3      	ldr	r3, [r0, #28]
 8006aa0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8006aa4:	61c3      	str	r3, [r0, #28]
      break;
 8006aa6:	e7c8      	b.n	8006a3a <HAL_TIM_PWM_ConfigChannel+0xda>
      TIM_OC5_SetConfig(htim->Instance, sConfig);
 8006aa8:	6803      	ldr	r3, [r0, #0]
  tmpccmrx |= OC_Config->OCMode;
 8006aaa:	682e      	ldr	r6, [r5, #0]
  tmpccer = TIMx->CCER;
 8006aac:	6a1a      	ldr	r2, [r3, #32]
  TIMx->CCER &= ~TIM_CCER_CC5E;
 8006aae:	6a19      	ldr	r1, [r3, #32]
 8006ab0:	f421 3180 	bic.w	r1, r1, #65536	@ 0x10000
 8006ab4:	6219      	str	r1, [r3, #32]
  tmpcr2 =  TIMx->CR2;
 8006ab6:	6858      	ldr	r0, [r3, #4]
  tmpccmrx = TIMx->CCMR3;
 8006ab8:	6d19      	ldr	r1, [r3, #80]	@ 0x50
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 8006aba:	f421 3180 	bic.w	r1, r1, #65536	@ 0x10000
 8006abe:	f021 0170 	bic.w	r1, r1, #112	@ 0x70
  tmpccmrx |= OC_Config->OCMode;
 8006ac2:	4331      	orrs	r1, r6
  tmpccer |= (OC_Config->OCPolarity << 16U);
 8006ac4:	68ae      	ldr	r6, [r5, #8]
  tmpccer &= ~TIM_CCER_CC5P;
 8006ac6:	f422 3200 	bic.w	r2, r2, #131072	@ 0x20000
  tmpccer |= (OC_Config->OCPolarity << 16U);
 8006aca:	ea42 4206 	orr.w	r2, r2, r6, lsl #16
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8006ace:	4e16      	ldr	r6, [pc, #88]	@ (8006b28 <HAL_TIM_PWM_ConfigChannel+0x1c8>)
 8006ad0:	42b3      	cmp	r3, r6
 8006ad2:	d00f      	beq.n	8006af4 <HAL_TIM_PWM_ConfigChannel+0x194>
 8006ad4:	f506 6600 	add.w	r6, r6, #2048	@ 0x800
 8006ad8:	42b3      	cmp	r3, r6
 8006ada:	d00b      	beq.n	8006af4 <HAL_TIM_PWM_ConfigChannel+0x194>
 8006adc:	f506 6640 	add.w	r6, r6, #3072	@ 0xc00
 8006ae0:	42b3      	cmp	r3, r6
 8006ae2:	d007      	beq.n	8006af4 <HAL_TIM_PWM_ConfigChannel+0x194>
 8006ae4:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
 8006ae8:	42b3      	cmp	r3, r6
 8006aea:	d003      	beq.n	8006af4 <HAL_TIM_PWM_ConfigChannel+0x194>
 8006aec:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
 8006af0:	42b3      	cmp	r3, r6
 8006af2:	d104      	bne.n	8006afe <HAL_TIM_PWM_ConfigChannel+0x19e>
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
 8006af4:	696e      	ldr	r6, [r5, #20]
    tmpcr2 &= ~TIM_CR2_OIS5;
 8006af6:	f420 3080 	bic.w	r0, r0, #65536	@ 0x10000
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
 8006afa:	ea40 2006 	orr.w	r0, r0, r6, lsl #8
  TIMx->CR2 = tmpcr2;
 8006afe:	6058      	str	r0, [r3, #4]
  TIMx->CCMR3 = tmpccmrx;
 8006b00:	6519      	str	r1, [r3, #80]	@ 0x50
  TIMx->CCR5 = OC_Config->Pulse;
 8006b02:	6869      	ldr	r1, [r5, #4]
 8006b04:	6499      	str	r1, [r3, #72]	@ 0x48
  TIMx->CCER = tmpccer;
 8006b06:	621a      	str	r2, [r3, #32]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 8006b08:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
 8006b0a:	6929      	ldr	r1, [r5, #16]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 8006b0c:	f042 0208 	orr.w	r2, r2, #8
 8006b10:	651a      	str	r2, [r3, #80]	@ 0x50
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
 8006b12:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 8006b14:	f022 0204 	bic.w	r2, r2, #4
 8006b18:	651a      	str	r2, [r3, #80]	@ 0x50
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
 8006b1a:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 8006b1c:	430a      	orrs	r2, r1
 8006b1e:	651a      	str	r2, [r3, #80]	@ 0x50
      break;
 8006b20:	e78b      	b.n	8006a3a <HAL_TIM_PWM_ConfigChannel+0xda>
  __HAL_LOCK(htim);
 8006b22:	2002      	movs	r0, #2
}
 8006b24:	4770      	bx	lr
 8006b26:	bf00      	nop
 8006b28:	40012c00 	.word	0x40012c00

08006b2c <HAL_TIMEx_MasterConfigSynchronization>:
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 8006b2c:	f890 303c 	ldrb.w	r3, [r0, #60]	@ 0x3c
 8006b30:	2b01      	cmp	r3, #1
 8006b32:	d046      	beq.n	8006bc2 <HAL_TIMEx_MasterConfigSynchronization+0x96>
{
 8006b34:	b470      	push	{r4, r5, r6}
 8006b36:	4602      	mov	r2, r0

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8006b38:	4e23      	ldr	r6, [pc, #140]	@ (8006bc8 <HAL_TIMEx_MasterConfigSynchronization+0x9c>)
  tmpcr2 = htim->Instance->CR2;
 8006b3a:	6800      	ldr	r0, [r0, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 8006b3c:	2302      	movs	r3, #2
 8006b3e:	f882 303d 	strb.w	r3, [r2, #61]	@ 0x3d
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8006b42:	42b0      	cmp	r0, r6
  tmpcr2 = htim->Instance->CR2;
 8006b44:	6843      	ldr	r3, [r0, #4]
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8006b46:	680d      	ldr	r5, [r1, #0]
  tmpsmcr = htim->Instance->SMCR;
 8006b48:	6884      	ldr	r4, [r0, #8]
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8006b4a:	d024      	beq.n	8006b96 <HAL_TIMEx_MasterConfigSynchronization+0x6a>
 8006b4c:	f506 6600 	add.w	r6, r6, #2048	@ 0x800
 8006b50:	42b0      	cmp	r0, r6
 8006b52:	d02b      	beq.n	8006bac <HAL_TIMEx_MasterConfigSynchronization+0x80>
  tmpcr2 &= ~TIM_CR2_MMS;
 8006b54:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
 8006b58:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8006b5c:	432b      	orrs	r3, r5

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8006b5e:	f1b0 4f80 	cmp.w	r0, #1073741824	@ 0x40000000
  htim->Instance->CR2 = tmpcr2;
 8006b62:	6043      	str	r3, [r0, #4]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8006b64:	d00a      	beq.n	8006b7c <HAL_TIMEx_MasterConfigSynchronization+0x50>
 8006b66:	4b19      	ldr	r3, [pc, #100]	@ (8006bcc <HAL_TIMEx_MasterConfigSynchronization+0xa0>)
 8006b68:	4298      	cmp	r0, r3
 8006b6a:	d007      	beq.n	8006b7c <HAL_TIMEx_MasterConfigSynchronization+0x50>
 8006b6c:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8006b70:	4298      	cmp	r0, r3
 8006b72:	d003      	beq.n	8006b7c <HAL_TIMEx_MasterConfigSynchronization+0x50>
 8006b74:	f503 339c 	add.w	r3, r3, #79872	@ 0x13800
 8006b78:	4298      	cmp	r0, r3
 8006b7a:	d104      	bne.n	8006b86 <HAL_TIMEx_MasterConfigSynchronization+0x5a>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8006b7c:	688b      	ldr	r3, [r1, #8]
    tmpsmcr &= ~TIM_SMCR_MSM;
 8006b7e:	f024 0480 	bic.w	r4, r4, #128	@ 0x80
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8006b82:	431c      	orrs	r4, r3

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 8006b84:	6084      	str	r4, [r0, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;

  __HAL_UNLOCK(htim);
 8006b86:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
 8006b88:	2301      	movs	r3, #1
 8006b8a:	f882 303d 	strb.w	r3, [r2, #61]	@ 0x3d
  __HAL_UNLOCK(htim);
 8006b8e:	f882 003c 	strb.w	r0, [r2, #60]	@ 0x3c

  return HAL_OK;
}
 8006b92:	bc70      	pop	{r4, r5, r6}
 8006b94:	4770      	bx	lr
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 8006b96:	684e      	ldr	r6, [r1, #4]
    tmpcr2 &= ~TIM_CR2_MMS2;
 8006b98:	f423 0370 	bic.w	r3, r3, #15728640	@ 0xf00000
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 8006b9c:	4333      	orrs	r3, r6
  tmpcr2 &= ~TIM_CR2_MMS;
 8006b9e:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
 8006ba2:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8006ba6:	432b      	orrs	r3, r5
  htim->Instance->CR2 = tmpcr2;
 8006ba8:	6043      	str	r3, [r0, #4]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8006baa:	e7e7      	b.n	8006b7c <HAL_TIMEx_MasterConfigSynchronization+0x50>
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 8006bac:	684e      	ldr	r6, [r1, #4]
    tmpcr2 &= ~TIM_CR2_MMS2;
 8006bae:	f423 0370 	bic.w	r3, r3, #15728640	@ 0xf00000
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 8006bb2:	4333      	orrs	r3, r6
  tmpcr2 &= ~TIM_CR2_MMS;
 8006bb4:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
 8006bb8:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8006bbc:	431d      	orrs	r5, r3
  htim->Instance->CR2 = tmpcr2;
 8006bbe:	6045      	str	r5, [r0, #4]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8006bc0:	e7dc      	b.n	8006b7c <HAL_TIMEx_MasterConfigSynchronization+0x50>
  __HAL_LOCK(htim);
 8006bc2:	2002      	movs	r0, #2
}
 8006bc4:	4770      	bx	lr
 8006bc6:	bf00      	nop
 8006bc8:	40012c00 	.word	0x40012c00
 8006bcc:	40000400 	.word	0x40000400

08006bd0 <HAL_TIMEx_ConfigBreakDeadTime>:
  assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->BreakFilter));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));
  assert_param(IS_TIM_BREAK_AFMODE(sBreakDeadTimeConfig->BreakAFMode));

  /* Check input state */
  __HAL_LOCK(htim);
 8006bd0:	f890 303c 	ldrb.w	r3, [r0, #60]	@ 0x3c
 8006bd4:	2b01      	cmp	r3, #1
 8006bd6:	d045      	beq.n	8006c64 <HAL_TIMEx_ConfigBreakDeadTime+0x94>
{
 8006bd8:	b410      	push	{r4}
  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */

  /* Set the BDTR bits */
  MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
 8006bda:	e9d1 4302 	ldrd	r4, r3, [r1, #8]
 8006bde:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8006be2:	4602      	mov	r2, r0
 8006be4:	4323      	orrs	r3, r4
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
 8006be6:	6848      	ldr	r0, [r1, #4]
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
 8006be8:	680c      	ldr	r4, [r1, #0]
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
 8006bea:	f423 6380 	bic.w	r3, r3, #1024	@ 0x400
 8006bee:	4303      	orrs	r3, r0
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
 8006bf0:	f423 6300 	bic.w	r3, r3, #2048	@ 0x800
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
 8006bf4:	6908      	ldr	r0, [r1, #16]
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
 8006bf6:	4323      	orrs	r3, r4
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
 8006bf8:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 8006bfc:	694c      	ldr	r4, [r1, #20]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
 8006bfe:	4303      	orrs	r3, r0
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 8006c00:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 8006c04:	6b08      	ldr	r0, [r1, #48]	@ 0x30
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 8006c06:	4323      	orrs	r3, r4
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 8006c08:	f423 4380 	bic.w	r3, r3, #16384	@ 0x4000
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << TIM_BDTR_BKF_Pos));
 8006c0c:	698c      	ldr	r4, [r1, #24]
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 8006c0e:	4303      	orrs	r3, r0
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << TIM_BDTR_BKF_Pos));
 8006c10:	f423 2370 	bic.w	r3, r3, #983040	@ 0xf0000
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKBID, sBreakDeadTimeConfig->BreakAFMode);
 8006c14:	69c8      	ldr	r0, [r1, #28]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << TIM_BDTR_BKF_Pos));
 8006c16:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKBID, sBreakDeadTimeConfig->BreakAFMode);
 8006c1a:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000

  if (IS_TIM_BKIN2_INSTANCE(htim->Instance))
 8006c1e:	4c12      	ldr	r4, [pc, #72]	@ (8006c68 <HAL_TIMEx_ConfigBreakDeadTime+0x98>)
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKBID, sBreakDeadTimeConfig->BreakAFMode);
 8006c20:	4303      	orrs	r3, r0
  if (IS_TIM_BKIN2_INSTANCE(htim->Instance))
 8006c22:	6810      	ldr	r0, [r2, #0]
 8006c24:	42a0      	cmp	r0, r4
 8006c26:	d00b      	beq.n	8006c40 <HAL_TIMEx_ConfigBreakDeadTime+0x70>
 8006c28:	f504 6400 	add.w	r4, r4, #2048	@ 0x800
 8006c2c:	42a0      	cmp	r0, r4
 8006c2e:	d007      	beq.n	8006c40 <HAL_TIMEx_ConfigBreakDeadTime+0x70>
  }

  /* Set TIMx_BDTR */
  htim->Instance->BDTR = tmpbdtr;

  __HAL_UNLOCK(htim);
 8006c30:	2100      	movs	r1, #0
  htim->Instance->BDTR = tmpbdtr;
 8006c32:	6443      	str	r3, [r0, #68]	@ 0x44
  __HAL_UNLOCK(htim);
 8006c34:	f882 103c 	strb.w	r1, [r2, #60]	@ 0x3c

  return HAL_OK;
 8006c38:	4608      	mov	r0, r1
}
 8006c3a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006c3e:	4770      	bx	lr
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2F, (sBreakDeadTimeConfig->Break2Filter << TIM_BDTR_BK2F_Pos));
 8006c40:	6a8c      	ldr	r4, [r1, #40]	@ 0x28
 8006c42:	f423 0370 	bic.w	r3, r3, #15728640	@ 0xf00000
 8006c46:	ea43 5304 	orr.w	r3, r3, r4, lsl #20
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, sBreakDeadTimeConfig->Break2State);
 8006c4a:	6a0c      	ldr	r4, [r1, #32]
 8006c4c:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
 8006c50:	4323      	orrs	r3, r4
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig->Break2Polarity);
 8006c52:	6a4c      	ldr	r4, [r1, #36]	@ 0x24
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2BID, sBreakDeadTimeConfig->Break2AFMode);
 8006c54:	6ac9      	ldr	r1, [r1, #44]	@ 0x2c
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig->Break2Polarity);
 8006c56:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
 8006c5a:	4323      	orrs	r3, r4
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2BID, sBreakDeadTimeConfig->Break2AFMode);
 8006c5c:	f023 5300 	bic.w	r3, r3, #536870912	@ 0x20000000
 8006c60:	430b      	orrs	r3, r1
 8006c62:	e7e5      	b.n	8006c30 <HAL_TIMEx_ConfigBreakDeadTime+0x60>
  __HAL_LOCK(htim);
 8006c64:	2002      	movs	r0, #2
}
 8006c66:	4770      	bx	lr
 8006c68:	40012c00 	.word	0x40012c00

08006c6c <HAL_TIMEx_ConfigBreakInput>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_ConfigBreakInput(TIM_HandleTypeDef *htim,
                                             uint32_t BreakInput,
                                             const TIMEx_BreakInputConfigTypeDef *sBreakInputConfig)
{
 8006c6c:	4603      	mov	r3, r0
  assert_param(IS_TIM_BREAKINPUTSOURCE(sBreakInputConfig->Source));
  assert_param(IS_TIM_BREAKINPUTSOURCE_STATE(sBreakInputConfig->Enable));
  assert_param(IS_TIM_BREAKINPUTSOURCE_POLARITY(sBreakInputConfig->Polarity));

  /* Check input state */
  __HAL_LOCK(htim);
 8006c6e:	f890 003c 	ldrb.w	r0, [r0, #60]	@ 0x3c
 8006c72:	2801      	cmp	r0, #1
 8006c74:	d047      	beq.n	8006d06 <HAL_TIMEx_ConfigBreakInput+0x9a>

  switch (sBreakInputConfig->Source)
 8006c76:	6810      	ldr	r0, [r2, #0]
 8006c78:	3801      	subs	r0, #1
 8006c7a:	280f      	cmp	r0, #15
{
 8006c7c:	b4f0      	push	{r4, r5, r6, r7}
 8006c7e:	d825      	bhi.n	8006ccc <HAL_TIMEx_ConfigBreakInput+0x60>
 8006c80:	4c22      	ldr	r4, [pc, #136]	@ (8006d0c <HAL_TIMEx_ConfigBreakInput+0xa0>)
 8006c82:	4e23      	ldr	r6, [pc, #140]	@ (8006d10 <HAL_TIMEx_ConfigBreakInput+0xa4>)
 8006c84:	f854 5020 	ldr.w	r5, [r4, r0, lsl #2]
 8006c88:	f856 c020 	ldr.w	ip, [r6, r0, lsl #2]
 8006c8c:	4c21      	ldr	r4, [pc, #132]	@ (8006d14 <HAL_TIMEx_ConfigBreakInput+0xa8>)
 8006c8e:	4e22      	ldr	r6, [pc, #136]	@ (8006d18 <HAL_TIMEx_ConfigBreakInput+0xac>)
 8006c90:	f854 4020 	ldr.w	r4, [r4, r0, lsl #2]
 8006c94:	f856 7020 	ldr.w	r7, [r6, r0, lsl #2]
      bkin_polarity_bitpos = 0U;
      break;
    }
  }

  switch (BreakInput)
 8006c98:	2901      	cmp	r1, #1
 8006c9a:	d01d      	beq.n	8006cd8 <HAL_TIMEx_ConfigBreakInput+0x6c>
 8006c9c:	2902      	cmp	r1, #2
 8006c9e:	d12c      	bne.n	8006cfa <HAL_TIMEx_ConfigBreakInput+0x8e>
      tmporx &= ~bkin_enable_mask;
      tmporx |= (sBreakInputConfig->Enable << bkin_enable_bitpos) & bkin_enable_mask;

      /* Set the break input polarity */
      tmporx &= ~bkin_polarity_mask;
      tmporx |= (sBreakInputConfig->Polarity << bkin_polarity_bitpos) & bkin_polarity_mask;
 8006ca0:	6890      	ldr	r0, [r2, #8]
      tmporx = htim->Instance->AF2;
 8006ca2:	681e      	ldr	r6, [r3, #0]
      tmporx |= (sBreakInputConfig->Enable << bkin_enable_bitpos) & bkin_enable_mask;
 8006ca4:	6851      	ldr	r1, [r2, #4]
      tmporx |= (sBreakInputConfig->Polarity << bkin_polarity_bitpos) & bkin_polarity_mask;
 8006ca6:	40b8      	lsls	r0, r7
      tmporx = htim->Instance->AF2;
 8006ca8:	6e77      	ldr	r7, [r6, #100]	@ 0x64
      tmporx |= (sBreakInputConfig->Enable << bkin_enable_bitpos) & bkin_enable_mask;
 8006caa:	fa01 f10c 	lsl.w	r1, r1, ip
 8006cae:	ea81 0207 	eor.w	r2, r1, r7
 8006cb2:	402a      	ands	r2, r5
 8006cb4:	407a      	eors	r2, r7
      tmporx |= (sBreakInputConfig->Polarity << bkin_polarity_bitpos) & bkin_polarity_mask;
 8006cb6:	ea80 0102 	eor.w	r1, r0, r2
 8006cba:	4021      	ands	r1, r4
 8006cbc:	404a      	eors	r2, r1

      /* Set TIMx_AF2 */
      htim->Instance->AF2 = tmporx;
 8006cbe:	6672      	str	r2, [r6, #100]	@ 0x64
    default:
      status = HAL_ERROR;
      break;
  }

  __HAL_UNLOCK(htim);
 8006cc0:	2200      	movs	r2, #0
 8006cc2:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c
  HAL_StatusTypeDef status = HAL_OK;
 8006cc6:	2000      	movs	r0, #0

  return status;
}
 8006cc8:	bcf0      	pop	{r4, r5, r6, r7}
 8006cca:	4770      	bx	lr
  switch (sBreakInputConfig->Source)
 8006ccc:	2700      	movs	r7, #0
  switch (BreakInput)
 8006cce:	2901      	cmp	r1, #1
  switch (sBreakInputConfig->Source)
 8006cd0:	46bc      	mov	ip, r7
 8006cd2:	463c      	mov	r4, r7
 8006cd4:	463d      	mov	r5, r7
  switch (BreakInput)
 8006cd6:	d1e1      	bne.n	8006c9c <HAL_TIMEx_ConfigBreakInput+0x30>
      tmporx |= (sBreakInputConfig->Polarity << bkin_polarity_bitpos) & bkin_polarity_mask;
 8006cd8:	6890      	ldr	r0, [r2, #8]
      tmporx = htim->Instance->AF1;
 8006cda:	681e      	ldr	r6, [r3, #0]
      tmporx |= (sBreakInputConfig->Enable << bkin_enable_bitpos) & bkin_enable_mask;
 8006cdc:	6851      	ldr	r1, [r2, #4]
      tmporx |= (sBreakInputConfig->Polarity << bkin_polarity_bitpos) & bkin_polarity_mask;
 8006cde:	40b8      	lsls	r0, r7
      tmporx = htim->Instance->AF1;
 8006ce0:	6e37      	ldr	r7, [r6, #96]	@ 0x60
      tmporx |= (sBreakInputConfig->Enable << bkin_enable_bitpos) & bkin_enable_mask;
 8006ce2:	fa01 f10c 	lsl.w	r1, r1, ip
 8006ce6:	ea81 0207 	eor.w	r2, r1, r7
 8006cea:	402a      	ands	r2, r5
 8006cec:	407a      	eors	r2, r7
      tmporx |= (sBreakInputConfig->Polarity << bkin_polarity_bitpos) & bkin_polarity_mask;
 8006cee:	ea80 0102 	eor.w	r1, r0, r2
 8006cf2:	4021      	ands	r1, r4
 8006cf4:	404a      	eors	r2, r1
      htim->Instance->AF1 = tmporx;
 8006cf6:	6632      	str	r2, [r6, #96]	@ 0x60
      break;
 8006cf8:	e7e2      	b.n	8006cc0 <HAL_TIMEx_ConfigBreakInput+0x54>
  __HAL_UNLOCK(htim);
 8006cfa:	2200      	movs	r2, #0
 8006cfc:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c
  switch (BreakInput)
 8006d00:	2001      	movs	r0, #1
}
 8006d02:	bcf0      	pop	{r4, r5, r6, r7}
 8006d04:	4770      	bx	lr
  __HAL_LOCK(htim);
 8006d06:	2002      	movs	r0, #2
}
 8006d08:	4770      	bx	lr
 8006d0a:	bf00      	nop
 8006d0c:	0800a67c 	.word	0x0800a67c
 8006d10:	0800a5fc 	.word	0x0800a5fc
 8006d14:	0800a63c 	.word	0x0800a63c
 8006d18:	0800a5bc 	.word	0x0800a5bc

08006d1c <HAL_TIMEx_CommutCallback>:
/**
  * @brief  Commutation callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
 8006d1c:	4770      	bx	lr
 8006d1e:	bf00      	nop

08006d20 <HAL_TIMEx_BreakCallback>:
/**
  * @brief  Break detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
 8006d20:	4770      	bx	lr
 8006d22:	bf00      	nop

08006d24 <HAL_TIMEx_Break2Callback>:
/**
  * @brief  Break2 detection callback in non blocking mode
  * @param  htim: TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_Break2Callback(TIM_HandleTypeDef *htim)
 8006d24:	4770      	bx	lr
 8006d26:	bf00      	nop

08006d28 <HAL_TIMEx_EncoderIndexCallback>:
/**
  * @brief  Encoder index callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_EncoderIndexCallback(TIM_HandleTypeDef *htim)
 8006d28:	4770      	bx	lr
 8006d2a:	bf00      	nop

08006d2c <HAL_TIMEx_DirectionChangeCallback>:
/**
  * @brief  Direction change callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_DirectionChangeCallback(TIM_HandleTypeDef *htim)
 8006d2c:	4770      	bx	lr
 8006d2e:	bf00      	nop

08006d30 <HAL_TIMEx_IndexErrorCallback>:
/**
  * @brief  Index error callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_IndexErrorCallback(TIM_HandleTypeDef *htim)
 8006d30:	4770      	bx	lr
 8006d32:	bf00      	nop

08006d34 <HAL_TIMEx_TransitionErrorCallback>:
/**
  * @brief  Transition error callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_TransitionErrorCallback(TIM_HandleTypeDef *htim)
 8006d34:	4770      	bx	lr
 8006d36:	bf00      	nop

08006d38 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 8006d38:	b570      	push	{r4, r5, r6, lr}
 8006d3a:	4604      	mov	r4, r0
  uint32_t pclk;

  /* Check the parameters */
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  if (UART_INSTANCE_LOWPOWER(huart))
 8006d3c:	6803      	ldr	r3, [r0, #0]
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8006d3e:	6882      	ldr	r2, [r0, #8]
 8006d40:	6900      	ldr	r0, [r0, #16]
 8006d42:	6961      	ldr	r1, [r4, #20]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8006d44:	681d      	ldr	r5, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8006d46:	4302      	orrs	r2, r0
 8006d48:	430a      	orrs	r2, r1
 8006d4a:	69e0      	ldr	r0, [r4, #28]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8006d4c:	4995      	ldr	r1, [pc, #596]	@ (8006fa4 <UART_SetConfig+0x26c>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8006d4e:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8006d50:	4029      	ands	r1, r5
 8006d52:	430a      	orrs	r2, r1
 8006d54:	601a      	str	r2, [r3, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8006d56:	685a      	ldr	r2, [r3, #4]
 8006d58:	68e1      	ldr	r1, [r4, #12]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);

  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 8006d5a:	6a65      	ldr	r5, [r4, #36]	@ 0x24
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8006d5c:	f422 5240 	bic.w	r2, r2, #12288	@ 0x3000
 8006d60:	430a      	orrs	r2, r1
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 8006d62:	4991      	ldr	r1, [pc, #580]	@ (8006fa8 <UART_SetConfig+0x270>)
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8006d64:	605a      	str	r2, [r3, #4]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 8006d66:	428b      	cmp	r3, r1
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8006d68:	6899      	ldr	r1, [r3, #8]
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 8006d6a:	69a2      	ldr	r2, [r4, #24]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8006d6c:	f021 416e 	bic.w	r1, r1, #3992977408	@ 0xee000000
 8006d70:	f421 6130 	bic.w	r1, r1, #2816	@ 0xb00
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 8006d74:	f000 80bb 	beq.w	8006eee <UART_SetConfig+0x1b6>
    tmpreg |= huart->Init.OneBitSampling;
 8006d78:	6a26      	ldr	r6, [r4, #32]
 8006d7a:	4332      	orrs	r2, r6
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8006d7c:	430a      	orrs	r2, r1
 8006d7e:	609a      	str	r2, [r3, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 8006d80:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8006d82:	f022 020f 	bic.w	r2, r2, #15
 8006d86:	432a      	orrs	r2, r5
 8006d88:	62da      	str	r2, [r3, #44]	@ 0x2c

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 8006d8a:	4a88      	ldr	r2, [pc, #544]	@ (8006fac <UART_SetConfig+0x274>)
 8006d8c:	4293      	cmp	r3, r2
 8006d8e:	d035      	beq.n	8006dfc <UART_SetConfig+0xc4>
 8006d90:	4a87      	ldr	r2, [pc, #540]	@ (8006fb0 <UART_SetConfig+0x278>)
 8006d92:	4293      	cmp	r3, r2
 8006d94:	d00e      	beq.n	8006db4 <UART_SetConfig+0x7c>
 8006d96:	4a87      	ldr	r2, [pc, #540]	@ (8006fb4 <UART_SetConfig+0x27c>)
 8006d98:	4293      	cmp	r3, r2
 8006d9a:	f000 8098 	beq.w	8006ece <UART_SetConfig+0x196>
 8006d9e:	4a86      	ldr	r2, [pc, #536]	@ (8006fb8 <UART_SetConfig+0x280>)
 8006da0:	4293      	cmp	r3, r2
 8006da2:	d03f      	beq.n	8006e24 <UART_SetConfig+0xec>

      /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
          (lpuart_ker_ck_pres > (4096U * huart->Init.BaudRate)))
      {
        ret = HAL_ERROR;
 8006da4:	2001      	movs	r0, #1
  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
  huart->NbRxDataToProcess = 1;

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 8006da6:	2300      	movs	r3, #0
  huart->NbRxDataToProcess = 1;
 8006da8:	f04f 1201 	mov.w	r2, #65537	@ 0x10001
  huart->TxISR = NULL;
 8006dac:	e9c4 331d 	strd	r3, r3, [r4, #116]	@ 0x74
  huart->NbRxDataToProcess = 1;
 8006db0:	66a2      	str	r2, [r4, #104]	@ 0x68

  return ret;
}
 8006db2:	bd70      	pop	{r4, r5, r6, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
 8006db4:	4b81      	ldr	r3, [pc, #516]	@ (8006fbc <UART_SetConfig+0x284>)
 8006db6:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8006dba:	f003 030c 	and.w	r3, r3, #12
 8006dbe:	2b0c      	cmp	r3, #12
 8006dc0:	d8f0      	bhi.n	8006da4 <UART_SetConfig+0x6c>
 8006dc2:	a201      	add	r2, pc, #4	@ (adr r2, 8006dc8 <UART_SetConfig+0x90>)
 8006dc4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8006dc8:	08006ec3 	.word	0x08006ec3
 8006dcc:	08006da5 	.word	0x08006da5
 8006dd0:	08006da5 	.word	0x08006da5
 8006dd4:	08006da5 	.word	0x08006da5
 8006dd8:	08006e3d 	.word	0x08006e3d
 8006ddc:	08006da5 	.word	0x08006da5
 8006de0:	08006da5 	.word	0x08006da5
 8006de4:	08006da5 	.word	0x08006da5
 8006de8:	08006e85 	.word	0x08006e85
 8006dec:	08006da5 	.word	0x08006da5
 8006df0:	08006da5 	.word	0x08006da5
 8006df4:	08006da5 	.word	0x08006da5
 8006df8:	08006e55 	.word	0x08006e55
 8006dfc:	4b6f      	ldr	r3, [pc, #444]	@ (8006fbc <UART_SetConfig+0x284>)
 8006dfe:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8006e02:	f003 0303 	and.w	r3, r3, #3
 8006e06:	2b02      	cmp	r3, #2
 8006e08:	d03c      	beq.n	8006e84 <UART_SetConfig+0x14c>
 8006e0a:	2b03      	cmp	r3, #3
 8006e0c:	d022      	beq.n	8006e54 <UART_SetConfig+0x11c>
 8006e0e:	2b01      	cmp	r3, #1
 8006e10:	d014      	beq.n	8006e3c <UART_SetConfig+0x104>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8006e12:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
 8006e16:	f000 80bc 	beq.w	8006f92 <UART_SetConfig+0x25a>
        pclk = HAL_RCC_GetPCLK2Freq();
 8006e1a:	f7ff f851 	bl	8005ec0 <HAL_RCC_GetPCLK2Freq>
    if (pclk != 0U)
 8006e1e:	b9a8      	cbnz	r0, 8006e4c <UART_SetConfig+0x114>
        pclk = (uint32_t) HSI_VALUE;
 8006e20:	2000      	movs	r0, #0
 8006e22:	e7c0      	b.n	8006da6 <UART_SetConfig+0x6e>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8006e24:	4b65      	ldr	r3, [pc, #404]	@ (8006fbc <UART_SetConfig+0x284>)
 8006e26:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8006e2a:	f003 03c0 	and.w	r3, r3, #192	@ 0xc0
 8006e2e:	2b80      	cmp	r3, #128	@ 0x80
 8006e30:	d028      	beq.n	8006e84 <UART_SetConfig+0x14c>
 8006e32:	d859      	bhi.n	8006ee8 <UART_SetConfig+0x1b0>
 8006e34:	2b00      	cmp	r3, #0
 8006e36:	d044      	beq.n	8006ec2 <UART_SetConfig+0x18a>
 8006e38:	2b40      	cmp	r3, #64	@ 0x40
 8006e3a:	d1b3      	bne.n	8006da4 <UART_SetConfig+0x6c>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8006e3c:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
 8006e40:	f000 80aa 	beq.w	8006f98 <UART_SetConfig+0x260>
        pclk = HAL_RCC_GetSysClockFreq();
 8006e44:	f7fe fee8 	bl	8005c18 <HAL_RCC_GetSysClockFreq>
    if (pclk != 0U)
 8006e48:	2800      	cmp	r0, #0
 8006e4a:	d0e9      	beq.n	8006e20 <UART_SetConfig+0xe8>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8006e4c:	6a65      	ldr	r5, [r4, #36]	@ 0x24
 8006e4e:	e006      	b.n	8006e5e <UART_SetConfig+0x126>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8006e50:	2b30      	cmp	r3, #48	@ 0x30
 8006e52:	d1a7      	bne.n	8006da4 <UART_SetConfig+0x6c>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8006e54:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
 8006e58:	d018      	beq.n	8006e8c <UART_SetConfig+0x154>
        pclk = (uint32_t) LSE_VALUE;
 8006e5a:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8006e5e:	6863      	ldr	r3, [r4, #4]
 8006e60:	4a57      	ldr	r2, [pc, #348]	@ (8006fc0 <UART_SetConfig+0x288>)
 8006e62:	f832 1015 	ldrh.w	r1, [r2, r5, lsl #1]
 8006e66:	fbb0 f0f1 	udiv	r0, r0, r1
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8006e6a:	f64f 72ef 	movw	r2, #65519	@ 0xffef
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8006e6e:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 8006e72:	fbb0 f0f3 	udiv	r0, r0, r3
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8006e76:	f1a0 0310 	sub.w	r3, r0, #16
 8006e7a:	4293      	cmp	r3, r2
 8006e7c:	d892      	bhi.n	8006da4 <UART_SetConfig+0x6c>
          huart->Instance->BRR = usartdiv;
 8006e7e:	6823      	ldr	r3, [r4, #0]
 8006e80:	60d8      	str	r0, [r3, #12]
 8006e82:	e7cd      	b.n	8006e20 <UART_SetConfig+0xe8>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8006e84:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
        pclk = (uint32_t) HSI_VALUE;
 8006e88:	484e      	ldr	r0, [pc, #312]	@ (8006fc4 <UART_SetConfig+0x28c>)
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8006e8a:	d1e8      	bne.n	8006e5e <UART_SetConfig+0x126>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8006e8c:	6862      	ldr	r2, [r4, #4]
 8006e8e:	4b4c      	ldr	r3, [pc, #304]	@ (8006fc0 <UART_SetConfig+0x288>)
 8006e90:	f833 1015 	ldrh.w	r1, [r3, r5, lsl #1]
 8006e94:	fbb0 f0f1 	udiv	r0, r0, r1
 8006e98:	0853      	lsrs	r3, r2, #1
 8006e9a:	eb03 0340 	add.w	r3, r3, r0, lsl #1
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8006e9e:	f64f 71ef 	movw	r1, #65519	@ 0xffef
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8006ea2:	fbb3 f3f2 	udiv	r3, r3, r2
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8006ea6:	f1a3 0210 	sub.w	r2, r3, #16
 8006eaa:	428a      	cmp	r2, r1
 8006eac:	f63f af7a 	bhi.w	8006da4 <UART_SetConfig+0x6c>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 8006eb0:	f023 020f 	bic.w	r2, r3, #15
        huart->Instance->BRR = brrtemp;
 8006eb4:	6821      	ldr	r1, [r4, #0]
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 8006eb6:	b292      	uxth	r2, r2
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8006eb8:	f3c3 0342 	ubfx	r3, r3, #1, #3
        huart->Instance->BRR = brrtemp;
 8006ebc:	4313      	orrs	r3, r2
 8006ebe:	60cb      	str	r3, [r1, #12]
 8006ec0:	e7ae      	b.n	8006e20 <UART_SetConfig+0xe8>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8006ec2:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
 8006ec6:	d05d      	beq.n	8006f84 <UART_SetConfig+0x24c>
        pclk = HAL_RCC_GetPCLK1Freq();
 8006ec8:	f7fe ffe8 	bl	8005e9c <HAL_RCC_GetPCLK1Freq>
        break;
 8006ecc:	e7a7      	b.n	8006e1e <UART_SetConfig+0xe6>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8006ece:	4b3b      	ldr	r3, [pc, #236]	@ (8006fbc <UART_SetConfig+0x284>)
 8006ed0:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8006ed4:	f003 0330 	and.w	r3, r3, #48	@ 0x30
 8006ed8:	2b20      	cmp	r3, #32
 8006eda:	d0d3      	beq.n	8006e84 <UART_SetConfig+0x14c>
 8006edc:	d8b8      	bhi.n	8006e50 <UART_SetConfig+0x118>
 8006ede:	2b00      	cmp	r3, #0
 8006ee0:	d0ef      	beq.n	8006ec2 <UART_SetConfig+0x18a>
 8006ee2:	2b10      	cmp	r3, #16
 8006ee4:	d0aa      	beq.n	8006e3c <UART_SetConfig+0x104>
 8006ee6:	e75d      	b.n	8006da4 <UART_SetConfig+0x6c>
 8006ee8:	2bc0      	cmp	r3, #192	@ 0xc0
 8006eea:	d0b3      	beq.n	8006e54 <UART_SetConfig+0x11c>
 8006eec:	e75a      	b.n	8006da4 <UART_SetConfig+0x6c>
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8006eee:	4311      	orrs	r1, r2
 8006ef0:	6099      	str	r1, [r3, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 8006ef2:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
 8006ef4:	4931      	ldr	r1, [pc, #196]	@ (8006fbc <UART_SetConfig+0x284>)
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 8006ef6:	f022 020f 	bic.w	r2, r2, #15
 8006efa:	432a      	orrs	r2, r5
 8006efc:	62da      	str	r2, [r3, #44]	@ 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
 8006efe:	f8d1 3088 	ldr.w	r3, [r1, #136]	@ 0x88
 8006f02:	f403 6340 	and.w	r3, r3, #3072	@ 0xc00
 8006f06:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8006f0a:	d048      	beq.n	8006f9e <UART_SetConfig+0x266>
 8006f0c:	d833      	bhi.n	8006f76 <UART_SetConfig+0x23e>
 8006f0e:	b37b      	cbz	r3, 8006f70 <UART_SetConfig+0x238>
 8006f10:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8006f14:	f47f af46 	bne.w	8006da4 <UART_SetConfig+0x6c>
        pclk = HAL_RCC_GetSysClockFreq();
 8006f18:	f7fe fe7e 	bl	8005c18 <HAL_RCC_GetSysClockFreq>
    if (pclk != 0U)
 8006f1c:	2800      	cmp	r0, #0
 8006f1e:	f43f af7f 	beq.w	8006e20 <UART_SetConfig+0xe8>
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 8006f22:	6a65      	ldr	r5, [r4, #36]	@ 0x24
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8006f24:	6866      	ldr	r6, [r4, #4]
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 8006f26:	4b26      	ldr	r3, [pc, #152]	@ (8006fc0 <UART_SetConfig+0x288>)
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8006f28:	eb06 0146 	add.w	r1, r6, r6, lsl #1
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 8006f2c:	f833 2015 	ldrh.w	r2, [r3, r5, lsl #1]
 8006f30:	fbb0 f3f2 	udiv	r3, r0, r2
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8006f34:	4299      	cmp	r1, r3
 8006f36:	f63f af35 	bhi.w	8006da4 <UART_SetConfig+0x6c>
 8006f3a:	ebb3 3f06 	cmp.w	r3, r6, lsl #12
 8006f3e:	f63f af31 	bhi.w	8006da4 <UART_SetConfig+0x6c>
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8006f42:	2300      	movs	r3, #0
 8006f44:	4619      	mov	r1, r3
 8006f46:	f7f9 f96b 	bl	8000220 <__aeabi_uldivmod>
 8006f4a:	0872      	lsrs	r2, r6, #1
 8006f4c:	0203      	lsls	r3, r0, #8
 8006f4e:	0209      	lsls	r1, r1, #8
 8006f50:	ea41 6110 	orr.w	r1, r1, r0, lsr #24
 8006f54:	1898      	adds	r0, r3, r2
 8006f56:	f141 0100 	adc.w	r1, r1, #0
 8006f5a:	4632      	mov	r2, r6
 8006f5c:	2300      	movs	r3, #0
 8006f5e:	f7f9 f95f 	bl	8000220 <__aeabi_uldivmod>
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 8006f62:	4b19      	ldr	r3, [pc, #100]	@ (8006fc8 <UART_SetConfig+0x290>)
 8006f64:	f5a0 7240 	sub.w	r2, r0, #768	@ 0x300
 8006f68:	429a      	cmp	r2, r3
 8006f6a:	f63f af1b 	bhi.w	8006da4 <UART_SetConfig+0x6c>
 8006f6e:	e786      	b.n	8006e7e <UART_SetConfig+0x146>
        pclk = HAL_RCC_GetPCLK1Freq();
 8006f70:	f7fe ff94 	bl	8005e9c <HAL_RCC_GetPCLK1Freq>
        break;
 8006f74:	e7d2      	b.n	8006f1c <UART_SetConfig+0x1e4>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8006f76:	f5b3 6f40 	cmp.w	r3, #3072	@ 0xc00
 8006f7a:	f47f af13 	bne.w	8006da4 <UART_SetConfig+0x6c>
        pclk = (uint32_t) LSE_VALUE;
 8006f7e:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
 8006f82:	e7cf      	b.n	8006f24 <UART_SetConfig+0x1ec>
        pclk = HAL_RCC_GetPCLK1Freq();
 8006f84:	f7fe ff8a 	bl	8005e9c <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 8006f88:	2800      	cmp	r0, #0
 8006f8a:	f43f af49 	beq.w	8006e20 <UART_SetConfig+0xe8>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8006f8e:	6a65      	ldr	r5, [r4, #36]	@ 0x24
 8006f90:	e77c      	b.n	8006e8c <UART_SetConfig+0x154>
        pclk = HAL_RCC_GetPCLK2Freq();
 8006f92:	f7fe ff95 	bl	8005ec0 <HAL_RCC_GetPCLK2Freq>
        break;
 8006f96:	e7f7      	b.n	8006f88 <UART_SetConfig+0x250>
        pclk = HAL_RCC_GetSysClockFreq();
 8006f98:	f7fe fe3e 	bl	8005c18 <HAL_RCC_GetSysClockFreq>
        break;
 8006f9c:	e7f4      	b.n	8006f88 <UART_SetConfig+0x250>
        pclk = (uint32_t) HSI_VALUE;
 8006f9e:	4809      	ldr	r0, [pc, #36]	@ (8006fc4 <UART_SetConfig+0x28c>)
 8006fa0:	e7c0      	b.n	8006f24 <UART_SetConfig+0x1ec>
 8006fa2:	bf00      	nop
 8006fa4:	cfff69f3 	.word	0xcfff69f3
 8006fa8:	40008000 	.word	0x40008000
 8006fac:	40013800 	.word	0x40013800
 8006fb0:	40004400 	.word	0x40004400
 8006fb4:	40004800 	.word	0x40004800
 8006fb8:	40004c00 	.word	0x40004c00
 8006fbc:	40021000 	.word	0x40021000
 8006fc0:	0800a6bc 	.word	0x0800a6bc
 8006fc4:	00f42400 	.word	0x00f42400
 8006fc8:	000ffcff 	.word	0x000ffcff

08006fcc <UART_AdvFeatureConfig>:
{
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 8006fcc:	6a83      	ldr	r3, [r0, #40]	@ 0x28
 8006fce:	071a      	lsls	r2, r3, #28
{
 8006fd0:	b410      	push	{r4}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 8006fd2:	d506      	bpl.n	8006fe2 <UART_AdvFeatureConfig+0x16>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 8006fd4:	6801      	ldr	r1, [r0, #0]
 8006fd6:	6b84      	ldr	r4, [r0, #56]	@ 0x38
 8006fd8:	684a      	ldr	r2, [r1, #4]
 8006fda:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
 8006fde:	4322      	orrs	r2, r4
 8006fe0:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8006fe2:	07dc      	lsls	r4, r3, #31
 8006fe4:	d506      	bpl.n	8006ff4 <UART_AdvFeatureConfig+0x28>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 8006fe6:	6801      	ldr	r1, [r0, #0]
 8006fe8:	6ac4      	ldr	r4, [r0, #44]	@ 0x2c
 8006fea:	684a      	ldr	r2, [r1, #4]
 8006fec:	f422 3200 	bic.w	r2, r2, #131072	@ 0x20000
 8006ff0:	4322      	orrs	r2, r4
 8006ff2:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 8006ff4:	0799      	lsls	r1, r3, #30
 8006ff6:	d506      	bpl.n	8007006 <UART_AdvFeatureConfig+0x3a>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 8006ff8:	6801      	ldr	r1, [r0, #0]
 8006ffa:	6b04      	ldr	r4, [r0, #48]	@ 0x30
 8006ffc:	684a      	ldr	r2, [r1, #4]
 8006ffe:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 8007002:	4322      	orrs	r2, r4
 8007004:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 8007006:	075a      	lsls	r2, r3, #29
 8007008:	d506      	bpl.n	8007018 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 800700a:	6801      	ldr	r1, [r0, #0]
 800700c:	6b44      	ldr	r4, [r0, #52]	@ 0x34
 800700e:	684a      	ldr	r2, [r1, #4]
 8007010:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
 8007014:	4322      	orrs	r2, r4
 8007016:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8007018:	06dc      	lsls	r4, r3, #27
 800701a:	d506      	bpl.n	800702a <UART_AdvFeatureConfig+0x5e>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 800701c:	6801      	ldr	r1, [r0, #0]
 800701e:	6bc4      	ldr	r4, [r0, #60]	@ 0x3c
 8007020:	688a      	ldr	r2, [r1, #8]
 8007022:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
 8007026:	4322      	orrs	r2, r4
 8007028:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 800702a:	0699      	lsls	r1, r3, #26
 800702c:	d506      	bpl.n	800703c <UART_AdvFeatureConfig+0x70>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 800702e:	6801      	ldr	r1, [r0, #0]
 8007030:	6c04      	ldr	r4, [r0, #64]	@ 0x40
 8007032:	688a      	ldr	r2, [r1, #8]
 8007034:	f422 5200 	bic.w	r2, r2, #8192	@ 0x2000
 8007038:	4322      	orrs	r2, r4
 800703a:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 800703c:	065a      	lsls	r2, r3, #25
 800703e:	d509      	bpl.n	8007054 <UART_AdvFeatureConfig+0x88>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8007040:	6801      	ldr	r1, [r0, #0]
 8007042:	6c44      	ldr	r4, [r0, #68]	@ 0x44
 8007044:	684a      	ldr	r2, [r1, #4]
 8007046:	f422 1280 	bic.w	r2, r2, #1048576	@ 0x100000
 800704a:	4322      	orrs	r2, r4
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800704c:	f5b4 1f80 	cmp.w	r4, #1048576	@ 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8007050:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8007052:	d00b      	beq.n	800706c <UART_AdvFeatureConfig+0xa0>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 8007054:	061b      	lsls	r3, r3, #24
 8007056:	d506      	bpl.n	8007066 <UART_AdvFeatureConfig+0x9a>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8007058:	6802      	ldr	r2, [r0, #0]
 800705a:	6cc1      	ldr	r1, [r0, #76]	@ 0x4c
 800705c:	6853      	ldr	r3, [r2, #4]
 800705e:	f423 2300 	bic.w	r3, r3, #524288	@ 0x80000
 8007062:	430b      	orrs	r3, r1
 8007064:	6053      	str	r3, [r2, #4]
  }
}
 8007066:	f85d 4b04 	ldr.w	r4, [sp], #4
 800706a:	4770      	bx	lr
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 800706c:	684a      	ldr	r2, [r1, #4]
 800706e:	6c84      	ldr	r4, [r0, #72]	@ 0x48
 8007070:	f422 02c0 	bic.w	r2, r2, #6291456	@ 0x600000
 8007074:	4322      	orrs	r2, r4
 8007076:	604a      	str	r2, [r1, #4]
 8007078:	e7ec      	b.n	8007054 <UART_AdvFeatureConfig+0x88>
 800707a:	bf00      	nop

0800707c <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 800707c:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800707e:	2300      	movs	r3, #0
{
 8007080:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8007082:	f8c0 3090 	str.w	r3, [r0, #144]	@ 0x90

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
 8007086:	f7fd f901 	bl	800428c <HAL_GetTick>

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800708a:	6822      	ldr	r2, [r4, #0]
 800708c:	6813      	ldr	r3, [r2, #0]
 800708e:	071b      	lsls	r3, r3, #28
  tickstart = HAL_GetTick();
 8007090:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8007092:	d40f      	bmi.n	80070b4 <UART_CheckIdleState+0x38>
      return HAL_TIMEOUT;
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 8007094:	6813      	ldr	r3, [r2, #0]
 8007096:	0759      	lsls	r1, r3, #29
 8007098:	d431      	bmi.n	80070fe <UART_CheckIdleState+0x82>
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
  huart->RxState = HAL_UART_STATE_READY;
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800709a:	2300      	movs	r3, #0
  huart->gState = HAL_UART_STATE_READY;
 800709c:	2220      	movs	r2, #32
 800709e:	f8c4 2088 	str.w	r2, [r4, #136]	@ 0x88
  huart->RxEventType = HAL_UART_RXEVENT_TC;

  __HAL_UNLOCK(huart);

  return HAL_OK;
 80070a2:	4618      	mov	r0, r3
  huart->RxState = HAL_UART_STATE_READY;
 80070a4:	f8c4 208c 	str.w	r2, [r4, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80070a8:	66e3      	str	r3, [r4, #108]	@ 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
 80070aa:	6723      	str	r3, [r4, #112]	@ 0x70
      __HAL_UNLOCK(huart);
 80070ac:	2300      	movs	r3, #0
 80070ae:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
}
 80070b2:	bd38      	pop	{r3, r4, r5, pc}
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80070b4:	69d3      	ldr	r3, [r2, #28]
 80070b6:	0298      	lsls	r0, r3, #10
 80070b8:	d4ec      	bmi.n	8007094 <UART_CheckIdleState+0x18>
 80070ba:	e00c      	b.n	80070d6 <UART_CheckIdleState+0x5a>
      {

        return HAL_TIMEOUT;
      }

      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
 80070bc:	6819      	ldr	r1, [r3, #0]
 80070be:	0749      	lsls	r1, r1, #29
 80070c0:	461a      	mov	r2, r3
 80070c2:	d505      	bpl.n	80070d0 <UART_CheckIdleState+0x54>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
 80070c4:	69d9      	ldr	r1, [r3, #28]
 80070c6:	0708      	lsls	r0, r1, #28
 80070c8:	d44a      	bmi.n	8007160 <UART_CheckIdleState+0xe4>
          /* Process Unlocked */
          __HAL_UNLOCK(huart);

          return HAL_ERROR;
        }
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 80070ca:	69d9      	ldr	r1, [r3, #28]
 80070cc:	0509      	lsls	r1, r1, #20
 80070ce:	d475      	bmi.n	80071bc <UART_CheckIdleState+0x140>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80070d0:	69db      	ldr	r3, [r3, #28]
 80070d2:	0298      	lsls	r0, r3, #10
 80070d4:	d4de      	bmi.n	8007094 <UART_CheckIdleState+0x18>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80070d6:	f7fd f8d9 	bl	800428c <HAL_GetTick>
 80070da:	1b43      	subs	r3, r0, r5
 80070dc:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
 80070e0:	6823      	ldr	r3, [r4, #0]
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80070e2:	d3eb      	bcc.n	80070bc <UART_CheckIdleState+0x40>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80070e4:	e853 2f00 	ldrex	r2, [r3]
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE));
 80070e8:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80070ec:	e843 2100 	strex	r1, r2, [r3]
 80070f0:	2900      	cmp	r1, #0
 80070f2:	d1f7      	bne.n	80070e4 <UART_CheckIdleState+0x68>
      huart->gState = HAL_UART_STATE_READY;
 80070f4:	2320      	movs	r3, #32
 80070f6:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
      return HAL_TIMEOUT;
 80070fa:	2003      	movs	r0, #3
 80070fc:	e7d6      	b.n	80070ac <UART_CheckIdleState+0x30>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80070fe:	69d3      	ldr	r3, [r2, #28]
 8007100:	025b      	lsls	r3, r3, #9
 8007102:	d4ca      	bmi.n	800709a <UART_CheckIdleState+0x1e>
 8007104:	e00d      	b.n	8007122 <UART_CheckIdleState+0xa6>
      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
 8007106:	681a      	ldr	r2, [r3, #0]
 8007108:	0750      	lsls	r0, r2, #29
 800710a:	d507      	bpl.n	800711c <UART_CheckIdleState+0xa0>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
 800710c:	69da      	ldr	r2, [r3, #28]
 800710e:	0711      	lsls	r1, r2, #28
 8007110:	f100 8082 	bmi.w	8007218 <UART_CheckIdleState+0x19c>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 8007114:	69da      	ldr	r2, [r3, #28]
 8007116:	0512      	lsls	r2, r2, #20
 8007118:	f100 80ac 	bmi.w	8007274 <UART_CheckIdleState+0x1f8>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800711c:	69db      	ldr	r3, [r3, #28]
 800711e:	025b      	lsls	r3, r3, #9
 8007120:	d4bb      	bmi.n	800709a <UART_CheckIdleState+0x1e>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8007122:	f7fd f8b3 	bl	800428c <HAL_GetTick>
 8007126:	1b43      	subs	r3, r0, r5
 8007128:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 800712c:	6823      	ldr	r3, [r4, #0]
 800712e:	d3ea      	bcc.n	8007106 <UART_CheckIdleState+0x8a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8007130:	e853 2f00 	ldrex	r2, [r3]
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 8007134:	f422 7290 	bic.w	r2, r2, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8007138:	e843 2100 	strex	r1, r2, [r3]
 800713c:	2900      	cmp	r1, #0
 800713e:	d1f7      	bne.n	8007130 <UART_CheckIdleState+0xb4>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8007140:	f103 0208 	add.w	r2, r3, #8
 8007144:	e852 2f00 	ldrex	r2, [r2]
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8007148:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800714c:	f103 0008 	add.w	r0, r3, #8
 8007150:	e840 2100 	strex	r1, r2, [r0]
 8007154:	2900      	cmp	r1, #0
 8007156:	d1f3      	bne.n	8007140 <UART_CheckIdleState+0xc4>
      huart->RxState = HAL_UART_STATE_READY;
 8007158:	2320      	movs	r3, #32
 800715a:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
      return HAL_TIMEOUT;
 800715e:	e7cc      	b.n	80070fa <UART_CheckIdleState+0x7e>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 8007160:	2208      	movs	r2, #8
 8007162:	621a      	str	r2, [r3, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8007164:	e853 2f00 	ldrex	r2, [r3]
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 8007168:	f422 7290 	bic.w	r2, r2, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800716c:	e843 2100 	strex	r1, r2, [r3]
 8007170:	2900      	cmp	r1, #0
 8007172:	d1f7      	bne.n	8007164 <UART_CheckIdleState+0xe8>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 8007174:	4856      	ldr	r0, [pc, #344]	@ (80072d0 <UART_CheckIdleState+0x254>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8007176:	f103 0208 	add.w	r2, r3, #8
 800717a:	e852 2f00 	ldrex	r2, [r2]
 800717e:	4002      	ands	r2, r0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8007180:	f103 0508 	add.w	r5, r3, #8
 8007184:	e845 2100 	strex	r1, r2, [r5]
 8007188:	2900      	cmp	r1, #0
 800718a:	d1f4      	bne.n	8007176 <UART_CheckIdleState+0xfa>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800718c:	6ee2      	ldr	r2, [r4, #108]	@ 0x6c
 800718e:	2a01      	cmp	r2, #1
 8007190:	d00b      	beq.n	80071aa <UART_CheckIdleState+0x12e>
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8007192:	2200      	movs	r2, #0
  huart->RxState = HAL_UART_STATE_READY;
 8007194:	2020      	movs	r0, #32
          huart->ErrorCode = HAL_UART_ERROR_ORE;
 8007196:	2108      	movs	r1, #8
  huart->RxState = HAL_UART_STATE_READY;
 8007198:	f8c4 008c 	str.w	r0, [r4, #140]	@ 0x8c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 800719c:	6762      	str	r2, [r4, #116]	@ 0x74
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800719e:	66e2      	str	r2, [r4, #108]	@ 0x6c
          __HAL_UNLOCK(huart);
 80071a0:	f884 2084 	strb.w	r2, [r4, #132]	@ 0x84
          huart->ErrorCode = HAL_UART_ERROR_ORE;
 80071a4:	f8c4 1090 	str.w	r1, [r4, #144]	@ 0x90
          return HAL_ERROR;
 80071a8:	e79c      	b.n	80070e4 <UART_CheckIdleState+0x68>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80071aa:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 80071ae:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80071b2:	e843 2100 	strex	r1, r2, [r3]
 80071b6:	2900      	cmp	r1, #0
 80071b8:	d1f7      	bne.n	80071aa <UART_CheckIdleState+0x12e>
 80071ba:	e7ea      	b.n	8007192 <UART_CheckIdleState+0x116>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 80071bc:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 80071c0:	621a      	str	r2, [r3, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80071c2:	e853 2f00 	ldrex	r2, [r3]
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 80071c6:	f422 7290 	bic.w	r2, r2, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80071ca:	e843 2100 	strex	r1, r2, [r3]
 80071ce:	2900      	cmp	r1, #0
 80071d0:	d1f7      	bne.n	80071c2 <UART_CheckIdleState+0x146>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 80071d2:	483f      	ldr	r0, [pc, #252]	@ (80072d0 <UART_CheckIdleState+0x254>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80071d4:	f103 0208 	add.w	r2, r3, #8
 80071d8:	e852 2f00 	ldrex	r2, [r2]
 80071dc:	4002      	ands	r2, r0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80071de:	f103 0508 	add.w	r5, r3, #8
 80071e2:	e845 2100 	strex	r1, r2, [r5]
 80071e6:	2900      	cmp	r1, #0
 80071e8:	d1f4      	bne.n	80071d4 <UART_CheckIdleState+0x158>
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 80071ea:	6ee2      	ldr	r2, [r4, #108]	@ 0x6c
 80071ec:	2a01      	cmp	r2, #1
 80071ee:	d00a      	beq.n	8007206 <UART_CheckIdleState+0x18a>
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80071f0:	2200      	movs	r2, #0
  huart->RxState = HAL_UART_STATE_READY;
 80071f2:	2120      	movs	r1, #32
 80071f4:	f8c4 108c 	str.w	r1, [r4, #140]	@ 0x8c
  huart->RxISR = NULL;
 80071f8:	6762      	str	r2, [r4, #116]	@ 0x74
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80071fa:	66e2      	str	r2, [r4, #108]	@ 0x6c
          __HAL_UNLOCK(huart);
 80071fc:	f884 2084 	strb.w	r2, [r4, #132]	@ 0x84
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 8007200:	f8c4 1090 	str.w	r1, [r4, #144]	@ 0x90
          return HAL_TIMEOUT;
 8007204:	e76e      	b.n	80070e4 <UART_CheckIdleState+0x68>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8007206:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800720a:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800720e:	e843 2100 	strex	r1, r2, [r3]
 8007212:	2900      	cmp	r1, #0
 8007214:	d1f7      	bne.n	8007206 <UART_CheckIdleState+0x18a>
 8007216:	e7eb      	b.n	80071f0 <UART_CheckIdleState+0x174>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 8007218:	2208      	movs	r2, #8
 800721a:	621a      	str	r2, [r3, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800721c:	e853 2f00 	ldrex	r2, [r3]
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 8007220:	f422 7290 	bic.w	r2, r2, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8007224:	e843 2100 	strex	r1, r2, [r3]
 8007228:	2900      	cmp	r1, #0
 800722a:	d1f7      	bne.n	800721c <UART_CheckIdleState+0x1a0>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 800722c:	4828      	ldr	r0, [pc, #160]	@ (80072d0 <UART_CheckIdleState+0x254>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800722e:	f103 0208 	add.w	r2, r3, #8
 8007232:	e852 2f00 	ldrex	r2, [r2]
 8007236:	4002      	ands	r2, r0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8007238:	f103 0508 	add.w	r5, r3, #8
 800723c:	e845 2100 	strex	r1, r2, [r5]
 8007240:	2900      	cmp	r1, #0
 8007242:	d1f4      	bne.n	800722e <UART_CheckIdleState+0x1b2>
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8007244:	6ee2      	ldr	r2, [r4, #108]	@ 0x6c
 8007246:	2a01      	cmp	r2, #1
 8007248:	d00b      	beq.n	8007262 <UART_CheckIdleState+0x1e6>
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800724a:	2200      	movs	r2, #0
  huart->RxState = HAL_UART_STATE_READY;
 800724c:	2020      	movs	r0, #32
          huart->ErrorCode = HAL_UART_ERROR_ORE;
 800724e:	2108      	movs	r1, #8
  huart->RxState = HAL_UART_STATE_READY;
 8007250:	f8c4 008c 	str.w	r0, [r4, #140]	@ 0x8c
  huart->RxISR = NULL;
 8007254:	6762      	str	r2, [r4, #116]	@ 0x74
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8007256:	66e2      	str	r2, [r4, #108]	@ 0x6c
          __HAL_UNLOCK(huart);
 8007258:	f884 2084 	strb.w	r2, [r4, #132]	@ 0x84
          huart->ErrorCode = HAL_UART_ERROR_ORE;
 800725c:	f8c4 1090 	str.w	r1, [r4, #144]	@ 0x90
          return HAL_ERROR;
 8007260:	e766      	b.n	8007130 <UART_CheckIdleState+0xb4>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8007262:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8007266:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800726a:	e843 2100 	strex	r1, r2, [r3]
 800726e:	2900      	cmp	r1, #0
 8007270:	d1f7      	bne.n	8007262 <UART_CheckIdleState+0x1e6>
 8007272:	e7ea      	b.n	800724a <UART_CheckIdleState+0x1ce>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 8007274:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 8007278:	621a      	str	r2, [r3, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800727a:	e853 2f00 	ldrex	r2, [r3]
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 800727e:	f422 7290 	bic.w	r2, r2, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8007282:	e843 2100 	strex	r1, r2, [r3]
 8007286:	2900      	cmp	r1, #0
 8007288:	d1f7      	bne.n	800727a <UART_CheckIdleState+0x1fe>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 800728a:	4811      	ldr	r0, [pc, #68]	@ (80072d0 <UART_CheckIdleState+0x254>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800728c:	f103 0208 	add.w	r2, r3, #8
 8007290:	e852 2f00 	ldrex	r2, [r2]
 8007294:	4002      	ands	r2, r0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8007296:	f103 0508 	add.w	r5, r3, #8
 800729a:	e845 2100 	strex	r1, r2, [r5]
 800729e:	2900      	cmp	r1, #0
 80072a0:	d1f4      	bne.n	800728c <UART_CheckIdleState+0x210>
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 80072a2:	6ee2      	ldr	r2, [r4, #108]	@ 0x6c
 80072a4:	2a01      	cmp	r2, #1
 80072a6:	d00a      	beq.n	80072be <UART_CheckIdleState+0x242>
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80072a8:	2200      	movs	r2, #0
  huart->RxState = HAL_UART_STATE_READY;
 80072aa:	2120      	movs	r1, #32
 80072ac:	f8c4 108c 	str.w	r1, [r4, #140]	@ 0x8c
  huart->RxISR = NULL;
 80072b0:	6762      	str	r2, [r4, #116]	@ 0x74
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80072b2:	66e2      	str	r2, [r4, #108]	@ 0x6c
          __HAL_UNLOCK(huart);
 80072b4:	f884 2084 	strb.w	r2, [r4, #132]	@ 0x84
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 80072b8:	f8c4 1090 	str.w	r1, [r4, #144]	@ 0x90
          return HAL_TIMEOUT;
 80072bc:	e738      	b.n	8007130 <UART_CheckIdleState+0xb4>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80072be:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 80072c2:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80072c6:	e843 2100 	strex	r1, r2, [r3]
 80072ca:	2900      	cmp	r1, #0
 80072cc:	d1f7      	bne.n	80072be <UART_CheckIdleState+0x242>
 80072ce:	e7eb      	b.n	80072a8 <UART_CheckIdleState+0x22c>
 80072d0:	effffffe 	.word	0xeffffffe

080072d4 <HAL_UART_Init>:
  if (huart == NULL)
 80072d4:	b380      	cbz	r0, 8007338 <HAL_UART_Init+0x64>
  if (huart->gState == HAL_UART_STATE_RESET)
 80072d6:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
{
 80072da:	b510      	push	{r4, lr}
 80072dc:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_RESET)
 80072de:	b333      	cbz	r3, 800732e <HAL_UART_Init+0x5a>
  __HAL_UART_DISABLE(huart);
 80072e0:	6822      	ldr	r2, [r4, #0]
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 80072e2:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
  huart->gState = HAL_UART_STATE_BUSY;
 80072e4:	2324      	movs	r3, #36	@ 0x24
 80072e6:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  __HAL_UART_DISABLE(huart);
 80072ea:	6813      	ldr	r3, [r2, #0]
 80072ec:	f023 0301 	bic.w	r3, r3, #1
 80072f0:	6013      	str	r3, [r2, #0]
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 80072f2:	b9c1      	cbnz	r1, 8007326 <HAL_UART_Init+0x52>
  if (UART_SetConfig(huart) == HAL_ERROR)
 80072f4:	4620      	mov	r0, r4
 80072f6:	f7ff fd1f 	bl	8006d38 <UART_SetConfig>
 80072fa:	2801      	cmp	r0, #1
 80072fc:	d011      	beq.n	8007322 <HAL_UART_Init+0x4e>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 80072fe:	6823      	ldr	r3, [r4, #0]
 8007300:	685a      	ldr	r2, [r3, #4]
 8007302:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
 8007306:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8007308:	689a      	ldr	r2, [r3, #8]
 800730a:	f022 022a 	bic.w	r2, r2, #42	@ 0x2a
 800730e:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 8007310:	681a      	ldr	r2, [r3, #0]
 8007312:	f042 0201 	orr.w	r2, r2, #1
  return (UART_CheckIdleState(huart));
 8007316:	4620      	mov	r0, r4
  __HAL_UART_ENABLE(huart);
 8007318:	601a      	str	r2, [r3, #0]
}
 800731a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return (UART_CheckIdleState(huart));
 800731e:	f7ff bead 	b.w	800707c <UART_CheckIdleState>
}
 8007322:	2001      	movs	r0, #1
 8007324:	bd10      	pop	{r4, pc}
    UART_AdvFeatureConfig(huart);
 8007326:	4620      	mov	r0, r4
 8007328:	f7ff fe50 	bl	8006fcc <UART_AdvFeatureConfig>
 800732c:	e7e2      	b.n	80072f4 <HAL_UART_Init+0x20>
    huart->Lock = HAL_UNLOCKED;
 800732e:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
    HAL_UART_MspInit(huart);
 8007332:	f7fc fdf1 	bl	8003f18 <HAL_UART_MspInit>
 8007336:	e7d3      	b.n	80072e0 <HAL_UART_Init+0xc>
}
 8007338:	2001      	movs	r0, #1
 800733a:	4770      	bx	lr

0800733c <HAL_UARTEx_DisableFifoMode>:

  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));

  /* Process Locked */
  __HAL_LOCK(huart);
 800733c:	f890 3084 	ldrb.w	r3, [r0, #132]	@ 0x84
 8007340:	2b01      	cmp	r3, #1
 8007342:	d017      	beq.n	8007374 <HAL_UARTEx_DisableFifoMode+0x38>

  huart->gState = HAL_UART_STATE_BUSY;

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8007344:	6802      	ldr	r2, [r0, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 8007346:	2324      	movs	r3, #36	@ 0x24
{
 8007348:	b410      	push	{r4}
  huart->gState = HAL_UART_STATE_BUSY;
 800734a:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  tmpcr1 = READ_REG(huart->Instance->CR1);
 800734e:	6811      	ldr	r1, [r2, #0]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 8007350:	6814      	ldr	r4, [r2, #0]

  /* Disable FIFO mode */
  CLEAR_BIT(tmpcr1, USART_CR1_FIFOEN);
  huart->FifoMode = UART_FIFOMODE_DISABLE;
 8007352:	2300      	movs	r3, #0
  __HAL_UART_DISABLE(huart);
 8007354:	f024 0401 	bic.w	r4, r4, #1
  CLEAR_BIT(tmpcr1, USART_CR1_FIFOEN);
 8007358:	f021 5100 	bic.w	r1, r1, #536870912	@ 0x20000000
  __HAL_UART_DISABLE(huart);
 800735c:	6014      	str	r4, [r2, #0]
  huart->FifoMode = UART_FIFOMODE_DISABLE;
 800735e:	6643      	str	r3, [r0, #100]	@ 0x64

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8007360:	6011      	str	r1, [r2, #0]

  huart->gState = HAL_UART_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 8007362:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
  huart->gState = HAL_UART_STATE_READY;
 8007366:	2220      	movs	r2, #32
 8007368:	f8c0 2088 	str.w	r2, [r0, #136]	@ 0x88

  return HAL_OK;
}
 800736c:	f85d 4b04 	ldr.w	r4, [sp], #4
  return HAL_OK;
 8007370:	4618      	mov	r0, r3
}
 8007372:	4770      	bx	lr
  __HAL_LOCK(huart);
 8007374:	2002      	movs	r0, #2
}
 8007376:	4770      	bx	lr

08007378 <HAL_UARTEx_SetTxFifoThreshold>:
  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
  assert_param(IS_UART_TXFIFO_THRESHOLD(Threshold));

  /* Process Locked */
  __HAL_LOCK(huart);
 8007378:	f890 2084 	ldrb.w	r2, [r0, #132]	@ 0x84
 800737c:	2a01      	cmp	r2, #1
 800737e:	d037      	beq.n	80073f0 <HAL_UARTEx_SetTxFifoThreshold+0x78>

  huart->gState = HAL_UART_STATE_BUSY;
 8007380:	4603      	mov	r3, r0

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8007382:	6802      	ldr	r2, [r0, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 8007384:	2024      	movs	r0, #36	@ 0x24
{
 8007386:	b530      	push	{r4, r5, lr}
  huart->gState = HAL_UART_STATE_BUSY;
 8007388:	f8c3 0088 	str.w	r0, [r3, #136]	@ 0x88
  tmpcr1 = READ_REG(huart->Instance->CR1);
 800738c:	6814      	ldr	r4, [r2, #0]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 800738e:	6810      	ldr	r0, [r2, #0]
 8007390:	f020 0001 	bic.w	r0, r0, #1
 8007394:	6010      	str	r0, [r2, #0]

  /* Update TX threshold configuration */
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 8007396:	6890      	ldr	r0, [r2, #8]
 8007398:	f020 4060 	bic.w	r0, r0, #3758096384	@ 0xe0000000
 800739c:	4301      	orrs	r1, r0
  uint8_t rx_fifo_threshold;
  uint8_t tx_fifo_threshold;
  static const uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
  static const uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};

  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 800739e:	6e58      	ldr	r0, [r3, #100]	@ 0x64
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 80073a0:	6091      	str	r1, [r2, #8]
  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 80073a2:	b310      	cbz	r0, 80073ea <HAL_UARTEx_SetTxFifoThreshold+0x72>
  }
  else
  {
    rx_fifo_depth = RX_FIFO_DEPTH;
    tx_fifo_depth = TX_FIFO_DEPTH;
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 80073a4:	6891      	ldr	r1, [r2, #8]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 80073a6:	6890      	ldr	r0, [r2, #8]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
                               (uint16_t)denominator[tx_fifo_threshold];
 80073a8:	4d12      	ldr	r5, [pc, #72]	@ (80073f4 <HAL_UARTEx_SetTxFifoThreshold+0x7c>)
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 80073aa:	f3c1 6c42 	ubfx	ip, r1, #25, #3
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 80073ae:	ea4f 7e50 	mov.w	lr, r0, lsr #29
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 80073b2:	4911      	ldr	r1, [pc, #68]	@ (80073f8 <HAL_UARTEx_SetTxFifoThreshold+0x80>)
 80073b4:	f811 000e 	ldrb.w	r0, [r1, lr]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 80073b8:	f811 100c 	ldrb.w	r1, [r1, ip]
                               (uint16_t)denominator[tx_fifo_threshold];
 80073bc:	f815 e00e 	ldrb.w	lr, [r5, lr]
                               (uint16_t)denominator[rx_fifo_threshold];
 80073c0:	f815 500c 	ldrb.w	r5, [r5, ip]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 80073c4:	00c0      	lsls	r0, r0, #3
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 80073c6:	00c9      	lsls	r1, r1, #3
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 80073c8:	fbb0 f0fe 	udiv	r0, r0, lr
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 80073cc:	fbb1 f1f5 	udiv	r1, r1, r5
 80073d0:	f8a3 1068 	strh.w	r1, [r3, #104]	@ 0x68
  __HAL_UNLOCK(huart);
 80073d4:	2100      	movs	r1, #0
 80073d6:	f8a3 006a 	strh.w	r0, [r3, #106]	@ 0x6a
  huart->gState = HAL_UART_STATE_READY;
 80073da:	2520      	movs	r5, #32
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 80073dc:	6014      	str	r4, [r2, #0]
  __HAL_UNLOCK(huart);
 80073de:	f883 1084 	strb.w	r1, [r3, #132]	@ 0x84
  return HAL_OK;
 80073e2:	4608      	mov	r0, r1
  huart->gState = HAL_UART_STATE_READY;
 80073e4:	f8c3 5088 	str.w	r5, [r3, #136]	@ 0x88
}
 80073e8:	bd30      	pop	{r4, r5, pc}
    huart->NbRxDataToProcess = 1U;
 80073ea:	2101      	movs	r1, #1
    huart->NbTxDataToProcess = 1U;
 80073ec:	4608      	mov	r0, r1
 80073ee:	e7ef      	b.n	80073d0 <HAL_UARTEx_SetTxFifoThreshold+0x58>
  __HAL_LOCK(huart);
 80073f0:	2002      	movs	r0, #2
}
 80073f2:	4770      	bx	lr
 80073f4:	0800a6d4 	.word	0x0800a6d4
 80073f8:	0800a6dc 	.word	0x0800a6dc

080073fc <HAL_UARTEx_SetRxFifoThreshold>:
  __HAL_LOCK(huart);
 80073fc:	f890 2084 	ldrb.w	r2, [r0, #132]	@ 0x84
 8007400:	2a01      	cmp	r2, #1
 8007402:	d037      	beq.n	8007474 <HAL_UARTEx_SetRxFifoThreshold+0x78>
  huart->gState = HAL_UART_STATE_BUSY;
 8007404:	4603      	mov	r3, r0
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8007406:	6802      	ldr	r2, [r0, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 8007408:	2024      	movs	r0, #36	@ 0x24
{
 800740a:	b530      	push	{r4, r5, lr}
  huart->gState = HAL_UART_STATE_BUSY;
 800740c:	f8c3 0088 	str.w	r0, [r3, #136]	@ 0x88
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8007410:	6814      	ldr	r4, [r2, #0]
  __HAL_UART_DISABLE(huart);
 8007412:	6810      	ldr	r0, [r2, #0]
 8007414:	f020 0001 	bic.w	r0, r0, #1
 8007418:	6010      	str	r0, [r2, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 800741a:	6890      	ldr	r0, [r2, #8]
 800741c:	f020 6060 	bic.w	r0, r0, #234881024	@ 0xe000000
 8007420:	4301      	orrs	r1, r0
  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 8007422:	6e58      	ldr	r0, [r3, #100]	@ 0x64
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 8007424:	6091      	str	r1, [r2, #8]
  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 8007426:	b310      	cbz	r0, 800746e <HAL_UARTEx_SetRxFifoThreshold+0x72>
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 8007428:	6891      	ldr	r1, [r2, #8]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 800742a:	6890      	ldr	r0, [r2, #8]
                               (uint16_t)denominator[tx_fifo_threshold];
 800742c:	4d12      	ldr	r5, [pc, #72]	@ (8007478 <HAL_UARTEx_SetRxFifoThreshold+0x7c>)
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 800742e:	f3c1 6c42 	ubfx	ip, r1, #25, #3
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 8007432:	ea4f 7e50 	mov.w	lr, r0, lsr #29
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8007436:	4911      	ldr	r1, [pc, #68]	@ (800747c <HAL_UARTEx_SetRxFifoThreshold+0x80>)
 8007438:	f811 000e 	ldrb.w	r0, [r1, lr]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 800743c:	f811 100c 	ldrb.w	r1, [r1, ip]
                               (uint16_t)denominator[tx_fifo_threshold];
 8007440:	f815 e00e 	ldrb.w	lr, [r5, lr]
                               (uint16_t)denominator[rx_fifo_threshold];
 8007444:	f815 500c 	ldrb.w	r5, [r5, ip]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8007448:	00c0      	lsls	r0, r0, #3
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 800744a:	00c9      	lsls	r1, r1, #3
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 800744c:	fbb0 f0fe 	udiv	r0, r0, lr
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8007450:	fbb1 f1f5 	udiv	r1, r1, r5
 8007454:	f8a3 1068 	strh.w	r1, [r3, #104]	@ 0x68
  __HAL_UNLOCK(huart);
 8007458:	2100      	movs	r1, #0
 800745a:	f8a3 006a 	strh.w	r0, [r3, #106]	@ 0x6a
  huart->gState = HAL_UART_STATE_READY;
 800745e:	2520      	movs	r5, #32
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8007460:	6014      	str	r4, [r2, #0]
  __HAL_UNLOCK(huart);
 8007462:	f883 1084 	strb.w	r1, [r3, #132]	@ 0x84
  return HAL_OK;
 8007466:	4608      	mov	r0, r1
  huart->gState = HAL_UART_STATE_READY;
 8007468:	f8c3 5088 	str.w	r5, [r3, #136]	@ 0x88
}
 800746c:	bd30      	pop	{r4, r5, pc}
    huart->NbRxDataToProcess = 1U;
 800746e:	2101      	movs	r1, #1
    huart->NbTxDataToProcess = 1U;
 8007470:	4608      	mov	r0, r1
 8007472:	e7ef      	b.n	8007454 <HAL_UARTEx_SetRxFifoThreshold+0x58>
  __HAL_LOCK(huart);
 8007474:	2002      	movs	r0, #2
}
 8007476:	4770      	bx	lr
 8007478:	0800a6d4 	.word	0x0800a6d4
 800747c:	0800a6dc 	.word	0x0800a6dc

08007480 <osKernelStart>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osKernelStart (void)
{
 8007480:	b508      	push	{r3, lr}
  vTaskStartScheduler();
 8007482:	f000 fe15 	bl	80080b0 <vTaskStartScheduler>
  
  return osOK;
}
 8007486:	2000      	movs	r0, #0
 8007488:	bd08      	pop	{r3, pc}
 800748a:	bf00      	nop

0800748c <osThreadCreate>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
 800748c:	b510      	push	{r4, lr}
 800748e:	4684      	mov	ip, r0
 8007490:	460b      	mov	r3, r1

    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
              thread_def->buffer, thread_def->controlblock);
#else
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8007492:	f8bc 2010 	ldrh.w	r2, [ip, #16]
 8007496:	f8dc 1000 	ldr.w	r1, [ip]
                   thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
 800749a:	f9bc c008 	ldrsh.w	ip, [ip, #8]
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 800749e:	6840      	ldr	r0, [r0, #4]
{
 80074a0:	b084      	sub	sp, #16
  if (priority != osPriorityError) {
 80074a2:	f1bc 0f84 	cmp.w	ip, #132	@ 0x84
    fpriority += (priority - osPriorityIdle);
 80074a6:	bf14      	ite	ne
 80074a8:	f10c 0403 	addne.w	r4, ip, #3
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 80074ac:	2400      	moveq	r4, #0
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 80074ae:	9400      	str	r4, [sp, #0]
 80074b0:	ac03      	add	r4, sp, #12
 80074b2:	9401      	str	r4, [sp, #4]
 80074b4:	f000 fcbe 	bl	8007e34 <xTaskCreate>
 80074b8:	2801      	cmp	r0, #1
                   &handle) != pdPASS)  {
    return NULL;
  }     
#endif
  
  return handle;
 80074ba:	bf0c      	ite	eq
 80074bc:	9803      	ldreq	r0, [sp, #12]
    return NULL;
 80074be:	2000      	movne	r0, #0
}
 80074c0:	b004      	add	sp, #16
 80074c2:	bd10      	pop	{r4, pc}

080074c4 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 80074c4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80074c8:	4604      	mov	r4, r0
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
 80074ca:	f000 fed5 	bl	8008278 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
 80074ce:	4a51      	ldr	r2, [pc, #324]	@ (8007614 <pvPortMalloc+0x150>)
 80074d0:	6815      	ldr	r5, [r2, #0]
 80074d2:	2d00      	cmp	r5, #0
 80074d4:	d035      	beq.n	8007542 <pvPortMalloc+0x7e>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 80074d6:	4b50      	ldr	r3, [pc, #320]	@ (8007618 <pvPortMalloc+0x154>)
 80074d8:	681e      	ldr	r6, [r3, #0]
 80074da:	4234      	tst	r4, r6
 80074dc:	d12b      	bne.n	8007536 <pvPortMalloc+0x72>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
 80074de:	b354      	cbz	r4, 8007536 <pvPortMalloc+0x72>
			{
				xWantedSize += xHeapStructSize;
 80074e0:	f104 0008 	add.w	r0, r4, #8

				/* Ensure that blocks are always aligned to the required number
				of bytes. */
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 80074e4:	0764      	lsls	r4, r4, #29
				{
					/* Byte alignment required. */
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 80074e6:	bf1c      	itt	ne
 80074e8:	f020 0007 	bicne.w	r0, r0, #7
 80074ec:	3008      	addne	r0, #8
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 80074ee:	b310      	cbz	r0, 8007536 <pvPortMalloc+0x72>
 80074f0:	f8df e138 	ldr.w	lr, [pc, #312]	@ 800762c <pvPortMalloc+0x168>
 80074f4:	f8de c000 	ldr.w	ip, [lr]
 80074f8:	4584      	cmp	ip, r0
 80074fa:	d31c      	bcc.n	8007536 <pvPortMalloc+0x72>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
 80074fc:	4c47      	ldr	r4, [pc, #284]	@ (800761c <pvPortMalloc+0x158>)
 80074fe:	6823      	ldr	r3, [r4, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8007500:	e003      	b.n	800750a <pvPortMalloc+0x46>
 8007502:	681a      	ldr	r2, [r3, #0]
 8007504:	b122      	cbz	r2, 8007510 <pvPortMalloc+0x4c>
 8007506:	461c      	mov	r4, r3
 8007508:	4613      	mov	r3, r2
 800750a:	6859      	ldr	r1, [r3, #4]
 800750c:	4281      	cmp	r1, r0
 800750e:	d3f8      	bcc.n	8007502 <pvPortMalloc+0x3e>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
 8007510:	42ab      	cmp	r3, r5
 8007512:	d010      	beq.n	8007536 <pvPortMalloc+0x72>
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8007514:	681a      	ldr	r2, [r3, #0]
 8007516:	6022      	str	r2, [r4, #0]

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 8007518:	1a0a      	subs	r2, r1, r0
 800751a:	2a10      	cmp	r2, #16
 800751c:	d946      	bls.n	80075ac <pvPortMalloc+0xe8>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 800751e:	181c      	adds	r4, r3, r0
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 8007520:	0761      	lsls	r1, r4, #29
 8007522:	d02c      	beq.n	800757e <pvPortMalloc+0xba>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 8007524:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007528:	f383 8811 	msr	BASEPRI, r3
 800752c:	f3bf 8f6f 	isb	sy
 8007530:	f3bf 8f4f 	dsb	sy
 8007534:	e7fe      	b.n	8007534 <pvPortMalloc+0x70>
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 8007536:	f000 fea7 	bl	8008288 <xTaskResumeAll>
void *pvReturn = NULL;
 800753a:	2400      	movs	r4, #0
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
 800753c:	4620      	mov	r0, r4
 800753e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;
 8007542:	4b37      	ldr	r3, [pc, #220]	@ (8007620 <pvPortMalloc+0x15c>)

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8007544:	4835      	ldr	r0, [pc, #212]	@ (800761c <pvPortMalloc+0x158>)
	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8007546:	4f34      	ldr	r7, [pc, #208]	@ (8007618 <pvPortMalloc+0x154>)
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 8007548:	075d      	lsls	r5, r3, #29
	uxAddress -= xHeapStructSize;
 800754a:	4d36      	ldr	r5, [pc, #216]	@ (8007624 <pvPortMalloc+0x160>)
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 800754c:	bf18      	it	ne
 800754e:	3307      	addne	r3, #7
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8007550:	f025 0507 	bic.w	r5, r5, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8007554:	bf18      	it	ne
 8007556:	f023 0307 	bicne.w	r3, r3, #7
	pxEnd = ( void * ) uxAddress;
 800755a:	6015      	str	r5, [r2, #0]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800755c:	4a32      	ldr	r2, [pc, #200]	@ (8007628 <pvPortMalloc+0x164>)
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 800755e:	6003      	str	r3, [r0, #0]
 8007560:	4619      	mov	r1, r3
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 8007562:	1aeb      	subs	r3, r5, r3
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8007564:	6013      	str	r3, [r2, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8007566:	4a31      	ldr	r2, [pc, #196]	@ (800762c <pvPortMalloc+0x168>)
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8007568:	f04f 4600 	mov.w	r6, #2147483648	@ 0x80000000
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800756c:	6013      	str	r3, [r2, #0]
	xStart.xBlockSize = ( size_t ) 0;
 800756e:	2200      	movs	r2, #0
 8007570:	6042      	str	r2, [r0, #4]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8007572:	603e      	str	r6, [r7, #0]
	pxEnd->pxNextFreeBlock = NULL;
 8007574:	e9c5 2200 	strd	r2, r2, [r5]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 8007578:	e9c1 5300 	strd	r5, r3, [r1]
}
 800757c:	e7ad      	b.n	80074da <pvPortMalloc+0x16>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 800757e:	6062      	str	r2, [r4, #4]
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 8007580:	4a26      	ldr	r2, [pc, #152]	@ (800761c <pvPortMalloc+0x158>)
						pxBlock->xBlockSize = xWantedSize;
 8007582:	6058      	str	r0, [r3, #4]
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 8007584:	4617      	mov	r7, r2
 8007586:	6812      	ldr	r2, [r2, #0]
 8007588:	4294      	cmp	r4, r2
 800758a:	d8fb      	bhi.n	8007584 <pvPortMalloc+0xc0>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 800758c:	6879      	ldr	r1, [r7, #4]
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 800758e:	f8d4 8004 	ldr.w	r8, [r4, #4]
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 8007592:	eb07 0901 	add.w	r9, r7, r1
 8007596:	454c      	cmp	r4, r9
 8007598:	d028      	beq.n	80075ec <pvPortMalloc+0x128>
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 800759a:	eb04 0108 	add.w	r1, r4, r8
 800759e:	428a      	cmp	r2, r1
 80075a0:	d02e      	beq.n	8007600 <pvPortMalloc+0x13c>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 80075a2:	6022      	str	r2, [r4, #0]
 80075a4:	4601      	mov	r1, r0

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 80075a6:	42a7      	cmp	r7, r4
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 80075a8:	bf18      	it	ne
 80075aa:	603c      	strne	r4, [r7, #0]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 80075ac:	481e      	ldr	r0, [pc, #120]	@ (8007628 <pvPortMalloc+0x164>)
 80075ae:	6804      	ldr	r4, [r0, #0]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 80075b0:	ebac 0201 	sub.w	r2, ip, r1
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 80075b4:	42a2      	cmp	r2, r4
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 80075b6:	bf38      	it	cc
 80075b8:	6002      	strcc	r2, [r0, #0]
					xNumberOfSuccessfulAllocations++;
 80075ba:	481d      	ldr	r0, [pc, #116]	@ (8007630 <pvPortMalloc+0x16c>)
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 80075bc:	f8ce 2000 	str.w	r2, [lr]
					xNumberOfSuccessfulAllocations++;
 80075c0:	6802      	ldr	r2, [r0, #0]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 80075c2:	4331      	orrs	r1, r6
					pxBlock->pxNextFreeBlock = NULL;
 80075c4:	2500      	movs	r5, #0
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 80075c6:	f103 0408 	add.w	r4, r3, #8
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 80075ca:	6059      	str	r1, [r3, #4]
					xNumberOfSuccessfulAllocations++;
 80075cc:	3201      	adds	r2, #1
					pxBlock->pxNextFreeBlock = NULL;
 80075ce:	601d      	str	r5, [r3, #0]
					xNumberOfSuccessfulAllocations++;
 80075d0:	6002      	str	r2, [r0, #0]
	( void ) xTaskResumeAll();
 80075d2:	f000 fe59 	bl	8008288 <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 80075d6:	0763      	lsls	r3, r4, #29
 80075d8:	d0b0      	beq.n	800753c <pvPortMalloc+0x78>
 80075da:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80075de:	f383 8811 	msr	BASEPRI, r3
 80075e2:	f3bf 8f6f 	isb	sy
 80075e6:	f3bf 8f4f 	dsb	sy
 80075ea:	e7fe      	b.n	80075ea <pvPortMalloc+0x126>
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 80075ec:	4488      	add	r8, r1
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 80075ee:	eb07 0108 	add.w	r1, r7, r8
 80075f2:	428a      	cmp	r2, r1
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 80075f4:	f8c7 8004 	str.w	r8, [r7, #4]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 80075f8:	d001      	beq.n	80075fe <pvPortMalloc+0x13a>
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 80075fa:	6859      	ldr	r1, [r3, #4]
 80075fc:	e7d6      	b.n	80075ac <pvPortMalloc+0xe8>
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 80075fe:	463c      	mov	r4, r7
		if( pxIterator->pxNextFreeBlock != pxEnd )
 8007600:	42aa      	cmp	r2, r5
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8007602:	bf1c      	itt	ne
 8007604:	6851      	ldrne	r1, [r2, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8007606:	6812      	ldrne	r2, [r2, #0]
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
 8007608:	6022      	str	r2, [r4, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 800760a:	bf1c      	itt	ne
 800760c:	4441      	addne	r1, r8
 800760e:	6061      	strne	r1, [r4, #4]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8007610:	6859      	ldr	r1, [r3, #4]
 8007612:	e7c8      	b.n	80075a6 <pvPortMalloc+0xe2>
 8007614:	200019e4 	.word	0x200019e4
 8007618:	200019d0 	.word	0x200019d0
 800761c:	200019e8 	.word	0x200019e8
 8007620:	200019f0 	.word	0x200019f0
 8007624:	200025e8 	.word	0x200025e8
 8007628:	200019dc 	.word	0x200019dc
 800762c:	200019e0 	.word	0x200019e0
 8007630:	200019d8 	.word	0x200019d8

08007634 <vPortFree>:
	if( pv != NULL )
 8007634:	b1d0      	cbz	r0, 800766c <vPortFree+0x38>
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 8007636:	4a2c      	ldr	r2, [pc, #176]	@ (80076e8 <vPortFree+0xb4>)
 8007638:	f850 3c04 	ldr.w	r3, [r0, #-4]
 800763c:	6812      	ldr	r2, [r2, #0]
 800763e:	4213      	tst	r3, r2
 8007640:	d00b      	beq.n	800765a <vPortFree+0x26>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 8007642:	f850 1c08 	ldr.w	r1, [r0, #-8]
 8007646:	b191      	cbz	r1, 800766e <vPortFree+0x3a>
 8007648:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800764c:	f383 8811 	msr	BASEPRI, r3
 8007650:	f3bf 8f6f 	isb	sy
 8007654:	f3bf 8f4f 	dsb	sy
 8007658:	e7fe      	b.n	8007658 <vPortFree+0x24>
 800765a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800765e:	f383 8811 	msr	BASEPRI, r3
 8007662:	f3bf 8f6f 	isb	sy
 8007666:	f3bf 8f4f 	dsb	sy
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 800766a:	e7fe      	b.n	800766a <vPortFree+0x36>
 800766c:	4770      	bx	lr
{
 800766e:	b570      	push	{r4, r5, r6, lr}
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 8007670:	ea23 0302 	bic.w	r3, r3, r2
{
 8007674:	b082      	sub	sp, #8
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 8007676:	f840 3c04 	str.w	r3, [r0, #-4]
					xFreeBytesRemaining += pxLink->xBlockSize;
 800767a:	4c1c      	ldr	r4, [pc, #112]	@ (80076ec <vPortFree+0xb8>)
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 800767c:	9001      	str	r0, [sp, #4]
				vTaskSuspendAll();
 800767e:	f000 fdfb 	bl	8008278 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 8007682:	9801      	ldr	r0, [sp, #4]
 8007684:	6822      	ldr	r2, [r4, #0]
 8007686:	f850 5c04 	ldr.w	r5, [r0, #-4]
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 800768a:	4b19      	ldr	r3, [pc, #100]	@ (80076f0 <vPortFree+0xbc>)
					xFreeBytesRemaining += pxLink->xBlockSize;
 800768c:	1951      	adds	r1, r2, r5
 800768e:	6021      	str	r1, [r4, #0]
		puc -= xHeapStructSize;
 8007690:	f1a0 0208 	sub.w	r2, r0, #8
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 8007694:	4619      	mov	r1, r3
 8007696:	681b      	ldr	r3, [r3, #0]
 8007698:	429a      	cmp	r2, r3
 800769a:	d8fb      	bhi.n	8007694 <vPortFree+0x60>
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 800769c:	684e      	ldr	r6, [r1, #4]
 800769e:	198c      	adds	r4, r1, r6
 80076a0:	42a2      	cmp	r2, r4
 80076a2:	d011      	beq.n	80076c8 <vPortFree+0x94>
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 80076a4:	eb02 0e05 	add.w	lr, r2, r5
 80076a8:	4573      	cmp	r3, lr
 80076aa:	d013      	beq.n	80076d4 <vPortFree+0xa0>
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 80076ac:	f840 3c08 	str.w	r3, [r0, #-8]
	if( pxIterator != pxBlockToInsert )
 80076b0:	4291      	cmp	r1, r2
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 80076b2:	bf18      	it	ne
 80076b4:	600a      	strne	r2, [r1, #0]
					xNumberOfSuccessfulFrees++;
 80076b6:	4a0f      	ldr	r2, [pc, #60]	@ (80076f4 <vPortFree+0xc0>)
 80076b8:	6813      	ldr	r3, [r2, #0]
 80076ba:	3301      	adds	r3, #1
 80076bc:	6013      	str	r3, [r2, #0]
}
 80076be:	b002      	add	sp, #8
 80076c0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				( void ) xTaskResumeAll();
 80076c4:	f000 bde0 	b.w	8008288 <xTaskResumeAll>
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 80076c8:	4435      	add	r5, r6
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 80076ca:	194a      	adds	r2, r1, r5
 80076cc:	4293      	cmp	r3, r2
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 80076ce:	604d      	str	r5, [r1, #4]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 80076d0:	d1f1      	bne.n	80076b6 <vPortFree+0x82>
 80076d2:	460a      	mov	r2, r1
		if( pxIterator->pxNextFreeBlock != pxEnd )
 80076d4:	4808      	ldr	r0, [pc, #32]	@ (80076f8 <vPortFree+0xc4>)
 80076d6:	6800      	ldr	r0, [r0, #0]
 80076d8:	4283      	cmp	r3, r0
 80076da:	d003      	beq.n	80076e4 <vPortFree+0xb0>
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 80076dc:	e9d3 0400 	ldrd	r0, r4, [r3]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 80076e0:	1963      	adds	r3, r4, r5
 80076e2:	6053      	str	r3, [r2, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 80076e4:	6010      	str	r0, [r2, #0]
 80076e6:	e7e3      	b.n	80076b0 <vPortFree+0x7c>
 80076e8:	200019d0 	.word	0x200019d0
 80076ec:	200019e0 	.word	0x200019e0
 80076f0:	200019e8 	.word	0x200019e8
 80076f4:	200019d4 	.word	0x200019d4
 80076f8:	200019e4 	.word	0x200019e4

080076fc <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80076fc:	f100 0308 	add.w	r3, r0, #8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8007700:	f04f 31ff 	mov.w	r1, #4294967295
	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8007704:	2200      	movs	r2, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8007706:	e9c0 3101 	strd	r3, r1, [r0, #4]
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800770a:	e9c0 3303 	strd	r3, r3, [r0, #12]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 800770e:	6002      	str	r2, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 8007710:	4770      	bx	lr
 8007712:	bf00      	nop

08007714 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
 8007714:	2300      	movs	r3, #0
 8007716:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 8007718:	4770      	bx	lr
 800771a:	bf00      	nop

0800771c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 800771c:	6842      	ldr	r2, [r0, #4]
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;

	( pxList->uxNumberOfItems )++;
 800771e:	6803      	ldr	r3, [r0, #0]
{
 8007720:	b410      	push	{r4}
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8007722:	6894      	ldr	r4, [r2, #8]
	( pxList->uxNumberOfItems )++;
 8007724:	3301      	adds	r3, #1
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8007726:	e9c1 2401 	strd	r2, r4, [r1, #4]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
 800772a:	6061      	str	r1, [r4, #4]
	pxIndex->pxPrevious = pxNewListItem;
 800772c:	6091      	str	r1, [r2, #8]
}
 800772e:	f85d 4b04 	ldr.w	r4, [sp], #4
	pxNewListItem->pxContainer = pxList;
 8007732:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 8007734:	6003      	str	r3, [r0, #0]
}
 8007736:	4770      	bx	lr

08007738 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 8007738:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 800773a:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 800773c:	1c6b      	adds	r3, r5, #1
 800773e:	d010      	beq.n	8007762 <vListInsert+0x2a>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 8007740:	f100 0308 	add.w	r3, r0, #8
 8007744:	461c      	mov	r4, r3
 8007746:	685b      	ldr	r3, [r3, #4]
 8007748:	681a      	ldr	r2, [r3, #0]
 800774a:	42aa      	cmp	r2, r5
 800774c:	d9fa      	bls.n	8007744 <vListInsert+0xc>

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;

	( pxList->uxNumberOfItems )++;
 800774e:	6802      	ldr	r2, [r0, #0]
	pxNewListItem->pxNext = pxIterator->pxNext;
 8007750:	604b      	str	r3, [r1, #4]
	( pxList->uxNumberOfItems )++;
 8007752:	3201      	adds	r2, #1
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8007754:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8007756:	608c      	str	r4, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 8007758:	6061      	str	r1, [r4, #4]
	pxNewListItem->pxContainer = pxList;
 800775a:	6108      	str	r0, [r1, #16]
}
 800775c:	bc30      	pop	{r4, r5}
	( pxList->uxNumberOfItems )++;
 800775e:	6002      	str	r2, [r0, #0]
}
 8007760:	4770      	bx	lr
		pxIterator = pxList->xListEnd.pxPrevious;
 8007762:	6904      	ldr	r4, [r0, #16]
	pxNewListItem->pxNext = pxIterator->pxNext;
 8007764:	6863      	ldr	r3, [r4, #4]
 8007766:	e7f2      	b.n	800774e <vListInsert+0x16>

08007768 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
 8007768:	6903      	ldr	r3, [r0, #16]
{
 800776a:	b410      	push	{r4}

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 800776c:	e9d0 1201 	ldrd	r1, r2, [r0, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8007770:	685c      	ldr	r4, [r3, #4]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8007772:	608a      	str	r2, [r1, #8]
	if( pxList->pxIndex == pxItemToRemove )
 8007774:	4284      	cmp	r4, r0
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8007776:	6051      	str	r1, [r2, #4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8007778:	bf08      	it	eq
 800777a:	605a      	streq	r2, [r3, #4]
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
	( pxList->uxNumberOfItems )--;
 800777c:	681a      	ldr	r2, [r3, #0]

	return pxList->uxNumberOfItems;
}
 800777e:	f85d 4b04 	ldr.w	r4, [sp], #4
	pxItemToRemove->pxContainer = NULL;
 8007782:	2100      	movs	r1, #0
	( pxList->uxNumberOfItems )--;
 8007784:	3a01      	subs	r2, #1
	pxItemToRemove->pxContainer = NULL;
 8007786:	6101      	str	r1, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8007788:	601a      	str	r2, [r3, #0]
	return pxList->uxNumberOfItems;
 800778a:	6818      	ldr	r0, [r3, #0]
}
 800778c:	4770      	bx	lr
 800778e:	bf00      	nop

08007790 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(
 8007790:	4808      	ldr	r0, [pc, #32]	@ (80077b4 <prvPortStartFirstTask+0x24>)
 8007792:	6800      	ldr	r0, [r0, #0]
 8007794:	6800      	ldr	r0, [r0, #0]
 8007796:	f380 8808 	msr	MSP, r0
 800779a:	f04f 0000 	mov.w	r0, #0
 800779e:	f380 8814 	msr	CONTROL, r0
 80077a2:	b662      	cpsie	i
 80077a4:	b661      	cpsie	f
 80077a6:	f3bf 8f4f 	dsb	sy
 80077aa:	f3bf 8f6f 	isb	sy
 80077ae:	df00      	svc	0
 80077b0:	bf00      	nop
					" dsb					\n"
					" isb					\n"
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
 80077b2:	0000      	.short	0x0000
 80077b4:	e000ed08 	.word	0xe000ed08

080077b8 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 80077b8:	f8df 000c 	ldr.w	r0, [pc, #12]	@ 80077c8 <vPortEnableVFP+0x10>
 80077bc:	6801      	ldr	r1, [r0, #0]
 80077be:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 80077c2:	6001      	str	r1, [r0, #0]
 80077c4:	4770      	bx	lr
		"								\n"
		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
		"	str r1, [r0]				\n"
		"	bx r14						"
	);
}
 80077c6:	0000      	.short	0x0000
 80077c8:	e000ed88 	.word	0xe000ed88

080077cc <prvTaskExitError>:
	configASSERT( uxCriticalNesting == ~0UL );
 80077cc:	4b0e      	ldr	r3, [pc, #56]	@ (8007808 <prvTaskExitError+0x3c>)
 80077ce:	681b      	ldr	r3, [r3, #0]
{
 80077d0:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0;
 80077d2:	2200      	movs	r2, #0
	configASSERT( uxCriticalNesting == ~0UL );
 80077d4:	3301      	adds	r3, #1
volatile uint32_t ulDummy = 0;
 80077d6:	9201      	str	r2, [sp, #4]
	configASSERT( uxCriticalNesting == ~0UL );
 80077d8:	d008      	beq.n	80077ec <prvTaskExitError+0x20>
 80077da:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80077de:	f383 8811 	msr	BASEPRI, r3
 80077e2:	f3bf 8f6f 	isb	sy
 80077e6:	f3bf 8f4f 	dsb	sy
 80077ea:	e7fe      	b.n	80077ea <prvTaskExitError+0x1e>
 80077ec:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80077f0:	f383 8811 	msr	BASEPRI, r3
 80077f4:	f3bf 8f6f 	isb	sy
 80077f8:	f3bf 8f4f 	dsb	sy
	while( ulDummy == 0 )
 80077fc:	9b01      	ldr	r3, [sp, #4]
 80077fe:	2b00      	cmp	r3, #0
 8007800:	d0fc      	beq.n	80077fc <prvTaskExitError+0x30>
}
 8007802:	b002      	add	sp, #8
 8007804:	4770      	bx	lr
 8007806:	bf00      	nop
 8007808:	20000480 	.word	0x20000480

0800780c <pxPortInitialiseStack>:
{
 800780c:	b410      	push	{r4}
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 800780e:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8007812:	4c07      	ldr	r4, [pc, #28]	@ (8007830 <pxPortInitialiseStack+0x24>)
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8007814:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 8007818:	f021 0101 	bic.w	r1, r1, #1
	*pxTopOfStack = portINITIAL_EXC_RETURN;
 800781c:	f06f 0302 	mvn.w	r3, #2
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8007820:	e940 4103 	strd	r4, r1, [r0, #-12]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
 8007824:	e940 3209 	strd	r3, r2, [r0, #-36]	@ 0x24
}
 8007828:	f85d 4b04 	ldr.w	r4, [sp], #4
 800782c:	3844      	subs	r0, #68	@ 0x44
 800782e:	4770      	bx	lr
 8007830:	080077cd 	.word	0x080077cd
	...

08007840 <SVC_Handler>:
	__asm volatile (
 8007840:	4b07      	ldr	r3, [pc, #28]	@ (8007860 <pxCurrentTCBConst2>)
 8007842:	6819      	ldr	r1, [r3, #0]
 8007844:	6808      	ldr	r0, [r1, #0]
 8007846:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800784a:	f380 8809 	msr	PSP, r0
 800784e:	f3bf 8f6f 	isb	sy
 8007852:	f04f 0000 	mov.w	r0, #0
 8007856:	f380 8811 	msr	BASEPRI, r0
 800785a:	4770      	bx	lr
 800785c:	f3af 8000 	nop.w

08007860 <pxCurrentTCBConst2>:
 8007860:	20002720 	.word	0x20002720

08007864 <vPortEnterCritical>:
 8007864:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007868:	f383 8811 	msr	BASEPRI, r3
 800786c:	f3bf 8f6f 	isb	sy
 8007870:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
 8007874:	4a0b      	ldr	r2, [pc, #44]	@ (80078a4 <vPortEnterCritical+0x40>)
 8007876:	6813      	ldr	r3, [r2, #0]
 8007878:	3301      	adds	r3, #1
	if( uxCriticalNesting == 1 )
 800787a:	2b01      	cmp	r3, #1
	uxCriticalNesting++;
 800787c:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 1 )
 800787e:	d000      	beq.n	8007882 <vPortEnterCritical+0x1e>
}
 8007880:	4770      	bx	lr
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 8007882:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8007886:	f8d3 3d04 	ldr.w	r3, [r3, #3332]	@ 0xd04
 800788a:	b2db      	uxtb	r3, r3
 800788c:	2b00      	cmp	r3, #0
 800788e:	d0f7      	beq.n	8007880 <vPortEnterCritical+0x1c>
 8007890:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007894:	f383 8811 	msr	BASEPRI, r3
 8007898:	f3bf 8f6f 	isb	sy
 800789c:	f3bf 8f4f 	dsb	sy
 80078a0:	e7fe      	b.n	80078a0 <vPortEnterCritical+0x3c>
 80078a2:	bf00      	nop
 80078a4:	20000480 	.word	0x20000480

080078a8 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
 80078a8:	4a08      	ldr	r2, [pc, #32]	@ (80078cc <vPortExitCritical+0x24>)
 80078aa:	6813      	ldr	r3, [r2, #0]
 80078ac:	b943      	cbnz	r3, 80078c0 <vPortExitCritical+0x18>
 80078ae:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80078b2:	f383 8811 	msr	BASEPRI, r3
 80078b6:	f3bf 8f6f 	isb	sy
 80078ba:	f3bf 8f4f 	dsb	sy
 80078be:	e7fe      	b.n	80078be <vPortExitCritical+0x16>
	uxCriticalNesting--;
 80078c0:	3b01      	subs	r3, #1
 80078c2:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 80078c4:	b90b      	cbnz	r3, 80078ca <vPortExitCritical+0x22>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 80078c6:	f383 8811 	msr	BASEPRI, r3
}
 80078ca:	4770      	bx	lr
 80078cc:	20000480 	.word	0x20000480

080078d0 <PendSV_Handler>:
	__asm volatile
 80078d0:	f3ef 8009 	mrs	r0, PSP
 80078d4:	f3bf 8f6f 	isb	sy
 80078d8:	4b15      	ldr	r3, [pc, #84]	@ (8007930 <pxCurrentTCBConst>)
 80078da:	681a      	ldr	r2, [r3, #0]
 80078dc:	f01e 0f10 	tst.w	lr, #16
 80078e0:	bf08      	it	eq
 80078e2:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 80078e6:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80078ea:	6010      	str	r0, [r2, #0]
 80078ec:	e92d 0009 	stmdb	sp!, {r0, r3}
 80078f0:	f04f 0050 	mov.w	r0, #80	@ 0x50
 80078f4:	f380 8811 	msr	BASEPRI, r0
 80078f8:	f3bf 8f4f 	dsb	sy
 80078fc:	f3bf 8f6f 	isb	sy
 8007900:	f000 fce2 	bl	80082c8 <vTaskSwitchContext>
 8007904:	f04f 0000 	mov.w	r0, #0
 8007908:	f380 8811 	msr	BASEPRI, r0
 800790c:	bc09      	pop	{r0, r3}
 800790e:	6819      	ldr	r1, [r3, #0]
 8007910:	6808      	ldr	r0, [r1, #0]
 8007912:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007916:	f01e 0f10 	tst.w	lr, #16
 800791a:	bf08      	it	eq
 800791c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 8007920:	f380 8809 	msr	PSP, r0
 8007924:	f3bf 8f6f 	isb	sy
 8007928:	4770      	bx	lr
 800792a:	bf00      	nop
 800792c:	f3af 8000 	nop.w

08007930 <pxCurrentTCBConst>:
 8007930:	20002720 	.word	0x20002720

08007934 <SysTick_Handler>:
{
 8007934:	b508      	push	{r3, lr}
	__asm volatile
 8007936:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800793a:	f383 8811 	msr	BASEPRI, r3
 800793e:	f3bf 8f6f 	isb	sy
 8007942:	f3bf 8f4f 	dsb	sy
		if( xTaskIncrementTick() != pdFALSE )
 8007946:	f000 fcaf 	bl	80082a8 <xTaskIncrementTick>
 800794a:	b128      	cbz	r0, 8007958 <SysTick_Handler+0x24>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 800794c:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8007950:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8007954:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
	__asm volatile
 8007958:	2300      	movs	r3, #0
 800795a:	f383 8811 	msr	BASEPRI, r3
}
 800795e:	bd08      	pop	{r3, pc}

08007960 <xPortStartScheduler>:
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 8007960:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8007964:	4a48      	ldr	r2, [pc, #288]	@ (8007a88 <xPortStartScheduler+0x128>)
 8007966:	f8d3 1d00 	ldr.w	r1, [r3, #3328]	@ 0xd00
 800796a:	4291      	cmp	r1, r2
 800796c:	d041      	beq.n	80079f2 <xPortStartScheduler+0x92>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 800796e:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	@ 0xd00
 8007972:	4b46      	ldr	r3, [pc, #280]	@ (8007a8c <xPortStartScheduler+0x12c>)
 8007974:	429a      	cmp	r2, r3
 8007976:	d033      	beq.n	80079e0 <xPortStartScheduler+0x80>
{
 8007978:	b570      	push	{r4, r5, r6, lr}
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 800797a:	4b45      	ldr	r3, [pc, #276]	@ (8007a90 <xPortStartScheduler+0x130>)
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 800797c:	4c45      	ldr	r4, [pc, #276]	@ (8007a94 <xPortStartScheduler+0x134>)
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 800797e:	781a      	ldrb	r2, [r3, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8007980:	4845      	ldr	r0, [pc, #276]	@ (8007a98 <xPortStartScheduler+0x138>)
{
 8007982:	b084      	sub	sp, #16
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 8007984:	21ff      	movs	r1, #255	@ 0xff
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8007986:	b2d2      	uxtb	r2, r2
 8007988:	9202      	str	r2, [sp, #8]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 800798a:	7019      	strb	r1, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 800798c:	781b      	ldrb	r3, [r3, #0]
 800798e:	b2db      	uxtb	r3, r3
 8007990:	f88d 3007 	strb.w	r3, [sp, #7]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8007994:	f89d 3007 	ldrb.w	r3, [sp, #7]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8007998:	f89d 2007 	ldrb.w	r2, [sp, #7]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 800799c:	f003 0350 	and.w	r3, r3, #80	@ 0x50
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 80079a0:	2107      	movs	r1, #7
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 80079a2:	0612      	lsls	r2, r2, #24
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 80079a4:	7023      	strb	r3, [r4, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 80079a6:	6001      	str	r1, [r0, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 80079a8:	bf48      	it	mi
 80079aa:	2206      	movmi	r2, #6
 80079ac:	d50f      	bpl.n	80079ce <xPortStartScheduler+0x6e>
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 80079ae:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80079b2:	005b      	lsls	r3, r3, #1
 80079b4:	b2db      	uxtb	r3, r3
 80079b6:	f88d 3007 	strb.w	r3, [sp, #7]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 80079ba:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80079be:	061b      	lsls	r3, r3, #24
 80079c0:	4611      	mov	r1, r2
 80079c2:	f102 32ff 	add.w	r2, r2, #4294967295
 80079c6:	d4f2      	bmi.n	80079ae <xPortStartScheduler+0x4e>
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 80079c8:	2903      	cmp	r1, #3
 80079ca:	d01b      	beq.n	8007a04 <xPortStartScheduler+0xa4>
 80079cc:	6001      	str	r1, [r0, #0]
	__asm volatile
 80079ce:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80079d2:	f383 8811 	msr	BASEPRI, r3
 80079d6:	f3bf 8f6f 	isb	sy
 80079da:	f3bf 8f4f 	dsb	sy
 80079de:	e7fe      	b.n	80079de <xPortStartScheduler+0x7e>
 80079e0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80079e4:	f383 8811 	msr	BASEPRI, r3
 80079e8:	f3bf 8f6f 	isb	sy
 80079ec:	f3bf 8f4f 	dsb	sy
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 80079f0:	e7fe      	b.n	80079f0 <xPortStartScheduler+0x90>
 80079f2:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80079f6:	f383 8811 	msr	BASEPRI, r3
 80079fa:	f3bf 8f6f 	isb	sy
 80079fe:	f3bf 8f4f 	dsb	sy
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 8007a02:	e7fe      	b.n	8007a02 <xPortStartScheduler+0xa2>
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 8007a04:	9b02      	ldr	r3, [sp, #8]
 8007a06:	4a22      	ldr	r2, [pc, #136]	@ (8007a90 <xPortStartScheduler+0x130>)
	uxCriticalNesting = 0;
 8007a08:	4d24      	ldr	r5, [pc, #144]	@ (8007a9c <xPortStartScheduler+0x13c>)
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8007a0a:	f04f 24e0 	mov.w	r4, #3758153728	@ 0xe000e000
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 8007a0e:	f44f 7140 	mov.w	r1, #768	@ 0x300
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 8007a12:	b2db      	uxtb	r3, r3
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 8007a14:	6001      	str	r1, [r0, #0]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 8007a16:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8007a18:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	@ 0xd20
 8007a1c:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 8007a20:	f8c4 3d20 	str.w	r3, [r4, #3360]	@ 0xd20
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8007a24:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	@ 0xd20
 8007a28:	f043 4370 	orr.w	r3, r3, #4026531840	@ 0xf0000000
 8007a2c:	f8c4 3d20 	str.w	r3, [r4, #3360]	@ 0xd20
	uxCriticalNesting = 0;
 8007a30:	2600      	movs	r6, #0
	vPortSetupTimerInterrupt();
 8007a32:	f7fa fbed 	bl	8002210 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 8007a36:	602e      	str	r6, [r5, #0]
	vPortEnableVFP();
 8007a38:	f7ff febe 	bl	80077b8 <vPortEnableVFP>
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 8007a3c:	f8d4 3f34 	ldr.w	r3, [r4, #3892]	@ 0xf34
 8007a40:	f043 4340 	orr.w	r3, r3, #3221225472	@ 0xc0000000
 8007a44:	f8c4 3f34 	str.w	r3, [r4, #3892]	@ 0xf34
	prvPortStartFirstTask();
 8007a48:	f7ff fea2 	bl	8007790 <prvPortStartFirstTask>
	vTaskSwitchContext();
 8007a4c:	f000 fc3c 	bl	80082c8 <vTaskSwitchContext>
	configASSERT( uxCriticalNesting == ~0UL );
 8007a50:	682b      	ldr	r3, [r5, #0]
volatile uint32_t ulDummy = 0;
 8007a52:	9603      	str	r6, [sp, #12]
	configASSERT( uxCriticalNesting == ~0UL );
 8007a54:	3301      	adds	r3, #1
 8007a56:	d008      	beq.n	8007a6a <xPortStartScheduler+0x10a>
 8007a58:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007a5c:	f383 8811 	msr	BASEPRI, r3
 8007a60:	f3bf 8f6f 	isb	sy
 8007a64:	f3bf 8f4f 	dsb	sy
 8007a68:	e7fe      	b.n	8007a68 <xPortStartScheduler+0x108>
 8007a6a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007a6e:	f383 8811 	msr	BASEPRI, r3
 8007a72:	f3bf 8f6f 	isb	sy
 8007a76:	f3bf 8f4f 	dsb	sy
	while( ulDummy == 0 )
 8007a7a:	9b03      	ldr	r3, [sp, #12]
 8007a7c:	2b00      	cmp	r3, #0
 8007a7e:	d0fc      	beq.n	8007a7a <xPortStartScheduler+0x11a>
}
 8007a80:	2000      	movs	r0, #0
 8007a82:	b004      	add	sp, #16
 8007a84:	bd70      	pop	{r4, r5, r6, pc}
 8007a86:	bf00      	nop
 8007a88:	410fc271 	.word	0x410fc271
 8007a8c:	410fc270 	.word	0x410fc270
 8007a90:	e000e400 	.word	0xe000e400
 8007a94:	200025f4 	.word	0x200025f4
 8007a98:	200025f0 	.word	0x200025f0
 8007a9c:	20000480 	.word	0x20000480

08007aa0 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 8007aa0:	b580      	push	{r7, lr}
 8007aa2:	4d16      	ldr	r5, [pc, #88]	@ (8007afc <prvIdleTask+0x5c>)
 8007aa4:	4f16      	ldr	r7, [pc, #88]	@ (8007b00 <prvIdleTask+0x60>)
 8007aa6:	4e17      	ldr	r6, [pc, #92]	@ (8007b04 <prvIdleTask+0x64>)
 8007aa8:	f8df 805c 	ldr.w	r8, [pc, #92]	@ 8007b08 <prvIdleTask+0x68>
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
			{
				taskYIELD();
 8007aac:	f04f 2ae0 	mov.w	sl, #3758153728	@ 0xe000e000
 8007ab0:	f04f 5980 	mov.w	r9, #268435456	@ 0x10000000
 8007ab4:	e014      	b.n	8007ae0 <prvIdleTask+0x40>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
 8007ab6:	f7ff fed5 	bl	8007864 <vPortEnterCritical>
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8007aba:	68fb      	ldr	r3, [r7, #12]
 8007abc:	68dc      	ldr	r4, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8007abe:	1d20      	adds	r0, r4, #4
 8007ac0:	f7ff fe52 	bl	8007768 <uxListRemove>
				--uxCurrentNumberOfTasks;
 8007ac4:	6833      	ldr	r3, [r6, #0]
 8007ac6:	3b01      	subs	r3, #1
 8007ac8:	6033      	str	r3, [r6, #0]
				--uxDeletedTasksWaitingCleanUp;
 8007aca:	682b      	ldr	r3, [r5, #0]
 8007acc:	3b01      	subs	r3, #1
 8007ace:	602b      	str	r3, [r5, #0]
			}
			taskEXIT_CRITICAL();
 8007ad0:	f7ff feea 	bl	80078a8 <vPortExitCritical>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
 8007ad4:	6b20      	ldr	r0, [r4, #48]	@ 0x30
 8007ad6:	f7ff fdad 	bl	8007634 <vPortFree>
			vPortFree( pxTCB );
 8007ada:	4620      	mov	r0, r4
 8007adc:	f7ff fdaa 	bl	8007634 <vPortFree>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8007ae0:	682b      	ldr	r3, [r5, #0]
 8007ae2:	2b00      	cmp	r3, #0
 8007ae4:	d1e7      	bne.n	8007ab6 <prvIdleTask+0x16>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8007ae6:	f8d8 3000 	ldr.w	r3, [r8]
 8007aea:	2b01      	cmp	r3, #1
 8007aec:	d9f8      	bls.n	8007ae0 <prvIdleTask+0x40>
				taskYIELD();
 8007aee:	f8ca 9d04 	str.w	r9, [sl, #3332]	@ 0xd04
 8007af2:	f3bf 8f4f 	dsb	sy
 8007af6:	f3bf 8f6f 	isb	sy
 8007afa:	e7f1      	b.n	8007ae0 <prvIdleTask+0x40>
 8007afc:	20002638 	.word	0x20002638
 8007b00:	2000263c 	.word	0x2000263c
 8007b04:	20002620 	.word	0x20002620
 8007b08:	20002694 	.word	0x20002694

08007b0c <prvAddCurrentTaskToDelayedList>:

#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 8007b0c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 8007b0e:	4b1b      	ldr	r3, [pc, #108]	@ (8007b7c <prvAddCurrentTaskToDelayedList+0x70>)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8007b10:	4e1b      	ldr	r6, [pc, #108]	@ (8007b80 <prvAddCurrentTaskToDelayedList+0x74>)
const TickType_t xConstTickCount = xTickCount;
 8007b12:	681c      	ldr	r4, [r3, #0]
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8007b14:	6833      	ldr	r3, [r6, #0]
{
 8007b16:	4605      	mov	r5, r0
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8007b18:	1d18      	adds	r0, r3, #4
{
 8007b1a:	460f      	mov	r7, r1
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8007b1c:	f7ff fe24 	bl	8007768 <uxListRemove>
 8007b20:	b940      	cbnz	r0, 8007b34 <prvAddCurrentTaskToDelayedList+0x28>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
 8007b22:	6833      	ldr	r3, [r6, #0]
 8007b24:	4917      	ldr	r1, [pc, #92]	@ (8007b84 <prvAddCurrentTaskToDelayedList+0x78>)
 8007b26:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8007b28:	2201      	movs	r2, #1
 8007b2a:	409a      	lsls	r2, r3
 8007b2c:	680b      	ldr	r3, [r1, #0]
 8007b2e:	ea23 0302 	bic.w	r3, r3, r2
 8007b32:	600b      	str	r3, [r1, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8007b34:	1c6b      	adds	r3, r5, #1
 8007b36:	d017      	beq.n	8007b68 <prvAddCurrentTaskToDelayedList+0x5c>
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8007b38:	6833      	ldr	r3, [r6, #0]
 8007b3a:	1964      	adds	r4, r4, r5
 8007b3c:	605c      	str	r4, [r3, #4]

			if( xTimeToWake < xConstTickCount )
 8007b3e:	d307      	bcc.n	8007b50 <prvAddCurrentTaskToDelayedList+0x44>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8007b40:	4b11      	ldr	r3, [pc, #68]	@ (8007b88 <prvAddCurrentTaskToDelayedList+0x7c>)
 8007b42:	6818      	ldr	r0, [r3, #0]
 8007b44:	6831      	ldr	r1, [r6, #0]

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8007b46:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8007b4a:	3104      	adds	r1, #4
 8007b4c:	f7ff bdf4 	b.w	8007738 <vListInsert>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8007b50:	4b0e      	ldr	r3, [pc, #56]	@ (8007b8c <prvAddCurrentTaskToDelayedList+0x80>)
 8007b52:	6818      	ldr	r0, [r3, #0]
 8007b54:	6831      	ldr	r1, [r6, #0]
 8007b56:	3104      	adds	r1, #4
 8007b58:	f7ff fdee 	bl	8007738 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 8007b5c:	4b0c      	ldr	r3, [pc, #48]	@ (8007b90 <prvAddCurrentTaskToDelayedList+0x84>)
 8007b5e:	681a      	ldr	r2, [r3, #0]
 8007b60:	42a2      	cmp	r2, r4
					xNextTaskUnblockTime = xTimeToWake;
 8007b62:	bf88      	it	hi
 8007b64:	601c      	strhi	r4, [r3, #0]
}
 8007b66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8007b68:	2f00      	cmp	r7, #0
 8007b6a:	d0e5      	beq.n	8007b38 <prvAddCurrentTaskToDelayedList+0x2c>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8007b6c:	6831      	ldr	r1, [r6, #0]
 8007b6e:	4809      	ldr	r0, [pc, #36]	@ (8007b94 <prvAddCurrentTaskToDelayedList+0x88>)
}
 8007b70:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8007b74:	3104      	adds	r1, #4
 8007b76:	f7ff bdd1 	b.w	800771c <vListInsertEnd>
 8007b7a:	bf00      	nop
 8007b7c:	2000261c 	.word	0x2000261c
 8007b80:	20002720 	.word	0x20002720
 8007b84:	20002618 	.word	0x20002618
 8007b88:	20002664 	.word	0x20002664
 8007b8c:	20002668 	.word	0x20002668
 8007b90:	20002600 	.word	0x20002600
 8007b94:	20002624 	.word	0x20002624

08007b98 <xTaskIncrementTick.part.0>:
BaseType_t xTaskIncrementTick( void )
 8007b98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 8007b9c:	4b48      	ldr	r3, [pc, #288]	@ (8007cc0 <xTaskIncrementTick.part.0+0x128>)
 8007b9e:	681d      	ldr	r5, [r3, #0]
 8007ba0:	3501      	adds	r5, #1
BaseType_t xTaskIncrementTick( void )
 8007ba2:	b083      	sub	sp, #12
		xTickCount = xConstTickCount;
 8007ba4:	601d      	str	r5, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 8007ba6:	2d00      	cmp	r5, #0
 8007ba8:	d041      	beq.n	8007c2e <xTaskIncrementTick.part.0+0x96>
 8007baa:	4b46      	ldr	r3, [pc, #280]	@ (8007cc4 <xTaskIncrementTick.part.0+0x12c>)
 8007bac:	9301      	str	r3, [sp, #4]
		if( xConstTickCount >= xNextTaskUnblockTime )
 8007bae:	681b      	ldr	r3, [r3, #0]
 8007bb0:	429d      	cmp	r5, r3
 8007bb2:	d349      	bcc.n	8007c48 <xTaskIncrementTick.part.0+0xb0>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8007bb4:	4e44      	ldr	r6, [pc, #272]	@ (8007cc8 <xTaskIncrementTick.part.0+0x130>)
 8007bb6:	f8df 8124 	ldr.w	r8, [pc, #292]	@ 8007cdc <xTaskIncrementTick.part.0+0x144>
 8007bba:	6833      	ldr	r3, [r6, #0]
 8007bbc:	f8df 9120 	ldr.w	r9, [pc, #288]	@ 8007ce0 <xTaskIncrementTick.part.0+0x148>
 8007bc0:	681c      	ldr	r4, [r3, #0]
 8007bc2:	2c00      	cmp	r4, #0
 8007bc4:	d076      	beq.n	8007cb4 <xTaskIncrementTick.part.0+0x11c>
					prvAddTaskToReadyList( pxTCB );
 8007bc6:	4f41      	ldr	r7, [pc, #260]	@ (8007ccc <xTaskIncrementTick.part.0+0x134>)
BaseType_t xSwitchRequired = pdFALSE;
 8007bc8:	2400      	movs	r4, #0
 8007bca:	e022      	b.n	8007c12 <xTaskIncrementTick.part.0+0x7a>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8007bcc:	f7ff fdcc 	bl	8007768 <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8007bd0:	f8db 2028 	ldr.w	r2, [fp, #40]	@ 0x28
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8007bd4:	f10b 0018 	add.w	r0, fp, #24
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8007bd8:	b10a      	cbz	r2, 8007bde <xTaskIncrementTick.part.0+0x46>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8007bda:	f7ff fdc5 	bl	8007768 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8007bde:	f8db 002c 	ldr.w	r0, [fp, #44]	@ 0x2c
 8007be2:	683b      	ldr	r3, [r7, #0]
 8007be4:	2201      	movs	r2, #1
 8007be6:	4082      	lsls	r2, r0
 8007be8:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8007bec:	431a      	orrs	r2, r3
 8007bee:	4651      	mov	r1, sl
 8007bf0:	eb08 0080 	add.w	r0, r8, r0, lsl #2
 8007bf4:	603a      	str	r2, [r7, #0]
 8007bf6:	f7ff fd91 	bl	800771c <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8007bfa:	f8d9 2000 	ldr.w	r2, [r9]
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8007bfe:	6830      	ldr	r0, [r6, #0]
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8007c00:	f8db 102c 	ldr.w	r1, [fp, #44]	@ 0x2c
 8007c04:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8007c06:	6803      	ldr	r3, [r0, #0]
							xSwitchRequired = pdTRUE;
 8007c08:	4291      	cmp	r1, r2
 8007c0a:	bf28      	it	cs
 8007c0c:	2401      	movcs	r4, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8007c0e:	2b00      	cmp	r3, #0
 8007c10:	d050      	beq.n	8007cb4 <xTaskIncrementTick.part.0+0x11c>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8007c12:	6833      	ldr	r3, [r6, #0]
 8007c14:	68db      	ldr	r3, [r3, #12]
 8007c16:	f8d3 b00c 	ldr.w	fp, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 8007c1a:	f8db 2004 	ldr.w	r2, [fp, #4]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8007c1e:	f10b 0a04 	add.w	sl, fp, #4
					if( xConstTickCount < xItemValue )
 8007c22:	4295      	cmp	r5, r2
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8007c24:	4650      	mov	r0, sl
					if( xConstTickCount < xItemValue )
 8007c26:	d2d1      	bcs.n	8007bcc <xTaskIncrementTick.part.0+0x34>
						xNextTaskUnblockTime = xItemValue;
 8007c28:	9b01      	ldr	r3, [sp, #4]
 8007c2a:	601a      	str	r2, [r3, #0]
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
 8007c2c:	e011      	b.n	8007c52 <xTaskIncrementTick.part.0+0xba>
			taskSWITCH_DELAYED_LISTS();
 8007c2e:	4b26      	ldr	r3, [pc, #152]	@ (8007cc8 <xTaskIncrementTick.part.0+0x130>)
 8007c30:	681a      	ldr	r2, [r3, #0]
 8007c32:	6812      	ldr	r2, [r2, #0]
 8007c34:	b30a      	cbz	r2, 8007c7a <xTaskIncrementTick.part.0+0xe2>
 8007c36:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007c3a:	f383 8811 	msr	BASEPRI, r3
 8007c3e:	f3bf 8f6f 	isb	sy
 8007c42:	f3bf 8f4f 	dsb	sy
 8007c46:	e7fe      	b.n	8007c46 <xTaskIncrementTick.part.0+0xae>
 8007c48:	f8df 8090 	ldr.w	r8, [pc, #144]	@ 8007cdc <xTaskIncrementTick.part.0+0x144>
 8007c4c:	f8df 9090 	ldr.w	r9, [pc, #144]	@ 8007ce0 <xTaskIncrementTick.part.0+0x148>
BaseType_t xSwitchRequired = pdFALSE;
 8007c50:	2400      	movs	r4, #0
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8007c52:	f8d9 3000 	ldr.w	r3, [r9]
			if( xYieldPending != pdFALSE )
 8007c56:	491e      	ldr	r1, [pc, #120]	@ (8007cd0 <xTaskIncrementTick.part.0+0x138>)
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8007c58:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8007c5a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8007c5e:	009b      	lsls	r3, r3, #2
 8007c60:	f858 2003 	ldr.w	r2, [r8, r3]
			if( xYieldPending != pdFALSE )
 8007c64:	680b      	ldr	r3, [r1, #0]
				xSwitchRequired = pdTRUE;
 8007c66:	2a02      	cmp	r2, #2
 8007c68:	bf28      	it	cs
 8007c6a:	2401      	movcs	r4, #1
				xSwitchRequired = pdTRUE;
 8007c6c:	2b00      	cmp	r3, #0
}
 8007c6e:	bf0c      	ite	eq
 8007c70:	4620      	moveq	r0, r4
 8007c72:	2001      	movne	r0, #1
 8007c74:	b003      	add	sp, #12
 8007c76:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			taskSWITCH_DELAYED_LISTS();
 8007c7a:	4a16      	ldr	r2, [pc, #88]	@ (8007cd4 <xTaskIncrementTick.part.0+0x13c>)
 8007c7c:	6818      	ldr	r0, [r3, #0]
 8007c7e:	6811      	ldr	r1, [r2, #0]
 8007c80:	6019      	str	r1, [r3, #0]
 8007c82:	4915      	ldr	r1, [pc, #84]	@ (8007cd8 <xTaskIncrementTick.part.0+0x140>)
 8007c84:	6010      	str	r0, [r2, #0]
 8007c86:	680a      	ldr	r2, [r1, #0]
 8007c88:	3201      	adds	r2, #1
 8007c8a:	600a      	str	r2, [r1, #0]
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8007c8c:	681a      	ldr	r2, [r3, #0]
 8007c8e:	6812      	ldr	r2, [r2, #0]
 8007c90:	b93a      	cbnz	r2, 8007ca2 <xTaskIncrementTick.part.0+0x10a>
		xNextTaskUnblockTime = portMAX_DELAY;
 8007c92:	4b0c      	ldr	r3, [pc, #48]	@ (8007cc4 <xTaskIncrementTick.part.0+0x12c>)
 8007c94:	9301      	str	r3, [sp, #4]
 8007c96:	461a      	mov	r2, r3
 8007c98:	f04f 33ff 	mov.w	r3, #4294967295
 8007c9c:	6013      	str	r3, [r2, #0]
 8007c9e:	4613      	mov	r3, r2
 8007ca0:	e785      	b.n	8007bae <xTaskIncrementTick.part.0+0x16>
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8007ca2:	681b      	ldr	r3, [r3, #0]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8007ca4:	4a07      	ldr	r2, [pc, #28]	@ (8007cc4 <xTaskIncrementTick.part.0+0x12c>)
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8007ca6:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8007ca8:	9201      	str	r2, [sp, #4]
 8007caa:	68db      	ldr	r3, [r3, #12]
 8007cac:	685b      	ldr	r3, [r3, #4]
 8007cae:	6013      	str	r3, [r2, #0]
 8007cb0:	4613      	mov	r3, r2
}
 8007cb2:	e77c      	b.n	8007bae <xTaskIncrementTick.part.0+0x16>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8007cb4:	9a01      	ldr	r2, [sp, #4]
 8007cb6:	f04f 33ff 	mov.w	r3, #4294967295
 8007cba:	6013      	str	r3, [r2, #0]
					break;
 8007cbc:	e7c9      	b.n	8007c52 <xTaskIncrementTick.part.0+0xba>
 8007cbe:	bf00      	nop
 8007cc0:	2000261c 	.word	0x2000261c
 8007cc4:	20002600 	.word	0x20002600
 8007cc8:	20002668 	.word	0x20002668
 8007ccc:	20002618 	.word	0x20002618
 8007cd0:	2000260c 	.word	0x2000260c
 8007cd4:	20002664 	.word	0x20002664
 8007cd8:	20002608 	.word	0x20002608
 8007cdc:	20002694 	.word	0x20002694
 8007ce0:	20002720 	.word	0x20002720

08007ce4 <xTaskResumeAll.part.0>:
BaseType_t xTaskResumeAll( void )
 8007ce4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		--uxSchedulerSuspended;
 8007ce8:	4d48      	ldr	r5, [pc, #288]	@ (8007e0c <xTaskResumeAll.part.0+0x128>)
BaseType_t xTaskResumeAll( void )
 8007cea:	b083      	sub	sp, #12
	taskENTER_CRITICAL();
 8007cec:	f7ff fdba 	bl	8007864 <vPortEnterCritical>
		--uxSchedulerSuspended;
 8007cf0:	682b      	ldr	r3, [r5, #0]
 8007cf2:	3b01      	subs	r3, #1
 8007cf4:	602b      	str	r3, [r5, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8007cf6:	682b      	ldr	r3, [r5, #0]
 8007cf8:	2b00      	cmp	r3, #0
 8007cfa:	d16e      	bne.n	8007dda <xTaskResumeAll.part.0+0xf6>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8007cfc:	4b44      	ldr	r3, [pc, #272]	@ (8007e10 <xTaskResumeAll.part.0+0x12c>)
 8007cfe:	681b      	ldr	r3, [r3, #0]
 8007d00:	2b00      	cmp	r3, #0
 8007d02:	d06a      	beq.n	8007dda <xTaskResumeAll.part.0+0xf6>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8007d04:	f8df a120 	ldr.w	sl, [pc, #288]	@ 8007e28 <xTaskResumeAll.part.0+0x144>
 8007d08:	f8da 2000 	ldr.w	r2, [sl]
 8007d0c:	2a00      	cmp	r2, #0
 8007d0e:	d079      	beq.n	8007e04 <xTaskResumeAll.part.0+0x120>
 8007d10:	4b40      	ldr	r3, [pc, #256]	@ (8007e14 <xTaskResumeAll.part.0+0x130>)
 8007d12:	4e41      	ldr	r6, [pc, #260]	@ (8007e18 <xTaskResumeAll.part.0+0x134>)
 8007d14:	f8df 9114 	ldr.w	r9, [pc, #276]	@ 8007e2c <xTaskResumeAll.part.0+0x148>
 8007d18:	f8df 8114 	ldr.w	r8, [pc, #276]	@ 8007e30 <xTaskResumeAll.part.0+0x14c>
 8007d1c:	9301      	str	r3, [sp, #4]
					prvAddTaskToReadyList( pxTCB );
 8007d1e:	2701      	movs	r7, #1
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8007d20:	f8da 200c 	ldr.w	r2, [sl, #12]
 8007d24:	f8d2 b00c 	ldr.w	fp, [r2, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8007d28:	f10b 0404 	add.w	r4, fp, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8007d2c:	f10b 0018 	add.w	r0, fp, #24
 8007d30:	f7ff fd1a 	bl	8007768 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8007d34:	4620      	mov	r0, r4
 8007d36:	f7ff fd17 	bl	8007768 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8007d3a:	f8db 002c 	ldr.w	r0, [fp, #44]	@ 0x2c
 8007d3e:	6831      	ldr	r1, [r6, #0]
 8007d40:	fa07 f200 	lsl.w	r2, r7, r0
 8007d44:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8007d48:	430a      	orrs	r2, r1
 8007d4a:	eb09 0080 	add.w	r0, r9, r0, lsl #2
 8007d4e:	4621      	mov	r1, r4
 8007d50:	6032      	str	r2, [r6, #0]
 8007d52:	f7ff fce3 	bl	800771c <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8007d56:	f8d8 2000 	ldr.w	r2, [r8]
 8007d5a:	f8db 102c 	ldr.w	r1, [fp, #44]	@ 0x2c
 8007d5e:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 8007d60:	4291      	cmp	r1, r2
 8007d62:	d341      	bcc.n	8007de8 <xTaskResumeAll.part.0+0x104>
						xYieldPending = pdTRUE;
 8007d64:	9b01      	ldr	r3, [sp, #4]
 8007d66:	601f      	str	r7, [r3, #0]
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8007d68:	f8da 2000 	ldr.w	r2, [sl]
 8007d6c:	2a00      	cmp	r2, #0
 8007d6e:	d1d7      	bne.n	8007d20 <xTaskResumeAll.part.0+0x3c>
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8007d70:	4b2a      	ldr	r3, [pc, #168]	@ (8007e1c <xTaskResumeAll.part.0+0x138>)
 8007d72:	681a      	ldr	r2, [r3, #0]
 8007d74:	6812      	ldr	r2, [r2, #0]
 8007d76:	2a00      	cmp	r2, #0
 8007d78:	d03f      	beq.n	8007dfa <xTaskResumeAll.part.0+0x116>
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8007d7a:	681a      	ldr	r2, [r3, #0]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8007d7c:	4b28      	ldr	r3, [pc, #160]	@ (8007e20 <xTaskResumeAll.part.0+0x13c>)
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8007d7e:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8007d80:	68d2      	ldr	r2, [r2, #12]
 8007d82:	6852      	ldr	r2, [r2, #4]
 8007d84:	601a      	str	r2, [r3, #0]
					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 8007d86:	4e27      	ldr	r6, [pc, #156]	@ (8007e24 <xTaskResumeAll.part.0+0x140>)
 8007d88:	6834      	ldr	r4, [r6, #0]
					if( xPendedCounts > ( TickType_t ) 0U )
 8007d8a:	b194      	cbz	r4, 8007db2 <xTaskResumeAll.part.0+0xce>
								xYieldPending = pdTRUE;
 8007d8c:	2701      	movs	r7, #1
 8007d8e:	e006      	b.n	8007d9e <xTaskResumeAll.part.0+0xba>
 8007d90:	f7ff ff02 	bl	8007b98 <xTaskIncrementTick.part.0>
							if( xTaskIncrementTick() != pdFALSE )
 8007d94:	b108      	cbz	r0, 8007d9a <xTaskResumeAll.part.0+0xb6>
								xYieldPending = pdTRUE;
 8007d96:	9b01      	ldr	r3, [sp, #4]
 8007d98:	601f      	str	r7, [r3, #0]
						} while( xPendedCounts > ( TickType_t ) 0U );
 8007d9a:	3c01      	subs	r4, #1
 8007d9c:	d008      	beq.n	8007db0 <xTaskResumeAll.part.0+0xcc>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8007d9e:	682b      	ldr	r3, [r5, #0]
 8007da0:	2b00      	cmp	r3, #0
 8007da2:	d0f5      	beq.n	8007d90 <xTaskResumeAll.part.0+0xac>
		++xPendedTicks;
 8007da4:	6833      	ldr	r3, [r6, #0]
						} while( xPendedCounts > ( TickType_t ) 0U );
 8007da6:	3c01      	subs	r4, #1
		++xPendedTicks;
 8007da8:	f103 0301 	add.w	r3, r3, #1
 8007dac:	6033      	str	r3, [r6, #0]
						} while( xPendedCounts > ( TickType_t ) 0U );
 8007dae:	d1f6      	bne.n	8007d9e <xTaskResumeAll.part.0+0xba>
						xPendedTicks = 0;
 8007db0:	6034      	str	r4, [r6, #0]
				if( xYieldPending != pdFALSE )
 8007db2:	9b01      	ldr	r3, [sp, #4]
 8007db4:	681b      	ldr	r3, [r3, #0]
 8007db6:	b183      	cbz	r3, 8007dda <xTaskResumeAll.part.0+0xf6>
					taskYIELD_IF_USING_PREEMPTION();
 8007db8:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8007dbc:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8007dc0:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8007dc4:	f3bf 8f4f 	dsb	sy
 8007dc8:	f3bf 8f6f 	isb	sy
	taskEXIT_CRITICAL();
 8007dcc:	f7ff fd6c 	bl	80078a8 <vPortExitCritical>
						xAlreadyYielded = pdTRUE;
 8007dd0:	2401      	movs	r4, #1
}
 8007dd2:	4620      	mov	r0, r4
 8007dd4:	b003      	add	sp, #12
 8007dd6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	taskEXIT_CRITICAL();
 8007dda:	f7ff fd65 	bl	80078a8 <vPortExitCritical>
BaseType_t xAlreadyYielded = pdFALSE;
 8007dde:	2400      	movs	r4, #0
}
 8007de0:	4620      	mov	r0, r4
 8007de2:	b003      	add	sp, #12
 8007de4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8007de8:	f8da 2000 	ldr.w	r2, [sl]
 8007dec:	2a00      	cmp	r2, #0
 8007dee:	d197      	bne.n	8007d20 <xTaskResumeAll.part.0+0x3c>
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8007df0:	4b0a      	ldr	r3, [pc, #40]	@ (8007e1c <xTaskResumeAll.part.0+0x138>)
 8007df2:	681a      	ldr	r2, [r3, #0]
 8007df4:	6812      	ldr	r2, [r2, #0]
 8007df6:	2a00      	cmp	r2, #0
 8007df8:	d1bf      	bne.n	8007d7a <xTaskResumeAll.part.0+0x96>
		xNextTaskUnblockTime = portMAX_DELAY;
 8007dfa:	4b09      	ldr	r3, [pc, #36]	@ (8007e20 <xTaskResumeAll.part.0+0x13c>)
 8007dfc:	f04f 32ff 	mov.w	r2, #4294967295
 8007e00:	601a      	str	r2, [r3, #0]
 8007e02:	e7c0      	b.n	8007d86 <xTaskResumeAll.part.0+0xa2>
 8007e04:	4b03      	ldr	r3, [pc, #12]	@ (8007e14 <xTaskResumeAll.part.0+0x130>)
 8007e06:	9301      	str	r3, [sp, #4]
 8007e08:	e7bd      	b.n	8007d86 <xTaskResumeAll.part.0+0xa2>
 8007e0a:	bf00      	nop
 8007e0c:	200025f8 	.word	0x200025f8
 8007e10:	20002620 	.word	0x20002620
 8007e14:	2000260c 	.word	0x2000260c
 8007e18:	20002618 	.word	0x20002618
 8007e1c:	20002668 	.word	0x20002668
 8007e20:	20002600 	.word	0x20002600
 8007e24:	20002610 	.word	0x20002610
 8007e28:	20002650 	.word	0x20002650
 8007e2c:	20002694 	.word	0x20002694
 8007e30:	20002720 	.word	0x20002720

08007e34 <xTaskCreate>:
	{
 8007e34:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 8007e38:	0095      	lsls	r5, r2, #2
	{
 8007e3a:	4680      	mov	r8, r0
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 8007e3c:	4628      	mov	r0, r5
	{
 8007e3e:	460e      	mov	r6, r1
 8007e40:	4699      	mov	r9, r3
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 8007e42:	f7ff fb3f 	bl	80074c4 <pvPortMalloc>
			if( pxStack != NULL )
 8007e46:	2800      	cmp	r0, #0
 8007e48:	f000 80ac 	beq.w	8007fa4 <xTaskCreate+0x170>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 8007e4c:	4607      	mov	r7, r0
 8007e4e:	2054      	movs	r0, #84	@ 0x54
 8007e50:	f7ff fb38 	bl	80074c4 <pvPortMalloc>
				if( pxNewTCB != NULL )
 8007e54:	4604      	mov	r4, r0
 8007e56:	2800      	cmp	r0, #0
 8007e58:	f000 80a1 	beq.w	8007f9e <xTaskCreate+0x16a>
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 8007e5c:	3d04      	subs	r5, #4
 8007e5e:	443d      	add	r5, r7
					pxNewTCB->pxStack = pxStack;
 8007e60:	6307      	str	r7, [r0, #48]	@ 0x30
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 8007e62:	f025 0507 	bic.w	r5, r5, #7
	if( pcName != NULL )
 8007e66:	2e00      	cmp	r6, #0
 8007e68:	f000 80af 	beq.w	8007fca <xTaskCreate+0x196>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007e6c:	7833      	ldrb	r3, [r6, #0]
 8007e6e:	f880 3034 	strb.w	r3, [r0, #52]	@ 0x34
			if( pcName[ x ] == ( char ) 0x00 )
 8007e72:	2b00      	cmp	r3, #0
 8007e74:	d036      	beq.n	8007ee4 <xTaskCreate+0xb0>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007e76:	7873      	ldrb	r3, [r6, #1]
 8007e78:	f880 3035 	strb.w	r3, [r0, #53]	@ 0x35
			if( pcName[ x ] == ( char ) 0x00 )
 8007e7c:	b393      	cbz	r3, 8007ee4 <xTaskCreate+0xb0>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007e7e:	78b3      	ldrb	r3, [r6, #2]
 8007e80:	f880 3036 	strb.w	r3, [r0, #54]	@ 0x36
			if( pcName[ x ] == ( char ) 0x00 )
 8007e84:	b373      	cbz	r3, 8007ee4 <xTaskCreate+0xb0>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007e86:	78f3      	ldrb	r3, [r6, #3]
 8007e88:	f880 3037 	strb.w	r3, [r0, #55]	@ 0x37
			if( pcName[ x ] == ( char ) 0x00 )
 8007e8c:	b353      	cbz	r3, 8007ee4 <xTaskCreate+0xb0>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007e8e:	7933      	ldrb	r3, [r6, #4]
 8007e90:	f880 3038 	strb.w	r3, [r0, #56]	@ 0x38
			if( pcName[ x ] == ( char ) 0x00 )
 8007e94:	b333      	cbz	r3, 8007ee4 <xTaskCreate+0xb0>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007e96:	7973      	ldrb	r3, [r6, #5]
 8007e98:	f880 3039 	strb.w	r3, [r0, #57]	@ 0x39
			if( pcName[ x ] == ( char ) 0x00 )
 8007e9c:	b313      	cbz	r3, 8007ee4 <xTaskCreate+0xb0>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007e9e:	79b3      	ldrb	r3, [r6, #6]
 8007ea0:	f880 303a 	strb.w	r3, [r0, #58]	@ 0x3a
			if( pcName[ x ] == ( char ) 0x00 )
 8007ea4:	b1f3      	cbz	r3, 8007ee4 <xTaskCreate+0xb0>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007ea6:	79f3      	ldrb	r3, [r6, #7]
 8007ea8:	f880 303b 	strb.w	r3, [r0, #59]	@ 0x3b
			if( pcName[ x ] == ( char ) 0x00 )
 8007eac:	b1d3      	cbz	r3, 8007ee4 <xTaskCreate+0xb0>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007eae:	7a33      	ldrb	r3, [r6, #8]
 8007eb0:	f880 303c 	strb.w	r3, [r0, #60]	@ 0x3c
			if( pcName[ x ] == ( char ) 0x00 )
 8007eb4:	b1b3      	cbz	r3, 8007ee4 <xTaskCreate+0xb0>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007eb6:	7a73      	ldrb	r3, [r6, #9]
 8007eb8:	f880 303d 	strb.w	r3, [r0, #61]	@ 0x3d
			if( pcName[ x ] == ( char ) 0x00 )
 8007ebc:	b193      	cbz	r3, 8007ee4 <xTaskCreate+0xb0>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007ebe:	7ab3      	ldrb	r3, [r6, #10]
 8007ec0:	f880 303e 	strb.w	r3, [r0, #62]	@ 0x3e
			if( pcName[ x ] == ( char ) 0x00 )
 8007ec4:	b173      	cbz	r3, 8007ee4 <xTaskCreate+0xb0>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007ec6:	7af3      	ldrb	r3, [r6, #11]
 8007ec8:	f880 303f 	strb.w	r3, [r0, #63]	@ 0x3f
			if( pcName[ x ] == ( char ) 0x00 )
 8007ecc:	b153      	cbz	r3, 8007ee4 <xTaskCreate+0xb0>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007ece:	7b33      	ldrb	r3, [r6, #12]
 8007ed0:	f880 3040 	strb.w	r3, [r0, #64]	@ 0x40
			if( pcName[ x ] == ( char ) 0x00 )
 8007ed4:	b133      	cbz	r3, 8007ee4 <xTaskCreate+0xb0>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007ed6:	7b73      	ldrb	r3, [r6, #13]
 8007ed8:	f880 3041 	strb.w	r3, [r0, #65]	@ 0x41
			if( pcName[ x ] == ( char ) 0x00 )
 8007edc:	b113      	cbz	r3, 8007ee4 <xTaskCreate+0xb0>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007ede:	7bb3      	ldrb	r3, [r6, #14]
 8007ee0:	f880 3042 	strb.w	r3, [r0, #66]	@ 0x42
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8007ee4:	2300      	movs	r3, #0
 8007ee6:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 8007eea:	9e08      	ldr	r6, [sp, #32]
 8007eec:	2e06      	cmp	r6, #6
 8007eee:	bf28      	it	cs
 8007ef0:	2606      	movcs	r6, #6
		pxNewTCB->uxMutexesHeld = 0;
 8007ef2:	f04f 0a00 	mov.w	sl, #0
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8007ef6:	1d27      	adds	r7, r4, #4
	pxNewTCB->uxPriority = uxPriority;
 8007ef8:	62e6      	str	r6, [r4, #44]	@ 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
 8007efa:	6466      	str	r6, [r4, #68]	@ 0x44
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8007efc:	4638      	mov	r0, r7
		pxNewTCB->uxMutexesHeld = 0;
 8007efe:	f8c4 a048 	str.w	sl, [r4, #72]	@ 0x48
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8007f02:	f7ff fc07 	bl	8007714 <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8007f06:	f1c6 0607 	rsb	r6, r6, #7
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 8007f0a:	f104 0018 	add.w	r0, r4, #24
 8007f0e:	f7ff fc01 	bl	8007714 <vListInitialiseItem>
		pxNewTCB->ulNotifiedValue = 0;
 8007f12:	f8c4 a04c 	str.w	sl, [r4, #76]	@ 0x4c
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8007f16:	61a6      	str	r6, [r4, #24]
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8007f18:	f884 a050 	strb.w	sl, [r4, #80]	@ 0x50
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8007f1c:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 8007f1e:	6264      	str	r4, [r4, #36]	@ 0x24
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8007f20:	464a      	mov	r2, r9
 8007f22:	4641      	mov	r1, r8
 8007f24:	4628      	mov	r0, r5
 8007f26:	f7ff fc71 	bl	800780c <pxPortInitialiseStack>
	if( pxCreatedTask != NULL )
 8007f2a:	9b09      	ldr	r3, [sp, #36]	@ 0x24
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8007f2c:	6020      	str	r0, [r4, #0]
	if( pxCreatedTask != NULL )
 8007f2e:	b103      	cbz	r3, 8007f32 <xTaskCreate+0xfe>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8007f30:	601c      	str	r4, [r3, #0]
	taskENTER_CRITICAL();
 8007f32:	f7ff fc97 	bl	8007864 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 8007f36:	4a39      	ldr	r2, [pc, #228]	@ (800801c <xTaskCreate+0x1e8>)
		if( pxCurrentTCB == NULL )
 8007f38:	4d39      	ldr	r5, [pc, #228]	@ (8008020 <xTaskCreate+0x1ec>)
		uxCurrentNumberOfTasks++;
 8007f3a:	6813      	ldr	r3, [r2, #0]
 8007f3c:	3301      	adds	r3, #1
 8007f3e:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
 8007f40:	682b      	ldr	r3, [r5, #0]
 8007f42:	2b00      	cmp	r3, #0
 8007f44:	d038      	beq.n	8007fb8 <xTaskCreate+0x184>
			if( xSchedulerRunning == pdFALSE )
 8007f46:	4e37      	ldr	r6, [pc, #220]	@ (8008024 <xTaskCreate+0x1f0>)
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8007f48:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
			if( xSchedulerRunning == pdFALSE )
 8007f4a:	6833      	ldr	r3, [r6, #0]
 8007f4c:	b373      	cbz	r3, 8007fac <xTaskCreate+0x178>
 8007f4e:	f8df 80f8 	ldr.w	r8, [pc, #248]	@ 8008048 <xTaskCreate+0x214>
		prvAddTaskToReadyList( pxNewTCB );
 8007f52:	4a35      	ldr	r2, [pc, #212]	@ (8008028 <xTaskCreate+0x1f4>)
 8007f54:	4639      	mov	r1, r7
		uxTaskNumber++;
 8007f56:	4f35      	ldr	r7, [pc, #212]	@ (800802c <xTaskCreate+0x1f8>)
 8007f58:	683b      	ldr	r3, [r7, #0]
 8007f5a:	3301      	adds	r3, #1
 8007f5c:	603b      	str	r3, [r7, #0]
		prvAddTaskToReadyList( pxNewTCB );
 8007f5e:	6817      	ldr	r7, [r2, #0]
 8007f60:	2301      	movs	r3, #1
 8007f62:	4083      	lsls	r3, r0
 8007f64:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8007f68:	433b      	orrs	r3, r7
 8007f6a:	eb08 0080 	add.w	r0, r8, r0, lsl #2
 8007f6e:	6013      	str	r3, [r2, #0]
 8007f70:	f7ff fbd4 	bl	800771c <vListInsertEnd>
	taskEXIT_CRITICAL();
 8007f74:	f7ff fc98 	bl	80078a8 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 8007f78:	6833      	ldr	r3, [r6, #0]
 8007f7a:	b173      	cbz	r3, 8007f9a <xTaskCreate+0x166>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 8007f7c:	682a      	ldr	r2, [r5, #0]
 8007f7e:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 8007f80:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 8007f82:	429a      	cmp	r2, r3
 8007f84:	d209      	bcs.n	8007f9a <xTaskCreate+0x166>
			taskYIELD_IF_USING_PREEMPTION();
 8007f86:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8007f8a:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8007f8e:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8007f92:	f3bf 8f4f 	dsb	sy
 8007f96:	f3bf 8f6f 	isb	sy
			xReturn = pdPASS;
 8007f9a:	2001      	movs	r0, #1
		return xReturn;
 8007f9c:	e004      	b.n	8007fa8 <xTaskCreate+0x174>
					vPortFree( pxStack );
 8007f9e:	4638      	mov	r0, r7
 8007fa0:	f7ff fb48 	bl	8007634 <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8007fa4:	f04f 30ff 	mov.w	r0, #4294967295
	}
 8007fa8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8007fac:	682b      	ldr	r3, [r5, #0]
 8007fae:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8007fb0:	4283      	cmp	r3, r0
					pxCurrentTCB = pxNewTCB;
 8007fb2:	bf98      	it	ls
 8007fb4:	602c      	strls	r4, [r5, #0]
 8007fb6:	e7ca      	b.n	8007f4e <xTaskCreate+0x11a>
			pxCurrentTCB = pxNewTCB;
 8007fb8:	602c      	str	r4, [r5, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8007fba:	6813      	ldr	r3, [r2, #0]
 8007fbc:	2b01      	cmp	r3, #1
 8007fbe:	d007      	beq.n	8007fd0 <xTaskCreate+0x19c>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8007fc0:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
 8007fc2:	f8df 8084 	ldr.w	r8, [pc, #132]	@ 8008048 <xTaskCreate+0x214>
 8007fc6:	4e17      	ldr	r6, [pc, #92]	@ (8008024 <xTaskCreate+0x1f0>)
 8007fc8:	e7c3      	b.n	8007f52 <xTaskCreate+0x11e>
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
 8007fca:	f880 6034 	strb.w	r6, [r0, #52]	@ 0x34
 8007fce:	e78c      	b.n	8007eea <xTaskCreate+0xb6>
 8007fd0:	f8df 8074 	ldr.w	r8, [pc, #116]	@ 8008048 <xTaskCreate+0x214>
 8007fd4:	4646      	mov	r6, r8
 8007fd6:	f108 098c 	add.w	r9, r8, #140	@ 0x8c
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8007fda:	4630      	mov	r0, r6
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8007fdc:	3614      	adds	r6, #20
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8007fde:	f7ff fb8d 	bl	80076fc <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8007fe2:	454e      	cmp	r6, r9
 8007fe4:	d1f9      	bne.n	8007fda <xTaskCreate+0x1a6>
	vListInitialise( &xDelayedTaskList1 );
 8007fe6:	f8df 9064 	ldr.w	r9, [pc, #100]	@ 800804c <xTaskCreate+0x218>
	vListInitialise( &xDelayedTaskList2 );
 8007fea:	4e11      	ldr	r6, [pc, #68]	@ (8008030 <xTaskCreate+0x1fc>)
	vListInitialise( &xDelayedTaskList1 );
 8007fec:	4648      	mov	r0, r9
 8007fee:	f7ff fb85 	bl	80076fc <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8007ff2:	4630      	mov	r0, r6
 8007ff4:	f7ff fb82 	bl	80076fc <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8007ff8:	480e      	ldr	r0, [pc, #56]	@ (8008034 <xTaskCreate+0x200>)
 8007ffa:	f7ff fb7f 	bl	80076fc <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 8007ffe:	480e      	ldr	r0, [pc, #56]	@ (8008038 <xTaskCreate+0x204>)
 8008000:	f7ff fb7c 	bl	80076fc <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 8008004:	480d      	ldr	r0, [pc, #52]	@ (800803c <xTaskCreate+0x208>)
 8008006:	f7ff fb79 	bl	80076fc <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
 800800a:	4b0d      	ldr	r3, [pc, #52]	@ (8008040 <xTaskCreate+0x20c>)
		prvAddTaskToReadyList( pxNewTCB );
 800800c:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
	pxDelayedTaskList = &xDelayedTaskList1;
 800800e:	f8c3 9000 	str.w	r9, [r3]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8008012:	4b0c      	ldr	r3, [pc, #48]	@ (8008044 <xTaskCreate+0x210>)
 8008014:	601e      	str	r6, [r3, #0]
 8008016:	4e03      	ldr	r6, [pc, #12]	@ (8008024 <xTaskCreate+0x1f0>)
}
 8008018:	e79b      	b.n	8007f52 <xTaskCreate+0x11e>
 800801a:	bf00      	nop
 800801c:	20002620 	.word	0x20002620
 8008020:	20002720 	.word	0x20002720
 8008024:	20002614 	.word	0x20002614
 8008028:	20002618 	.word	0x20002618
 800802c:	20002604 	.word	0x20002604
 8008030:	2000266c 	.word	0x2000266c
 8008034:	20002650 	.word	0x20002650
 8008038:	2000263c 	.word	0x2000263c
 800803c:	20002624 	.word	0x20002624
 8008040:	20002668 	.word	0x20002668
 8008044:	20002664 	.word	0x20002664
 8008048:	20002694 	.word	0x20002694
 800804c:	20002680 	.word	0x20002680

08008050 <vTaskDelay>:
	{
 8008050:	b510      	push	{r4, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
 8008052:	b950      	cbnz	r0, 800806a <vTaskDelay+0x1a>
			portYIELD_WITHIN_API();
 8008054:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8008058:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 800805c:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8008060:	f3bf 8f4f 	dsb	sy
 8008064:	f3bf 8f6f 	isb	sy
	}
 8008068:	bd10      	pop	{r4, pc}
			configASSERT( uxSchedulerSuspended == 0 );
 800806a:	4c10      	ldr	r4, [pc, #64]	@ (80080ac <vTaskDelay+0x5c>)
 800806c:	6821      	ldr	r1, [r4, #0]
 800806e:	b141      	cbz	r1, 8008082 <vTaskDelay+0x32>
 8008070:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8008074:	f383 8811 	msr	BASEPRI, r3
 8008078:	f3bf 8f6f 	isb	sy
 800807c:	f3bf 8f4f 	dsb	sy
 8008080:	e7fe      	b.n	8008080 <vTaskDelay+0x30>
	++uxSchedulerSuspended;
 8008082:	6823      	ldr	r3, [r4, #0]
 8008084:	3301      	adds	r3, #1
 8008086:	6023      	str	r3, [r4, #0]
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 8008088:	f7ff fd40 	bl	8007b0c <prvAddCurrentTaskToDelayedList>
	configASSERT( uxSchedulerSuspended );
 800808c:	6823      	ldr	r3, [r4, #0]
 800808e:	b943      	cbnz	r3, 80080a2 <vTaskDelay+0x52>
 8008090:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8008094:	f383 8811 	msr	BASEPRI, r3
 8008098:	f3bf 8f6f 	isb	sy
 800809c:	f3bf 8f4f 	dsb	sy
 80080a0:	e7fe      	b.n	80080a0 <vTaskDelay+0x50>
 80080a2:	f7ff fe1f 	bl	8007ce4 <xTaskResumeAll.part.0>
		if( xAlreadyYielded == pdFALSE )
 80080a6:	2800      	cmp	r0, #0
 80080a8:	d0d4      	beq.n	8008054 <vTaskDelay+0x4>
	}
 80080aa:	bd10      	pop	{r4, pc}
 80080ac:	200025f8 	.word	0x200025f8

080080b0 <vTaskStartScheduler>:
{
 80080b0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 80080b4:	f44f 7000 	mov.w	r0, #512	@ 0x200
 80080b8:	f7ff fa04 	bl	80074c4 <pvPortMalloc>
			if( pxStack != NULL )
 80080bc:	2800      	cmp	r0, #0
 80080be:	d079      	beq.n	80081b4 <vTaskStartScheduler+0x104>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 80080c0:	4605      	mov	r5, r0
 80080c2:	2054      	movs	r0, #84	@ 0x54
 80080c4:	f7ff f9fe 	bl	80074c4 <pvPortMalloc>
				if( pxNewTCB != NULL )
 80080c8:	4604      	mov	r4, r0
 80080ca:	2800      	cmp	r0, #0
 80080cc:	d06f      	beq.n	80081ae <vTaskStartScheduler+0xfe>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80080ce:	2600      	movs	r6, #0
 80080d0:	4b57      	ldr	r3, [pc, #348]	@ (8008230 <vTaskStartScheduler+0x180>)
 80080d2:	6343      	str	r3, [r0, #52]	@ 0x34
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 80080d4:	1d07      	adds	r7, r0, #4
		pxNewTCB->uxMutexesHeld = 0;
 80080d6:	e9c0 6611 	strd	r6, r6, [r0, #68]	@ 0x44
					pxNewTCB->pxStack = pxStack;
 80080da:	6305      	str	r5, [r0, #48]	@ 0x30
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80080dc:	f880 6038 	strb.w	r6, [r0, #56]	@ 0x38
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 80080e0:	f880 6043 	strb.w	r6, [r0, #67]	@ 0x43
	pxNewTCB->uxPriority = uxPriority;
 80080e4:	62c6      	str	r6, [r0, #44]	@ 0x2c
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 80080e6:	4638      	mov	r0, r7
 80080e8:	f7ff fb14 	bl	8007714 <vListInitialiseItem>
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 80080ec:	f505 75fe 	add.w	r5, r5, #508	@ 0x1fc
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 80080f0:	f104 0018 	add.w	r0, r4, #24
 80080f4:	f7ff fb0e 	bl	8007714 <vListInitialiseItem>
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 80080f8:	f025 0507 	bic.w	r5, r5, #7
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80080fc:	2307      	movs	r3, #7
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 80080fe:	4632      	mov	r2, r6
		pxNewTCB->ulNotifiedValue = 0;
 8008100:	64e6      	str	r6, [r4, #76]	@ 0x4c
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8008102:	494c      	ldr	r1, [pc, #304]	@ (8008234 <vTaskStartScheduler+0x184>)
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8008104:	61a3      	str	r3, [r4, #24]
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8008106:	f884 6050 	strb.w	r6, [r4, #80]	@ 0x50
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 800810a:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 800810c:	6264      	str	r4, [r4, #36]	@ 0x24
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800810e:	4628      	mov	r0, r5
 8008110:	f7ff fb7c 	bl	800780c <pxPortInitialiseStack>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8008114:	4b48      	ldr	r3, [pc, #288]	@ (8008238 <vTaskStartScheduler+0x188>)
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8008116:	6020      	str	r0, [r4, #0]
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8008118:	601c      	str	r4, [r3, #0]
	taskENTER_CRITICAL();
 800811a:	f7ff fba3 	bl	8007864 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 800811e:	4a47      	ldr	r2, [pc, #284]	@ (800823c <vTaskStartScheduler+0x18c>)
		if( pxCurrentTCB == NULL )
 8008120:	4e47      	ldr	r6, [pc, #284]	@ (8008240 <vTaskStartScheduler+0x190>)
		uxCurrentNumberOfTasks++;
 8008122:	6813      	ldr	r3, [r2, #0]
 8008124:	3301      	adds	r3, #1
 8008126:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
 8008128:	6833      	ldr	r3, [r6, #0]
 800812a:	2b00      	cmp	r3, #0
 800812c:	d051      	beq.n	80081d2 <vTaskStartScheduler+0x122>
			if( xSchedulerRunning == pdFALSE )
 800812e:	4d45      	ldr	r5, [pc, #276]	@ (8008244 <vTaskStartScheduler+0x194>)
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8008130:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
			if( xSchedulerRunning == pdFALSE )
 8008132:	682b      	ldr	r3, [r5, #0]
 8008134:	2b00      	cmp	r3, #0
 8008136:	d046      	beq.n	80081c6 <vTaskStartScheduler+0x116>
 8008138:	f8df 8134 	ldr.w	r8, [pc, #308]	@ 8008270 <vTaskStartScheduler+0x1c0>
		prvAddTaskToReadyList( pxNewTCB );
 800813c:	4a42      	ldr	r2, [pc, #264]	@ (8008248 <vTaskStartScheduler+0x198>)
 800813e:	4639      	mov	r1, r7
		uxTaskNumber++;
 8008140:	4f42      	ldr	r7, [pc, #264]	@ (800824c <vTaskStartScheduler+0x19c>)
 8008142:	683b      	ldr	r3, [r7, #0]
 8008144:	3301      	adds	r3, #1
 8008146:	603b      	str	r3, [r7, #0]
		prvAddTaskToReadyList( pxNewTCB );
 8008148:	6817      	ldr	r7, [r2, #0]
 800814a:	2301      	movs	r3, #1
 800814c:	4083      	lsls	r3, r0
 800814e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8008152:	433b      	orrs	r3, r7
 8008154:	eb08 0080 	add.w	r0, r8, r0, lsl #2
 8008158:	6013      	str	r3, [r2, #0]
 800815a:	f7ff fadf 	bl	800771c <vListInsertEnd>
	taskEXIT_CRITICAL();
 800815e:	f7ff fba3 	bl	80078a8 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 8008162:	682b      	ldr	r3, [r5, #0]
 8008164:	b173      	cbz	r3, 8008184 <vTaskStartScheduler+0xd4>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 8008166:	6832      	ldr	r2, [r6, #0]
 8008168:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 800816a:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 800816c:	429a      	cmp	r2, r3
 800816e:	d209      	bcs.n	8008184 <vTaskStartScheduler+0xd4>
			taskYIELD_IF_USING_PREEMPTION();
 8008170:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8008174:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8008178:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 800817c:	f3bf 8f4f 	dsb	sy
 8008180:	f3bf 8f6f 	isb	sy
 8008184:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8008188:	f383 8811 	msr	BASEPRI, r3
 800818c:	f3bf 8f6f 	isb	sy
 8008190:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
 8008194:	4a2e      	ldr	r2, [pc, #184]	@ (8008250 <vTaskStartScheduler+0x1a0>)
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 8008196:	4b2f      	ldr	r3, [pc, #188]	@ (8008254 <vTaskStartScheduler+0x1a4>)
		xNextTaskUnblockTime = portMAX_DELAY;
 8008198:	f04f 30ff 	mov.w	r0, #4294967295
 800819c:	6010      	str	r0, [r2, #0]
		xSchedulerRunning = pdTRUE;
 800819e:	2101      	movs	r1, #1
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 80081a0:	2200      	movs	r2, #0
		xSchedulerRunning = pdTRUE;
 80081a2:	6029      	str	r1, [r5, #0]
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 80081a4:	601a      	str	r2, [r3, #0]
}
 80081a6:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		if( xPortStartScheduler() != pdFALSE )
 80081aa:	f7ff bbd9 	b.w	8007960 <xPortStartScheduler>
					vPortFree( pxStack );
 80081ae:	4628      	mov	r0, r5
 80081b0:	f7ff fa40 	bl	8007634 <vPortFree>
 80081b4:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80081b8:	f383 8811 	msr	BASEPRI, r3
 80081bc:	f3bf 8f6f 	isb	sy
 80081c0:	f3bf 8f4f 	dsb	sy
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 80081c4:	e7fe      	b.n	80081c4 <vTaskStartScheduler+0x114>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 80081c6:	6833      	ldr	r3, [r6, #0]
 80081c8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80081ca:	4283      	cmp	r3, r0
					pxCurrentTCB = pxNewTCB;
 80081cc:	bf98      	it	ls
 80081ce:	6034      	strls	r4, [r6, #0]
 80081d0:	e7b2      	b.n	8008138 <vTaskStartScheduler+0x88>
			pxCurrentTCB = pxNewTCB;
 80081d2:	6034      	str	r4, [r6, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 80081d4:	6813      	ldr	r3, [r2, #0]
 80081d6:	2b01      	cmp	r3, #1
 80081d8:	d004      	beq.n	80081e4 <vTaskStartScheduler+0x134>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 80081da:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
 80081dc:	f8df 8090 	ldr.w	r8, [pc, #144]	@ 8008270 <vTaskStartScheduler+0x1c0>
 80081e0:	4d18      	ldr	r5, [pc, #96]	@ (8008244 <vTaskStartScheduler+0x194>)
 80081e2:	e7ab      	b.n	800813c <vTaskStartScheduler+0x8c>
 80081e4:	f8df 8088 	ldr.w	r8, [pc, #136]	@ 8008270 <vTaskStartScheduler+0x1c0>
 80081e8:	4645      	mov	r5, r8
 80081ea:	f108 098c 	add.w	r9, r8, #140	@ 0x8c
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 80081ee:	4628      	mov	r0, r5
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 80081f0:	3514      	adds	r5, #20
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 80081f2:	f7ff fa83 	bl	80076fc <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 80081f6:	454d      	cmp	r5, r9
 80081f8:	d1f9      	bne.n	80081ee <vTaskStartScheduler+0x13e>
	vListInitialise( &xDelayedTaskList1 );
 80081fa:	f8df 9078 	ldr.w	r9, [pc, #120]	@ 8008274 <vTaskStartScheduler+0x1c4>
	vListInitialise( &xDelayedTaskList2 );
 80081fe:	4d16      	ldr	r5, [pc, #88]	@ (8008258 <vTaskStartScheduler+0x1a8>)
	vListInitialise( &xDelayedTaskList1 );
 8008200:	4648      	mov	r0, r9
 8008202:	f7ff fa7b 	bl	80076fc <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8008206:	4628      	mov	r0, r5
 8008208:	f7ff fa78 	bl	80076fc <vListInitialise>
	vListInitialise( &xPendingReadyList );
 800820c:	4813      	ldr	r0, [pc, #76]	@ (800825c <vTaskStartScheduler+0x1ac>)
 800820e:	f7ff fa75 	bl	80076fc <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 8008212:	4813      	ldr	r0, [pc, #76]	@ (8008260 <vTaskStartScheduler+0x1b0>)
 8008214:	f7ff fa72 	bl	80076fc <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 8008218:	4812      	ldr	r0, [pc, #72]	@ (8008264 <vTaskStartScheduler+0x1b4>)
 800821a:	f7ff fa6f 	bl	80076fc <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
 800821e:	4b12      	ldr	r3, [pc, #72]	@ (8008268 <vTaskStartScheduler+0x1b8>)
		prvAddTaskToReadyList( pxNewTCB );
 8008220:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
	pxDelayedTaskList = &xDelayedTaskList1;
 8008222:	f8c3 9000 	str.w	r9, [r3]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8008226:	4b11      	ldr	r3, [pc, #68]	@ (800826c <vTaskStartScheduler+0x1bc>)
 8008228:	601d      	str	r5, [r3, #0]
 800822a:	4d06      	ldr	r5, [pc, #24]	@ (8008244 <vTaskStartScheduler+0x194>)
}
 800822c:	e786      	b.n	800813c <vTaskStartScheduler+0x8c>
 800822e:	bf00      	nop
 8008230:	454c4449 	.word	0x454c4449
 8008234:	08007aa1 	.word	0x08007aa1
 8008238:	200025fc 	.word	0x200025fc
 800823c:	20002620 	.word	0x20002620
 8008240:	20002720 	.word	0x20002720
 8008244:	20002614 	.word	0x20002614
 8008248:	20002618 	.word	0x20002618
 800824c:	20002604 	.word	0x20002604
 8008250:	20002600 	.word	0x20002600
 8008254:	2000261c 	.word	0x2000261c
 8008258:	2000266c 	.word	0x2000266c
 800825c:	20002650 	.word	0x20002650
 8008260:	2000263c 	.word	0x2000263c
 8008264:	20002624 	.word	0x20002624
 8008268:	20002668 	.word	0x20002668
 800826c:	20002664 	.word	0x20002664
 8008270:	20002694 	.word	0x20002694
 8008274:	20002680 	.word	0x20002680

08008278 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 8008278:	4a02      	ldr	r2, [pc, #8]	@ (8008284 <vTaskSuspendAll+0xc>)
 800827a:	6813      	ldr	r3, [r2, #0]
 800827c:	3301      	adds	r3, #1
 800827e:	6013      	str	r3, [r2, #0]
}
 8008280:	4770      	bx	lr
 8008282:	bf00      	nop
 8008284:	200025f8 	.word	0x200025f8

08008288 <xTaskResumeAll>:
	configASSERT( uxSchedulerSuspended );
 8008288:	4b06      	ldr	r3, [pc, #24]	@ (80082a4 <xTaskResumeAll+0x1c>)
 800828a:	681b      	ldr	r3, [r3, #0]
 800828c:	b943      	cbnz	r3, 80082a0 <xTaskResumeAll+0x18>
 800828e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8008292:	f383 8811 	msr	BASEPRI, r3
 8008296:	f3bf 8f6f 	isb	sy
 800829a:	f3bf 8f4f 	dsb	sy
 800829e:	e7fe      	b.n	800829e <xTaskResumeAll+0x16>
 80082a0:	f7ff bd20 	b.w	8007ce4 <xTaskResumeAll.part.0>
 80082a4:	200025f8 	.word	0x200025f8

080082a8 <xTaskIncrementTick>:
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80082a8:	4b05      	ldr	r3, [pc, #20]	@ (80082c0 <xTaskIncrementTick+0x18>)
 80082aa:	681b      	ldr	r3, [r3, #0]
 80082ac:	b90b      	cbnz	r3, 80082b2 <xTaskIncrementTick+0xa>
 80082ae:	f7ff bc73 	b.w	8007b98 <xTaskIncrementTick.part.0>
		++xPendedTicks;
 80082b2:	4a04      	ldr	r2, [pc, #16]	@ (80082c4 <xTaskIncrementTick+0x1c>)
 80082b4:	6813      	ldr	r3, [r2, #0]
 80082b6:	3301      	adds	r3, #1
}
 80082b8:	2000      	movs	r0, #0
		++xPendedTicks;
 80082ba:	6013      	str	r3, [r2, #0]
}
 80082bc:	4770      	bx	lr
 80082be:	bf00      	nop
 80082c0:	200025f8 	.word	0x200025f8
 80082c4:	20002610 	.word	0x20002610

080082c8 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 80082c8:	4b16      	ldr	r3, [pc, #88]	@ (8008324 <vTaskSwitchContext+0x5c>)
 80082ca:	681b      	ldr	r3, [r3, #0]
 80082cc:	b11b      	cbz	r3, 80082d6 <vTaskSwitchContext+0xe>
		xYieldPending = pdTRUE;
 80082ce:	4b16      	ldr	r3, [pc, #88]	@ (8008328 <vTaskSwitchContext+0x60>)
 80082d0:	2201      	movs	r2, #1
 80082d2:	601a      	str	r2, [r3, #0]
 80082d4:	4770      	bx	lr
		xYieldPending = pdFALSE;
 80082d6:	4914      	ldr	r1, [pc, #80]	@ (8008328 <vTaskSwitchContext+0x60>)
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80082d8:	4a14      	ldr	r2, [pc, #80]	@ (800832c <vTaskSwitchContext+0x64>)
		xYieldPending = pdFALSE;
 80082da:	600b      	str	r3, [r1, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80082dc:	6813      	ldr	r3, [r2, #0]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 80082de:	fab3 f383 	clz	r3, r3
 80082e2:	b2db      	uxtb	r3, r3
 80082e4:	f1c3 031f 	rsb	r3, r3, #31
 80082e8:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80082ec:	4910      	ldr	r1, [pc, #64]	@ (8008330 <vTaskSwitchContext+0x68>)
 80082ee:	009a      	lsls	r2, r3, #2
 80082f0:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 80082f4:	5888      	ldr	r0, [r1, r2]
 80082f6:	b940      	cbnz	r0, 800830a <vTaskSwitchContext+0x42>
	__asm volatile
 80082f8:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80082fc:	f383 8811 	msr	BASEPRI, r3
 8008300:	f3bf 8f6f 	isb	sy
 8008304:	f3bf 8f4f 	dsb	sy
 8008308:	e7fe      	b.n	8008308 <vTaskSwitchContext+0x40>
 800830a:	6858      	ldr	r0, [r3, #4]
 800830c:	3208      	adds	r2, #8
 800830e:	6840      	ldr	r0, [r0, #4]
 8008310:	6058      	str	r0, [r3, #4]
 8008312:	440a      	add	r2, r1
 8008314:	4290      	cmp	r0, r2
 8008316:	bf04      	itt	eq
 8008318:	6840      	ldreq	r0, [r0, #4]
 800831a:	6058      	streq	r0, [r3, #4]
 800831c:	4b05      	ldr	r3, [pc, #20]	@ (8008334 <vTaskSwitchContext+0x6c>)
 800831e:	68c2      	ldr	r2, [r0, #12]
 8008320:	601a      	str	r2, [r3, #0]
}
 8008322:	4770      	bx	lr
 8008324:	200025f8 	.word	0x200025f8
 8008328:	2000260c 	.word	0x2000260c
 800832c:	20002618 	.word	0x20002618
 8008330:	20002694 	.word	0x20002694
 8008334:	20002720 	.word	0x20002720

08008338 <VBS_GetAvBusVoltage_V>:
    temp = 0U;
  }
  else
  {
#endif
    temp = (uint32_t)(pHandle->AvBusVoltage_d);
 8008338:	88c3      	ldrh	r3, [r0, #6]
    temp *= pHandle->ConversionFactor;
 800833a:	8840      	ldrh	r0, [r0, #2]
 800833c:	fb03 f000 	mul.w	r0, r3, r0
    temp /= 65536U;
#ifdef NULL_PTR_CHECK_BUS_VOLT
  }
#endif
  return ((uint16_t)temp);
}
 8008340:	0c00      	lsrs	r0, r0, #16
 8008342:	4770      	bx	lr

08008344 <Circle_Limitation>:
  *  @f$v_q = \sqrt(MaxModule^2-v_d^2\ ) @f$

  *
  */
__weak qd_t Circle_Limitation(const CircleLimitation_Handle_t *pHandle, qd_t Vqd)
{
 8008344:	b570      	push	{r4, r5, r6, lr}
    int32_t square_limit;
    int32_t vd_square_limit;
    int32_t new_q;
    int32_t new_d;

    maxModule = (int32_t)pHandle->MaxModule;
 8008346:	8803      	ldrh	r3, [r0, #0]
 8008348:	140d      	asrs	r5, r1, #16
 800834a:	b20c      	sxth	r4, r1

    square_q = ((int32_t)(Vqd.q)) * Vqd.q;
    square_d = ((int32_t)(Vqd.d)) * Vqd.d;
 800834c:	fb05 f205 	mul.w	r2, r5, r5
    square_limit = maxModule * maxModule;
 8008350:	fb03 f303 	mul.w	r3, r3, r3
    vd_square_limit = ((int32_t)pHandle->MaxVd) * ((int32_t)pHandle->MaxVd);
    square_sum = square_q + square_d;
 8008354:	fb04 2104 	mla	r1, r4, r4, r2

    if (square_sum > square_limit)
 8008358:	428b      	cmp	r3, r1
{
 800835a:	b084      	sub	sp, #16
    if (square_sum > square_limit)
 800835c:	da0f      	bge.n	800837e <Circle_Limitation+0x3a>
    vd_square_limit = ((int32_t)pHandle->MaxVd) * ((int32_t)pHandle->MaxVd);
 800835e:	8846      	ldrh	r6, [r0, #2]
 8008360:	fb06 f006 	mul.w	r0, r6, r6
    {
      if (square_d <= vd_square_limit)
 8008364:	4282      	cmp	r2, r0
 8008366:	dd13      	ble.n	8008390 <Circle_Limitation+0x4c>
        new_d = Vqd.d;
      }
      else
      {
        new_d = (int32_t)pHandle->MaxVd;
        if (Vqd.d < 0)
 8008368:	2d00      	cmp	r5, #0
#if defined CIRCLE_LIMITATION_SQRT_M0
        square_temp = (square_limit - vd_square_limit) / 1048576;
        new_q = SqrtTable[square_temp];
#else
        square_temp = square_limit - vd_square_limit;
        new_q = MCM_Sqrt(square_temp);
 800836a:	eba3 0000 	sub.w	r0, r3, r0
          new_d = -new_d;
 800836e:	bfb8      	it	lt
 8008370:	4276      	neglt	r6, r6
        new_q = MCM_Sqrt(square_temp);
 8008372:	f7f9 f931 	bl	80015d8 <MCM_Sqrt>
#endif
        if (Vqd.q < 0)
 8008376:	2c00      	cmp	r4, #0
        {
          /* Nothing to do */
        }
      }
      local_vqd.q = (int16_t)new_q;
      local_vqd.d = (int16_t)new_d;
 8008378:	b235      	sxth	r5, r6
        if (Vqd.q < 0)
 800837a:	db0e      	blt.n	800839a <Circle_Limitation+0x56>
      local_vqd.q = (int16_t)new_q;
 800837c:	b204      	sxth	r4, r0
    }
#ifdef NULL_PTR_CHECK_CRC_LIM
  }
#endif
  return (local_vqd);
 800837e:	b2a4      	uxth	r4, r4
 8008380:	2000      	movs	r0, #0
 8008382:	f364 000f 	bfi	r0, r4, #0, #16
 8008386:	b2ad      	uxth	r5, r5
 8008388:	f365 401f 	bfi	r0, r5, #16, #16
}
 800838c:	b004      	add	sp, #16
 800838e:	bd70      	pop	{r4, r5, r6, pc}
        new_q = MCM_Sqrt(square_temp);
 8008390:	1a98      	subs	r0, r3, r2
 8008392:	f7f9 f921 	bl	80015d8 <MCM_Sqrt>
        if (Vqd.q < 0)
 8008396:	2c00      	cmp	r4, #0
 8008398:	daf0      	bge.n	800837c <Circle_Limitation+0x38>
          new_q = - new_q;
 800839a:	4240      	negs	r0, r0
      local_vqd.q = (int16_t)new_q;
 800839c:	b204      	sxth	r4, r0
      local_vqd.d = (int16_t)new_d;
 800839e:	e7ee      	b.n	800837e <Circle_Limitation+0x3a>

080083a0 <EAC_Init>:
  {
#endif
    pHandle->pSTC = pSTC;
    pHandle->pVSS = pVSS;
    pHandle->pENC = pENC;
    pHandle->EncAligned = false;
 80083a0:	f04f 0c00 	mov.w	ip, #0
    pHandle->pVSS = pVSS;
 80083a4:	e9c0 1200 	strd	r1, r2, [r0]
    pHandle->pENC = pENC;
 80083a8:	6083      	str	r3, [r0, #8]
    pHandle->EncAligned = false;
 80083aa:	f8a0 c00e 	strh.w	ip, [r0, #14]
    pHandle->EncRestart = false;
#ifdef NULL_PTR_CHECK_ENC_ALI_CTRL
  }
#endif
}
 80083ae:	4770      	bx	lr

080083b0 <EAC_StartAlignment>:
  * It configures the VSS (Virtual Speed Sensor) with the required angle and sets the
  * STC (Speed and Torque Controller) to execute the required torque ramp.
  * @param  pHandle: handler of the current instance of the EncAlignCtrl component.
  */
__weak void EAC_StartAlignment(EncAlign_Handle_t *pHandle)
{
 80083b0:	b510      	push	{r4, lr}
  {
#endif
    uint32_t wAux;

    /* Set pVSS mechanical speed to zero */
    VSS_SetMecAcceleration(pHandle->pVSS, 0, 0U);
 80083b2:	2200      	movs	r2, #0
{
 80083b4:	4604      	mov	r4, r0
    VSS_SetMecAcceleration(pHandle->pVSS, 0, 0U);
 80083b6:	4611      	mov	r1, r2
 80083b8:	6840      	ldr	r0, [r0, #4]
 80083ba:	f001 ff35 	bl	800a228 <VSS_SetMecAcceleration>

    /* Set pVSS mechanical angle */
    VSS_SetMecAngle(pHandle->pVSS, pHandle->hElAngle);
 80083be:	6863      	ldr	r3, [r4, #4]
 80083c0:	f9b4 2014 	ldrsh.w	r2, [r4, #20]
  }
  else
  {
#endif
    pHandle->hElAngleAccu = hMecAngle;
    pHandle->_Super.hMecAngle = pHandle->hElAngleAccu / ((int16_t)pHandle->_Super.bElToMecRatio);
 80083c4:	f893 c001 	ldrb.w	ip, [r3, #1]

    /* Set pSTC in MCM_TORQUE_MODE */
    STC_SetControlMode(pHandle->pSTC, MCM_TORQUE_MODE);
 80083c8:	6820      	ldr	r0, [r4, #0]
 80083ca:	fb92 fcfc 	sdiv	ip, r2, ip
    pHandle->hElAngleAccu = hMecAngle;
 80083ce:	861a      	strh	r2, [r3, #48]	@ 0x30
    pHandle->_Super.hElAngle = hMecAngle;
 80083d0:	809a      	strh	r2, [r3, #4]
    pHandle->_Super.hMecAngle = pHandle->hElAngleAccu / ((int16_t)pHandle->_Super.bElToMecRatio);
 80083d2:	f8a3 c006 	strh.w	ip, [r3, #6]
 80083d6:	2104      	movs	r1, #4
 80083d8:	f001 fc0c 	bl	8009bf4 <STC_SetControlMode>

    /* Set starting torque to Zero */
    (void)STC_ExecRamp(pHandle->pSTC, 0, 0U);
 80083dc:	2200      	movs	r2, #0
 80083de:	4611      	mov	r1, r2
 80083e0:	6820      	ldr	r0, [r4, #0]
 80083e2:	f001 fc0b 	bl	8009bfc <STC_ExecRamp>

    /* Execute the torque ramp */
    (void)STC_ExecRamp(pHandle->pSTC, pHandle->hFinalTorque, (uint32_t)pHandle->hDurationms);
 80083e6:	8ae2      	ldrh	r2, [r4, #22]
 80083e8:	f9b4 1012 	ldrsh.w	r1, [r4, #18]
 80083ec:	6820      	ldr	r0, [r4, #0]
 80083ee:	f001 fc05 	bl	8009bfc <STC_ExecRamp>
    /* Compute hRemainingTicks, the number of thick of alignment phase */
    wAux = ((uint32_t)pHandle->hDurationms) * ((uint32_t)pHandle->hEACFrequencyHz);
 80083f2:	8ae3      	ldrh	r3, [r4, #22]
 80083f4:	8a21      	ldrh	r1, [r4, #16]
    wAux /= 1000U;
 80083f6:	4a04      	ldr	r2, [pc, #16]	@ (8008408 <EAC_StartAlignment+0x58>)
    wAux = ((uint32_t)pHandle->hDurationms) * ((uint32_t)pHandle->hEACFrequencyHz);
 80083f8:	fb01 f303 	mul.w	r3, r1, r3
    wAux /= 1000U;
 80083fc:	fba2 2303 	umull	r2, r3, r2, r3
 8008400:	099b      	lsrs	r3, r3, #6
    pHandle->hRemainingTicks = (uint16_t)wAux;
    pHandle->hRemainingTicks++;
 8008402:	3301      	adds	r3, #1
 8008404:	81a3      	strh	r3, [r4, #12]
#ifdef NULL_PTR_CHECK_ENC_ALI_CTRL
  }
#endif
}
 8008406:	bd10      	pop	{r4, pc}
 8008408:	10624dd3 	.word	0x10624dd3

0800840c <EAC_Exec>:
    retVal = false;
  }
  else
  {
#endif
    if (pHandle->hRemainingTicks > 0U)
 800840c:	8983      	ldrh	r3, [r0, #12]
 800840e:	b90b      	cbnz	r3, 8008414 <EAC_Exec+0x8>
  bool retVal = true;
 8008410:	2001      	movs	r0, #1
#ifdef NULL_PTR_CHECK_ENC_ALI_CTRL
  }
#endif

  return (retVal);
}
 8008412:	4770      	bx	lr
      pHandle->hRemainingTicks--;
 8008414:	3b01      	subs	r3, #1
 8008416:	b29b      	uxth	r3, r3
{
 8008418:	b510      	push	{r4, lr}
 800841a:	4604      	mov	r4, r0
      pHandle->hRemainingTicks--;
 800841c:	8183      	strh	r3, [r0, #12]
      if (0U == pHandle->hRemainingTicks)
 800841e:	b10b      	cbz	r3, 8008424 <EAC_Exec+0x18>
        retVal = false;
 8008420:	2000      	movs	r0, #0
}
 8008422:	bd10      	pop	{r4, pc}
        ENC_SetMecAngle(pHandle->pENC, pHandle->hElAngle / ((int16_t)pHandle->bElToMecRatio));
 8008424:	7e03      	ldrb	r3, [r0, #24]
 8008426:	f9b0 1014 	ldrsh.w	r1, [r0, #20]
 800842a:	6880      	ldr	r0, [r0, #8]
 800842c:	fb91 f1f3 	sdiv	r1, r1, r3
 8008430:	f000 f93c 	bl	80086ac <ENC_SetMecAngle>
        pHandle->EncAligned = true;
 8008434:	2301      	movs	r3, #1
 8008436:	73a3      	strb	r3, [r4, #14]
  bool retVal = true;
 8008438:	2001      	movs	r0, #1
}
 800843a:	bd10      	pop	{r4, pc}

0800843c <ENC_Init>:
    /* Nothing to do */
  }
  else
  {
#endif
    TIM_TypeDef *TIMx = pHandle->TIMx;
 800843c:	6a03      	ldr	r3, [r0, #32]
#endif
    /* Reset counter */
    LL_TIM_SetCounter(TIMx, 0);

    /*Calculations of convenience*/
    pHandle->U32MAXdivPulseNumber = UINT32_MAX / ((uint32_t) pHandle->PulseNumber);
 800843e:	f8b0 c06e 	ldrh.w	ip, [r0, #110]	@ 0x6e
  SET_BIT(TIMx->CR1, TIM_CR1_UIFREMAP);
 8008442:	681a      	ldr	r2, [r3, #0]
 8008444:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
{
 8008448:	b410      	push	{r4}
 800844a:	601a      	str	r2, [r3, #0]
    pHandle->SpeedSamplingFreqUnit = ((uint32_t)pHandle->SpeedSamplingFreqHz * (uint32_t)SPEED_UNIT);
 800844c:	f8b0 206c 	ldrh.w	r2, [r0, #108]	@ 0x6c
 8008450:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8008454:	0052      	lsls	r2, r2, #1
  WRITE_REG(TIMx->CNT, Counter);
 8008456:	2100      	movs	r1, #0
 8008458:	6259      	str	r1, [r3, #36]	@ 0x24
    pHandle->U32MAXdivPulseNumber = UINT32_MAX / ((uint32_t) pHandle->PulseNumber);
 800845a:	f04f 34ff 	mov.w	r4, #4294967295
    pHandle->SpeedSamplingFreqUnit = ((uint32_t)pHandle->SpeedSamplingFreqHz * (uint32_t)SPEED_UNIT);
 800845e:	6242      	str	r2, [r0, #36]	@ 0x24
    pHandle->U32MAXdivPulseNumber = UINT32_MAX / ((uint32_t) pHandle->PulseNumber);
 8008460:	fbb4 f4fc 	udiv	r4, r4, ip
 8008464:	6684      	str	r4, [r0, #104]	@ 0x68
  MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel]), (ICFilter >> 16U) << SHIFT_TAB_ICxx[iChannel]);
 8008466:	699c      	ldr	r4, [r3, #24]
 8008468:	f8b0 207a 	ldrh.w	r2, [r0, #122]	@ 0x7a
 800846c:	f024 0cf0 	bic.w	ip, r4, #240	@ 0xf0
 8008470:	ea42 020c 	orr.w	r2, r2, ip
 8008474:	619a      	str	r2, [r3, #24]
 8008476:	699a      	ldr	r2, [r3, #24]
 8008478:	f8b0 407a 	ldrh.w	r4, [r0, #122]	@ 0x7a
 800847c:	f422 4270 	bic.w	r2, r2, #61440	@ 0xf000
 8008480:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8008484:	f06f 0401 	mvn.w	r4, #1
  MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel]), (ICFilter >> 16U) << SHIFT_TAB_ICxx[iChannel]);
 8008488:	619a      	str	r2, [r3, #24]
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 800848a:	611c      	str	r4, [r3, #16]
  SET_BIT(TIMx->DIER, TIM_DIER_UIE);
 800848c:	68da      	ldr	r2, [r3, #12]
 800848e:	f042 0201 	orr.w	r2, r2, #1
 8008492:	60da      	str	r2, [r3, #12]
  SET_BIT(TIMx->CR1, TIM_CR1_CEN);
 8008494:	681a      	ldr	r2, [r3, #0]
 8008496:	f042 0201 	orr.w	r2, r2, #1
 800849a:	601a      	str	r2, [r3, #0]

    /* Enable the counting timer */
    LL_TIM_EnableCounter(TIMx);

    /* Erase speed buffer */
    bufferSize = pHandle->SpeedBufferSize;
 800849c:	f890 2074 	ldrb.w	r2, [r0, #116]	@ 0x74

    for (index = 0U; index < bufferSize; index++)
 80084a0:	b12a      	cbz	r2, 80084ae <ENC_Init+0x72>
      pHandle->DeltaCapturesBuffer[index] = 0;
    }
#ifdef NULL_PTR_CHECK_ENC_SPD_POS_FDB
  }
#endif
}
 80084a2:	f85d 4b04 	ldr.w	r4, [sp], #4
      pHandle->DeltaCapturesBuffer[index] = 0;
 80084a6:	0092      	lsls	r2, r2, #2
 80084a8:	3028      	adds	r0, #40	@ 0x28
 80084aa:	f001 bef9 	b.w	800a2a0 <memset>
}
 80084ae:	f85d 4b04 	ldr.w	r4, [sp], #4
 80084b2:	4770      	bx	lr

080084b4 <ENC_Clear>:
  *         This function must be called before starting the motor to initialize
  *         the speed measurement process.
  * @param  pHandle: handler of the current instance of the encoder component
  */
__weak void ENC_Clear(ENCODER_Handle_t *pHandle)
{
 80084b4:	b510      	push	{r4, lr}
  else
  {
#endif
    uint8_t index;

    for (index = 0u; index < pHandle->SpeedBufferSize; index++)
 80084b6:	f890 2074 	ldrb.w	r2, [r0, #116]	@ 0x74
{
 80084ba:	4604      	mov	r4, r0
    for (index = 0u; index < pHandle->SpeedBufferSize; index++)
 80084bc:	b122      	cbz	r2, 80084c8 <ENC_Clear+0x14>
    {
      pHandle->DeltaCapturesBuffer[index] = 0;
 80084be:	0092      	lsls	r2, r2, #2
 80084c0:	2100      	movs	r1, #0
 80084c2:	3028      	adds	r0, #40	@ 0x28
 80084c4:	f001 feec 	bl	800a2a0 <memset>
    }
    pHandle->SensorIsReliable = true;
 80084c8:	2301      	movs	r3, #1
 80084ca:	f884 3075 	strb.w	r3, [r4, #117]	@ 0x75
#ifdef NULL_PTR_CHECK_ENC_SPD_POS_FDB
  }
#endif
}
 80084ce:	bd10      	pop	{r4, pc}

080084d0 <ENC_CalcAngle>:
  *         of the instantaneous value of the timer counter.
  * @param  pHandle: handler of the current instance of the encoder component
  * @retval Measured electrical angle in [s16degree](measurement_units.md) format.
  */
__weak int16_t ENC_CalcAngle(ENCODER_Handle_t *pHandle)
{
 80084d0:	b410      	push	{r4}
    int16_t mecAngle; /* s16degree format */
    uint32_t uwtemp1;
    int32_t wtemp1;
    /* PR 52926 We need to keep only the 16 LSB, bit 31 could be at 1
     if the overflow occurs just after the entry in the High frequency task */
    uwtemp1 = (LL_TIM_GetCounter(pHandle->TIMx) & 0xffffU) * (pHandle->U32MAXdivPulseNumber);
 80084d2:	6a02      	ldr	r2, [r0, #32]
    wtemp1 = (int32_t)uwtemp1 / 65536;
#endif
    /* Computes and stores the rotor mechanical angle */
    mecAngle = (int16_t)wtemp1;

    int16_t hMecAnglePrev = pHandle->_Super.hMecAngle;
 80084d4:	f9b0 1006 	ldrsh.w	r1, [r0, #6]
  return (uint32_t)(READ_REG(TIMx->CNT));
 80084d8:	6a52      	ldr	r2, [r2, #36]	@ 0x24
{
 80084da:	4603      	mov	r3, r0
    uwtemp1 = (LL_TIM_GetCounter(pHandle->TIMx) & 0xffffU) * (pHandle->U32MAXdivPulseNumber);
 80084dc:	b292      	uxth	r2, r2
 80084de:	6e9c      	ldr	r4, [r3, #104]	@ 0x68

    pHandle->_Super.hMecAngle = mecAngle;

    /* Computes and stores the rotor electrical angle */
    elAngle = mecAngle * (int16_t)(pHandle->_Super.bElToMecRatio);
 80084e0:	7840      	ldrb	r0, [r0, #1]
    uwtemp1 = (LL_TIM_GetCounter(pHandle->TIMx) & 0xffffU) * (pHandle->U32MAXdivPulseNumber);
 80084e2:	fb04 f202 	mul.w	r2, r4, r2
    wtemp1 = (int32_t)uwtemp1 >> 16U;  //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 80084e6:	1412      	asrs	r2, r2, #16
    elAngle = mecAngle * (int16_t)(pHandle->_Super.bElToMecRatio);
 80084e8:	fb02 f000 	mul.w	r0, r2, r0

    pHandle->_Super.hElAngle = elAngle;

    int16_t hMecSpeedDpp = mecAngle - hMecAnglePrev;
 80084ec:	1a51      	subs	r1, r2, r1
    mecAngle = (int16_t)wtemp1;
 80084ee:	80da      	strh	r2, [r3, #6]
    pHandle->_Super.wMecAngle += ((int32_t)hMecSpeedDpp);
 80084f0:	689a      	ldr	r2, [r3, #8]
#ifdef NULL_PTR_CHECK_ENC_SPD_POS_FDB
  }
#endif
  /*Returns rotor electrical angle*/
  return (elAngle);
}
 80084f2:	f85d 4b04 	ldr.w	r4, [sp], #4
    elAngle = mecAngle * (int16_t)(pHandle->_Super.bElToMecRatio);
 80084f6:	b200      	sxth	r0, r0
    pHandle->_Super.wMecAngle += ((int32_t)hMecSpeedDpp);
 80084f8:	fa02 f281 	sxtah	r2, r2, r1
    pHandle->_Super.hElAngle = elAngle;
 80084fc:	8098      	strh	r0, [r3, #4]
    pHandle->_Super.wMecAngle += ((int32_t)hMecSpeedDpp);
 80084fe:	609a      	str	r2, [r3, #8]
}
 8008500:	4770      	bx	lr
 8008502:	bf00      	nop

08008504 <ENC_CalcAvrgMecSpeedUnit>:
  * @param  pMecSpeedUnit pointer used to return the rotor average mechanical speed
  *         expressed in the unit defined by #SPEED_UNIT
  * @retval true = sensor information is reliable. false = sensor information is not reliable
  */
__weak bool ENC_CalcAvrgMecSpeedUnit(ENCODER_Handle_t *pHandle, int16_t *pMecSpeedUnit)
{
 8008504:	b5f0      	push	{r4, r5, r6, r7, lr}
    int32_t wtemp2;
    uint32_t OverflowCntSample;
    uint32_t CntCapture;
    uint32_t directionSample;
    int32_t wOverallAngleVariation = 0;
    TIM_TypeDef *TIMx = pHandle->TIMx;
 8008506:	6a02      	ldr	r2, [r0, #32]
  CLEAR_BIT(TIMx->DIER, TIM_DIER_UIE);
 8008508:	68d4      	ldr	r4, [r2, #12]
 800850a:	f024 0401 	bic.w	r4, r4, #1
{
 800850e:	4603      	mov	r3, r0
    uint8_t bBufferSize = pHandle->SpeedBufferSize;
 8008510:	f890 0074 	ldrb.w	r0, [r0, #116]	@ 0x74
 8008514:	60d4      	str	r4, [r2, #12]
  return (uint32_t)(READ_REG(TIMx->CNT));
 8008516:	6a54      	ldr	r4, [r2, #36]	@ 0x24
#ifdef TIM_CNT_UIFCPY
    /* disable Interrupt generation */
    LL_TIM_DisableIT_UPDATE(TIMx);
#endif
    CntCapture = LL_TIM_GetCounter(TIMx);
    OverflowCntSample = pHandle->TimerOverflowNb;
 8008518:	f8b3 5070 	ldrh.w	r5, [r3, #112]	@ 0x70
    pHandle->TimerOverflowNb = 0;
    directionSample = LL_TIM_GetDirection(TIMx);
#ifdef TIM_CNT_UIFCPY
    OFbit = __LL_TIM_GETFLAG_UIFCPY(CntCapture);
    if (0U == OFbit)
 800851c:	ea5f 7ed4 	movs.w	lr, r4, lsr #31
    pHandle->TimerOverflowNb = 0;
 8008520:	f04f 0600 	mov.w	r6, #0
 8008524:	f8a3 6070 	strh.w	r6, [r3, #112]	@ 0x70
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8008528:	bf18      	it	ne
 800852a:	f06f 0701 	mvnne.w	r7, #1
  return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_DIR));
 800852e:	6816      	ldr	r6, [r2, #0]
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8008530:	bf18      	it	ne
 8008532:	6117      	strne	r7, [r2, #16]
      into accout, we must not clear the interrupt in order to accumulate it */
      LL_TIM_ClearFlag_UPDATE(TIMx);
    }

    LL_TIM_EnableIT_UPDATE(TIMx);
    CLEAR_BIT(CntCapture, TIM_CNT_UIFCPY);
 8008534:	f024 4c00 	bic.w	ip, r4, #2147483648	@ 0x80000000
  SET_BIT(TIMx->DIER, TIM_DIER_UIE);
 8008538:	68d4      	ldr	r4, [r2, #12]
    OverflowCntSample = pHandle->TimerOverflowNb;
 800853a:	b2ad      	uxth	r5, r5
 800853c:	f044 0401 	orr.w	r4, r4, #1

    /* If UIFCPY is not present, OverflowCntSample can not be used safely for
    speed computation, but we still use it to check that we do not exceed one overflow
    (sample frequency not less than mechanical motor speed */

    if ((OverflowCntSample + OFbit) > ENC_MAX_OVERFLOW_NB)
 8008540:	44ae      	add	lr, r5
 8008542:	60d4      	str	r4, [r2, #12]
 8008544:	f5be 6f00 	cmp.w	lr, #2048	@ 0x800
      /* If UIFCPY not present Overflow counter can not be safely used -> limitation to 1 OF */
#ifndef TIM_CNT_UIFCPY
      OverflowCntSample = (CntCapture > pHandle->PreviousCapture) ? 1 : 0;
#endif
      pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] =
        ((int32_t)CntCapture) - ((int32_t)pHandle->PreviousCapture)
 8008548:	f8b3 2072 	ldrh.w	r2, [r3, #114]	@ 0x72
        - ((((int32_t)OverflowCntSample) + (int32_t)OFbit) * ((int32_t)pHandle->PulseNumber));
 800854c:	f8b3 506e 	ldrh.w	r5, [r3, #110]	@ 0x6e
    {
      /* Nothing to do */
    }

    /* Checks the reliability status, then stores and returns it */
    if (pHandle->TimerOverflowError)
 8008550:	bf94      	ite	ls
 8008552:	f893 407d 	ldrbls.w	r4, [r3, #125]	@ 0x7d
      pHandle->TimerOverflowError = true;
 8008556:	2401      	movhi	r4, #1
  return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_DIR));
 8008558:	f006 0610 	and.w	r6, r6, #16
 800855c:	bf88      	it	hi
 800855e:	f883 407d 	strbhi.w	r4, [r3, #125]	@ 0x7d
        ((int32_t)CntCapture) - ((int32_t)pHandle->PreviousCapture)
 8008562:	ebac 0202 	sub.w	r2, ip, r2
        - ((((int32_t)OverflowCntSample) + (int32_t)OFbit) * ((int32_t)pHandle->PulseNumber));
 8008566:	fb05 fe0e 	mul.w	lr, r5, lr
    if (LL_TIM_COUNTERDIRECTION_DOWN == directionSample)
 800856a:	2e00      	cmp	r6, #0
 800856c:	f000 808c 	beq.w	8008688 <ENC_CalcAvrgMecSpeedUnit+0x184>
      pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] =
 8008570:	f893 607c 	ldrb.w	r6, [r3, #124]	@ 0x7c
 8008574:	360a      	adds	r6, #10
        - ((((int32_t)OverflowCntSample) + (int32_t)OFbit) * ((int32_t)pHandle->PulseNumber));
 8008576:	eba2 020e 	sub.w	r2, r2, lr
      pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] =
 800857a:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 800857e:	2800      	cmp	r0, #0
 8008580:	f000 808b 	beq.w	800869a <ENC_CalcAvrgMecSpeedUnit+0x196>
 8008584:	2801      	cmp	r0, #1
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008586:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008588:	d039      	beq.n	80085fe <ENC_CalcAvrgMecSpeedUnit+0xfa>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 800858a:	6ade      	ldr	r6, [r3, #44]	@ 0x2c
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 800858c:	2802      	cmp	r0, #2
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 800858e:	4432      	add	r2, r6
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008590:	d035      	beq.n	80085fe <ENC_CalcAvrgMecSpeedUnit+0xfa>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008592:	6b1e      	ldr	r6, [r3, #48]	@ 0x30
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008594:	2803      	cmp	r0, #3
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008596:	4432      	add	r2, r6
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008598:	d031      	beq.n	80085fe <ENC_CalcAvrgMecSpeedUnit+0xfa>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 800859a:	6b5e      	ldr	r6, [r3, #52]	@ 0x34
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 800859c:	2804      	cmp	r0, #4
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 800859e:	4432      	add	r2, r6
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 80085a0:	d02d      	beq.n	80085fe <ENC_CalcAvrgMecSpeedUnit+0xfa>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 80085a2:	6b9e      	ldr	r6, [r3, #56]	@ 0x38
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 80085a4:	2805      	cmp	r0, #5
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 80085a6:	4432      	add	r2, r6
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 80085a8:	d029      	beq.n	80085fe <ENC_CalcAvrgMecSpeedUnit+0xfa>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 80085aa:	6bde      	ldr	r6, [r3, #60]	@ 0x3c
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 80085ac:	2806      	cmp	r0, #6
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 80085ae:	4432      	add	r2, r6
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 80085b0:	d025      	beq.n	80085fe <ENC_CalcAvrgMecSpeedUnit+0xfa>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 80085b2:	6c1e      	ldr	r6, [r3, #64]	@ 0x40
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 80085b4:	2807      	cmp	r0, #7
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 80085b6:	4432      	add	r2, r6
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 80085b8:	d021      	beq.n	80085fe <ENC_CalcAvrgMecSpeedUnit+0xfa>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 80085ba:	6c5e      	ldr	r6, [r3, #68]	@ 0x44
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 80085bc:	2808      	cmp	r0, #8
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 80085be:	4432      	add	r2, r6
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 80085c0:	d01d      	beq.n	80085fe <ENC_CalcAvrgMecSpeedUnit+0xfa>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 80085c2:	6c9e      	ldr	r6, [r3, #72]	@ 0x48
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 80085c4:	2809      	cmp	r0, #9
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 80085c6:	4432      	add	r2, r6
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 80085c8:	d019      	beq.n	80085fe <ENC_CalcAvrgMecSpeedUnit+0xfa>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 80085ca:	6cde      	ldr	r6, [r3, #76]	@ 0x4c
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 80085cc:	280a      	cmp	r0, #10
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 80085ce:	4432      	add	r2, r6
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 80085d0:	d015      	beq.n	80085fe <ENC_CalcAvrgMecSpeedUnit+0xfa>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 80085d2:	6d1e      	ldr	r6, [r3, #80]	@ 0x50
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 80085d4:	280b      	cmp	r0, #11
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 80085d6:	4432      	add	r2, r6
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 80085d8:	d011      	beq.n	80085fe <ENC_CalcAvrgMecSpeedUnit+0xfa>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 80085da:	6d5e      	ldr	r6, [r3, #84]	@ 0x54
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 80085dc:	280c      	cmp	r0, #12
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 80085de:	4432      	add	r2, r6
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 80085e0:	d00d      	beq.n	80085fe <ENC_CalcAvrgMecSpeedUnit+0xfa>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 80085e2:	6d9e      	ldr	r6, [r3, #88]	@ 0x58
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 80085e4:	280d      	cmp	r0, #13
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 80085e6:	4432      	add	r2, r6
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 80085e8:	d009      	beq.n	80085fe <ENC_CalcAvrgMecSpeedUnit+0xfa>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 80085ea:	6dde      	ldr	r6, [r3, #92]	@ 0x5c
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 80085ec:	280e      	cmp	r0, #14
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 80085ee:	4432      	add	r2, r6
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 80085f0:	d005      	beq.n	80085fe <ENC_CalcAvrgMecSpeedUnit+0xfa>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 80085f2:	6e1e      	ldr	r6, [r3, #96]	@ 0x60
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 80085f4:	280f      	cmp	r0, #15
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 80085f6:	4432      	add	r2, r6
 80085f8:	bf1c      	itt	ne
 80085fa:	6e5e      	ldrne	r6, [r3, #100]	@ 0x64
 80085fc:	1992      	addne	r2, r2, r6
    wtemp1 = wOverallAngleVariation * ((int32_t)pHandle->SpeedSamplingFreqUnit);
 80085fe:	6a5e      	ldr	r6, [r3, #36]	@ 0x24
    wtemp2 = ((int32_t)pHandle->PulseNumber) * ((int32_t)pHandle->SpeedBufferSize);
 8008600:	fb00 f505 	mul.w	r5, r0, r5
    wtemp1 = wOverallAngleVariation * ((int32_t)pHandle->SpeedSamplingFreqUnit);
 8008604:	fb06 f202 	mul.w	r2, r6, r2
    wtemp1 = ((0 == wtemp2) ? wtemp1 : (wtemp1 / wtemp2));
 8008608:	b10d      	cbz	r5, 800860e <ENC_CalcAvrgMecSpeedUnit+0x10a>
 800860a:	fb92 f2f5 	sdiv	r2, r2, r5
    *pMecSpeedUnit = (int16_t)wtemp1;
 800860e:	b216      	sxth	r6, r2
    pHandle->_Super.hMecAccelUnitP = (int16_t)(wtemp1 - pHandle->_Super.hAvrMecSpeedUnit);
 8008610:	b292      	uxth	r2, r2
    *pMecSpeedUnit = (int16_t)wtemp1;
 8008612:	800e      	strh	r6, [r1, #0]
    wtemp1 = pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] * ((int32_t)pHandle->SpeedSamplingFreqHz)
 8008614:	f893 507c 	ldrb.w	r5, [r3, #124]	@ 0x7c
    pHandle->DeltaCapturesIndex++;
 8008618:	f893 e07c 	ldrb.w	lr, [r3, #124]	@ 0x7c
    wtemp1 = pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] * ((int32_t)pHandle->SpeedSamplingFreqHz)
 800861c:	350a      	adds	r5, #10
    pHandle->DeltaCapturesIndex++;
 800861e:	f10e 0e01 	add.w	lr, lr, #1
 8008622:	fa5f fe8e 	uxtb.w	lr, lr
    wtemp1 = pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] * ((int32_t)pHandle->SpeedSamplingFreqHz)
 8008626:	f853 5025 	ldr.w	r5, [r3, r5, lsl #2]
    pHandle->DeltaCapturesIndex++;
 800862a:	f883 e07c 	strb.w	lr, [r3, #124]	@ 0x7c
    pHandle->_Super.hMecAccelUnitP = (int16_t)(wtemp1 - pHandle->_Super.hAvrMecSpeedUnit);
 800862e:	f8b3 e00c 	ldrh.w	lr, [r3, #12]
    pHandle->_Super.hAvrMecSpeedUnit = (int16_t)wtemp1;
 8008632:	819e      	strh	r6, [r3, #12]
    pHandle->_Super.hMecAccelUnitP = (int16_t)(wtemp1 - pHandle->_Super.hAvrMecSpeedUnit);
 8008634:	eba2 020e 	sub.w	r2, r2, lr
 8008638:	825a      	strh	r2, [r3, #18]
    wtemp1 = pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] * ((int32_t)pHandle->SpeedSamplingFreqHz)
 800863a:	f8b3 206c 	ldrh.w	r2, [r3, #108]	@ 0x6c
    if (pHandle->DeltaCapturesIndex >= pHandle->SpeedBufferSize)
 800863e:	f893 607c 	ldrb.w	r6, [r3, #124]	@ 0x7c
    wtemp1 = pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] * ((int32_t)pHandle->SpeedSamplingFreqHz)
 8008642:	fb05 f202 	mul.w	r2, r5, r2
             * ((int32_t)pHandle->_Super.bElToMecRatio);
 8008646:	785d      	ldrb	r5, [r3, #1]
    pHandle->PreviousCapture = (CntCapture >= (uint32_t)65535) ? 65535U : (uint16_t)CntCapture;
 8008648:	f64f 7eff 	movw	lr, #65535	@ 0xffff
 800864c:	45f4      	cmp	ip, lr
    wtemp1 = pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] * ((int32_t)pHandle->SpeedSamplingFreqHz)
 800864e:	fb05 f202 	mul.w	r2, r5, r2
    wtemp1 *= ((int32_t)pHandle->_Super.DPPConvFactor);
 8008652:	69dd      	ldr	r5, [r3, #28]
    pHandle->PreviousCapture = (CntCapture >= (uint32_t)65535) ? 65535U : (uint16_t)CntCapture;
 8008654:	bf28      	it	cs
 8008656:	46f4      	movcs	ip, lr
    if (pHandle->DeltaCapturesIndex >= pHandle->SpeedBufferSize)
 8008658:	4286      	cmp	r6, r0
    pHandle->PreviousCapture = (CntCapture >= (uint32_t)65535) ? 65535U : (uint16_t)CntCapture;
 800865a:	f8a3 c072 	strh.w	ip, [r3, #114]	@ 0x72
    wtemp1 /= ((int32_t)pHandle->PulseNumber);
 800865e:	f8b3 c06e 	ldrh.w	ip, [r3, #110]	@ 0x6e
 8008662:	fb92 f2fc 	sdiv	r2, r2, ip
    wtemp1 *= ((int32_t)pHandle->_Super.DPPConvFactor);
 8008666:	fb05 f202 	mul.w	r2, r5, r2
    wtemp1 /= ((int32_t)pHandle->_Super.hMeasurementFrequency);
 800866a:	8b5d      	ldrh	r5, [r3, #26]
 800866c:	fb92 f2f5 	sdiv	r2, r2, r5
    pHandle->_Super.hElSpeedDpp = (int16_t)wtemp1;
 8008670:	81da      	strh	r2, [r3, #14]
      pHandle->DeltaCapturesIndex = 0U;
 8008672:	bf24      	itt	cs
 8008674:	2200      	movcs	r2, #0
 8008676:	f883 207c 	strbcs.w	r2, [r3, #124]	@ 0x7c
    if (pHandle->TimerOverflowError)
 800867a:	b18c      	cbz	r4, 80086a0 <ENC_CalcAvrgMecSpeedUnit+0x19c>
    {
      bReliability = false;
      pHandle->SensorIsReliable = false;
      pHandle->_Super.bSpeedErrorNumber = pHandle->_Super.bMaximumSpeedErrorsNumber;
 800867c:	78da      	ldrb	r2, [r3, #3]
 800867e:	701a      	strb	r2, [r3, #0]
      pHandle->SensorIsReliable = false;
 8008680:	2000      	movs	r0, #0
 8008682:	f883 0075 	strb.w	r0, [r3, #117]	@ 0x75
    }
#ifdef NULL_PTR_CHECK_ENC_SPD_POS_FDB
  }
#endif
  return (bReliability);
}
 8008686:	bdf0      	pop	{r4, r5, r6, r7, pc}
      pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] =
 8008688:	f893 607c 	ldrb.w	r6, [r3, #124]	@ 0x7c
 800868c:	360a      	adds	r6, #10
        + ((((int32_t)OverflowCntSample) + (int32_t)OFbit) * ((int32_t)pHandle->PulseNumber));
 800868e:	4472      	add	r2, lr
      pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] =
 8008690:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008694:	2800      	cmp	r0, #0
 8008696:	f47f af75 	bne.w	8008584 <ENC_CalcAvrgMecSpeedUnit+0x80>
 800869a:	4602      	mov	r2, r0
 800869c:	4606      	mov	r6, r0
 800869e:	e7b8      	b.n	8008612 <ENC_CalcAvrgMecSpeedUnit+0x10e>
}
 80086a0:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
      bReliability = SPD_IsMecSpeedReliable(&pHandle->_Super, pMecSpeedUnit);
 80086a4:	4618      	mov	r0, r3
 80086a6:	f001 ba41 	b.w	8009b2c <SPD_IsMecSpeedReliable>
 80086aa:	bf00      	nop

080086ac <ENC_SetMecAngle>:
    uint16_t hAngleCounts;
    uint16_t hMecAngleuint;
    int16_t localhMecAngle = hMecAngle;

    pHandle->_Super.hMecAngle = localhMecAngle;
    pHandle->_Super.hElAngle = localhMecAngle * (int16_t)pHandle->_Super.bElToMecRatio;
 80086ac:	7843      	ldrb	r3, [r0, #1]
    pHandle->_Super.hMecAngle = localhMecAngle;
 80086ae:	80c1      	strh	r1, [r0, #6]
    pHandle->_Super.hElAngle = localhMecAngle * (int16_t)pHandle->_Super.bElToMecRatio;
 80086b0:	b28a      	uxth	r2, r1
 80086b2:	fb01 f303 	mul.w	r3, r1, r3
    if (localhMecAngle < 0)
 80086b6:	2900      	cmp	r1, #0
    pHandle->_Super.hElAngle = localhMecAngle * (int16_t)pHandle->_Super.bElToMecRatio;
 80086b8:	8083      	strh	r3, [r0, #4]
 80086ba:	bfb8      	it	lt
 80086bc:	f102 32ff 	addlt.w	r2, r2, #4294967295
    else
    {
      hMecAngleuint = (uint16_t)localhMecAngle;
    }

    hAngleCounts = (uint16_t)((((uint32_t)hMecAngleuint) * ((uint32_t)pHandle->PulseNumber)) / 65535U);
 80086c0:	f8b0 306e 	ldrh.w	r3, [r0, #110]	@ 0x6e
 80086c4:	4906      	ldr	r1, [pc, #24]	@ (80086e0 <ENC_SetMecAngle+0x34>)
 80086c6:	bfb8      	it	lt
 80086c8:	b292      	uxthlt	r2, r2
 80086ca:	fb02 f303 	mul.w	r3, r2, r3
{
 80086ce:	b410      	push	{r4}
    hAngleCounts = (uint16_t)((((uint32_t)hMecAngleuint) * ((uint32_t)pHandle->PulseNumber)) / 65535U);
 80086d0:	fba1 1303 	umull	r1, r3, r1, r3
    TIM_TypeDef *TIMx = pHandle->TIMx;
 80086d4:	6a04      	ldr	r4, [r0, #32]
    hAngleCounts = (uint16_t)((((uint32_t)hMecAngleuint) * ((uint32_t)pHandle->PulseNumber)) / 65535U);
 80086d6:	0bdb      	lsrs	r3, r3, #15

    TIMx->CNT = (uint16_t)hAngleCounts;
 80086d8:	6263      	str	r3, [r4, #36]	@ 0x24
#ifdef NULL_PTR_CHECK_ENC_SPD_POS_FDB
  }
#endif
}
 80086da:	f85d 4b04 	ldr.w	r4, [sp], #4
 80086de:	4770      	bx	lr
 80086e0:	80008001 	.word	0x80008001

080086e4 <ENC_IRQHandler>:
/**
  * @brief  TIMER ENCODER Overflow interrupt counter update
  * @param  pHandleVoid: handler of the current instance of the encoder component
  */
__weak void *ENC_IRQHandler(void *pHandleVoid)
{
 80086e4:	4602      	mov	r2, r0
  /* Updates the number of overflows occurred */
  /* The handling of overflow error is done in ENC_CalcAvrgMecSpeedUnit */
  pHandle->TimerOverflowNb += 1U;

  return (MC_NULL);
}
 80086e6:	2000      	movs	r0, #0
  pHandle->TimerOverflowNb += 1U;
 80086e8:	f8b2 3070 	ldrh.w	r3, [r2, #112]	@ 0x70
 80086ec:	3301      	adds	r3, #1
 80086ee:	b29b      	uxth	r3, r3
 80086f0:	f8a2 3070 	strh.w	r3, [r2, #112]	@ 0x70
}
 80086f4:	4770      	bx	lr
 80086f6:	bf00      	nop

080086f8 <MCPA_dataLog>:
  * @brief  Allocates and fills buffer with asynchronous data to be sent to controller
  *
  * @param  *pHandle Pointer to the MCPA Handle
  */
void MCPA_dataLog(MCPA_Handle_t *pHandle)
{
 80086f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
#endif
    uint32_t *logValue;
    uint16_t *logValue16;
    uint8_t i;

    if (pHandle->HFIndex == pHandle->HFRateBuff) /*  */
 80086fa:	7fc3      	ldrb	r3, [r0, #31]
 80086fc:	f890 2022 	ldrb.w	r2, [r0, #34]	@ 0x22
 8008700:	429a      	cmp	r2, r3
{
 8008702:	4604      	mov	r4, r0
    if (pHandle->HFIndex == pHandle->HFRateBuff) /*  */
 8008704:	d002      	beq.n	800870c <MCPA_dataLog+0x14>
      }
    }
    else
    {
      /* Nothing to log just waiting next call to MCPA_datalog */
      pHandle->HFIndex++;
 8008706:	3301      	adds	r3, #1
 8008708:	77c3      	strb	r3, [r0, #31]
    }
#ifdef NULL_PTR_CHECK_MCPA
  }
#endif
}
 800870a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (0U == pHandle->bufferIndex)
 800870c:	8b05      	ldrh	r5, [r0, #24]
      pHandle->HFIndex = 0U;
 800870e:	2300      	movs	r3, #0
 8008710:	77c3      	strb	r3, [r0, #31]
      if (0U == pHandle->bufferIndex)
 8008712:	b1a5      	cbz	r5, 800873e <MCPA_dataLog+0x46>
 8008714:	6961      	ldr	r1, [r4, #20]
      if ((pHandle->bufferIndex > 0U)  && (pHandle->bufferIndex <= pHandle->bufferTxTriggerBuff))
 8008716:	8ba2      	ldrh	r2, [r4, #28]
 8008718:	42aa      	cmp	r2, r5
 800871a:	d24e      	bcs.n	80087ba <MCPA_dataLog+0xc2>
 800871c:	f894 3026 	ldrb.w	r3, [r4, #38]	@ 0x26
        if (pHandle->MFRateBuff == 254U) /* MFRateBuff = 254 means we dump MF data once per buffer */
 8008720:	2bfe      	cmp	r3, #254	@ 0xfe
 8008722:	d066      	beq.n	80087f2 <MCPA_dataLog+0xfa>
        *logValue16 = pHandle->MarkBuff; /* MarkBuff is actually 8 bits, but we add also 8 bits of the ASYNCID=0 after
 8008724:	f894 302a 	ldrb.w	r3, [r4, #42]	@ 0x2a
 8008728:	534b      	strh	r3, [r1, r5]
        pHandle->pTransportLayer->fSendPacket(pHandle->pTransportLayer, pHandle->currentBuffer,
 800872a:	8b22      	ldrh	r2, [r4, #24]
 800872c:	6820      	ldr	r0, [r4, #0]
 800872e:	3202      	adds	r2, #2
 8008730:	2309      	movs	r3, #9
 8008732:	6845      	ldr	r5, [r0, #4]
 8008734:	b292      	uxth	r2, r2
 8008736:	47a8      	blx	r5
        pHandle->bufferIndex = 0U;
 8008738:	2300      	movs	r3, #0
 800873a:	8323      	strh	r3, [r4, #24]
}
 800873c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (0U == pHandle->pTransportLayer->fGetBuffer (pHandle->pTransportLayer,
 800873e:	4601      	mov	r1, r0
 8008740:	2209      	movs	r2, #9
 8008742:	f851 0b14 	ldr.w	r0, [r1], #20
 8008746:	6803      	ldr	r3, [r0, #0]
 8008748:	4798      	blx	r3
 800874a:	b390      	cbz	r0, 80087b2 <MCPA_dataLog+0xba>
          *logValue = GLOBAL_TIMESTAMP; /* 32 first bits is used to store Timestamp */
 800874c:	4b49      	ldr	r3, [pc, #292]	@ (8008874 <MCPA_dataLog+0x17c>)
 800874e:	6961      	ldr	r1, [r4, #20]
 8008750:	681b      	ldr	r3, [r3, #0]
 8008752:	600b      	str	r3, [r1, #0]
          if (pHandle->Mark == pHandle->MarkBuff)
 8008754:	f894 0029 	ldrb.w	r0, [r4, #41]	@ 0x29
 8008758:	f894 202a 	ldrb.w	r2, [r4, #42]	@ 0x2a
          pHandle->MFIndex = 0U; /* Restart the motif from scratch at each buffer */
 800875c:	f884 5020 	strb.w	r5, [r4, #32]
          pHandle->bufferIndex = 4U;
 8008760:	2304      	movs	r3, #4
          if (pHandle->Mark == pHandle->MarkBuff)
 8008762:	4282      	cmp	r2, r0
          pHandle->bufferIndex = 4U;
 8008764:	8323      	strh	r3, [r4, #24]
          if (pHandle->Mark == pHandle->MarkBuff)
 8008766:	d101      	bne.n	800876c <MCPA_dataLog+0x74>
 8008768:	461d      	mov	r5, r3
      if ((pHandle->bufferIndex > 0U)  && (pHandle->bufferIndex <= pHandle->bufferTxTriggerBuff))
 800876a:	e7d4      	b.n	8008716 <MCPA_dataLog+0x1e>
            pHandle->MFNumBuff           = pHandle->MFNum;
 800876c:	f894 3027 	ldrb.w	r3, [r4, #39]	@ 0x27
            pHandle->HFNumBuff           = pHandle->HFNum;
 8008770:	f894 2023 	ldrb.w	r2, [r4, #35]	@ 0x23
            pHandle->MFRateBuff          = pHandle->MFRate;
 8008774:	f894 1025 	ldrb.w	r1, [r4, #37]	@ 0x25
            pHandle->HFRateBuff          = pHandle->HFRate;
 8008778:	f894 5021 	ldrb.w	r5, [r4, #33]	@ 0x21
            pHandle->HFNumBuff           = pHandle->HFNum;
 800877c:	f884 2024 	strb.w	r2, [r4, #36]	@ 0x24
            pHandle->MFNumBuff           = pHandle->MFNum;
 8008780:	f884 3028 	strb.w	r3, [r4, #40]	@ 0x28
                         ((uint32_t)pHandle->HFNum + (uint32_t)pHandle->MFNum) * 4U); /* We store pointer here,
 8008784:	441a      	add	r2, r3
            pHandle->bufferTxTriggerBuff = pHandle->bufferTxTrigger;
 8008786:	8b63      	ldrh	r3, [r4, #26]
            pHandle->MarkBuff            = pHandle->Mark;
 8008788:	f884 002a 	strb.w	r0, [r4, #42]	@ 0x2a
            (void)memcpy(pHandle->dataPtrTableBuff, pHandle->dataPtrTable,
 800878c:	0092      	lsls	r2, r2, #2
            pHandle->MFRateBuff          = pHandle->MFRate;
 800878e:	f884 1026 	strb.w	r1, [r4, #38]	@ 0x26
            pHandle->bufferTxTriggerBuff = pHandle->bufferTxTrigger;
 8008792:	83a3      	strh	r3, [r4, #28]
            (void)memcpy(pHandle->dataPtrTableBuff, pHandle->dataPtrTable,
 8008794:	e9d4 1001 	ldrd	r1, r0, [r4, #4]
            pHandle->HFRateBuff          = pHandle->HFRate;
 8008798:	f884 5022 	strb.w	r5, [r4, #34]	@ 0x22
            (void)memcpy(pHandle->dataPtrTableBuff, pHandle->dataPtrTable,
 800879c:	f001 fdac 	bl	800a2f8 <memcpy>
                         (uint32_t)pHandle->HFNum + (uint32_t)pHandle->MFNum); /* 1 size byte per ID */
 80087a0:	f894 2023 	ldrb.w	r2, [r4, #35]	@ 0x23
 80087a4:	f894 3027 	ldrb.w	r3, [r4, #39]	@ 0x27
            (void)memcpy(pHandle->dataSizeTableBuff, pHandle->dataSizeTable,
 80087a8:	e9d4 1003 	ldrd	r1, r0, [r4, #12]
 80087ac:	441a      	add	r2, r3
 80087ae:	f001 fda3 	bl	800a2f8 <memcpy>
      if ((pHandle->bufferIndex > 0U)  && (pHandle->bufferIndex <= pHandle->bufferTxTriggerBuff))
 80087b2:	8b25      	ldrh	r5, [r4, #24]
 80087b4:	2d00      	cmp	r5, #0
 80087b6:	d1ad      	bne.n	8008714 <MCPA_dataLog+0x1c>
}
 80087b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        for (i = 0U; i < pHandle->HFNumBuff; i++)
 80087ba:	f894 6024 	ldrb.w	r6, [r4, #36]	@ 0x24
        logValue16 = (uint16_t *)&pHandle->currentBuffer[pHandle->bufferIndex]; //cstat !MISRAC2012-Rule-11.3
 80087be:	194b      	adds	r3, r1, r5
        for (i = 0U; i < pHandle->HFNumBuff; i++)
 80087c0:	b36e      	cbz	r6, 800881e <MCPA_dataLog+0x126>
 80087c2:	68a2      	ldr	r2, [r4, #8]
 80087c4:	eb03 0c46 	add.w	ip, r3, r6, lsl #1
 80087c8:	3a04      	subs	r2, #4
          *logValue16 = *((uint16_t *) pHandle->dataPtrTableBuff[i]) ; //cstat !MISRAC2012-Rule-11.5
 80087ca:	f852 0f04 	ldr.w	r0, [r2, #4]!
 80087ce:	8800      	ldrh	r0, [r0, #0]
 80087d0:	f823 0b02 	strh.w	r0, [r3], #2
          pHandle->bufferIndex = pHandle->bufferIndex + 2U;
 80087d4:	8b25      	ldrh	r5, [r4, #24]
 80087d6:	3502      	adds	r5, #2
 80087d8:	b2ad      	uxth	r5, r5
        for (i = 0U; i < pHandle->HFNumBuff; i++)
 80087da:	459c      	cmp	ip, r3
          pHandle->bufferIndex = pHandle->bufferIndex + 2U;
 80087dc:	8325      	strh	r5, [r4, #24]
        for (i = 0U; i < pHandle->HFNumBuff; i++)
 80087de:	d1f4      	bne.n	80087ca <MCPA_dataLog+0xd2>
        if (pHandle->MFRateBuff < 254U)
 80087e0:	f894 3026 	ldrb.w	r3, [r4, #38]	@ 0x26
      if (pHandle->bufferIndex > pHandle->bufferTxTriggerBuff)
 80087e4:	8ba2      	ldrh	r2, [r4, #28]
        if (pHandle->MFRateBuff < 254U)
 80087e6:	2bfd      	cmp	r3, #253	@ 0xfd
 80087e8:	4618      	mov	r0, r3
 80087ea:	d91d      	bls.n	8008828 <MCPA_dataLog+0x130>
      if (pHandle->bufferIndex > pHandle->bufferTxTriggerBuff)
 80087ec:	4295      	cmp	r5, r2
 80087ee:	d897      	bhi.n	8008720 <MCPA_dataLog+0x28>
}
 80087f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
          for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 80087f2:	f894 3024 	ldrb.w	r3, [r4, #36]	@ 0x24
 80087f6:	f894 0028 	ldrb.w	r0, [r4, #40]	@ 0x28
 80087fa:	4418      	add	r0, r3
 80087fc:	4298      	cmp	r0, r3
 80087fe:	dd91      	ble.n	8008724 <MCPA_dataLog+0x2c>
            *logValue = *((uint32_t *)pHandle->dataPtrTableBuff[i]); //cstat !MISRAC2012-Rule-11.5
 8008800:	68a7      	ldr	r7, [r4, #8]
            pHandle->bufferIndex = pHandle->bufferIndex + pHandle->dataSizeTableBuff[i];
 8008802:	6926      	ldr	r6, [r4, #16]
            *logValue = *((uint32_t *)pHandle->dataPtrTableBuff[i]); //cstat !MISRAC2012-Rule-11.5
 8008804:	f857 2023 	ldr.w	r2, [r7, r3, lsl #2]
 8008808:	6812      	ldr	r2, [r2, #0]
 800880a:	514a      	str	r2, [r1, r5]
          for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 800880c:	1c5a      	adds	r2, r3, #1
            pHandle->bufferIndex = pHandle->bufferIndex + pHandle->dataSizeTableBuff[i];
 800880e:	5cf3      	ldrb	r3, [r6, r3]
 8008810:	442b      	add	r3, r5
 8008812:	b29d      	uxth	r5, r3
          for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8008814:	b2d3      	uxtb	r3, r2
 8008816:	4283      	cmp	r3, r0
            pHandle->bufferIndex = pHandle->bufferIndex + pHandle->dataSizeTableBuff[i];
 8008818:	8325      	strh	r5, [r4, #24]
          for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 800881a:	dbf3      	blt.n	8008804 <MCPA_dataLog+0x10c>
 800881c:	e782      	b.n	8008724 <MCPA_dataLog+0x2c>
        if (pHandle->MFRateBuff < 254U)
 800881e:	f894 0026 	ldrb.w	r0, [r4, #38]	@ 0x26
 8008822:	28fd      	cmp	r0, #253	@ 0xfd
 8008824:	f63f af71 	bhi.w	800870a <MCPA_dataLog+0x12>
          if (pHandle->MFIndex == pHandle->MFRateBuff)
 8008828:	f894 3020 	ldrb.w	r3, [r4, #32]
 800882c:	4283      	cmp	r3, r0
 800882e:	d006      	beq.n	800883e <MCPA_dataLog+0x146>
            pHandle->MFIndex ++;
 8008830:	3301      	adds	r3, #1
 8008832:	f884 3020 	strb.w	r3, [r4, #32]
      if (pHandle->bufferIndex > pHandle->bufferTxTriggerBuff)
 8008836:	4295      	cmp	r5, r2
 8008838:	f63f af74 	bhi.w	8008724 <MCPA_dataLog+0x2c>
}
 800883c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 800883e:	f894 7028 	ldrb.w	r7, [r4, #40]	@ 0x28
 8008842:	4437      	add	r7, r6
            pHandle->MFIndex = 0U;
 8008844:	2300      	movs	r3, #0
            for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8008846:	42b7      	cmp	r7, r6
            pHandle->MFIndex = 0U;
 8008848:	f884 3020 	strb.w	r3, [r4, #32]
            for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 800884c:	ddf3      	ble.n	8008836 <MCPA_dataLog+0x13e>
              *logValue = *((uint32_t *)pHandle->dataPtrTableBuff[i]); //cstat !MISRAC2012-Rule-11.5
 800884e:	f8d4 e008 	ldr.w	lr, [r4, #8]
              pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 8008852:	f8d4 c010 	ldr.w	ip, [r4, #16]
              *logValue = *((uint32_t *)pHandle->dataPtrTableBuff[i]); //cstat !MISRAC2012-Rule-11.5
 8008856:	f85e 3026 	ldr.w	r3, [lr, r6, lsl #2]
 800885a:	681b      	ldr	r3, [r3, #0]
 800885c:	514b      	str	r3, [r1, r5]
              pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 800885e:	f81c 3006 	ldrb.w	r3, [ip, r6]
            for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8008862:	1c70      	adds	r0, r6, #1
              pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 8008864:	442b      	add	r3, r5
            for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8008866:	b2c6      	uxtb	r6, r0
              pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 8008868:	b29d      	uxth	r5, r3
            for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 800886a:	42be      	cmp	r6, r7
              pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 800886c:	8325      	strh	r5, [r4, #24]
            for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 800886e:	dbf2      	blt.n	8008856 <MCPA_dataLog+0x15e>
 8008870:	e7e1      	b.n	8008836 <MCPA_dataLog+0x13e>
 8008872:	bf00      	nop
 8008874:	20002724 	.word	0x20002724

08008878 <MCPA_flushDataLog>:
#endif
    uint32_t *logValue;
    uint16_t *logValue16;
    uint8_t i;

    if (pHandle->bufferIndex > 0U)
 8008878:	8b03      	ldrh	r3, [r0, #24]
 800887a:	b19b      	cbz	r3, 80088a4 <MCPA_flushDataLog+0x2c>
{
 800887c:	b570      	push	{r4, r5, r6, lr}
    {  /* If buffer is allocated, we must send it */
      if (pHandle->MFRateBuff == 254U) /* In case of flush, we must respect the packet format to allow
 800887e:	f890 2026 	ldrb.w	r2, [r0, #38]	@ 0x26
                                          proper decoding */
      {
        for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
        {
         logValue = (uint32_t *)&pHandle->currentBuffer[pHandle->bufferIndex]; //cstat !MISRAC2012-Rule-11.3
 8008882:	6941      	ldr	r1, [r0, #20]
      if (pHandle->MFRateBuff == 254U) /* In case of flush, we must respect the packet format to allow
 8008884:	2afe      	cmp	r2, #254	@ 0xfe
 8008886:	4604      	mov	r4, r0
 8008888:	d00d      	beq.n	80088a6 <MCPA_flushDataLog+0x2e>
      else
      {
        /* Nothing to do */
      }
      logValue16 = (uint16_t *)&pHandle->currentBuffer[pHandle->bufferIndex]; //cstat !MISRAC2012-Rule-11.3
      *logValue16 = pHandle->MarkBuff; /* MarkBuff is actually 8 bits, but we add also 8 bits of the ASYNCID=0 after
 800888a:	f894 202a 	ldrb.w	r2, [r4, #42]	@ 0x2a
 800888e:	52ca      	strh	r2, [r1, r3]
                                          the MARK */
      pHandle->pTransportLayer->fSendPacket (pHandle->pTransportLayer, pHandle->currentBuffer,
 8008890:	8b22      	ldrh	r2, [r4, #24]
 8008892:	6820      	ldr	r0, [r4, #0]
 8008894:	3202      	adds	r2, #2
 8008896:	2309      	movs	r3, #9
 8008898:	6845      	ldr	r5, [r0, #4]
 800889a:	b292      	uxth	r2, r2
 800889c:	47a8      	blx	r5
                                             pHandle->bufferIndex + 2U, MCTL_ASYNC);
      pHandle->bufferIndex = 0U;
 800889e:	2300      	movs	r3, #0
 80088a0:	8323      	strh	r3, [r4, #24]
      /* Nothing to do */
    }
#ifdef NULL_PTR_CHECK_MCPA
  }
#endif
}
 80088a2:	bd70      	pop	{r4, r5, r6, pc}
 80088a4:	4770      	bx	lr
        for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 80088a6:	f890 2024 	ldrb.w	r2, [r0, #36]	@ 0x24
 80088aa:	f890 c028 	ldrb.w	ip, [r0, #40]	@ 0x28
 80088ae:	4494      	add	ip, r2
 80088b0:	4562      	cmp	r2, ip
 80088b2:	daea      	bge.n	800888a <MCPA_flushDataLog+0x12>
         *logValue = *((uint32_t *)pHandle->dataPtrTableBuff[i]); //cstat !MISRAC2012-Rule-11.5
 80088b4:	6886      	ldr	r6, [r0, #8]
         pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 80088b6:	6905      	ldr	r5, [r0, #16]
         *logValue = *((uint32_t *)pHandle->dataPtrTableBuff[i]); //cstat !MISRAC2012-Rule-11.5
 80088b8:	f856 0022 	ldr.w	r0, [r6, r2, lsl #2]
 80088bc:	6800      	ldr	r0, [r0, #0]
 80088be:	50c8      	str	r0, [r1, r3]
         pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 80088c0:	5ca8      	ldrb	r0, [r5, r2]
        for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 80088c2:	3201      	adds	r2, #1
         pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 80088c4:	4403      	add	r3, r0
        for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 80088c6:	b2d2      	uxtb	r2, r2
         pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 80088c8:	b29b      	uxth	r3, r3
        for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 80088ca:	4562      	cmp	r2, ip
         pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 80088cc:	8323      	strh	r3, [r4, #24]
        for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 80088ce:	dbf3      	blt.n	80088b8 <MCPA_flushDataLog+0x40>
 80088d0:	e7db      	b.n	800888a <MCPA_flushDataLog+0x12>
 80088d2:	bf00      	nop

080088d4 <MCPA_cfgLog>:
  *
  * @param  *pHandle Pointer to the MCPA Handle
  * @param  *cfgdata Configuration of the Async communication
  */
uint8_t MCPA_cfgLog(MCPA_Handle_t *pHandle, uint8_t *cfgdata)
{
 80088d4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    uint8_t i;
    uint16_t logSize = 0U; /* Max size of a log per iteration (HF+MF) */
    uint16_t newID, buffSize;
    uint8_t *pCfgData = cfgdata;

    buffSize = *((uint16_t *)pCfgData); //cstat !MISRAC2012-Rule-11.3
 80088d8:	880f      	ldrh	r7, [r1, #0]
{
 80088da:	4604      	mov	r4, r0

    if (buffSize == 0U)
 80088dc:	2f00      	cmp	r7, #0
 80088de:	d046      	beq.n	800896e <MCPA_cfgLog+0x9a>
    { 
      /* Switch Off condition */
      MCPA_stopDataLog(pHandle);
    }
    else if (buffSize > pHandle->pTransportLayer->txAsyncMaxPayload)
 80088e0:	6803      	ldr	r3, [r0, #0]
 80088e2:	89db      	ldrh	r3, [r3, #14]
 80088e4:	42bb      	cmp	r3, r7
 80088e6:	d33f      	bcc.n	8008968 <MCPA_cfgLog+0x94>
    {
      result = MCP_ERROR_NO_TXASYNC_SPACE;
    }
    else
    {
      pHandle->HFRate = *((uint8_t *)&pCfgData[2]);
 80088e8:	788b      	ldrb	r3, [r1, #2]
 80088ea:	f880 3021 	strb.w	r3, [r0, #33]	@ 0x21
      pHandle->HFNum  = *((uint8_t *)&pCfgData[3]);
 80088ee:	f891 8003 	ldrb.w	r8, [r1, #3]
 80088f2:	f880 8023 	strb.w	r8, [r0, #35]	@ 0x23
      pHandle->MFRate = *((uint8_t *)&pCfgData[4]);
 80088f6:	790b      	ldrb	r3, [r1, #4]
 80088f8:	f880 3025 	strb.w	r3, [r0, #37]	@ 0x25
      pHandle->MFNum  = *((uint8_t *)&pCfgData[5]);
 80088fc:	794b      	ldrb	r3, [r1, #5]
      pCfgData = &pCfgData[6]; /* Start of the HF IDs */

      if ((pHandle->HFNum + pHandle->MFNum) <= pHandle->nbrOfDataLog)
 80088fe:	7f82      	ldrb	r2, [r0, #30]
      pHandle->MFNum  = *((uint8_t *)&pCfgData[5]);
 8008900:	f880 3027 	strb.w	r3, [r0, #39]	@ 0x27
      if ((pHandle->HFNum + pHandle->MFNum) <= pHandle->nbrOfDataLog)
 8008904:	4443      	add	r3, r8
 8008906:	4293      	cmp	r3, r2
 8008908:	dc57      	bgt.n	80089ba <MCPA_cfgLog+0xe6>
      pCfgData = &pCfgData[6]; /* Start of the HF IDs */
 800890a:	1d8e      	adds	r6, r1, #6
      {
        for (i = 0; i < (pHandle->HFNum + pHandle->MFNum); i++)
 800890c:	2b00      	cmp	r3, #0
 800890e:	d057      	beq.n	80089c0 <MCPA_cfgLog+0xec>
    uint16_t logSize = 0U; /* Max size of a log per iteration (HF+MF) */
 8008910:	f04f 0800 	mov.w	r8, #0
        for (i = 0; i < (pHandle->HFNum + pHandle->MFNum); i++)
 8008914:	4645      	mov	r5, r8
 8008916:	e011      	b.n	800893c <MCPA_cfgLog+0x68>
        {
          newID = *((uint16_t *)pCfgData); //cstat !MISRAC2012-Rule-11.3
          (void)RI_GetPtrReg(newID, &pHandle->dataPtrTable[i]);
          /* HF Data are fixed to 2 bytes */
          pHandle->dataSizeTable[i] = (i < pHandle->HFNum ) ? 2U : RI_GetIDSize(newID);
 8008918:	68e3      	ldr	r3, [r4, #12]
 800891a:	5558      	strb	r0, [r3, r5]
          pCfgData++; /* Point to the next UID */
          pCfgData++;
          logSize = logSize+pHandle->dataSizeTable[i];
 800891c:	68e2      	ldr	r2, [r4, #12]
        for (i = 0; i < (pHandle->HFNum + pHandle->MFNum); i++)
 800891e:	f894 3023 	ldrb.w	r3, [r4, #35]	@ 0x23
 8008922:	f894 1027 	ldrb.w	r1, [r4, #39]	@ 0x27
          logSize = logSize+pHandle->dataSizeTable[i];
 8008926:	5d52      	ldrb	r2, [r2, r5]
        for (i = 0; i < (pHandle->HFNum + pHandle->MFNum); i++)
 8008928:	f105 0c01 	add.w	ip, r5, #1
 800892c:	fa5f f58c 	uxtb.w	r5, ip
 8008930:	440b      	add	r3, r1
          logSize = logSize+pHandle->dataSizeTable[i];
 8008932:	4442      	add	r2, r8
        for (i = 0; i < (pHandle->HFNum + pHandle->MFNum); i++)
 8008934:	429d      	cmp	r5, r3
          logSize = logSize+pHandle->dataSizeTable[i];
 8008936:	fa1f f882 	uxth.w	r8, r2
        for (i = 0; i < (pHandle->HFNum + pHandle->MFNum); i++)
 800893a:	da11      	bge.n	8008960 <MCPA_cfgLog+0x8c>
          newID = *((uint16_t *)pCfgData); //cstat !MISRAC2012-Rule-11.3
 800893c:	f836 9b02 	ldrh.w	r9, [r6], #2
          (void)RI_GetPtrReg(newID, &pHandle->dataPtrTable[i]);
 8008940:	6861      	ldr	r1, [r4, #4]
 8008942:	4648      	mov	r0, r9
 8008944:	eb01 0185 	add.w	r1, r1, r5, lsl #2
 8008948:	f7fa fdaa 	bl	80034a0 <RI_GetPtrReg>
          pHandle->dataSizeTable[i] = (i < pHandle->HFNum ) ? 2U : RI_GetIDSize(newID);
 800894c:	f894 3023 	ldrb.w	r3, [r4, #35]	@ 0x23
 8008950:	42ab      	cmp	r3, r5
 8008952:	f04f 0002 	mov.w	r0, #2
 8008956:	d8df      	bhi.n	8008918 <MCPA_cfgLog+0x44>
 8008958:	4648      	mov	r0, r9
 800895a:	f7fa fd95 	bl	8003488 <RI_GetIDSize>
 800895e:	e7db      	b.n	8008918 <MCPA_cfgLog+0x44>
        }

        /* Smallest packet must be able to contain logSize Markbyte AsyncID and TimeStamp */
        if (buffSize < (logSize + 2U + 4U))
 8008960:	f108 0206 	add.w	r2, r8, #6
 8008964:	4297      	cmp	r7, r2
 8008966:	d210      	bcs.n	800898a <MCPA_cfgLog+0xb6>
      result = MCP_ERROR_NO_TXASYNC_SPACE;
 8008968:	2009      	movs	r0, #9
    }
#ifdef NULL_PTR_CHECK_MCPA
  }
#endif
  return (result);
}
 800896a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  if (pHandle->bufferIndex > 0U)
 800896e:	8b03      	ldrh	r3, [r0, #24]
  pHandle->Mark = 0U;
 8008970:	f880 7029 	strb.w	r7, [r0, #41]	@ 0x29
  if (pHandle->bufferIndex > 0U)
 8008974:	b9ab      	cbnz	r3, 80089a2 <MCPA_cfgLog+0xce>
  pHandle->bufferIndex = 0U;
 8008976:	2300      	movs	r3, #0
 8008978:	8323      	strh	r3, [r4, #24]
  pHandle->MarkBuff    = 0U;
 800897a:	f884 302a 	strb.w	r3, [r4, #42]	@ 0x2a
  pHandle->HFIndex     = 0U;
 800897e:	77e3      	strb	r3, [r4, #31]
  pHandle->HFRateBuff  = 0U; /* We do not want to miss any sample at the restart */
 8008980:	f884 3022 	strb.w	r3, [r4, #34]	@ 0x22
  uint8_t result = MCP_CMD_OK;
 8008984:	2000      	movs	r0, #0
}
 8008986:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
          pHandle->bufferTxTrigger = buffSize-logSize - 2U; /* 2 is required to add the last Mark byte and NUL
 800898a:	3f02      	subs	r7, #2
 800898c:	eba7 0708 	sub.w	r7, r7, r8
 8008990:	8367      	strh	r7, [r4, #26]
          pHandle->Mark = *((uint8_t *)pCfgData);
 8008992:	7833      	ldrb	r3, [r6, #0]
 8008994:	f884 3029 	strb.w	r3, [r4, #41]	@ 0x29
          if (0U == pHandle->Mark)
 8008998:	2b00      	cmp	r3, #0
 800899a:	d1f3      	bne.n	8008984 <MCPA_cfgLog+0xb0>
  if (pHandle->bufferIndex > 0U)
 800899c:	8b23      	ldrh	r3, [r4, #24]
 800899e:	2b00      	cmp	r3, #0
 80089a0:	d0e9      	beq.n	8008976 <MCPA_cfgLog+0xa2>
    logValue16 = (uint16_t *)&pHandle->currentBuffer[pHandle->bufferIndex]; //cstat !MISRAC2012-Rule-11.3
 80089a2:	6961      	ldr	r1, [r4, #20]
    *logValue16 = pHandle->MarkBuff; /* MarkBuff is actually 8 bits, but we add also 8 bits of the ASYNCID=0 after
 80089a4:	f894 202a 	ldrb.w	r2, [r4, #42]	@ 0x2a
 80089a8:	52ca      	strh	r2, [r1, r3]
    pHandle->pTransportLayer->fSendPacket (pHandle->pTransportLayer, pHandle->currentBuffer,
 80089aa:	8b22      	ldrh	r2, [r4, #24]
 80089ac:	6820      	ldr	r0, [r4, #0]
 80089ae:	3202      	adds	r2, #2
 80089b0:	6845      	ldr	r5, [r0, #4]
 80089b2:	b292      	uxth	r2, r2
 80089b4:	2309      	movs	r3, #9
 80089b6:	47a8      	blx	r5
 80089b8:	e7dd      	b.n	8008976 <MCPA_cfgLog+0xa2>
        result = MCP_ERROR_BAD_RAW_FORMAT;
 80089ba:	200a      	movs	r0, #10
}
 80089bc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        for (i = 0; i < (pHandle->HFNum + pHandle->MFNum); i++)
 80089c0:	2206      	movs	r2, #6
    uint16_t logSize = 0U; /* Max size of a log per iteration (HF+MF) */
 80089c2:	4698      	mov	r8, r3
 80089c4:	e7ce      	b.n	8008964 <MCPA_cfgLog+0x90>
 80089c6:	bf00      	nop

080089c8 <NTC_SetFaultState>:
    hFault = MC_SW_ERROR;
  }
  else
  {
#endif
    if (pHandle->hSensitivity > 0 )
 80089c8:	f9b0 1010 	ldrsh.w	r1, [r0, #16]
    {
      if (pHandle->hAvTemp_d > pHandle->hOverTempThreshold)
 80089cc:	8843      	ldrh	r3, [r0, #2]
 80089ce:	8982      	ldrh	r2, [r0, #12]
    if (pHandle->hSensitivity > 0 )
 80089d0:	2900      	cmp	r1, #0
 80089d2:	dd08      	ble.n	80089e6 <NTC_SetFaultState+0x1e>
      if (pHandle->hAvTemp_d > pHandle->hOverTempThreshold)
 80089d4:	4293      	cmp	r3, r2
 80089d6:	d804      	bhi.n	80089e2 <NTC_SetFaultState+0x1a>
      {
        hFault = MC_OVER_TEMP;
      }
      else if (pHandle->hAvTemp_d < pHandle->hOverTempDeactThreshold)
 80089d8:	89c2      	ldrh	r2, [r0, #14]
 80089da:	429a      	cmp	r2, r3
 80089dc:	d908      	bls.n	80089f0 <NTC_SetFaultState+0x28>
      {
        hFault = MC_NO_ERROR;
 80089de:	2000      	movs	r0, #0
 80089e0:	4770      	bx	lr
    }
    else
    {
      if (pHandle->hAvTemp_d < pHandle->hOverTempThreshold)
      {
        hFault = MC_OVER_TEMP;
 80089e2:	2008      	movs	r0, #8
    }
#ifdef NULL_PTR_CHECK_NTC_TEMP_SENS
  }
#endif
  return (hFault);
}
 80089e4:	4770      	bx	lr
      if (pHandle->hAvTemp_d < pHandle->hOverTempThreshold)
 80089e6:	4293      	cmp	r3, r2
 80089e8:	d3fb      	bcc.n	80089e2 <NTC_SetFaultState+0x1a>
      else if (pHandle->hAvTemp_d > pHandle->hOverTempDeactThreshold)
 80089ea:	89c2      	ldrh	r2, [r0, #14]
 80089ec:	429a      	cmp	r2, r3
 80089ee:	d3f6      	bcc.n	80089de <NTC_SetFaultState+0x16>
        hFault = pHandle->hFaultState;
 80089f0:	8900      	ldrh	r0, [r0, #8]
 80089f2:	4770      	bx	lr

080089f4 <NTC_Init>:
    /* Nothing to do */
  }
  else
  {
#endif
    if (REAL_SENSOR == pHandle->bSensorType)
 80089f4:	7803      	ldrb	r3, [r0, #0]
 80089f6:	b94b      	cbnz	r3, 8008a0c <NTC_Init+0x18>
    /* nothing to do */
  }
  else
  {
#endif
    if (pHandle->hSensitivity > 0 ) 
 80089f8:	f9b0 3010 	ldrsh.w	r3, [r0, #16]
 80089fc:	2b00      	cmp	r3, #0
 80089fe:	bfcc      	ite	gt
 8008a00:	2300      	movgt	r3, #0
 8008a02:	2301      	movle	r3, #1
 8008a04:	425b      	negs	r3, r3
 8008a06:	b29b      	uxth	r3, r3
    {
      pHandle->hAvTemp_d = 0U;
    }
    else
    {
      pHandle->hAvTemp_d = 0xFFFFU;
 8008a08:	8043      	strh	r3, [r0, #2]
}
 8008a0a:	4770      	bx	lr
      pHandle->hAvTemp_d = pHandle->hExpectedTemp_d;
 8008a0c:	8883      	ldrh	r3, [r0, #4]
      pHandle->hAvTemp_d = 0xFFFFU;
 8008a0e:	8043      	strh	r3, [r0, #2]
      pHandle->hFaultState = MC_NO_ERROR;
 8008a10:	2200      	movs	r2, #0
 8008a12:	8102      	strh	r2, [r0, #8]
}
 8008a14:	4770      	bx	lr
 8008a16:	bf00      	nop

08008a18 <NTC_CalcAvTemp>:
  * @param pHandle : Pointer on Handle structure of TemperatureSensor component
  *
  * @retval Fault status : Error reported in case of an over temperature detection
  */
__weak uint16_t NTC_CalcAvTemp(NTC_Handle_t *pHandle, uint16_t rawValue)
{
 8008a18:	b510      	push	{r4, lr}
    returnValue = 0U;
  }
  else
  {
#endif
    if (REAL_SENSOR == pHandle->bSensorType)
 8008a1a:	7803      	ldrb	r3, [r0, #0]
{
 8008a1c:	4604      	mov	r4, r0
    if (REAL_SENSOR == pHandle->bSensorType)
 8008a1e:	b983      	cbnz	r3, 8008a42 <NTC_CalcAvTemp+0x2a>
    {
      uint16_t hAux;
      hAux = rawValue;

      if (0xFFFFU == hAux)
 8008a20:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 8008a24:	4299      	cmp	r1, r3
 8008a26:	d007      	beq.n	8008a38 <NTC_CalcAvTemp+0x20>
        /* Nothing to do */
      }
      else
      {
        uint32_t wtemp;
        wtemp = (uint32_t)(pHandle->hLowPassFilterBW) - 1U;
 8008a28:	8943      	ldrh	r3, [r0, #10]
        wtemp *= ((uint32_t)pHandle->hAvTemp_d);
 8008a2a:	8842      	ldrh	r2, [r0, #2]
        wtemp = (uint32_t)(pHandle->hLowPassFilterBW) - 1U;
 8008a2c:	1e58      	subs	r0, r3, #1
        wtemp += hAux;
 8008a2e:	fb00 1102 	mla	r1, r0, r2, r1
        wtemp /= ((uint32_t)pHandle->hLowPassFilterBW);
 8008a32:	fbb1 f1f3 	udiv	r1, r1, r3

        pHandle->hAvTemp_d = (uint16_t)wtemp;
 8008a36:	8061      	strh	r1, [r4, #2]
      }

      pHandle->hFaultState = NTC_SetFaultState(pHandle);
 8008a38:	4620      	mov	r0, r4
 8008a3a:	f7ff ffc5 	bl	80089c8 <NTC_SetFaultState>
 8008a3e:	8120      	strh	r0, [r4, #8]
    returnValue = pHandle->hFaultState;
#ifdef NULL_PTR_CHECK_NTC_TEMP_SENS
  }
#endif
  return (returnValue);
}
 8008a40:	bd10      	pop	{r4, pc}
 8008a42:	2000      	movs	r0, #0
      pHandle->hFaultState = NTC_SetFaultState(pHandle);
 8008a44:	8120      	strh	r0, [r4, #8]
}
 8008a46:	bd10      	pop	{r4, pc}

08008a48 <NTC_GetAvTemp_C>:
  else
  {
#endif
    int32_t wTemp;

    if (REAL_SENSOR == pHandle->bSensorType)
 8008a48:	7803      	ldrb	r3, [r0, #0]
 8008a4a:	b95b      	cbnz	r3, 8008a64 <NTC_GetAvTemp_C+0x1c>
    {
      wTemp = (int32_t)pHandle->hAvTemp_d;
 8008a4c:	8842      	ldrh	r2, [r0, #2]
      wTemp -= ((int32_t)pHandle->wV0);
 8008a4e:	6941      	ldr	r1, [r0, #20]
      wTemp *= pHandle->hSensitivity;
 8008a50:	f9b0 3010 	ldrsh.w	r3, [r0, #16]
#ifndef FULL_MISRA_C_COMPLIANCY_NTC_TEMP
      //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
      wTemp = (wTemp >> 16) + (int32_t)pHandle->hT0;
 8008a54:	8b00      	ldrh	r0, [r0, #24]
      wTemp -= ((int32_t)pHandle->wV0);
 8008a56:	1a52      	subs	r2, r2, r1
      wTemp *= pHandle->hSensitivity;
 8008a58:	fb02 f303 	mul.w	r3, r2, r3
      wTemp = (wTemp >> 16) + (int32_t)pHandle->hT0;
 8008a5c:	eb00 4023 	add.w	r0, r0, r3, asr #16
    returnValue = (int16_t)wTemp;
#ifdef NULL_PTR_CHECK_NTC_TEMP_SENS
  }
#endif
  return (returnValue);
}
 8008a60:	b200      	sxth	r0, r0
 8008a62:	4770      	bx	lr
      wTemp = (int32_t)pHandle->hExpectedTemp_C;
 8008a64:	88c0      	ldrh	r0, [r0, #6]
}
 8008a66:	b200      	sxth	r0, r0
 8008a68:	4770      	bx	lr
 8008a6a:	bf00      	nop

08008a6c <PID_HandleInit>:
  {
#endif
    pHandle->hKpGain =  pHandle->hDefKpGain;
    pHandle->hKiGain =  pHandle->hDefKiGain;
    pHandle->hKdGain =  pHandle->hDefKdGain;
    pHandle->wIntegralTerm = 0;
 8008a6c:	2300      	movs	r3, #0
    pHandle->hKpGain =  pHandle->hDefKpGain;
 8008a6e:	6801      	ldr	r1, [r0, #0]
    pHandle->hKdGain =  pHandle->hDefKdGain;
 8008a70:	8c02      	ldrh	r2, [r0, #32]
    pHandle->hKpGain =  pHandle->hDefKpGain;
 8008a72:	6041      	str	r1, [r0, #4]
    pHandle->hKdGain =  pHandle->hDefKdGain;
 8008a74:	8442      	strh	r2, [r0, #34]	@ 0x22
    pHandle->wIntegralTerm = 0;
 8008a76:	6083      	str	r3, [r0, #8]
    pHandle->wPrevProcessVarError = 0;
 8008a78:	6283      	str	r3, [r0, #40]	@ 0x28
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 8008a7a:	4770      	bx	lr

08008a7c <PID_SetKP>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->hKpGain = hKpGain;
 8008a7c:	8081      	strh	r1, [r0, #4]
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 8008a7e:	4770      	bx	lr

08008a80 <PID_SetKI>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->hKiGain = hKiGain;
 8008a80:	80c1      	strh	r1, [r0, #6]
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 8008a82:	4770      	bx	lr

08008a84 <PID_GetKP>:
#ifdef NULL_PTR_CHECK_PID_REG
  return ((MC_NULL == pHandle) ? 0 : pHandle->hKpGain);
#else
  return (pHandle->hKpGain);
#endif
}
 8008a84:	f9b0 0004 	ldrsh.w	r0, [r0, #4]
 8008a88:	4770      	bx	lr
 8008a8a:	bf00      	nop

08008a8c <PID_GetKI>:
#ifdef NULL_PTR_CHECK_PID_REG
  return ((MC_NULL == pHandle) ? 0 : pHandle->hKiGain);
#else
  return (pHandle->hKiGain);
#endif
}
 8008a8c:	f9b0 0006 	ldrsh.w	r0, [r0, #6]
 8008a90:	4770      	bx	lr
 8008a92:	bf00      	nop

08008a94 <PID_SetIntegralTerm>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->wIntegralTerm = wIntegralTermValue;
 8008a94:	6081      	str	r1, [r0, #8]
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
  return;
}
 8008a96:	4770      	bx	lr

08008a98 <PID_GetKPDivisorPOW2>:
#ifdef NULL_PTR_CHECK_PID_REG
  return ((MC_NULL == pHandle) ? 0U : pHandle->hKpDivisorPOW2);
#else
  return (pHandle->hKpDivisorPOW2);
#endif
}
 8008a98:	8b80      	ldrh	r0, [r0, #28]
 8008a9a:	4770      	bx	lr

08008a9c <PID_SetKPDivisorPOW2>:
  }
  else
  {
#endif
    pHandle->hKpDivisorPOW2 = hKpDivisorPOW2;
    pHandle->hKpDivisor = (((uint16_t)1) << hKpDivisorPOW2);
 8008a9c:	2301      	movs	r3, #1
 8008a9e:	408b      	lsls	r3, r1
    pHandle->hKpDivisorPOW2 = hKpDivisorPOW2;
 8008aa0:	8381      	strh	r1, [r0, #28]
    pHandle->hKpDivisor = (((uint16_t)1) << hKpDivisorPOW2);
 8008aa2:	8303      	strh	r3, [r0, #24]
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 8008aa4:	4770      	bx	lr
 8008aa6:	bf00      	nop

08008aa8 <PID_GetKIDivisorPOW2>:
#ifdef NULL_PTR_CHECK_PID_REG
  return ((MC_NULL == pHandle) ? 0U : pHandle->hKiDivisorPOW2);
#else
  return (pHandle->hKiDivisorPOW2);
#endif
}
 8008aa8:	8bc0      	ldrh	r0, [r0, #30]
 8008aaa:	4770      	bx	lr

08008aac <PID_SetLowerIntegralTermLimit>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->wLowerIntegralLimit = wLowerLimit;
 8008aac:	6101      	str	r1, [r0, #16]
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 8008aae:	4770      	bx	lr

08008ab0 <PID_SetUpperIntegralTermLimit>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->wUpperIntegralLimit = wUpperLimit;
 8008ab0:	60c1      	str	r1, [r0, #12]
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 8008ab2:	4770      	bx	lr

08008ab4 <PID_SetKIDivisorPOW2>:
{
 8008ab4:	b538      	push	{r3, r4, r5, lr}
    uint32_t wKiDiv = (((uint32_t)1) << hKiDivisorPOW2);
 8008ab6:	2301      	movs	r3, #1
{
 8008ab8:	460c      	mov	r4, r1
    uint32_t wKiDiv = (((uint32_t)1) << hKiDivisorPOW2);
 8008aba:	408b      	lsls	r3, r1
    PID_SetUpperIntegralTermLimit(pHandle, (int32_t)INT16_MAX * (int32_t)wKiDiv);
 8008abc:	f647 71ff 	movw	r1, #32767	@ 0x7fff
 8008ac0:	40a1      	lsls	r1, r4
    pHandle->hKiDivisorPOW2 = hKiDivisorPOW2;
 8008ac2:	83c4      	strh	r4, [r0, #30]
    pHandle->hKiDivisor = (uint16_t)wKiDiv;
 8008ac4:	8343      	strh	r3, [r0, #26]
{
 8008ac6:	4605      	mov	r5, r0
    PID_SetUpperIntegralTermLimit(pHandle, (int32_t)INT16_MAX * (int32_t)wKiDiv);
 8008ac8:	f7ff fff2 	bl	8008ab0 <PID_SetUpperIntegralTermLimit>
    PID_SetLowerIntegralTermLimit(pHandle, (int32_t)(-INT16_MAX) * (int32_t)wKiDiv);
 8008acc:	4902      	ldr	r1, [pc, #8]	@ (8008ad8 <PID_SetKIDivisorPOW2+0x24>)
 8008ace:	4628      	mov	r0, r5
 8008ad0:	40a1      	lsls	r1, r4
 8008ad2:	f7ff ffeb 	bl	8008aac <PID_SetLowerIntegralTermLimit>
}
 8008ad6:	bd38      	pop	{r3, r4, r5, pc}
 8008ad8:	ffff8001 	.word	0xffff8001

08008adc <PID_SetKD>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->hKdGain = hKdGain;
 8008adc:	8441      	strh	r1, [r0, #34]	@ 0x22
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 8008ade:	4770      	bx	lr

08008ae0 <PID_GetKD>:
#ifdef NULL_PTR_CHECK_PID_REG
  return ((MC_NULL == pHandle) ? 0 : pHandle->hKdGain);
#else
  return (pHandle->hKdGain);
#endif
}
 8008ae0:	f9b0 0022 	ldrsh.w	r0, [r0, #34]	@ 0x22
 8008ae4:	4770      	bx	lr
 8008ae6:	bf00      	nop

08008ae8 <PID_GetKDDivisorPOW2>:
#ifdef NULL_PTR_CHECK_PID_REG
  return ((MC_NULL == pHandle) ? 0U : pHandle->hKdDivisorPOW2);
#else
  return (pHandle->hKdDivisorPOW2);
#endif
}
 8008ae8:	8cc0      	ldrh	r0, [r0, #38]	@ 0x26
 8008aea:	4770      	bx	lr

08008aec <PID_SetKDDivisorPOW2>:
  }
  else
  {
#endif
    pHandle->hKdDivisorPOW2 = hKdDivisorPOW2;
    pHandle->hKdDivisor = (((uint16_t)1) << hKdDivisorPOW2);
 8008aec:	2301      	movs	r3, #1
 8008aee:	408b      	lsls	r3, r1
    pHandle->hKdDivisorPOW2 = hKdDivisorPOW2;
 8008af0:	84c1      	strh	r1, [r0, #38]	@ 0x26
    pHandle->hKdDivisor = (((uint16_t)1) << hKdDivisorPOW2);
 8008af2:	8483      	strh	r3, [r0, #36]	@ 0x24
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 8008af4:	4770      	bx	lr
 8008af6:	bf00      	nop

08008af8 <PI_Controller>:
    int32_t wDischarge = 0;
    int16_t hUpperOutputLimit = pHandle->hUpperOutputLimit;
    int16_t hLowerOutputLimit = pHandle->hLowerOutputLimit;

    /* Proportional term computation*/
    wProportional_Term = pHandle->hKpGain * wProcessVarError;
 8008af8:	f9b0 2004 	ldrsh.w	r2, [r0, #4]
{
 8008afc:	4603      	mov	r3, r0
 8008afe:	b530      	push	{r4, r5, lr}

    /* Integral term computation */
    if (0 == pHandle->hKiGain)
 8008b00:	f9b0 4006 	ldrsh.w	r4, [r0, #6]
    int16_t hLowerOutputLimit = pHandle->hLowerOutputLimit;
 8008b04:	f9b3 c016 	ldrsh.w	ip, [r3, #22]
    int16_t hUpperOutputLimit = pHandle->hUpperOutputLimit;
 8008b08:	f9b0 0014 	ldrsh.w	r0, [r0, #20]
    wProportional_Term = pHandle->hKpGain * wProcessVarError;
 8008b0c:	fb01 f202 	mul.w	r2, r1, r2
    if (0 == pHandle->hKiGain)
 8008b10:	b17c      	cbz	r4, 8008b32 <PI_Controller+0x3a>
    {
      pHandle->wIntegralTerm = 0;
    }
    else
    {
      wIntegral_Term = pHandle->hKiGain * wProcessVarError;
 8008b12:	fb04 f101 	mul.w	r1, r4, r1
        {
          /* Nothing to do */
        }
      }

      if (wIntegral_sum_temp > pHandle->wUpperIntegralLimit)
 8008b16:	e9d3 5402 	ldrd	r5, r4, [r3, #8]
      if (wIntegral_sum_temp < 0)
 8008b1a:	eb15 0e01 	adds.w	lr, r5, r1
 8008b1e:	d41d      	bmi.n	8008b5c <PI_Controller+0x64>
            wIntegral_sum_temp = -INT32_MAX;
 8008b20:	420d      	tst	r5, r1
 8008b22:	4914      	ldr	r1, [pc, #80]	@ (8008b74 <PI_Controller+0x7c>)
 8008b24:	bf48      	it	mi
 8008b26:	468e      	movmi	lr, r1
      if (wIntegral_sum_temp > pHandle->wUpperIntegralLimit)
 8008b28:	45a6      	cmp	lr, r4
 8008b2a:	dc02      	bgt.n	8008b32 <PI_Controller+0x3a>
      {
        pHandle->wIntegralTerm = pHandle->wUpperIntegralLimit;
      }
      else if (wIntegral_sum_temp < pHandle->wLowerIntegralLimit)
 8008b2c:	691c      	ldr	r4, [r3, #16]
 8008b2e:	4574      	cmp	r4, lr
 8008b30:	dd1d      	ble.n	8008b6e <PI_Controller+0x76>
    /* WARNING: the below instruction is not MISRA compliant, user should verify
               that Cortex-M3 assembly instruction ASR (arithmetic shift right)
               is used by the compiler to perform the shifts (instead of LSR
               logical shift right)*/
    //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
    wOutput_32 = (wProportional_Term >> pHandle->hKpDivisorPOW2) + (pHandle->wIntegralTerm >> pHandle->hKiDivisorPOW2);
 8008b32:	8b99      	ldrh	r1, [r3, #28]
 8008b34:	410a      	asrs	r2, r1
 8008b36:	8bd9      	ldrh	r1, [r3, #30]
 8008b38:	fa44 f101 	asr.w	r1, r4, r1
 8008b3c:	440a      	add	r2, r1
#else
    wOutput_32 = (wProportional_Term / (int32_t)pHandle->hKpDivisor)
              + (pHandle->wIntegralTerm / (int32_t)pHandle->hKiDivisor);
#endif

    if (wOutput_32 > hUpperOutputLimit)
 8008b3e:	4290      	cmp	r0, r2
 8008b40:	da03      	bge.n	8008b4a <PI_Controller+0x52>
    {
      wDischarge = hUpperOutputLimit - wOutput_32;
 8008b42:	1a82      	subs	r2, r0, r2
    else
    {
      /* Nothing to do here */
    }

    pHandle->wIntegralTerm += wDischarge;
 8008b44:	4414      	add	r4, r2
 8008b46:	609c      	str	r4, [r3, #8]
    returnValue = (int16_t)wOutput_32;
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
  return (returnValue);
}
 8008b48:	bd30      	pop	{r4, r5, pc}
    else if (wOutput_32 < hLowerOutputLimit)
 8008b4a:	4594      	cmp	ip, r2
      wDischarge = hLowerOutputLimit - wOutput_32;
 8008b4c:	bfc5      	ittet	gt
 8008b4e:	ebac 0202 	subgt.w	r2, ip, r2
    pHandle->wIntegralTerm += wDischarge;
 8008b52:	18a4      	addgt	r4, r4, r2
    returnValue = (int16_t)wOutput_32;
 8008b54:	b210      	sxthle	r0, r2
      wOutput_32 = hLowerOutputLimit;
 8008b56:	4660      	movgt	r0, ip
    pHandle->wIntegralTerm += wDischarge;
 8008b58:	609c      	str	r4, [r3, #8]
}
 8008b5a:	bd30      	pop	{r4, r5, pc}
        if (pHandle->wIntegralTerm > 0)
 8008b5c:	2d00      	cmp	r5, #0
 8008b5e:	dde3      	ble.n	8008b28 <PI_Controller+0x30>
          if (wIntegral_Term > 0)
 8008b60:	2900      	cmp	r1, #0
 8008b62:	dde1      	ble.n	8008b28 <PI_Controller+0x30>
      if (wIntegral_sum_temp > pHandle->wUpperIntegralLimit)
 8008b64:	f06f 4100 	mvn.w	r1, #2147483648	@ 0x80000000
 8008b68:	428c      	cmp	r4, r1
 8008b6a:	d1e2      	bne.n	8008b32 <PI_Controller+0x3a>
 8008b6c:	46a6      	mov	lr, r4
        pHandle->wIntegralTerm = wIntegral_sum_temp;
 8008b6e:	4674      	mov	r4, lr
 8008b70:	e7df      	b.n	8008b32 <PI_Controller+0x3a>
 8008b72:	bf00      	nop
 8008b74:	80000001 	.word	0x80000001

08008b78 <PID_Controller>:
#endif
    int32_t wDifferential_Term;
    int32_t wDeltaError;
    int32_t wTemp_output;

    if (0 == pHandle->hKdGain) /* derivative terms not used */
 8008b78:	f9b0 2022 	ldrsh.w	r2, [r0, #34]	@ 0x22
{
 8008b7c:	b538      	push	{r3, r4, r5, lr}
    if (0 == pHandle->hKdGain) /* derivative terms not used */
 8008b7e:	b912      	cbnz	r2, 8008b86 <PID_Controller+0xe>
    {
      wTemp_output = PI_Controller(pHandle, wProcessVarError);
 8008b80:	f7ff ffba 	bl	8008af8 <PI_Controller>
    returnValue = (int16_t) wTemp_output;
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
  return (returnValue);
}
 8008b84:	bd38      	pop	{r3, r4, r5, pc}
      wDeltaError = wProcessVarError - pHandle->wPrevProcessVarError;
 8008b86:	6a84      	ldr	r4, [r0, #40]	@ 0x28
      wDifferential_Term >>= pHandle->hKdDivisorPOW2;
 8008b88:	8cc3      	ldrh	r3, [r0, #38]	@ 0x26
      pHandle->wPrevProcessVarError = wProcessVarError;
 8008b8a:	6281      	str	r1, [r0, #40]	@ 0x28
      wDeltaError = wProcessVarError - pHandle->wPrevProcessVarError;
 8008b8c:	1b0c      	subs	r4, r1, r4
      wDifferential_Term = pHandle->hKdGain * wDeltaError;
 8008b8e:	fb02 f404 	mul.w	r4, r2, r4
      wDifferential_Term >>= pHandle->hKdDivisorPOW2;
 8008b92:	411c      	asrs	r4, r3
      wTemp_output = PI_Controller(pHandle, wProcessVarError) + wDifferential_Term;
 8008b94:	4605      	mov	r5, r0
 8008b96:	f7ff ffaf 	bl	8008af8 <PI_Controller>
 8008b9a:	4603      	mov	r3, r0
      if (wTemp_output > pHandle->hUpperOutputLimit)
 8008b9c:	f9b5 0014 	ldrsh.w	r0, [r5, #20]
      wTemp_output = PI_Controller(pHandle, wProcessVarError) + wDifferential_Term;
 8008ba0:	4423      	add	r3, r4
      if (wTemp_output > pHandle->hUpperOutputLimit)
 8008ba2:	4298      	cmp	r0, r3
 8008ba4:	dbee      	blt.n	8008b84 <PID_Controller+0xc>
      else if (wTemp_output < pHandle->hLowerOutputLimit)
 8008ba6:	f9b5 0016 	ldrsh.w	r0, [r5, #22]
    returnValue = (int16_t) wTemp_output;
 8008baa:	4298      	cmp	r0, r3
 8008bac:	bfb8      	it	lt
 8008bae:	4618      	movlt	r0, r3
 8008bb0:	b200      	sxth	r0, r0
}
 8008bb2:	bd38      	pop	{r3, r4, r5, pc}

08008bb4 <PQD_CalcElMotorPower>:
  }
  else
  {
#endif
    int32_t wAux;
    qd_t Iqd = pHandle->pFOCVars->Iqd;
 8008bb4:	6882      	ldr	r2, [r0, #8]
{
 8008bb6:	b500      	push	{lr}
    qd_t Vqd = pHandle->pFOCVars->Vqd;

    wAux = ((int32_t)Iqd.q * (int32_t)Vqd.q)
         + ((int32_t)Iqd.d * (int32_t)Vqd.d);
 8008bb8:	89d1      	ldrh	r1, [r2, #14]
 8008bba:	f8b2 e018 	ldrh.w	lr, [r2, #24]
    wAux = ((int32_t)Iqd.q * (int32_t)Vqd.q)
 8008bbe:	8993      	ldrh	r3, [r2, #12]
 8008bc0:	f8b2 c016 	ldrh.w	ip, [r2, #22]
         + ((int32_t)Iqd.d * (int32_t)Vqd.d);
 8008bc4:	fb11 f20e 	smulbb	r2, r1, lr
    wAux /= 65536;
 8008bc8:	fb13 230c 	smlabb	r3, r3, ip, r2
 8008bcc:	2b00      	cmp	r3, #0

    /* pHandle->hAvrgElMotorPower += (wAux - pHandle->hAvrgElMotorPower) >> 4 */
    pHandle->hAvrgElMotorPower += (int16_t)((wAux - (int32_t)pHandle->hAvrgElMotorPower) / 16);
 8008bce:	f9b0 2000 	ldrsh.w	r2, [r0]
    wAux /= 65536;
 8008bd2:	bfbc      	itt	lt
 8008bd4:	f503 437f 	addlt.w	r3, r3, #65280	@ 0xff00
 8008bd8:	33ff      	addlt	r3, #255	@ 0xff
    pHandle->hAvrgElMotorPower += (int16_t)((wAux - (int32_t)pHandle->hAvrgElMotorPower) / 16);
 8008bda:	ebd2 4323 	rsbs	r3, r2, r3, asr #16
 8008bde:	bf48      	it	mi
 8008be0:	330f      	addmi	r3, #15
 8008be2:	eb02 1223 	add.w	r2, r2, r3, asr #4
 8008be6:	8002      	strh	r2, [r0, #0]

#ifdef NULL_PTR_CHECK_PQD_MOT_POW_MEAS
  }
#endif
}
 8008be8:	f85d fb04 	ldr.w	pc, [sp], #4

08008bec <PQD_GetAvrgElMotorPowerW>:
  * 
  * @param pHandle pointer on the related component instance.
  * @retval float_t The average measured motor power expressed in Watts.
  */
__weak float_t PQD_GetAvrgElMotorPowerW(const PQD_MotorPowMeas_Handle_t *pHandle)
{
 8008bec:	b510      	push	{r4, lr}
  else
  {
#endif

  /* First perform an integer multiplication, then a float one. */
  PowerW = ((float_t)pHandle->hAvrgElMotorPower * (float_t)VBS_GetAvBusVoltage_V(pHandle->pVBS)) * pHandle->ConvFact;
 8008bee:	f9b0 3000 	ldrsh.w	r3, [r0]
 8008bf2:	ee07 3a90 	vmov	s15, r3
{
 8008bf6:	ed2d 8b02 	vpush	{d8}
 8008bfa:	4604      	mov	r4, r0
  PowerW = ((float_t)pHandle->hAvrgElMotorPower * (float_t)VBS_GetAvBusVoltage_V(pHandle->pVBS)) * pHandle->ConvFact;
 8008bfc:	68c0      	ldr	r0, [r0, #12]
 8008bfe:	eeb8 8ae7 	vcvt.f32.s32	s16, s15
 8008c02:	f7ff fb99 	bl	8008338 <VBS_GetAvBusVoltage_V>
 8008c06:	edd4 7a01 	vldr	s15, [r4, #4]
 8008c0a:	ee68 7a27 	vmul.f32	s15, s16, s15

#ifdef NULL_PTR_CHECK_PQD_MOT_POW_MEAS
  }
#endif
  return (PowerW);
}
 8008c0e:	ecbd 8b02 	vpop	{d8}
  PowerW = ((float_t)pHandle->hAvrgElMotorPower * (float_t)VBS_GetAvBusVoltage_V(pHandle->pVBS)) * pHandle->ConvFact;
 8008c12:	ee00 0a10 	vmov	s0, r0
 8008c16:	eeb8 0a40 	vcvt.f32.u32	s0, s0
}
 8008c1a:	ee27 0a80 	vmul.f32	s0, s15, s0
 8008c1e:	bd10      	pop	{r4, pc}

08008c20 <R3_1_GetPhaseCurrents>:
  * @brief  Computes and stores in the handler the latest converted motor phase currents in ab_t format.
  *
  */
__weak void R3_1_GetPhaseCurrents(PWMC_Handle_t *pHdl, ab_t *Iab)
{
  if (MC_NULL == Iab)
 8008c20:	b1c1      	cbz	r1, 8008c54 <R3_1_GetPhaseCurrents+0x34>

    PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl;  //cstat !MISRAC2012-Rule-11.3
#if defined (__ICCARM__)
  #pragma cstat_restore = "MISRAC2012-Rule-11.3"
#endif /* __ICCARM__ */
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8008c22:	f8d0 209c 	ldr.w	r2, [r0, #156]	@ 0x9c
{
 8008c26:	b470      	push	{r4, r5, r6}
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8008c28:	e9d2 3400 	ldrd	r3, r4, [r2]
    ADC_TypeDef * ADCx = pHandle->pParams_str->ADCx;
    uint8_t Sector;

    Sector = (uint8_t)pHandle->_Super.Sector;
    ADCDataReg1 = ADCx->JDR1;
 8008c2c:	f8d3 5080 	ldr.w	r5, [r3, #128]	@ 0x80
    ADCDataReg2 = ADCx->JDR2;
 8008c30:	f8d3 6084 	ldr.w	r6, [r3, #132]	@ 0x84
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 8008c34:	6863      	ldr	r3, [r4, #4]
    Sector = (uint8_t)pHandle->_Super.Sector;
 8008c36:	f890 207a 	ldrb.w	r2, [r0, #122]	@ 0x7a
 8008c3a:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
 8008c3e:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 8008c42:	6063      	str	r3, [r4, #4]

    /* disable ADC trigger source */
    /* LL_TIM_CC_DisableChannel(TIMx, LL_TIM_CHANNEL_CH4) */
    LL_TIM_SetTriggerOutput(TIMx, LL_TIM_TRGO_RESET);

    switch (Sector)
 8008c44:	2a05      	cmp	r2, #5
 8008c46:	f200 809e 	bhi.w	8008d86 <R3_1_GetPhaseCurrents+0x166>
 8008c4a:	e8df f002 	tbb	[pc, r2]
 8008c4e:	1f11      	.short	0x1f11
 8008c50:	1104041f 	.word	0x1104041f
 8008c54:	4770      	bx	lr
      case SECTOR_4:
      case SECTOR_5:
      {
        /* Current on Phase C is not accessible     */
        /* Ia = PhaseAOffset - ADC converted value) */
        Aux = (int32_t)(pHandle->PhaseAOffset) - (int32_t)(ADCDataReg1);
 8008c56:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88

        /* Saturation of Ia */
        if (Aux < -INT16_MAX)
 8008c5a:	4a4e      	ldr	r2, [pc, #312]	@ (8008d94 <R3_1_GetPhaseCurrents+0x174>)
        Aux = (int32_t)(pHandle->PhaseAOffset) - (int32_t)(ADCDataReg1);
 8008c5c:	1b5b      	subs	r3, r3, r5
        if (Aux < -INT16_MAX)
 8008c5e:	4293      	cmp	r3, r2
 8008c60:	db22      	blt.n	8008ca8 <R3_1_GetPhaseCurrents+0x88>
        {
          Iab->a = -INT16_MAX;
        }
        else  if (Aux > INT16_MAX)
 8008c62:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 8008c66:	f2c0 808b 	blt.w	8008d80 <R3_1_GetPhaseCurrents+0x160>
 8008c6a:	f647 7cff 	movw	ip, #32767	@ 0x7fff
 8008c6e:	e01c      	b.n	8008caa <R3_1_GetPhaseCurrents+0x8a>
      case SECTOR_6:
      case SECTOR_1:
      {
        /* Current on Phase A is not accessible     */
        /* Ib = PhaseBOffset - ADC converted value) */
        Aux = (int32_t)(pHandle->PhaseBOffset) - (int32_t)(ADCDataReg1);
 8008c70:	f8d0 408c 	ldr.w	r4, [r0, #140]	@ 0x8c

        /* Saturation of Ib */
        if (Aux < -INT16_MAX)
 8008c74:	4b47      	ldr	r3, [pc, #284]	@ (8008d94 <R3_1_GetPhaseCurrents+0x174>)
        Aux = (int32_t)(pHandle->PhaseBOffset) - (int32_t)(ADCDataReg1);
 8008c76:	1b64      	subs	r4, r4, r5
        if (Aux < -INT16_MAX)
 8008c78:	429c      	cmp	r4, r3
 8008c7a:	db2d      	blt.n	8008cd8 <R3_1_GetPhaseCurrents+0xb8>
        {
          Iab->b = -INT16_MAX;
        }
        else  if (Aux > INT16_MAX)
 8008c7c:	f5b4 4f00 	cmp.w	r4, #32768	@ 0x8000
 8008c80:	db7b      	blt.n	8008d7a <R3_1_GetPhaseCurrents+0x15a>
 8008c82:	f647 72ff 	movw	r2, #32767	@ 0x7fff
 8008c86:	4614      	mov	r4, r2
 8008c88:	4615      	mov	r5, r2
 8008c8a:	e029      	b.n	8008ce0 <R3_1_GetPhaseCurrents+0xc0>
      case SECTOR_2:
      case SECTOR_3:
      {
        /* Current on Phase B is not accessible     */
        /* Ia = PhaseAOffset - ADC converted value) */
        Aux = (int32_t)(pHandle->PhaseAOffset) - (int32_t)(ADCDataReg1);
 8008c8c:	f8d0 4088 	ldr.w	r4, [r0, #136]	@ 0x88

        /* Saturation of Ia */
        if (Aux < -INT16_MAX)
 8008c90:	4b40      	ldr	r3, [pc, #256]	@ (8008d94 <R3_1_GetPhaseCurrents+0x174>)
        Aux = (int32_t)(pHandle->PhaseAOffset) - (int32_t)(ADCDataReg1);
 8008c92:	1b64      	subs	r4, r4, r5
        if (Aux < -INT16_MAX)
 8008c94:	429c      	cmp	r4, r3
 8008c96:	db30      	blt.n	8008cfa <R3_1_GetPhaseCurrents+0xda>
        {
          Iab->a = -INT16_MAX;
        }
        else  if (Aux > INT16_MAX)
 8008c98:	f5b4 4f00 	cmp.w	r4, #32768	@ 0x8000
 8008c9c:	db69      	blt.n	8008d72 <R3_1_GetPhaseCurrents+0x152>
 8008c9e:	f647 73ff 	movw	r3, #32767	@ 0x7fff
 8008ca2:	461c      	mov	r4, r3
 8008ca4:	469c      	mov	ip, r3
 8008ca6:	e02c      	b.n	8008d02 <R3_1_GetPhaseCurrents+0xe2>
 8008ca8:	4694      	mov	ip, r2
        Aux = (int32_t)(pHandle->PhaseBOffset) - (int32_t)(ADCDataReg2);
 8008caa:	f8d0 208c 	ldr.w	r2, [r0, #140]	@ 0x8c
        if (Aux < -INT16_MAX)
 8008cae:	4d39      	ldr	r5, [pc, #228]	@ (8008d94 <R3_1_GetPhaseCurrents+0x174>)
          Iab->a = -INT16_MAX;
 8008cb0:	f8a1 c000 	strh.w	ip, [r1]
        Aux = (int32_t)(pHandle->PhaseBOffset) - (int32_t)(ADCDataReg2);
 8008cb4:	1b92      	subs	r2, r2, r6
        if (Aux < -INT16_MAX)
 8008cb6:	42aa      	cmp	r2, r5
 8008cb8:	da31      	bge.n	8008d1e <R3_1_GetPhaseCurrents+0xfe>
          Iab->b = -INT16_MAX;
 8008cba:	804d      	strh	r5, [r1, #2]
        break;
    }

    pHandle->_Super.Ia = Iab->a;
    pHandle->_Super.Ib = Iab->b;
    pHandle->_Super.Ic = -Iab->a - Iab->b;
 8008cbc:	fa1f f38c 	uxth.w	r3, ip
 8008cc0:	f248 0201 	movw	r2, #32769	@ 0x8001
 8008cc4:	4413      	add	r3, r2
 8008cc6:	425b      	negs	r3, r3
    pHandle->_Super.Ib = Iab->b;
 8008cc8:	f8a0 5064 	strh.w	r5, [r0, #100]	@ 0x64
    pHandle->_Super.Ia = Iab->a;
 8008ccc:	f8a0 c062 	strh.w	ip, [r0, #98]	@ 0x62
  }
}
 8008cd0:	bc70      	pop	{r4, r5, r6}
    pHandle->_Super.Ic = -Iab->a - Iab->b;
 8008cd2:	f8a0 3066 	strh.w	r3, [r0, #102]	@ 0x66
}
 8008cd6:	4770      	bx	lr
 8008cd8:	461c      	mov	r4, r3
 8008cda:	f248 0201 	movw	r2, #32769	@ 0x8001
 8008cde:	461d      	mov	r5, r3
        Aux = (int32_t)(ADCDataReg2) - (int32_t)(pHandle->PhaseCOffset); /* -Ic */
 8008ce0:	f8d0 3090 	ldr.w	r3, [r0, #144]	@ 0x90
          Iab->b = -INT16_MAX;
 8008ce4:	804d      	strh	r5, [r1, #2]
        Aux = (int32_t)(ADCDataReg2) - (int32_t)(pHandle->PhaseCOffset); /* -Ic */
 8008ce6:	1af3      	subs	r3, r6, r3
        Aux -= (int32_t)Iab->b;             /* Ia  */
 8008ce8:	1b1b      	subs	r3, r3, r4
        if (Aux > INT16_MAX)
 8008cea:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 8008cee:	db21      	blt.n	8008d34 <R3_1_GetPhaseCurrents+0x114>
          Iab->a = INT16_MAX;
 8008cf0:	f647 73ff 	movw	r3, #32767	@ 0x7fff
 8008cf4:	800b      	strh	r3, [r1, #0]
 8008cf6:	469c      	mov	ip, r3
 8008cf8:	e7e4      	b.n	8008cc4 <R3_1_GetPhaseCurrents+0xa4>
 8008cfa:	461c      	mov	r4, r3
 8008cfc:	46a4      	mov	ip, r4
 8008cfe:	f248 0301 	movw	r3, #32769	@ 0x8001
        Aux = (int32_t)(ADCDataReg2) - (int32_t)(pHandle->PhaseCOffset); /* -Ic */
 8008d02:	f8d0 2090 	ldr.w	r2, [r0, #144]	@ 0x90
          Iab->a = -INT16_MAX;
 8008d06:	f8a1 c000 	strh.w	ip, [r1]
        Aux = (int32_t)(ADCDataReg2) - (int32_t)(pHandle->PhaseCOffset); /* -Ic */
 8008d0a:	1ab2      	subs	r2, r6, r2
        Aux -= (int32_t)Iab->a;             /* Ib */
 8008d0c:	1b12      	subs	r2, r2, r4
        if (Aux > INT16_MAX)
 8008d0e:	f5b2 4f00 	cmp.w	r2, #32768	@ 0x8000
 8008d12:	db17      	blt.n	8008d44 <R3_1_GetPhaseCurrents+0x124>
          Iab->b = INT16_MAX;
 8008d14:	f647 72ff 	movw	r2, #32767	@ 0x7fff
 8008d18:	804a      	strh	r2, [r1, #2]
 8008d1a:	4615      	mov	r5, r2
 8008d1c:	e7d2      	b.n	8008cc4 <R3_1_GetPhaseCurrents+0xa4>
        else  if (Aux > INT16_MAX)
 8008d1e:	f5b2 4f00 	cmp.w	r2, #32768	@ 0x8000
 8008d22:	db20      	blt.n	8008d66 <R3_1_GetPhaseCurrents+0x146>
          Iab->b = INT16_MAX;
 8008d24:	f647 73ff 	movw	r3, #32767	@ 0x7fff
 8008d28:	461a      	mov	r2, r3
 8008d2a:	804b      	strh	r3, [r1, #2]
 8008d2c:	4615      	mov	r5, r2
    pHandle->_Super.Ic = -Iab->a - Iab->b;
 8008d2e:	fa1f f38c 	uxth.w	r3, ip
 8008d32:	e7c7      	b.n	8008cc4 <R3_1_GetPhaseCurrents+0xa4>
        else  if (Aux < -INT16_MAX)
 8008d34:	4c17      	ldr	r4, [pc, #92]	@ (8008d94 <R3_1_GetPhaseCurrents+0x174>)
 8008d36:	42a3      	cmp	r3, r4
 8008d38:	da0f      	bge.n	8008d5a <R3_1_GetPhaseCurrents+0x13a>
          Iab->a = -INT16_MAX;
 8008d3a:	800c      	strh	r4, [r1, #0]
 8008d3c:	f248 0301 	movw	r3, #32769	@ 0x8001
 8008d40:	46a4      	mov	ip, r4
 8008d42:	e7bf      	b.n	8008cc4 <R3_1_GetPhaseCurrents+0xa4>
        else  if (Aux < -INT16_MAX)
 8008d44:	4d13      	ldr	r5, [pc, #76]	@ (8008d94 <R3_1_GetPhaseCurrents+0x174>)
 8008d46:	42aa      	cmp	r2, r5
 8008d48:	da03      	bge.n	8008d52 <R3_1_GetPhaseCurrents+0x132>
          Iab->b = -INT16_MAX;
 8008d4a:	804d      	strh	r5, [r1, #2]
 8008d4c:	f248 0201 	movw	r2, #32769	@ 0x8001
 8008d50:	e7b8      	b.n	8008cc4 <R3_1_GetPhaseCurrents+0xa4>
          Iab->b = (int16_t)Aux;
 8008d52:	b215      	sxth	r5, r2
 8008d54:	804d      	strh	r5, [r1, #2]
    pHandle->_Super.Ic = -Iab->a - Iab->b;
 8008d56:	b292      	uxth	r2, r2
 8008d58:	e7b4      	b.n	8008cc4 <R3_1_GetPhaseCurrents+0xa4>
          Iab->a = (int16_t)Aux;
 8008d5a:	fa0f fc83 	sxth.w	ip, r3
 8008d5e:	f8a1 c000 	strh.w	ip, [r1]
    pHandle->_Super.Ic = -Iab->a - Iab->b;
 8008d62:	b29b      	uxth	r3, r3
 8008d64:	e7ae      	b.n	8008cc4 <R3_1_GetPhaseCurrents+0xa4>
          Iab->b = (int16_t)Aux;
 8008d66:	b215      	sxth	r5, r2
 8008d68:	804d      	strh	r5, [r1, #2]
    pHandle->_Super.Ic = -Iab->a - Iab->b;
 8008d6a:	fa1f f38c 	uxth.w	r3, ip
 8008d6e:	b292      	uxth	r2, r2
 8008d70:	e7a8      	b.n	8008cc4 <R3_1_GetPhaseCurrents+0xa4>
          Iab->a = (int16_t)Aux;
 8008d72:	fa0f fc84 	sxth.w	ip, r4
    pHandle->_Super.Ic = -Iab->a - Iab->b;
 8008d76:	b2a3      	uxth	r3, r4
 8008d78:	e7c3      	b.n	8008d02 <R3_1_GetPhaseCurrents+0xe2>
          Iab->b = (int16_t)Aux;
 8008d7a:	b225      	sxth	r5, r4
    pHandle->_Super.Ic = -Iab->a - Iab->b;
 8008d7c:	b2a2      	uxth	r2, r4
 8008d7e:	e7af      	b.n	8008ce0 <R3_1_GetPhaseCurrents+0xc0>
          Iab->a = (int16_t)Aux;
 8008d80:	fa0f fc83 	sxth.w	ip, r3
 8008d84:	e791      	b.n	8008caa <R3_1_GetPhaseCurrents+0x8a>
    pHandle->_Super.Ia = Iab->a;
 8008d86:	f9b1 c000 	ldrsh.w	ip, [r1]
    pHandle->_Super.Ib = Iab->b;
 8008d8a:	f9b1 5002 	ldrsh.w	r5, [r1, #2]
    pHandle->_Super.Ic = -Iab->a - Iab->b;
 8008d8e:	880b      	ldrh	r3, [r1, #0]
 8008d90:	884a      	ldrh	r2, [r1, #2]
 8008d92:	e797      	b.n	8008cc4 <R3_1_GetPhaseCurrents+0xa4>
 8008d94:	ffff8001 	.word	0xffff8001

08008d98 <R3_1_SetADCSampPointPolarization>:
  *
  * @param  pHdl: Handler of the current instance of the PWM component.
  * @retval uint16_t Returns the return value of R3_1_WriteTIMRegisters.
  */
uint16_t R3_1_SetADCSampPointPolarization(PWMC_Handle_t *pHdl)
{
 8008d98:	b410      	push	{r4}
#endif /* __ICCARM__ */
  PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
#if defined (__ICCARM__)
  #pragma cstat_restore = "MISRAC2012-Rule-11.3"
#endif /* __ICCARM__ */
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8008d9a:	f8d0 309c 	ldr.w	r3, [r0, #156]	@ 0x9c
  pHandle->_Super.Sector = pHandle->PolarizationSector;
 8008d9e:	f890 4099 	ldrb.w	r4, [r0, #153]	@ 0x99
 8008da2:	f880 407a 	strb.w	r4, [r0, #122]	@ 0x7a
  return R3_1_WriteTIMRegisters(&pHandle->_Super, (pHandle->Half_PWMPeriod - (uint16_t)1));
 8008da6:	f8b0 2094 	ldrh.w	r2, [r0, #148]	@ 0x94
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8008daa:	685b      	ldr	r3, [r3, #4]
  uint16_t Aux;


  LL_TIM_OC_SetCompareCH1(TIMx, (uint32_t) pHandle->_Super.CntPhA);
 8008dac:	f8b0 4050 	ldrh.w	r4, [r0, #80]	@ 0x50
  WRITE_REG(TIMx->CCR1, CompareValue);
 8008db0:	635c      	str	r4, [r3, #52]	@ 0x34
  return R3_1_WriteTIMRegisters(&pHandle->_Super, (pHandle->Half_PWMPeriod - (uint16_t)1));
 8008db2:	3a01      	subs	r2, #1
  LL_TIM_OC_SetCompareCH2(TIMx, (uint32_t) pHandle->_Super.CntPhB);
 8008db4:	f8b0 4052 	ldrh.w	r4, [r0, #82]	@ 0x52
  LL_TIM_OC_SetCompareCH3(TIMx, (uint32_t) pHandle->_Super.CntPhC);
 8008db8:	f8b0 0054 	ldrh.w	r0, [r0, #84]	@ 0x54
  WRITE_REG(TIMx->CCR2, CompareValue);
 8008dbc:	639c      	str	r4, [r3, #56]	@ 0x38
  return R3_1_WriteTIMRegisters(&pHandle->_Super, (pHandle->Half_PWMPeriod - (uint16_t)1));
 8008dbe:	b292      	uxth	r2, r2
  WRITE_REG(TIMx->CCR3, CompareValue);
 8008dc0:	63d8      	str	r0, [r3, #60]	@ 0x3c
  WRITE_REG(TIMx->CCR4, CompareValue);
 8008dc2:	641a      	str	r2, [r3, #64]	@ 0x40
  LL_TIM_OC_SetCompareCH4(TIMx, (uint32_t) SamplingPoint);

  /* Limit for update event */

//  if ( LL_TIM_CC_IsEnabledChannel(TIMx, LL_TIM_CHANNEL_CH4) == 1u )
  if (((TIMx->CR2) & TIM_CR2_MMS_Msk) != LL_TIM_TRGO_RESET)
 8008dc4:	4904      	ldr	r1, [pc, #16]	@ (8008dd8 <R3_1_SetADCSampPointPolarization+0x40>)
 8008dc6:	685b      	ldr	r3, [r3, #4]
}
 8008dc8:	f85d 4b04 	ldr.w	r4, [sp], #4
  if (((TIMx->CR2) & TIM_CR2_MMS_Msk) != LL_TIM_TRGO_RESET)
 8008dcc:	420b      	tst	r3, r1
}
 8008dce:	bf14      	ite	ne
 8008dd0:	2001      	movne	r0, #1
 8008dd2:	2000      	moveq	r0, #0
 8008dd4:	4770      	bx	lr
 8008dd6:	bf00      	nop
 8008dd8:	02000070 	.word	0x02000070

08008ddc <R3_1_HFCurrentsPolarizationAB>:
  * @param  Iab: Pointer to the structure that will receive motor current
  *         of phase A and B in ab_t format.
  */
static void R3_1_HFCurrentsPolarizationAB(PWMC_Handle_t *pHdl, ab_t *Iab)
{
  if (MC_NULL == Iab)
 8008ddc:	b321      	cbz	r1, 8008e28 <R3_1_HFCurrentsPolarizationAB+0x4c>
#endif /* __ICCARM__ */
    PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
#if defined (__ICCARM__)
  #pragma cstat_restore = "MISRAC2012-Rule-11.3"
#endif /* __ICCARM__ */
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8008dde:	f8d0 209c 	ldr.w	r2, [r0, #156]	@ 0x9c
 8008de2:	e9d2 3200 	ldrd	r3, r2, [r2]
{
 8008de6:	b430      	push	{r4, r5}
    ADC_TypeDef * ADCx = pHandle->pParams_str->ADCx;
    uint32_t ADCDataReg1 = ADCx->JDR1;
 8008de8:	f8d3 4080 	ldr.w	r4, [r3, #128]	@ 0x80
    uint32_t ADCDataReg2 = ADCx->JDR2;
 8008dec:	f8d3 5084 	ldr.w	r5, [r3, #132]	@ 0x84
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 8008df0:	6853      	ldr	r3, [r2, #4]
 8008df2:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
 8008df6:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 8008dfa:	6053      	str	r3, [r2, #4]

    /* disable ADC trigger source */
    /* LL_TIM_CC_DisableChannel(TIMx, LL_TIM_CHANNEL_CH4) */
    LL_TIM_SetTriggerOutput(TIMx, LL_TIM_TRGO_RESET);

    if (pHandle->PolarizationCounter < NB_CONVERSIONS)
 8008dfc:	f890 3098 	ldrb.w	r3, [r0, #152]	@ 0x98
 8008e00:	2b0f      	cmp	r3, #15
 8008e02:	d80d      	bhi.n	8008e20 <R3_1_HFCurrentsPolarizationAB+0x44>
    {
      pHandle-> PhaseAOffset += ADCDataReg1;
 8008e04:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
      pHandle-> PhaseBOffset += ADCDataReg2;
 8008e08:	f8d0 208c 	ldr.w	r2, [r0, #140]	@ 0x8c
      pHandle-> PhaseAOffset += ADCDataReg1;
 8008e0c:	441c      	add	r4, r3
      pHandle->PolarizationCounter++;
 8008e0e:	f890 3098 	ldrb.w	r3, [r0, #152]	@ 0x98
      pHandle-> PhaseBOffset += ADCDataReg2;
 8008e12:	442a      	add	r2, r5
      pHandle->PolarizationCounter++;
 8008e14:	3301      	adds	r3, #1
      pHandle-> PhaseBOffset += ADCDataReg2;
 8008e16:	e9c0 4222 	strd	r4, r2, [r0, #136]	@ 0x88
      pHandle->PolarizationCounter++;
 8008e1a:	b2db      	uxtb	r3, r3
 8008e1c:	f880 3098 	strb.w	r3, [r0, #152]	@ 0x98
    {
      /* Nothing to do */
    }

    /* during offset calibration no current is flowing in the phases */
    Iab->a = 0;
 8008e20:	2300      	movs	r3, #0
    Iab->b = 0;
  }
}
 8008e22:	bc30      	pop	{r4, r5}
    Iab->a = 0;
 8008e24:	600b      	str	r3, [r1, #0]
}
 8008e26:	4770      	bx	lr
 8008e28:	4770      	bx	lr
 8008e2a:	bf00      	nop

08008e2c <R3_1_HFCurrentsPolarizationC>:
  *                Min value: 0 (low sides ON)
  *                Max value: PWM_PERIOD_CYCLES/2 (low sides OFF)
  */
static void R3_1_HFCurrentsPolarizationC(PWMC_Handle_t *pHdl, ab_t *Iab)
{
  if (MC_NULL == Iab)
 8008e2c:	b301      	cbz	r1, 8008e70 <R3_1_HFCurrentsPolarizationC+0x44>
#endif /* __ICCARM__ */
    PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
#if defined (__ICCARM__)
  #pragma cstat_restore = "MISRAC2012-Rule-11.3"
#endif /* __ICCARM__ */
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8008e2e:	f8d0 309c 	ldr.w	r3, [r0, #156]	@ 0x9c
    ADC_TypeDef * ADCx = pHandle->pParams_str->ADCx;
 8008e32:	e9d3 3200 	ldrd	r3, r2, [r3]
{
 8008e36:	b410      	push	{r4}
    uint32_t ADCDataReg2 = ADCx->JDR2;
 8008e38:	f8d3 4084 	ldr.w	r4, [r3, #132]	@ 0x84
 8008e3c:	6853      	ldr	r3, [r2, #4]
 8008e3e:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
 8008e42:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 8008e46:	6053      	str	r3, [r2, #4]

    /* disable ADC trigger source */
    /* LL_TIM_CC_DisableChannel(TIMx, LL_TIM_CHANNEL_CH4) */
    LL_TIM_SetTriggerOutput(TIMx, LL_TIM_TRGO_RESET);

    if (pHandle->PolarizationCounter < NB_CONVERSIONS)
 8008e48:	f890 3098 	ldrb.w	r3, [r0, #152]	@ 0x98
 8008e4c:	2b0f      	cmp	r3, #15
 8008e4e:	d80a      	bhi.n	8008e66 <R3_1_HFCurrentsPolarizationC+0x3a>
    {
      /* Phase C is read from SECTOR_1, second value */
      pHandle-> PhaseCOffset += ADCDataReg2;
      pHandle->PolarizationCounter++;
 8008e50:	f890 3098 	ldrb.w	r3, [r0, #152]	@ 0x98
      pHandle-> PhaseCOffset += ADCDataReg2;
 8008e54:	f8d0 2090 	ldr.w	r2, [r0, #144]	@ 0x90
      pHandle->PolarizationCounter++;
 8008e58:	3301      	adds	r3, #1
      pHandle-> PhaseCOffset += ADCDataReg2;
 8008e5a:	4422      	add	r2, r4
      pHandle->PolarizationCounter++;
 8008e5c:	b2db      	uxtb	r3, r3
      pHandle-> PhaseCOffset += ADCDataReg2;
 8008e5e:	f8c0 2090 	str.w	r2, [r0, #144]	@ 0x90
      pHandle->PolarizationCounter++;
 8008e62:	f880 3098 	strb.w	r3, [r0, #152]	@ 0x98
    {
      /* Nothing to do */
    }

    /* during offset calibration no current is flowing in the phases */
    Iab->a = 0;
 8008e66:	2300      	movs	r3, #0
    Iab->b = 0;
  }
}
 8008e68:	f85d 4b04 	ldr.w	r4, [sp], #4
    Iab->a = 0;
 8008e6c:	600b      	str	r3, [r1, #0]
}
 8008e6e:	4770      	bx	lr
 8008e70:	4770      	bx	lr
 8008e72:	bf00      	nop

08008e74 <R3_1_SwitchOnPWM>:
#endif /* __ICCARM__ */
  PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
#if defined (__ICCARM__)
  #pragma cstat_restore = "MISRAC2012-Rule-11.3"
#endif /* __ICCARM__ */
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8008e74:	f8d0 309c 	ldr.w	r3, [r0, #156]	@ 0x9c
  pHandle->ADCRegularLocked = true;

  pHandle->_Super.TurnOnLowSidesAction = false;

  /* Set all duty to 50% */
  LL_TIM_OC_SetCompareCH1(TIMx, ((uint32_t)pHandle->Half_PWMPeriod / (uint32_t)2));
 8008e78:	f8b0 2094 	ldrh.w	r2, [r0, #148]	@ 0x94
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8008e7c:	685b      	ldr	r3, [r3, #4]
  pHandle->ADCRegularLocked = true;
 8008e7e:	f04f 0c01 	mov.w	ip, #1
{
 8008e82:	b5f0      	push	{r4, r5, r6, r7, lr}
  LL_TIM_OC_SetCompareCH1(TIMx, ((uint32_t)pHandle->Half_PWMPeriod / (uint32_t)2));
 8008e84:	fa22 f10c 	lsr.w	r1, r2, ip
  pHandle->_Super.TurnOnLowSidesAction = false;
 8008e88:	f04f 0e00 	mov.w	lr, #0
 8008e8c:	f880 e07c 	strb.w	lr, [r0, #124]	@ 0x7c
  pHandle->ADCRegularLocked = true;
 8008e90:	f880 c0a0 	strb.w	ip, [r0, #160]	@ 0xa0
  LL_TIM_OC_SetCompareCH2(TIMx, ((uint32_t)pHandle->Half_PWMPeriod / (uint32_t)2));
  LL_TIM_OC_SetCompareCH3(TIMx, ((uint32_t)pHandle->Half_PWMPeriod / (uint32_t)2));
  LL_TIM_OC_SetCompareCH4(TIMx, ((uint32_t)pHandle->Half_PWMPeriod - (uint32_t)5));
 8008e94:	3a05      	subs	r2, #5
  WRITE_REG(TIMx->CCR1, CompareValue);
 8008e96:	6359      	str	r1, [r3, #52]	@ 0x34
  WRITE_REG(TIMx->CCR2, CompareValue);
 8008e98:	6399      	str	r1, [r3, #56]	@ 0x38
  WRITE_REG(TIMx->CCR3, CompareValue);
 8008e9a:	63d9      	str	r1, [r3, #60]	@ 0x3c
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8008e9c:	f06f 0101 	mvn.w	r1, #1
  WRITE_REG(TIMx->CCR4, CompareValue);
 8008ea0:	641a      	str	r2, [r3, #64]	@ 0x40
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8008ea2:	6119      	str	r1, [r3, #16]
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 8008ea4:	691a      	ldr	r2, [r3, #16]
 8008ea6:	07d2      	lsls	r2, r2, #31
 8008ea8:	d5fc      	bpl.n	8008ea4 <R3_1_SwitchOnPWM+0x30>
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8008eaa:	f06f 0201 	mvn.w	r2, #1
 8008eae:	611a      	str	r2, [r3, #16]
    /* Nothing to do */
  }
  LL_TIM_ClearFlag_UPDATE(TIMx);

  /* Main PWM Output Enable */
  TIMx->BDTR |= LL_TIM_OSSI_ENABLE;
 8008eb0:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8008eb2:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 8008eb6:	645a      	str	r2, [r3, #68]	@ 0x44
  SET_BIT(TIMx->BDTR, TIM_BDTR_MOE);
 8008eb8:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8008eba:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 8008ebe:	645a      	str	r2, [r3, #68]	@ 0x44
  LL_TIM_EnableAllOutputs(TIMx);

  if ((ES_GPIO == pHandle->_Super.LowSideOutputs))
 8008ec0:	f890 207b 	ldrb.w	r2, [r0, #123]	@ 0x7b
 8008ec4:	2a02      	cmp	r2, #2
 8008ec6:	d007      	beq.n	8008ed8 <R3_1_SwitchOnPWM+0x64>
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8008ec8:	f06f 0201 	mvn.w	r2, #1
 8008ecc:	611a      	str	r2, [r3, #16]
  SET_BIT(TIMx->DIER, TIM_DIER_UIE);
 8008ece:	68da      	ldr	r2, [r3, #12]
 8008ed0:	f042 0201 	orr.w	r2, r2, #1
 8008ed4:	60da      	str	r2, [r3, #12]
  }
  /* Clear Update Flag */
  LL_TIM_ClearFlag_UPDATE(TIMx);
  /* Enable Update IRQ */
  LL_TIM_EnableIT_UPDATE(TIMx);
}
 8008ed6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if ((TIMx->CCER & TIMxCCER_MASK_CH123) != 0U)
 8008ed8:	6a19      	ldr	r1, [r3, #32]
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_u_port, pHandle->_Super.pwm_en_u_pin);
 8008eda:	6bc7      	ldr	r7, [r0, #60]	@ 0x3c
 8008edc:	f8b0 c048 	ldrh.w	ip, [r0, #72]	@ 0x48
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 8008ee0:	6c05      	ldr	r5, [r0, #64]	@ 0x40
 8008ee2:	f8b0 604a 	ldrh.w	r6, [r0, #74]	@ 0x4a
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 8008ee6:	6c44      	ldr	r4, [r0, #68]	@ 0x44
 8008ee8:	f8b0 004c 	ldrh.w	r0, [r0, #76]	@ 0x4c
    if ((TIMx->CCER & TIMxCCER_MASK_CH123) != 0U)
 8008eec:	f240 5255 	movw	r2, #1365	@ 0x555
 8008ef0:	4211      	tst	r1, r2
 8008ef2:	d004      	beq.n	8008efe <R3_1_SwitchOnPWM+0x8a>
  WRITE_REG(GPIOx->BSRR, PinMask);
 8008ef4:	f8c7 c018 	str.w	ip, [r7, #24]
 8008ef8:	61ae      	str	r6, [r5, #24]
 8008efa:	61a0      	str	r0, [r4, #24]
}
 8008efc:	e7e4      	b.n	8008ec8 <R3_1_SwitchOnPWM+0x54>
  WRITE_REG(GPIOx->BRR, PinMask);
 8008efe:	f8c7 c028 	str.w	ip, [r7, #40]	@ 0x28
 8008f02:	62ae      	str	r6, [r5, #40]	@ 0x28
 8008f04:	62a0      	str	r0, [r4, #40]	@ 0x28
}
 8008f06:	e7df      	b.n	8008ec8 <R3_1_SwitchOnPWM+0x54>

08008f08 <R3_1_SwitchOffPWM>:
#endif /* __ICCARM__ */
  PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
#if defined (__ICCARM__)
  #pragma cstat_restore = "MISRAC2012-Rule-11.3"
#endif /* __ICCARM__ */
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8008f08:	f8d0 309c 	ldr.w	r3, [r0, #156]	@ 0x9c

  pHandle->_Super.TurnOnLowSidesAction = false;

  /* Main PWM Output Disable */
  LL_TIM_DisableAllOutputs(TIMx);
  if (true == pHandle->_Super.BrakeActionLock)
 8008f0c:	f890 1083 	ldrb.w	r1, [r0, #131]	@ 0x83
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8008f10:	685a      	ldr	r2, [r3, #4]
  CLEAR_BIT(TIMx->DIER, TIM_DIER_UIE);
 8008f12:	68d3      	ldr	r3, [r2, #12]
 8008f14:	f023 0301 	bic.w	r3, r3, #1
 8008f18:	60d3      	str	r3, [r2, #12]
  CLEAR_BIT(TIMx->BDTR, TIM_BDTR_MOE);
 8008f1a:	6c53      	ldr	r3, [r2, #68]	@ 0x44
  pHandle->_Super.TurnOnLowSidesAction = false;
 8008f1c:	f04f 0c00 	mov.w	ip, #0
 8008f20:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
 8008f24:	f880 c07c 	strb.w	ip, [r0, #124]	@ 0x7c
 8008f28:	6453      	str	r3, [r2, #68]	@ 0x44
  if (true == pHandle->_Super.BrakeActionLock)
 8008f2a:	b919      	cbnz	r1, 8008f34 <R3_1_SwitchOffPWM+0x2c>
  {
    /* Nothing to do */
  }
  else
  {
    if (ES_GPIO == pHandle->_Super.LowSideOutputs)
 8008f2c:	f890 307b 	ldrb.w	r3, [r0, #123]	@ 0x7b
 8008f30:	2b02      	cmp	r3, #2
 8008f32:	d00c      	beq.n	8008f4e <R3_1_SwitchOffPWM+0x46>
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8008f34:	f06f 0301 	mvn.w	r3, #1
 8008f38:	6113      	str	r3, [r2, #16]
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 8008f3a:	6913      	ldr	r3, [r2, #16]
 8008f3c:	07db      	lsls	r3, r3, #31
 8008f3e:	d5fc      	bpl.n	8008f3a <R3_1_SwitchOffPWM+0x32>
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8008f40:	f06f 0101 	mvn.w	r1, #1
    /* Nothing to do */
  }
  LL_TIM_ClearFlag_UPDATE(TIMx);

  /* We allow ADC usage for regular conversion on Systick*/
  pHandle->ADCRegularLocked = false;
 8008f44:	2300      	movs	r3, #0
 8008f46:	6111      	str	r1, [r2, #16]
 8008f48:	f880 30a0 	strb.w	r3, [r0, #160]	@ 0xa0
 8008f4c:	4770      	bx	lr
{
 8008f4e:	b430      	push	{r4, r5}
      LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 8008f50:	e9d0 410f 	ldrd	r4, r1, [r0, #60]	@ 0x3c
      LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_u_port, pHandle->_Super.pwm_en_u_pin);
 8008f54:	f8b0 5048 	ldrh.w	r5, [r0, #72]	@ 0x48
      LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 8008f58:	6c43      	ldr	r3, [r0, #68]	@ 0x44
  WRITE_REG(GPIOx->BRR, PinMask);
 8008f5a:	62a5      	str	r5, [r4, #40]	@ 0x28
      LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 8008f5c:	f8b0 404a 	ldrh.w	r4, [r0, #74]	@ 0x4a
 8008f60:	628c      	str	r4, [r1, #40]	@ 0x28
      LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 8008f62:	f8b0 104c 	ldrh.w	r1, [r0, #76]	@ 0x4c
 8008f66:	6299      	str	r1, [r3, #40]	@ 0x28
 8008f68:	f06f 0301 	mvn.w	r3, #1
 8008f6c:	6113      	str	r3, [r2, #16]
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 8008f6e:	6913      	ldr	r3, [r2, #16]
 8008f70:	07d9      	lsls	r1, r3, #31
 8008f72:	d5fc      	bpl.n	8008f6e <R3_1_SwitchOffPWM+0x66>
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8008f74:	f06f 0101 	mvn.w	r1, #1
  pHandle->ADCRegularLocked = false;
 8008f78:	2300      	movs	r3, #0
 8008f7a:	6111      	str	r1, [r2, #16]
}
 8008f7c:	bc30      	pop	{r4, r5}
  pHandle->ADCRegularLocked = false;
 8008f7e:	f880 30a0 	strb.w	r3, [r0, #160]	@ 0xa0
}
 8008f82:	4770      	bx	lr

08008f84 <R3_1_RLGetPhaseCurrents>:
  }
  else
  {
#endif
    PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8008f84:	f8d0 209c 	ldr.w	r2, [r0, #156]	@ 0x9c
    int32_t wAux;

    /* Disable ADC trigger source */
    LL_TIM_SetTriggerOutput(TIMx, LL_TIM_TRGO_RESET);

    wAux = ((int32_t)pHandle->PhaseBOffset)
 8008f88:	f8d0 308c 	ldr.w	r3, [r0, #140]	@ 0x8c
{
 8008f8c:	b410      	push	{r4}
    ADC_TypeDef *ADCx = pHandle->pParams_str->ADCx;
 8008f8e:	e9d2 4000 	ldrd	r4, r0, [r2]
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 8008f92:	6842      	ldr	r2, [r0, #4]
 8008f94:	f022 7200 	bic.w	r2, r2, #33554432	@ 0x2000000
 8008f98:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
 8008f9c:	6042      	str	r2, [r0, #4]
         - (int32_t)ADCx->JDR2;
 8008f9e:	f8d4 0084 	ldr.w	r0, [r4, #132]	@ 0x84
    else
    {
      wAux = -INT16_MAX;
    }

    pStator_Currents->a = (int16_t)wAux;
 8008fa2:	4a0a      	ldr	r2, [pc, #40]	@ (8008fcc <R3_1_RLGetPhaseCurrents+0x48>)
    pStator_Currents->b = (int16_t)wAux;
#ifdef NULL_PTR_CHECK_R3_1_PWM_CURR_FDB
  }
#endif
}
 8008fa4:	f85d 4b04 	ldr.w	r4, [sp], #4
    wAux = ((int32_t)pHandle->PhaseBOffset)
 8008fa8:	1a1b      	subs	r3, r3, r0
      if (wAux < INT16_MAX)
 8008faa:	f647 70ff 	movw	r0, #32767	@ 0x7fff
 8008fae:	4283      	cmp	r3, r0
 8008fb0:	bfa8      	it	ge
 8008fb2:	4603      	movge	r3, r0
    pStator_Currents->a = (int16_t)wAux;
 8008fb4:	4293      	cmp	r3, r2
 8008fb6:	bfb8      	it	lt
 8008fb8:	4613      	movlt	r3, r2
 8008fba:	b21b      	sxth	r3, r3
 8008fbc:	2200      	movs	r2, #0
 8008fbe:	f363 020f 	bfi	r2, r3, #0, #16
 8008fc2:	f363 421f 	bfi	r2, r3, #16, #16
 8008fc6:	600a      	str	r2, [r1, #0]
}
 8008fc8:	4770      	bx	lr
 8008fca:	bf00      	nop
 8008fcc:	ffff8001 	.word	0xffff8001

08008fd0 <R3_1_RLSwitchOnPWM>:
  }
  else
  {
#endif
    PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8008fd0:	f8d0 209c 	ldr.w	r2, [r0, #156]	@ 0x9c
    ADC_TypeDef *ADCx = pHandle->pParams_str->ADCx;
 8008fd4:	e9d2 1300 	ldrd	r1, r3, [r2]
{
 8008fd8:	b5f0      	push	{r4, r5, r6, r7, lr}
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8008fda:	f06f 0201 	mvn.w	r2, #1

    pHandle->ADCRegularLocked=true;
 8008fde:	2401      	movs	r4, #1
 8008fe0:	f880 40a0 	strb.w	r4, [r0, #160]	@ 0xa0
 8008fe4:	611a      	str	r2, [r3, #16]
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 8008fe6:	691a      	ldr	r2, [r3, #16]
 8008fe8:	07d4      	lsls	r4, r2, #31
 8008fea:	d5fc      	bpl.n	8008fe6 <R3_1_RLSwitchOnPWM+0x16>
    }
    /* Clear Update Flag */
    LL_TIM_ClearFlag_UPDATE(TIMx);

    LL_TIM_OC_SetCompareCH1(TIMx, 1U);
    LL_TIM_OC_SetCompareCH4(TIMx, ((uint32_t )pHandle->Half_PWMPeriod) - 5U);
 8008fec:	f8b0 2094 	ldrh.w	r2, [r0, #148]	@ 0x94
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8008ff0:	f06f 0401 	mvn.w	r4, #1
 8008ff4:	611c      	str	r4, [r3, #16]
 8008ff6:	3a05      	subs	r2, #5
  WRITE_REG(TIMx->CCR1, CompareValue);
 8008ff8:	2401      	movs	r4, #1
 8008ffa:	635c      	str	r4, [r3, #52]	@ 0x34
  WRITE_REG(TIMx->CCR4, CompareValue);
 8008ffc:	641a      	str	r2, [r3, #64]	@ 0x40
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 8008ffe:	691a      	ldr	r2, [r3, #16]
 8009000:	07d2      	lsls	r2, r2, #31
 8009002:	d5fc      	bpl.n	8008ffe <R3_1_RLSwitchOnPWM+0x2e>
  SET_BIT(TIMx->DIER, TIM_DIER_UIE);
 8009004:	68da      	ldr	r2, [r3, #12]
 8009006:	f042 0201 	orr.w	r2, r2, #1
 800900a:	60da      	str	r2, [r3, #12]

    /* Enable TIMx update interrupt */
    LL_TIM_EnableIT_UPDATE(TIMx);

    /* Main PWM Output Enable */
    TIMx->BDTR |= LL_TIM_OSSI_ENABLE ;
 800900c:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 800900e:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 8009012:	645a      	str	r2, [r3, #68]	@ 0x44
  SET_BIT(TIMx->BDTR, TIM_BDTR_MOE);
 8009014:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8009016:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 800901a:	645a      	str	r2, [r3, #68]	@ 0x44
    LL_TIM_EnableAllOutputs(TIMx);

    if (ES_GPIO ==  pHandle->_Super.LowSideOutputs)
 800901c:	f890 207b 	ldrb.w	r2, [r0, #123]	@ 0x7b
 8009020:	2a02      	cmp	r2, #2
 8009022:	d115      	bne.n	8009050 <R3_1_RLSwitchOnPWM+0x80>
    {
      if ((TIMx->CCER & TIMxCCER_MASK_CH123 ) != 0U)
 8009024:	6a1a      	ldr	r2, [r3, #32]
      {
        LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_u_port, pHandle->_Super.pwm_en_u_pin);
 8009026:	f8d0 c03c 	ldr.w	ip, [r0, #60]	@ 0x3c
        LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 800902a:	6c06      	ldr	r6, [r0, #64]	@ 0x40
        LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 800902c:	6c44      	ldr	r4, [r0, #68]	@ 0x44
        LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_u_port, pHandle->_Super.pwm_en_u_pin);
 800902e:	f8b0 e048 	ldrh.w	lr, [r0, #72]	@ 0x48
        LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 8009032:	f8b0 704a 	ldrh.w	r7, [r0, #74]	@ 0x4a
        LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 8009036:	f8b0 504c 	ldrh.w	r5, [r0, #76]	@ 0x4c
      if ((TIMx->CCER & TIMxCCER_MASK_CH123 ) != 0U)
 800903a:	f240 5355 	movw	r3, #1365	@ 0x555
 800903e:	421a      	tst	r2, r3
  WRITE_REG(GPIOx->BSRR, PinMask);
 8009040:	bf15      	itete	ne
 8009042:	f8cc e018 	strne.w	lr, [ip, #24]
  WRITE_REG(GPIOx->BRR, PinMask);
 8009046:	f8cc e028 	streq.w	lr, [ip, #40]	@ 0x28
  WRITE_REG(GPIOx->BSRR, PinMask);
 800904a:	61b7      	strne	r7, [r6, #24]
  WRITE_REG(GPIOx->BRR, PinMask);
 800904c:	62b7      	streq	r7, [r6, #40]	@ 0x28
 800904e:	62a5      	str	r5, [r4, #40]	@ 0x28
      /* Nothing to do */
    }

    /* Set the sector that correspond to Phase B and C sampling
     * B will be sampled by ADCx */
    pHdl->Sector = SECTOR_4;
 8009050:	2303      	movs	r3, #3
 8009052:	f880 307a 	strb.w	r3, [r0, #122]	@ 0x7a
  MODIFY_REG(ADCx->CR,
 8009056:	688b      	ldr	r3, [r1, #8]
 8009058:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 800905c:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
 8009060:	f043 0308 	orr.w	r3, r3, #8
 8009064:	608b      	str	r3, [r1, #8]
    LL_ADC_INJ_StartConversion(ADCx);

#ifdef NULL_PTR_CHECK_R3_1_PWM_CURR_FDB
  }
#endif
}
 8009066:	bdf0      	pop	{r4, r5, r6, r7, pc}

08009068 <R3_1_TurnOnLowSides>:
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009068:	f8d0 309c 	ldr.w	r3, [r0, #156]	@ 0x9c
 800906c:	685a      	ldr	r2, [r3, #4]
  pHandle->_Super.TurnOnLowSidesAction = true;
 800906e:	f04f 0c01 	mov.w	ip, #1
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8009072:	f06f 0301 	mvn.w	r3, #1
 8009076:	f880 c07c 	strb.w	ip, [r0, #124]	@ 0x7c
 800907a:	6113      	str	r3, [r2, #16]
  WRITE_REG(TIMx->CCR1, CompareValue);
 800907c:	6351      	str	r1, [r2, #52]	@ 0x34
  WRITE_REG(TIMx->CCR2, CompareValue);
 800907e:	6391      	str	r1, [r2, #56]	@ 0x38
  WRITE_REG(TIMx->CCR3, CompareValue);
 8009080:	63d1      	str	r1, [r2, #60]	@ 0x3c
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 8009082:	6913      	ldr	r3, [r2, #16]
 8009084:	07db      	lsls	r3, r3, #31
 8009086:	d5fc      	bpl.n	8009082 <R3_1_TurnOnLowSides+0x1a>
  SET_BIT(TIMx->BDTR, TIM_BDTR_MOE);
 8009088:	6c53      	ldr	r3, [r2, #68]	@ 0x44
 800908a:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 800908e:	6453      	str	r3, [r2, #68]	@ 0x44
  if ((ES_GPIO == pHandle->_Super.LowSideOutputs))
 8009090:	f890 307b 	ldrb.w	r3, [r0, #123]	@ 0x7b
 8009094:	2b02      	cmp	r3, #2
 8009096:	d000      	beq.n	800909a <R3_1_TurnOnLowSides+0x32>
 8009098:	4770      	bx	lr
    LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 800909a:	e9d0 210f 	ldrd	r2, r1, [r0, #60]	@ 0x3c
{
 800909e:	b410      	push	{r4}
    LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 80090a0:	6c43      	ldr	r3, [r0, #68]	@ 0x44
    LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_u_port, pHandle->_Super.pwm_en_u_pin);
 80090a2:	f8b0 4048 	ldrh.w	r4, [r0, #72]	@ 0x48
  WRITE_REG(GPIOx->BSRR, PinMask);
 80090a6:	6194      	str	r4, [r2, #24]
    LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 80090a8:	f8b0 404a 	ldrh.w	r4, [r0, #74]	@ 0x4a
    LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 80090ac:	f8b0 204c 	ldrh.w	r2, [r0, #76]	@ 0x4c
 80090b0:	618c      	str	r4, [r1, #24]
}
 80090b2:	f85d 4b04 	ldr.w	r4, [sp], #4
 80090b6:	619a      	str	r2, [r3, #24]
 80090b8:	4770      	bx	lr
 80090ba:	bf00      	nop

080090bc <R3_1_SetAOReferenceVoltage>:
  __IO uint32_t *preg = __DAC_PTR_REG_OFFSET(DACx->DHR12R1, (DAC_Channel >> DAC_REG_DHR12LX_REGOFFSET_BITOFFSET_POS)
 80090bc:	ea4f 4c90 	mov.w	ip, r0, lsr #18
{
 80090c0:	b510      	push	{r4, lr}
 80090c2:	f00c 0c3c 	and.w	ip, ip, #60	@ 0x3c
 80090c6:	f101 0e08 	add.w	lr, r1, #8
 80090ca:	b082      	sub	sp, #8
  MODIFY_REG(*preg, DAC_DHR12L1_DACC1DHR, Data);
 80090cc:	f85e 300c 	ldr.w	r3, [lr, ip]
 80090d0:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
 80090d4:	f023 03f0 	bic.w	r3, r3, #240	@ 0xf0
 80090d8:	4313      	orrs	r3, r2
 80090da:	f84e 300c 	str.w	r3, [lr, ip]
  SET_BIT(DACx->SWTRIGR,
 80090de:	684a      	ldr	r2, [r1, #4]
 80090e0:	f000 0303 	and.w	r3, r0, #3
 80090e4:	4313      	orrs	r3, r2
 80090e6:	604b      	str	r3, [r1, #4]
  return ((READ_BIT(DACx->CR,
 80090e8:	680a      	ldr	r2, [r1, #0]
 80090ea:	f000 0010 	and.w	r0, r0, #16
 80090ee:	2301      	movs	r3, #1
 80090f0:	4083      	lsls	r3, r0
           == (DAC_CR_EN1 << (DAC_Channel & DAC_CR_CHX_BITOFFSET_MASK))) ? 1UL : 0UL);
 80090f2:	ea33 0202 	bics.w	r2, r3, r2
 80090f6:	d014      	beq.n	8009122 <R3_1_SetAOReferenceVoltage+0x66>
                                         * (SystemCoreClock / (1000000UL * 2UL)));
 80090f8:	4a14      	ldr	r2, [pc, #80]	@ (800914c <R3_1_SetAOReferenceVoltage+0x90>)
 80090fa:	4815      	ldr	r0, [pc, #84]	@ (8009150 <R3_1_SetAOReferenceVoltage+0x94>)
 80090fc:	6812      	ldr	r2, [r2, #0]
  SET_BIT(DACx->CR,
 80090fe:	680c      	ldr	r4, [r1, #0]
 8009100:	fba0 0202 	umull	r0, r2, r0, r2
 8009104:	0cd2      	lsrs	r2, r2, #19
 8009106:	4323      	orrs	r3, r4
 8009108:	00d2      	lsls	r2, r2, #3
 800910a:	600b      	str	r3, [r1, #0]
    volatile uint32_t wait_loop_index = ((LL_DAC_DELAY_STARTUP_VOLTAGE_SETTLING_US)
 800910c:	9200      	str	r2, [sp, #0]
    while (wait_loop_index != 0UL)
 800910e:	9b00      	ldr	r3, [sp, #0]
 8009110:	b12b      	cbz	r3, 800911e <R3_1_SetAOReferenceVoltage+0x62>
      wait_loop_index--;
 8009112:	9b00      	ldr	r3, [sp, #0]
 8009114:	3b01      	subs	r3, #1
 8009116:	9300      	str	r3, [sp, #0]
    while (wait_loop_index != 0UL)
 8009118:	9b00      	ldr	r3, [sp, #0]
 800911a:	2b00      	cmp	r3, #0
 800911c:	d1f9      	bne.n	8009112 <R3_1_SetAOReferenceVoltage+0x56>
}
 800911e:	b002      	add	sp, #8
 8009120:	bd10      	pop	{r4, pc}
    volatile uint32_t wait_loop_index = ((LL_DAC_DELAY_VOLTAGE_SETTLING_US) * (SystemCoreClock / (1000000UL * 2UL)));
 8009122:	4b0a      	ldr	r3, [pc, #40]	@ (800914c <R3_1_SetAOReferenceVoltage+0x90>)
 8009124:	4a0a      	ldr	r2, [pc, #40]	@ (8009150 <R3_1_SetAOReferenceVoltage+0x94>)
 8009126:	681b      	ldr	r3, [r3, #0]
 8009128:	fba2 2303 	umull	r2, r3, r2, r3
 800912c:	0cdb      	lsrs	r3, r3, #19
 800912e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8009132:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 8009134:	9b01      	ldr	r3, [sp, #4]
 8009136:	2b00      	cmp	r3, #0
 8009138:	d0f1      	beq.n	800911e <R3_1_SetAOReferenceVoltage+0x62>
      wait_loop_index--;
 800913a:	9b01      	ldr	r3, [sp, #4]
 800913c:	3b01      	subs	r3, #1
 800913e:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 8009140:	9b01      	ldr	r3, [sp, #4]
 8009142:	2b00      	cmp	r3, #0
 8009144:	d1f9      	bne.n	800913a <R3_1_SetAOReferenceVoltage+0x7e>
}
 8009146:	b002      	add	sp, #8
 8009148:	bd10      	pop	{r4, pc}
 800914a:	bf00      	nop
 800914c:	20000474 	.word	0x20000474
 8009150:	431bde83 	.word	0x431bde83

08009154 <R3_1_RLTurnOnLowSides>:
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009154:	f8d0 309c 	ldr.w	r3, [r0, #156]	@ 0x9c
 8009158:	685a      	ldr	r2, [r3, #4]
  pHandle->ADCRegularLocked = true;
 800915a:	f04f 0c01 	mov.w	ip, #1
  WRITE_REG(TIMx->CCR1, CompareValue);
 800915e:	2100      	movs	r1, #0
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8009160:	f06f 0301 	mvn.w	r3, #1
 8009164:	f880 c0a0 	strb.w	ip, [r0, #160]	@ 0xa0
  WRITE_REG(TIMx->CCR1, CompareValue);
 8009168:	6351      	str	r1, [r2, #52]	@ 0x34
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 800916a:	6113      	str	r3, [r2, #16]
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 800916c:	6913      	ldr	r3, [r2, #16]
 800916e:	07db      	lsls	r3, r3, #31
 8009170:	d5fc      	bpl.n	800916c <R3_1_RLTurnOnLowSides+0x18>
  SET_BIT(TIMx->BDTR, TIM_BDTR_MOE);
 8009172:	6c53      	ldr	r3, [r2, #68]	@ 0x44
 8009174:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 8009178:	6453      	str	r3, [r2, #68]	@ 0x44
  if (ES_GPIO == pHandle->_Super.LowSideOutputs)
 800917a:	f890 307b 	ldrb.w	r3, [r0, #123]	@ 0x7b
 800917e:	2b02      	cmp	r3, #2
 8009180:	d000      	beq.n	8009184 <R3_1_RLTurnOnLowSides+0x30>
 8009182:	4770      	bx	lr
    LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 8009184:	e9d0 210f 	ldrd	r2, r1, [r0, #60]	@ 0x3c
{
 8009188:	b410      	push	{r4}
    LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 800918a:	6c43      	ldr	r3, [r0, #68]	@ 0x44
    LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_u_port, pHandle->_Super.pwm_en_u_pin);
 800918c:	f8b0 4048 	ldrh.w	r4, [r0, #72]	@ 0x48
 8009190:	6194      	str	r4, [r2, #24]
    LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 8009192:	f8b0 404a 	ldrh.w	r4, [r0, #74]	@ 0x4a
    LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 8009196:	f8b0 204c 	ldrh.w	r2, [r0, #76]	@ 0x4c
  WRITE_REG(GPIOx->BRR, PinMask);
 800919a:	628c      	str	r4, [r1, #40]	@ 0x28
}
 800919c:	f85d 4b04 	ldr.w	r4, [sp], #4
 80091a0:	629a      	str	r2, [r3, #40]	@ 0x28
 80091a2:	4770      	bx	lr

080091a4 <R3_1_Init>:
  if (MC_NULL == pHandle)
 80091a4:	2800      	cmp	r0, #0
 80091a6:	f000 8140 	beq.w	800942a <R3_1_Init+0x286>
{
 80091aa:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    R3_3_OPAMPParams_t *OPAMPParams = pHandle->pParams_str->OPAMPParams;
 80091ae:	f8d0 509c 	ldr.w	r5, [r0, #156]	@ 0x9c
    ADC_TypeDef *ADCx = pHandle->pParams_str->ADCx;
 80091b2:	682e      	ldr	r6, [r5, #0]
    DAC_TypeDef *DAC_OCPCx = pHandle->pParams_str->DAC_OCP_CSelection;
 80091b4:	6a6c      	ldr	r4, [r5, #36]	@ 0x24
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_EOC);
 80091b6:	6872      	ldr	r2, [r6, #4]
    COMP_TypeDef *COMP_OCPBx = pHandle->pParams_str->CompOCPBSelection;
 80091b8:	f8d5 a010 	ldr.w	sl, [r5, #16]
{
 80091bc:	b087      	sub	sp, #28
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_EOC);
 80091be:	f04f 0c04 	mov.w	ip, #4
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_EOC);
 80091c2:	f022 0204 	bic.w	r2, r2, #4
    DAC_TypeDef *DAC_OCPCx = pHandle->pParams_str->DAC_OCP_CSelection;
 80091c6:	9401      	str	r4, [sp, #4]
    DAC_TypeDef *DAC_OVPx = pHandle->pParams_str->DAC_OVP_Selection;
 80091c8:	6aac      	ldr	r4, [r5, #40]	@ 0x28
 80091ca:	9402      	str	r4, [sp, #8]
    COMP_TypeDef *COMP_OVPx = pHandle->pParams_str->CompOVPSelection;
 80091cc:	e9d5 9805 	ldrd	r9, r8, [r5, #20]
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 80091d0:	686c      	ldr	r4, [r5, #4]
    DAC_TypeDef *DAC_OCPBx = pHandle->pParams_str->DAC_OCP_BSelection;
 80091d2:	e9d5 1b07 	ldrd	r1, fp, [r5, #28]
 80091d6:	4607      	mov	r7, r0
    COMP_TypeDef *COMP_OCPAx = pHandle->pParams_str->CompOCPASelection;
 80091d8:	e9d5 0302 	ldrd	r0, r3, [r5, #8]
 80091dc:	6072      	str	r2, [r6, #4]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_EOC);
 80091de:	f8c6 c000 	str.w	ip, [r6]
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_JEOC);
 80091e2:	6872      	ldr	r2, [r6, #4]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_JEOC);
 80091e4:	f04f 0c20 	mov.w	ip, #32
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_JEOC);
 80091e8:	f022 0220 	bic.w	r2, r2, #32
 80091ec:	6072      	str	r2, [r6, #4]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_JEOC);
 80091ee:	f8c6 c000 	str.w	ip, [r6]
      if (TIM1 ==  TIMx)
 80091f2:	4aaa      	ldr	r2, [pc, #680]	@ (800949c <R3_1_Init+0x2f8>)
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_DBGMCU_APB2_GRP1_FreezePeriph(uint32_t Periphs)
{
  SET_BIT(DBGMCU->APB2FZ, Periphs);
 80091f4:	f8df c2b4 	ldr.w	ip, [pc, #692]	@ 80094ac <R3_1_Init+0x308>
 80091f8:	4294      	cmp	r4, r2
 80091fa:	f8dc 2010 	ldr.w	r2, [ip, #16]
 80091fe:	bf0c      	ite	eq
 8009200:	f442 6200 	orreq.w	r2, r2, #2048	@ 0x800
 8009204:	f442 5200 	orrne.w	r2, r2, #8192	@ 0x2000
 8009208:	f8cc 2010 	str.w	r2, [ip, #16]
      if (OPAMPParams != NULL)
 800920c:	b190      	cbz	r0, 8009234 <R3_1_Init+0x90>
        LL_OPAMP_Enable(OPAMPParams->OPAMPSelect_1[1]);
 800920e:	e9d0 2c00 	ldrd	r2, ip, [r0]
  * @param  OPAMPx OPAMP instance
  * @retval None
  */
__STATIC_INLINE void LL_OPAMP_Enable(OPAMP_TypeDef *OPAMPx)
{
  SET_BIT(OPAMPx->CSR, OPAMP_CSR_OPAMPxEN);
 8009212:	f8d2 e000 	ldr.w	lr, [r2]
        LL_OPAMP_Enable(OPAMPParams->OPAMPSelect_2[0]);
 8009216:	6980      	ldr	r0, [r0, #24]
 8009218:	f04e 0e01 	orr.w	lr, lr, #1
 800921c:	f8c2 e000 	str.w	lr, [r2]
 8009220:	f8dc 2000 	ldr.w	r2, [ip]
 8009224:	f042 0201 	orr.w	r2, r2, #1
 8009228:	f8cc 2000 	str.w	r2, [ip]
 800922c:	6802      	ldr	r2, [r0, #0]
 800922e:	f042 0201 	orr.w	r2, r2, #1
 8009232:	6002      	str	r2, [r0, #0]
      if (COMP_OCPAx != NULL)
 8009234:	b19b      	cbz	r3, 800925e <R3_1_Init+0xba>
        if ((pHandle->pParams_str->CompOCPAInvInput_MODE != EXT_MODE) && (DAC_OCPAx != MC_NULL))
 8009236:	f895 2063 	ldrb.w	r2, [r5, #99]	@ 0x63
 800923a:	2a01      	cmp	r2, #1
 800923c:	d007      	beq.n	800924e <R3_1_Init+0xaa>
 800923e:	b131      	cbz	r1, 800924e <R3_1_Init+0xaa>
          R3_1_SetAOReferenceVoltage(pHandle->pParams_str->DAC_Channel_OCPA, DAC_OCPAx,
 8009240:	f8b5 205e 	ldrh.w	r2, [r5, #94]	@ 0x5e
 8009244:	6ae8      	ldr	r0, [r5, #44]	@ 0x2c
 8009246:	9303      	str	r3, [sp, #12]
 8009248:	f7ff ff38 	bl	80090bc <R3_1_SetAOReferenceVoltage>
 800924c:	9b03      	ldr	r3, [sp, #12]
  * @param  COMPx Comparator instance
  * @retval None
  */
__STATIC_INLINE void LL_COMP_Enable(COMP_TypeDef *COMPx)
{
  SET_BIT(COMPx->CSR, COMP_CSR_EN);
 800924e:	681a      	ldr	r2, [r3, #0]
 8009250:	f042 0201 	orr.w	r2, r2, #1
 8009254:	601a      	str	r2, [r3, #0]
  * @param  COMPx Comparator instance
  * @retval None
  */
__STATIC_INLINE void LL_COMP_Lock(COMP_TypeDef *COMPx)
{
  SET_BIT(COMPx->CSR, COMP_CSR_LOCK);
 8009256:	681a      	ldr	r2, [r3, #0]
 8009258:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
 800925c:	601a      	str	r2, [r3, #0]
      if (COMP_OCPBx != NULL)
 800925e:	f1ba 0f00 	cmp.w	sl, #0
 8009262:	d018      	beq.n	8009296 <R3_1_Init+0xf2>
        if ((pHandle->pParams_str->CompOCPBInvInput_MODE != EXT_MODE) && (DAC_OCPBx != MC_NULL))
 8009264:	f895 3064 	ldrb.w	r3, [r5, #100]	@ 0x64
 8009268:	2b01      	cmp	r3, #1
 800926a:	d008      	beq.n	800927e <R3_1_Init+0xda>
 800926c:	f1bb 0f00 	cmp.w	fp, #0
 8009270:	d005      	beq.n	800927e <R3_1_Init+0xda>
          R3_1_SetAOReferenceVoltage(pHandle->pParams_str->DAC_Channel_OCPB, DAC_OCPBx,
 8009272:	f8b5 205e 	ldrh.w	r2, [r5, #94]	@ 0x5e
 8009276:	6b28      	ldr	r0, [r5, #48]	@ 0x30
 8009278:	4659      	mov	r1, fp
 800927a:	f7ff ff1f 	bl	80090bc <R3_1_SetAOReferenceVoltage>
  SET_BIT(COMPx->CSR, COMP_CSR_EN);
 800927e:	f8da 3000 	ldr.w	r3, [sl]
 8009282:	f043 0301 	orr.w	r3, r3, #1
 8009286:	f8ca 3000 	str.w	r3, [sl]
  SET_BIT(COMPx->CSR, COMP_CSR_LOCK);
 800928a:	f8da 3000 	ldr.w	r3, [sl]
 800928e:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8009292:	f8ca 3000 	str.w	r3, [sl]
      if (COMP_OCPCx != NULL)
 8009296:	f1b9 0f00 	cmp.w	r9, #0
 800929a:	d017      	beq.n	80092cc <R3_1_Init+0x128>
        if ((pHandle->pParams_str->CompOCPCInvInput_MODE != EXT_MODE)  && (DAC_OCPCx != MC_NULL))
 800929c:	f895 3065 	ldrb.w	r3, [r5, #101]	@ 0x65
 80092a0:	2b01      	cmp	r3, #1
 80092a2:	d007      	beq.n	80092b4 <R3_1_Init+0x110>
 80092a4:	9b01      	ldr	r3, [sp, #4]
 80092a6:	b12b      	cbz	r3, 80092b4 <R3_1_Init+0x110>
          R3_1_SetAOReferenceVoltage(pHandle->pParams_str->DAC_Channel_OCPC, DAC_OCPCx,
 80092a8:	f8b5 205e 	ldrh.w	r2, [r5, #94]	@ 0x5e
 80092ac:	6b68      	ldr	r0, [r5, #52]	@ 0x34
 80092ae:	4619      	mov	r1, r3
 80092b0:	f7ff ff04 	bl	80090bc <R3_1_SetAOReferenceVoltage>
  SET_BIT(COMPx->CSR, COMP_CSR_EN);
 80092b4:	f8d9 3000 	ldr.w	r3, [r9]
 80092b8:	f043 0301 	orr.w	r3, r3, #1
 80092bc:	f8c9 3000 	str.w	r3, [r9]
  SET_BIT(COMPx->CSR, COMP_CSR_LOCK);
 80092c0:	f8d9 3000 	ldr.w	r3, [r9]
 80092c4:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 80092c8:	f8c9 3000 	str.w	r3, [r9]
      if (COMP_OVPx != NULL)
 80092cc:	f1b8 0f00 	cmp.w	r8, #0
 80092d0:	d017      	beq.n	8009302 <R3_1_Init+0x15e>
        if ((pHandle->pParams_str->CompOVPInvInput_MODE != EXT_MODE) && (DAC_OVPx != MC_NULL))
 80092d2:	f895 3066 	ldrb.w	r3, [r5, #102]	@ 0x66
 80092d6:	2b01      	cmp	r3, #1
 80092d8:	d007      	beq.n	80092ea <R3_1_Init+0x146>
 80092da:	9b02      	ldr	r3, [sp, #8]
 80092dc:	b12b      	cbz	r3, 80092ea <R3_1_Init+0x146>
          R3_1_SetAOReferenceVoltage(pHandle->pParams_str->DAC_Channel_OVP, DAC_OVPx,
 80092de:	f8b5 2060 	ldrh.w	r2, [r5, #96]	@ 0x60
 80092e2:	6ba8      	ldr	r0, [r5, #56]	@ 0x38
 80092e4:	4619      	mov	r1, r3
 80092e6:	f7ff fee9 	bl	80090bc <R3_1_SetAOReferenceVoltage>
  SET_BIT(COMPx->CSR, COMP_CSR_EN);
 80092ea:	f8d8 3000 	ldr.w	r3, [r8]
 80092ee:	f043 0301 	orr.w	r3, r3, #1
 80092f2:	f8c8 3000 	str.w	r3, [r8]
  SET_BIT(COMPx->CSR, COMP_CSR_LOCK);
 80092f6:	f8d8 3000 	ldr.w	r3, [r8]
 80092fa:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 80092fe:	f8c8 3000 	str.w	r3, [r8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8009302:	68b3      	ldr	r3, [r6, #8]
 8009304:	07d8      	lsls	r0, r3, #31
 8009306:	d45a      	bmi.n	80093be <R3_1_Init+0x21a>
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
 8009308:	68b3      	ldr	r3, [r6, #8]
 800930a:	f023 4320 	bic.w	r3, r3, #2684354560	@ 0xa0000000
 800930e:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
 8009312:	60b3      	str	r3, [r6, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 8009314:	68b3      	ldr	r3, [r6, #8]
 8009316:	00d9      	lsls	r1, r3, #3
 8009318:	d418      	bmi.n	800934c <R3_1_Init+0x1a8>
  MODIFY_REG(ADCx->CR,
 800931a:	68b3      	ldr	r3, [r6, #8]
                                         * (SystemCoreClock / (100000UL * 2UL)));
 800931c:	4a60      	ldr	r2, [pc, #384]	@ (80094a0 <R3_1_Init+0x2fc>)
 800931e:	f023 4310 	bic.w	r3, r3, #2415919104	@ 0x90000000
 8009322:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
 8009326:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 800932a:	60b3      	str	r3, [r6, #8]
 800932c:	4b5d      	ldr	r3, [pc, #372]	@ (80094a4 <R3_1_Init+0x300>)
 800932e:	681b      	ldr	r3, [r3, #0]
 8009330:	099b      	lsrs	r3, r3, #6
 8009332:	fba2 2303 	umull	r2, r3, r2, r3
 8009336:	099b      	lsrs	r3, r3, #6
 8009338:	005b      	lsls	r3, r3, #1
    volatile uint32_t wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL)
 800933a:	9304      	str	r3, [sp, #16]
    while (wait_loop_index != 0UL)
 800933c:	9b04      	ldr	r3, [sp, #16]
 800933e:	b12b      	cbz	r3, 800934c <R3_1_Init+0x1a8>
      wait_loop_index--;
 8009340:	9b04      	ldr	r3, [sp, #16]
 8009342:	3b01      	subs	r3, #1
 8009344:	9304      	str	r3, [sp, #16]
    while (wait_loop_index != 0UL)
 8009346:	9b04      	ldr	r3, [sp, #16]
 8009348:	2b00      	cmp	r3, #0
 800934a:	d1f9      	bne.n	8009340 <R3_1_Init+0x19c>
  MODIFY_REG(ADCx->CR,
 800934c:	68b3      	ldr	r3, [r6, #8]
 800934e:	f023 4340 	bic.w	r3, r3, #3221225472	@ 0xc0000000
 8009352:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
 8009356:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 800935a:	60b3      	str	r3, [r6, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADCAL) == (ADC_CR_ADCAL)) ? 1UL : 0UL);
 800935c:	68b3      	ldr	r3, [r6, #8]
 800935e:	2b00      	cmp	r3, #0
 8009360:	dbfc      	blt.n	800935c <R3_1_Init+0x1b8>
  return ((READ_BIT(ADCx->ISR, LL_ADC_FLAG_ADRDY) == (LL_ADC_FLAG_ADRDY)) ? 1UL : 0UL);
 8009362:	6833      	ldr	r3, [r6, #0]
 8009364:	07da      	lsls	r2, r3, #31
 8009366:	d408      	bmi.n	800937a <R3_1_Init+0x1d6>
  MODIFY_REG(ADCx->CR,
 8009368:	4a4f      	ldr	r2, [pc, #316]	@ (80094a8 <R3_1_Init+0x304>)
 800936a:	68b3      	ldr	r3, [r6, #8]
 800936c:	4013      	ands	r3, r2
 800936e:	f043 0301 	orr.w	r3, r3, #1
 8009372:	60b3      	str	r3, [r6, #8]
  return ((READ_BIT(ADCx->ISR, LL_ADC_FLAG_ADRDY) == (LL_ADC_FLAG_ADRDY)) ? 1UL : 0UL);
 8009374:	6833      	ldr	r3, [r6, #0]
 8009376:	07db      	lsls	r3, r3, #31
 8009378:	d5f7      	bpl.n	800936a <R3_1_Init+0x1c6>
  MODIFY_REG(ADCx->CR,
 800937a:	68b3      	ldr	r3, [r6, #8]
 800937c:	4a4a      	ldr	r2, [pc, #296]	@ (80094a8 <R3_1_Init+0x304>)
 800937e:	4013      	ands	r3, r2
 8009380:	f043 0308 	orr.w	r3, r3, #8
 8009384:	60b3      	str	r3, [r6, #8]
  MODIFY_REG(ADCx->CR,
 8009386:	68b3      	ldr	r3, [r6, #8]
 8009388:	4013      	ands	r3, r2
 800938a:	f043 0320 	orr.w	r3, r3, #32
 800938e:	60b3      	str	r3, [r6, #8]
  MODIFY_REG(ADCx->CFGR, ADC_CFGR_JQM | ADC_CFGR_JQDIS, QueueMode);
 8009390:	68f3      	ldr	r3, [r6, #12]
 8009392:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 8009396:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 800939a:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 800939e:	60f3      	str	r3, [r6, #12]
  MODIFY_REG(ADCx->SQR1, ADC_SQR1_L, SequencerNbRanks);
 80093a0:	6b33      	ldr	r3, [r6, #48]	@ 0x30
 80093a2:	f023 030f 	bic.w	r3, r3, #15
 80093a6:	6333      	str	r3, [r6, #48]	@ 0x30
  MODIFY_REG(ADCx->CR,
 80093a8:	68b3      	ldr	r3, [r6, #8]
 80093aa:	4013      	ands	r3, r2
 80093ac:	f043 0304 	orr.w	r3, r3, #4
 80093b0:	60b3      	str	r3, [r6, #8]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_JEOS);
 80093b2:	2340      	movs	r3, #64	@ 0x40
 80093b4:	6033      	str	r3, [r6, #0]
  SET_BIT(ADCx->IER, LL_ADC_IT_JEOS);
 80093b6:	6873      	ldr	r3, [r6, #4]
 80093b8:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 80093bc:	6073      	str	r3, [r6, #4]
  volatile uint32_t Brk2Timeout = 1000;
 80093be:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 80093c2:	9305      	str	r3, [sp, #20]
  CLEAR_BIT(TIMx->CR1, TIM_CR1_CEN);
 80093c4:	6823      	ldr	r3, [r4, #0]
 80093c6:	f023 0301 	bic.w	r3, r3, #1
 80093ca:	6023      	str	r3, [r4, #0]
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 80093cc:	6863      	ldr	r3, [r4, #4]
 80093ce:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
 80093d2:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 80093d6:	6063      	str	r3, [r4, #4]
  SET_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
 80093d8:	69a3      	ldr	r3, [r4, #24]
 80093da:	f043 0308 	orr.w	r3, r3, #8
 80093de:	61a3      	str	r3, [r4, #24]
 80093e0:	69a3      	ldr	r3, [r4, #24]
 80093e2:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
 80093e6:	61a3      	str	r3, [r4, #24]
 80093e8:	69e3      	ldr	r3, [r4, #28]
 80093ea:	f043 0308 	orr.w	r3, r3, #8
 80093ee:	61e3      	str	r3, [r4, #28]
 80093f0:	69e3      	ldr	r3, [r4, #28]
 80093f2:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
 80093f6:	61e3      	str	r3, [r4, #28]
  SET_BIT(TIMx->EGR, TIM_EGR_UG);
 80093f8:	6963      	ldr	r3, [r4, #20]
 80093fa:	f043 0301 	orr.w	r3, r3, #1
 80093fe:	6163      	str	r3, [r4, #20]
  if (2U == pHandle->pParams_str->FreqRatio)
 8009400:	f895 3067 	ldrb.w	r3, [r5, #103]	@ 0x67
 8009404:	2b02      	cmp	r3, #2
 8009406:	d011      	beq.n	800942c <R3_1_Init+0x288>
    if (M1 == pHandle->_Super.Motor)
 8009408:	f897 3078 	ldrb.w	r3, [r7, #120]	@ 0x78
 800940c:	b9b3      	cbnz	r3, 800943c <R3_1_Init+0x298>
      if (1U == pHandle->pParams_str->RepetitionCounter)
 800940e:	f895 3062 	ldrb.w	r3, [r5, #98]	@ 0x62
 8009412:	2b01      	cmp	r3, #1
 8009414:	d00e      	beq.n	8009434 <R3_1_Init+0x290>
      else if (3U == pHandle->pParams_str->RepetitionCounter)
 8009416:	2b03      	cmp	r3, #3
 8009418:	d110      	bne.n	800943c <R3_1_Init+0x298>
  WRITE_REG(TIMx->RCR, RepetitionCounter);
 800941a:	2201      	movs	r2, #1
 800941c:	6322      	str	r2, [r4, #48]	@ 0x30
  SET_BIT(TIMx->EGR, TIM_EGR_UG);
 800941e:	6962      	ldr	r2, [r4, #20]
 8009420:	f042 0201 	orr.w	r2, r2, #1
 8009424:	6162      	str	r2, [r4, #20]
  WRITE_REG(TIMx->RCR, RepetitionCounter);
 8009426:	6323      	str	r3, [r4, #48]	@ 0x30
}
 8009428:	e008      	b.n	800943c <R3_1_Init+0x298>
 800942a:	4770      	bx	lr
    if (HIGHER_FREQ == pHandle->pParams_str->IsHigherFreqTim)
 800942c:	f895 3068 	ldrb.w	r3, [r5, #104]	@ 0x68
 8009430:	2b01      	cmp	r3, #1
 8009432:	d027      	beq.n	8009484 <R3_1_Init+0x2e0>
        LL_TIM_SetCounter(TIMx, (uint32_t)(pHandle->Half_PWMPeriod) - 1U);
 8009434:	f8b7 3094 	ldrh.w	r3, [r7, #148]	@ 0x94
 8009438:	3b01      	subs	r3, #1
  WRITE_REG(TIMx->CNT, Counter);
 800943a:	6263      	str	r3, [r4, #36]	@ 0x24
  WRITE_REG(TIMx->SR, ~(TIM_SR_BIF));
 800943c:	f06f 0380 	mvn.w	r3, #128	@ 0x80
 8009440:	6123      	str	r3, [r4, #16]
  return ((READ_BIT(TIMx->SR, TIM_SR_B2IF) == (TIM_SR_B2IF)) ? 1UL : 0UL);
 8009442:	6923      	ldr	r3, [r4, #16]
  while ((Brk2Timeout != 0u) && (1U == result))
 8009444:	9a05      	ldr	r2, [sp, #20]
 8009446:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800944a:	b172      	cbz	r2, 800946a <R3_1_Init+0x2c6>
 800944c:	b16b      	cbz	r3, 800946a <R3_1_Init+0x2c6>
  WRITE_REG(TIMx->SR, ~(TIM_SR_B2IF));
 800944e:	f46f 7180 	mvn.w	r1, #256	@ 0x100
 8009452:	e000      	b.n	8009456 <R3_1_Init+0x2b2>
 8009454:	b14b      	cbz	r3, 800946a <R3_1_Init+0x2c6>
 8009456:	6121      	str	r1, [r4, #16]
    Brk2Timeout--;
 8009458:	9b05      	ldr	r3, [sp, #20]
 800945a:	3b01      	subs	r3, #1
 800945c:	9305      	str	r3, [sp, #20]
  return ((READ_BIT(TIMx->SR, TIM_SR_B2IF) == (TIM_SR_B2IF)) ? 1UL : 0UL);
 800945e:	6923      	ldr	r3, [r4, #16]
  while ((Brk2Timeout != 0u) && (1U == result))
 8009460:	9a05      	ldr	r2, [sp, #20]
 8009462:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8009466:	2a00      	cmp	r2, #0
 8009468:	d1f4      	bne.n	8009454 <R3_1_Init+0x2b0>
  SET_BIT(TIMx->DIER, TIM_DIER_BIE);
 800946a:	68e3      	ldr	r3, [r4, #12]
 800946c:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8009470:	60e3      	str	r3, [r4, #12]
  SET_BIT(TIMx->CCER, Channels);
 8009472:	6a23      	ldr	r3, [r4, #32]
 8009474:	f443 63aa 	orr.w	r3, r3, #1360	@ 0x550
 8009478:	f043 0305 	orr.w	r3, r3, #5
 800947c:	6223      	str	r3, [r4, #32]
}
 800947e:	b007      	add	sp, #28
 8009480:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (3U == pHandle->pParams_str->RepetitionCounter)
 8009484:	f895 2062 	ldrb.w	r2, [r5, #98]	@ 0x62
 8009488:	2a03      	cmp	r2, #3
 800948a:	d1d3      	bne.n	8009434 <R3_1_Init+0x290>
  WRITE_REG(TIMx->RCR, RepetitionCounter);
 800948c:	6323      	str	r3, [r4, #48]	@ 0x30
  SET_BIT(TIMx->EGR, TIM_EGR_UG);
 800948e:	6963      	ldr	r3, [r4, #20]
 8009490:	f043 0301 	orr.w	r3, r3, #1
 8009494:	6163      	str	r3, [r4, #20]
  WRITE_REG(TIMx->RCR, RepetitionCounter);
 8009496:	6322      	str	r2, [r4, #48]	@ 0x30
}
 8009498:	e7cc      	b.n	8009434 <R3_1_Init+0x290>
 800949a:	bf00      	nop
 800949c:	40012c00 	.word	0x40012c00
 80094a0:	053e2d63 	.word	0x053e2d63
 80094a4:	20000474 	.word	0x20000474
 80094a8:	7fffffc0 	.word	0x7fffffc0
 80094ac:	e0042000 	.word	0xe0042000

080094b0 <R3_1_SetOffsetCalib>:
{
 80094b0:	b410      	push	{r4}
  pHandle->PhaseAOffset = offsets->phaseAOffset;
 80094b2:	e9d1 4201 	ldrd	r4, r2, [r1, #4]
 80094b6:	680b      	ldr	r3, [r1, #0]
 80094b8:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  pHdl->offsetCalibStatus = true;
 80094bc:	2301      	movs	r3, #1
  pHandle->PhaseAOffset = offsets->phaseAOffset;
 80094be:	e9c0 4223 	strd	r4, r2, [r0, #140]	@ 0x8c
  pHdl->offsetCalibStatus = true;
 80094c2:	f880 307f 	strb.w	r3, [r0, #127]	@ 0x7f
}
 80094c6:	f85d 4b04 	ldr.w	r4, [sp], #4
 80094ca:	4770      	bx	lr

080094cc <R3_1_GetOffsetCalib>:
  offsets->phaseAOffset = pHandle->PhaseAOffset;
 80094cc:	e9d0 2323 	ldrd	r2, r3, [r0, #140]	@ 0x8c
 80094d0:	f8d0 0088 	ldr.w	r0, [r0, #136]	@ 0x88
 80094d4:	608b      	str	r3, [r1, #8]
 80094d6:	e9c1 0200 	strd	r0, r2, [r1]
}
 80094da:	4770      	bx	lr

080094dc <R3_1_CurrentReadingPolarization>:
{
 80094dc:	b5f0      	push	{r4, r5, r6, r7, lr}
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 80094de:	f8d0 309c 	ldr.w	r3, [r0, #156]	@ 0x9c
  ADC_TypeDef *ADCx = pHandle->pParams_str->ADCx;
 80094e2:	e9d3 6500 	ldrd	r6, r5, [r3]
  if (true == pHandle->_Super.offsetCalibStatus)
 80094e6:	f890 307f 	ldrb.w	r3, [r0, #127]	@ 0x7f
{
 80094ea:	b083      	sub	sp, #12
 80094ec:	4604      	mov	r4, r0
  if (true == pHandle->_Super.offsetCalibStatus)
 80094ee:	b193      	cbz	r3, 8009516 <R3_1_CurrentReadingPolarization+0x3a>
  MODIFY_REG(ADCx->CR,
 80094f0:	68b3      	ldr	r3, [r6, #8]
 80094f2:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 80094f6:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
    pHandle->ADC_ExternalPolarityInjected = (uint16_t)LL_ADC_INJ_TRIG_EXT_RISING;
 80094fa:	2280      	movs	r2, #128	@ 0x80
 80094fc:	f043 0308 	orr.w	r3, r3, #8
 8009500:	60b3      	str	r3, [r6, #8]
 8009502:	f8a0 2096 	strh.w	r2, [r0, #150]	@ 0x96
  pHandle->_Super.Sector = SECTOR_5;
 8009506:	2204      	movs	r2, #4
  pHandle->_Super.BrakeActionLock = false;
 8009508:	2300      	movs	r3, #0
  pHandle->_Super.Sector = SECTOR_5;
 800950a:	f884 207a 	strb.w	r2, [r4, #122]	@ 0x7a
  pHandle->_Super.BrakeActionLock = false;
 800950e:	f884 3083 	strb.w	r3, [r4, #131]	@ 0x83
}
 8009512:	b003      	add	sp, #12
 8009514:	bdf0      	pop	{r4, r5, r6, r7, pc}
    GetPhaseCurrCbSave = pHandle->_Super.pFctGetPhaseCurrents;
 8009516:	6802      	ldr	r2, [r0, #0]
 8009518:	9200      	str	r2, [sp, #0]
    pHandle->PhaseAOffset = 0U;
 800951a:	e9c0 3322 	strd	r3, r3, [r0, #136]	@ 0x88
    SetSampPointSectXCbSave = pHandle->_Super.pFctSetADCSampPointSectX;
 800951e:	6942      	ldr	r2, [r0, #20]
 8009520:	9201      	str	r2, [sp, #4]
    pHandle->PolarizationCounter = 0U;
 8009522:	f880 3098 	strb.w	r3, [r0, #152]	@ 0x98
    pHandle->PhaseCOffset = 0U;
 8009526:	f8c0 3090 	str.w	r3, [r0, #144]	@ 0x90
  CLEAR_BIT(TIMx->CCER, Channels);
 800952a:	6a2b      	ldr	r3, [r5, #32]
 800952c:	f423 63aa 	bic.w	r3, r3, #1360	@ 0x550
 8009530:	f023 0305 	bic.w	r3, r3, #5
 8009534:	622b      	str	r3, [r5, #32]
    pHandle->_Super.pFctGetPhaseCurrents = &R3_1_HFCurrentsPolarizationAB;
 8009536:	4b34      	ldr	r3, [pc, #208]	@ (8009608 <R3_1_CurrentReadingPolarization+0x12c>)
 8009538:	6003      	str	r3, [r0, #0]
    pHandle->_Super.pFctSetADCSampPointSectX = &R3_1_SetADCSampPointPolarization;
 800953a:	4b34      	ldr	r3, [pc, #208]	@ (800960c <R3_1_CurrentReadingPolarization+0x130>)
 800953c:	6143      	str	r3, [r0, #20]
    pHandle->ADC_ExternalPolarityInjected = (uint16_t)LL_ADC_INJ_TRIG_EXT_RISING;
 800953e:	2380      	movs	r3, #128	@ 0x80
 8009540:	f8a0 3096 	strh.w	r3, [r0, #150]	@ 0x96
  pHandle->PolarizationSector=SECTOR_5;
 8009544:	2304      	movs	r3, #4
 8009546:	f880 3099 	strb.w	r3, [r0, #153]	@ 0x99
  pHandle->_Super.Sector = SECTOR_5;   
 800954a:	f880 307a 	strb.w	r3, [r0, #122]	@ 0x7a
    R3_1_SwitchOnPWM(&pHandle->_Super);
 800954e:	f7ff fc91 	bl	8008e74 <R3_1_SwitchOnPWM>
    while (((TIMx->CR2) & TIM_CR2_MMS_Msk) != LL_TIM_TRGO_OC4REF)
 8009552:	4a2f      	ldr	r2, [pc, #188]	@ (8009610 <R3_1_CurrentReadingPolarization+0x134>)
 8009554:	686b      	ldr	r3, [r5, #4]
 8009556:	4013      	ands	r3, r2
 8009558:	2b70      	cmp	r3, #112	@ 0x70
 800955a:	d1fb      	bne.n	8009554 <R3_1_CurrentReadingPolarization+0x78>
 800955c:	68b3      	ldr	r3, [r6, #8]
 800955e:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 8009562:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
 8009566:	f043 0308 	orr.w	r3, r3, #8
 800956a:	60b3      	str	r3, [r6, #8]
                           pHandle->pParams_str->RepetitionCounter,
 800956c:	f8d4 309c 	ldr.w	r3, [r4, #156]	@ 0x9c
    waitForPolarizationEnd(TIMx,
 8009570:	f104 0798 	add.w	r7, r4, #152	@ 0x98
 8009574:	f893 2062 	ldrb.w	r2, [r3, #98]	@ 0x62
 8009578:	f104 0156 	add.w	r1, r4, #86	@ 0x56
 800957c:	463b      	mov	r3, r7
 800957e:	4628      	mov	r0, r5
 8009580:	460e      	mov	r6, r1
 8009582:	f7f8 fea1 	bl	80022c8 <waitForPolarizationEnd>
    R3_1_SwitchOffPWM(&pHandle->_Super);
 8009586:	4620      	mov	r0, r4
 8009588:	f7ff fcbe 	bl	8008f08 <R3_1_SwitchOffPWM>
    pHandle->PolarizationCounter = 0U;
 800958c:	2300      	movs	r3, #0
 800958e:	f884 3098 	strb.w	r3, [r4, #152]	@ 0x98
  pHandle->PolarizationSector=SECTOR_1;
 8009592:	f884 3099 	strb.w	r3, [r4, #153]	@ 0x99
  pHandle->_Super.Sector = SECTOR_1;   
 8009596:	f884 307a 	strb.w	r3, [r4, #122]	@ 0x7a
    pHandle->_Super.pFctGetPhaseCurrents = &R3_1_HFCurrentsPolarizationC;
 800959a:	4b1e      	ldr	r3, [pc, #120]	@ (8009614 <R3_1_CurrentReadingPolarization+0x138>)
 800959c:	6023      	str	r3, [r4, #0]
    R3_1_SwitchOnPWM(&pHandle->_Super);
 800959e:	4620      	mov	r0, r4
 80095a0:	f7ff fc68 	bl	8008e74 <R3_1_SwitchOnPWM>
                           pHandle->pParams_str->RepetitionCounter,
 80095a4:	f8d4 209c 	ldr.w	r2, [r4, #156]	@ 0x9c
    waitForPolarizationEnd(TIMx,
 80095a8:	463b      	mov	r3, r7
 80095aa:	f892 2062 	ldrb.w	r2, [r2, #98]	@ 0x62
 80095ae:	4631      	mov	r1, r6
 80095b0:	4628      	mov	r0, r5
 80095b2:	f7f8 fe89 	bl	80022c8 <waitForPolarizationEnd>
    R3_1_SwitchOffPWM(&pHandle->_Super);
 80095b6:	4620      	mov	r0, r4
 80095b8:	f7ff fca6 	bl	8008f08 <R3_1_SwitchOffPWM>
    pHandle->PhaseBOffset /= NB_CONVERSIONS;
 80095bc:	e9d4 1222 	ldrd	r1, r2, [r4, #136]	@ 0x88
    pHandle->PhaseCOffset /= NB_CONVERSIONS;
 80095c0:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
    pHandle->PhaseBOffset /= NB_CONVERSIONS;
 80095c4:	0912      	lsrs	r2, r2, #4
    pHandle->PhaseAOffset /= NB_CONVERSIONS;
 80095c6:	0909      	lsrs	r1, r1, #4
    pHandle->PhaseBOffset /= NB_CONVERSIONS;
 80095c8:	e9c4 1222 	strd	r1, r2, [r4, #136]	@ 0x88
    if (0U == pHandle->_Super.SWerror)
 80095cc:	f8b4 2056 	ldrh.w	r2, [r4, #86]	@ 0x56
    pHandle->PhaseCOffset /= NB_CONVERSIONS;
 80095d0:	091b      	lsrs	r3, r3, #4
 80095d2:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
    if (0U == pHandle->_Super.SWerror)
 80095d6:	b912      	cbnz	r2, 80095de <R3_1_CurrentReadingPolarization+0x102>
      pHandle->_Super.offsetCalibStatus = true;
 80095d8:	2301      	movs	r3, #1
 80095da:	f884 307f 	strb.w	r3, [r4, #127]	@ 0x7f
    LL_TIM_OC_SetCompareCH1 (TIMx, pHandle->Half_PWMPeriod >> 1u);
 80095de:	f8b4 3094 	ldrh.w	r3, [r4, #148]	@ 0x94
    pHandle->_Super.pFctGetPhaseCurrents = GetPhaseCurrCbSave;
 80095e2:	9900      	ldr	r1, [sp, #0]
    pHandle->_Super.pFctSetADCSampPointSectX = SetSampPointSectXCbSave;
 80095e4:	9a01      	ldr	r2, [sp, #4]
    pHandle->_Super.pFctGetPhaseCurrents = GetPhaseCurrCbSave;
 80095e6:	6021      	str	r1, [r4, #0]
    LL_TIM_OC_SetCompareCH1 (TIMx, pHandle->Half_PWMPeriod >> 1u);
 80095e8:	085b      	lsrs	r3, r3, #1
    pHandle->_Super.pFctSetADCSampPointSectX = SetSampPointSectXCbSave;
 80095ea:	6162      	str	r2, [r4, #20]
  WRITE_REG(TIMx->CCR1, CompareValue);
 80095ec:	636b      	str	r3, [r5, #52]	@ 0x34
  WRITE_REG(TIMx->CCR2, CompareValue);
 80095ee:	63ab      	str	r3, [r5, #56]	@ 0x38
  WRITE_REG(TIMx->CCR3, CompareValue);
 80095f0:	63eb      	str	r3, [r5, #60]	@ 0x3c
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_GenerateEvent_COM(TIM_TypeDef *TIMx)
{
  SET_BIT(TIMx->EGR, TIM_EGR_COMG);
 80095f2:	696b      	ldr	r3, [r5, #20]
 80095f4:	f043 0320 	orr.w	r3, r3, #32
 80095f8:	616b      	str	r3, [r5, #20]
  SET_BIT(TIMx->CCER, Channels);
 80095fa:	6a2b      	ldr	r3, [r5, #32]
 80095fc:	f443 63aa 	orr.w	r3, r3, #1360	@ 0x550
 8009600:	f043 0305 	orr.w	r3, r3, #5
 8009604:	622b      	str	r3, [r5, #32]
}
 8009606:	e77e      	b.n	8009506 <R3_1_CurrentReadingPolarization+0x2a>
 8009608:	08008ddd 	.word	0x08008ddd
 800960c:	08008d99 	.word	0x08008d99
 8009610:	02000070 	.word	0x02000070
 8009614:	08008e2d 	.word	0x08008e2d

08009618 <R3_1_SetADCSampPointSectX>:
  if (MC_NULL == pHdl)
 8009618:	2800      	cmp	r0, #0
 800961a:	d03b      	beq.n	8009694 <R3_1_SetADCSampPointSectX+0x7c>
{
 800961c:	b530      	push	{r4, r5, lr}
    if ((uint16_t)(pHandle->Half_PWMPeriod - pHdl->lowDuty) > pHandle->pParams_str->Tafter)
 800961e:	f8b0 3058 	ldrh.w	r3, [r0, #88]	@ 0x58
 8009622:	f8b0 e094 	ldrh.w	lr, [r0, #148]	@ 0x94
 8009626:	f8d0 109c 	ldr.w	r1, [r0, #156]	@ 0x9c
 800962a:	ebae 0203 	sub.w	r2, lr, r3
 800962e:	f8b1 4054 	ldrh.w	r4, [r1, #84]	@ 0x54
 8009632:	b292      	uxth	r2, r2
 8009634:	42a2      	cmp	r2, r4
 8009636:	d917      	bls.n	8009668 <R3_1_SetADCSampPointSectX+0x50>
      pHandle->_Super.Sector = SECTOR_5;
 8009638:	2204      	movs	r2, #4
      SamplingPoint =  pHandle->Half_PWMPeriod - (uint16_t)1;
 800963a:	f10e 33ff 	add.w	r3, lr, #4294967295
      pHandle->_Super.Sector = SECTOR_5;
 800963e:	f880 207a 	strb.w	r2, [r0, #122]	@ 0x7a
      SamplingPoint =  pHandle->Half_PWMPeriod - (uint16_t)1;
 8009642:	b29b      	uxth	r3, r3
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009644:	684a      	ldr	r2, [r1, #4]
  LL_TIM_OC_SetCompareCH1(TIMx, (uint32_t) pHandle->_Super.CntPhA);
 8009646:	f8b0 5050 	ldrh.w	r5, [r0, #80]	@ 0x50
  LL_TIM_OC_SetCompareCH2(TIMx, (uint32_t) pHandle->_Super.CntPhB);
 800964a:	f8b0 4052 	ldrh.w	r4, [r0, #82]	@ 0x52
  LL_TIM_OC_SetCompareCH3(TIMx, (uint32_t) pHandle->_Super.CntPhC);
 800964e:	f8b0 1054 	ldrh.w	r1, [r0, #84]	@ 0x54
  WRITE_REG(TIMx->CCR1, CompareValue);
 8009652:	6355      	str	r5, [r2, #52]	@ 0x34
  WRITE_REG(TIMx->CCR2, CompareValue);
 8009654:	6394      	str	r4, [r2, #56]	@ 0x38
  WRITE_REG(TIMx->CCR3, CompareValue);
 8009656:	63d1      	str	r1, [r2, #60]	@ 0x3c
  WRITE_REG(TIMx->CCR4, CompareValue);
 8009658:	6413      	str	r3, [r2, #64]	@ 0x40
  if (((TIMx->CR2) & TIM_CR2_MMS_Msk) != LL_TIM_TRGO_RESET)
 800965a:	6852      	ldr	r2, [r2, #4]
 800965c:	4b10      	ldr	r3, [pc, #64]	@ (80096a0 <R3_1_SetADCSampPointSectX+0x88>)
 800965e:	421a      	tst	r2, r3
 8009660:	bf14      	ite	ne
 8009662:	2001      	movne	r0, #1
 8009664:	2000      	moveq	r0, #0
}
 8009666:	bd30      	pop	{r4, r5, pc}
      DeltaDuty = (uint16_t)(pHdl->lowDuty - pHdl->midDuty);
 8009668:	f8b0 c05a 	ldrh.w	ip, [r0, #90]	@ 0x5a
 800966c:	eba3 0c0c 	sub.w	ip, r3, ip
      if (DeltaDuty > ((uint16_t)(pHandle->Half_PWMPeriod - pHdl->lowDuty) * 2U))
 8009670:	fa1f fc8c 	uxth.w	ip, ip
 8009674:	ebbc 0f42 	cmp.w	ip, r2, lsl #1
 8009678:	d80d      	bhi.n	8009696 <R3_1_SetADCSampPointSectX+0x7e>
        SamplingPoint = pHdl->lowDuty + pHandle->pParams_str->Tafter;
 800967a:	4423      	add	r3, r4
 800967c:	b29b      	uxth	r3, r3
        if (SamplingPoint >= pHandle->Half_PWMPeriod)
 800967e:	459e      	cmp	lr, r3
 8009680:	d8e0      	bhi.n	8009644 <R3_1_SetADCSampPointSectX+0x2c>
          SamplingPoint = (2U * pHandle->Half_PWMPeriod) - SamplingPoint - (uint16_t)1;
 8009682:	43db      	mvns	r3, r3
          pHandle->ADC_ExternalPolarityInjected = (uint16_t)LL_ADC_INJ_TRIG_EXT_FALLING;
 8009684:	f44f 7280 	mov.w	r2, #256	@ 0x100
          SamplingPoint = (2U * pHandle->Half_PWMPeriod) - SamplingPoint - (uint16_t)1;
 8009688:	eb03 034e 	add.w	r3, r3, lr, lsl #1
          pHandle->ADC_ExternalPolarityInjected = (uint16_t)LL_ADC_INJ_TRIG_EXT_FALLING;
 800968c:	f8a0 2096 	strh.w	r2, [r0, #150]	@ 0x96
          SamplingPoint = (2U * pHandle->Half_PWMPeriod) - SamplingPoint - (uint16_t)1;
 8009690:	b29b      	uxth	r3, r3
 8009692:	e7d7      	b.n	8009644 <R3_1_SetADCSampPointSectX+0x2c>
}
 8009694:	4770      	bx	lr
        SamplingPoint = pHdl->lowDuty - pHandle->pParams_str->Tbefore;
 8009696:	f8b1 2058 	ldrh.w	r2, [r1, #88]	@ 0x58
 800969a:	1a9b      	subs	r3, r3, r2
 800969c:	b29b      	uxth	r3, r3
 800969e:	e7d1      	b.n	8009644 <R3_1_SetADCSampPointSectX+0x2c>
 80096a0:	02000070 	.word	0x02000070

080096a4 <R3_1_TIMx_UP_IRQHandler>:
  if (MC_NULL == pHandle)
 80096a4:	4602      	mov	r2, r0
 80096a6:	2800      	cmp	r0, #0
 80096a8:	d034      	beq.n	8009714 <R3_1_TIMx_UP_IRQHandler+0x70>
{
 80096aa:	b4f0      	push	{r4, r5, r6, r7}
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 80096ac:	f8d0 009c 	ldr.w	r0, [r0, #156]	@ 0x9c
    ADCx->JSQR = pHandle->pParams_str->ADCConfig[pHandle->_Super.Sector] | (uint32_t) pHandle->ADC_ExternalPolarityInjected;
 80096b0:	f892 c07a 	ldrb.w	ip, [r2, #122]	@ 0x7a
    ADC_TypeDef *ADCx = pHandle->pParams_str->ADCx;
 80096b4:	6801      	ldr	r1, [r0, #0]
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 80096b6:	e9d0 5401 	ldrd	r5, r4, [r0, #4]
    if (OPAMPParams != NULL)
 80096ba:	b1ac      	cbz	r4, 80096e8 <R3_1_TIMx_UP_IRQHandler+0x44>
      while (ADCx->JSQR != 0x0u)
 80096bc:	6ccb      	ldr	r3, [r1, #76]	@ 0x4c
 80096be:	2b00      	cmp	r3, #0
 80096c0:	d1fc      	bne.n	80096bc <R3_1_TIMx_UP_IRQHandler+0x18>
      operationAmp = OPAMPParams->OPAMPSelect_1[pHandle->_Super.Sector];
 80096c2:	f854 702c 	ldr.w	r7, [r4, ip, lsl #2]
      if (operationAmp != NULL)
 80096c6:	eb04 048c 	add.w	r4, r4, ip, lsl #2
 80096ca:	b12f      	cbz	r7, 80096d8 <R3_1_TIMx_UP_IRQHandler+0x34>
        MODIFY_REG(operationAmp->CSR, (OPAMP_CSR_OPAMPINTEN | OPAMP_CSR_VPSEL), OpampConfig);
 80096cc:	683b      	ldr	r3, [r7, #0]
 80096ce:	6b26      	ldr	r6, [r4, #48]	@ 0x30
 80096d0:	f423 7386 	bic.w	r3, r3, #268	@ 0x10c
 80096d4:	4333      	orrs	r3, r6
 80096d6:	603b      	str	r3, [r7, #0]
      operationAmp = OPAMPParams->OPAMPSelect_2[pHandle->_Super.Sector];
 80096d8:	69a6      	ldr	r6, [r4, #24]
      if (operationAmp != NULL)
 80096da:	b12e      	cbz	r6, 80096e8 <R3_1_TIMx_UP_IRQHandler+0x44>
        MODIFY_REG(operationAmp->CSR, (OPAMP_CSR_OPAMPINTEN | OPAMP_CSR_VPSEL), OpampConfig);
 80096dc:	6833      	ldr	r3, [r6, #0]
 80096de:	6ca4      	ldr	r4, [r4, #72]	@ 0x48
 80096e0:	f423 7386 	bic.w	r3, r3, #268	@ 0x10c
 80096e4:	4323      	orrs	r3, r4
 80096e6:	6033      	str	r3, [r6, #0]
    ADCx->JSQR = pHandle->pParams_str->ADCConfig[pHandle->_Super.Sector] | (uint32_t) pHandle->ADC_ExternalPolarityInjected;
 80096e8:	eb00 008c 	add.w	r0, r0, ip, lsl #2
 80096ec:	f8b2 3096 	ldrh.w	r3, [r2, #150]	@ 0x96
 80096f0:	6bc0      	ldr	r0, [r0, #60]	@ 0x3c
 80096f2:	4303      	orrs	r3, r0
 80096f4:	64cb      	str	r3, [r1, #76]	@ 0x4c
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 80096f6:	686b      	ldr	r3, [r5, #4]
 80096f8:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
 80096fc:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
    pHandle->ADC_ExternalPolarityInjected = (uint16_t)LL_ADC_INJ_TRIG_EXT_RISING;
 8009700:	2180      	movs	r1, #128	@ 0x80
 8009702:	f043 0370 	orr.w	r3, r3, #112	@ 0x70
 8009706:	606b      	str	r3, [r5, #4]
    tempPointer = &(pHandle->_Super.Motor);
 8009708:	f102 0078 	add.w	r0, r2, #120	@ 0x78
}
 800970c:	bcf0      	pop	{r4, r5, r6, r7}
    pHandle->ADC_ExternalPolarityInjected = (uint16_t)LL_ADC_INJ_TRIG_EXT_RISING;
 800970e:	f8a2 1096 	strh.w	r1, [r2, #150]	@ 0x96
}
 8009712:	4770      	bx	lr
 8009714:	4770      	bx	lr
 8009716:	bf00      	nop

08009718 <R3_1_RLDetectionModeEnable>:
  if (false == pHandle->_Super.RLDetectionMode)
 8009718:	f890 107e 	ldrb.w	r1, [r0, #126]	@ 0x7e
{
 800971c:	b410      	push	{r4}
  if (false == pHandle->_Super.RLDetectionMode)
 800971e:	2900      	cmp	r1, #0
 8009720:	d13f      	bne.n	80097a2 <R3_1_RLDetectionModeEnable+0x8a>
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009722:	f8d0 309c 	ldr.w	r3, [r0, #156]	@ 0x9c
 8009726:	685b      	ldr	r3, [r3, #4]
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 8009728:	699a      	ldr	r2, [r3, #24]
 800972a:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 800972e:	f022 0273 	bic.w	r2, r2, #115	@ 0x73
 8009732:	f042 0260 	orr.w	r2, r2, #96	@ 0x60
 8009736:	619a      	str	r2, [r3, #24]
  SET_BIT(TIMx->CCER, Channels);
 8009738:	6a1a      	ldr	r2, [r3, #32]
 800973a:	f042 0201 	orr.w	r2, r2, #1
 800973e:	621a      	str	r2, [r3, #32]
  CLEAR_BIT(TIMx->CCER, Channels);
 8009740:	6a1a      	ldr	r2, [r3, #32]
 8009742:	f022 0204 	bic.w	r2, r2, #4
 8009746:	621a      	str	r2, [r3, #32]
  WRITE_REG(TIMx->CCR1, CompareValue);
 8009748:	6359      	str	r1, [r3, #52]	@ 0x34
    if (LS_PWM_TIMER == pHandle->_Super.LowSideOutputs)
 800974a:	f890 207b 	ldrb.w	r2, [r0, #123]	@ 0x7b
 800974e:	2a01      	cmp	r2, #1
  __IO uint32_t *pReg = (__IO uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
 8009750:	f103 0418 	add.w	r4, r3, #24
 8009754:	d033      	beq.n	80097be <R3_1_RLDetectionModeEnable+0xa6>
    else if (ES_GPIO ==  pHandle->_Super.LowSideOutputs)
 8009756:	2a02      	cmp	r2, #2
 8009758:	d10f      	bne.n	800977a <R3_1_RLDetectionModeEnable+0x62>
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 800975a:	699a      	ldr	r2, [r3, #24]
 800975c:	f022 7280 	bic.w	r2, r2, #16777216	@ 0x1000000
 8009760:	f422 42e6 	bic.w	r2, r2, #29440	@ 0x7300
 8009764:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
 8009768:	619a      	str	r2, [r3, #24]
  SET_BIT(TIMx->CCER, Channels);
 800976a:	6a1a      	ldr	r2, [r3, #32]
 800976c:	f042 0210 	orr.w	r2, r2, #16
 8009770:	621a      	str	r2, [r3, #32]
  CLEAR_BIT(TIMx->CCER, Channels);
 8009772:	6a1a      	ldr	r2, [r3, #32]
 8009774:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 8009778:	621a      	str	r2, [r3, #32]
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 800977a:	6862      	ldr	r2, [r4, #4]
 800977c:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 8009780:	f022 0273 	bic.w	r2, r2, #115	@ 0x73
 8009784:	f042 0270 	orr.w	r2, r2, #112	@ 0x70
 8009788:	6062      	str	r2, [r4, #4]
  CLEAR_BIT(TIMx->CCER, Channels);
 800978a:	6a1a      	ldr	r2, [r3, #32]
    pHandle->PhaseAOffset = pHandle->PhaseBOffset; /* Use only the offset of phB */
 800978c:	f8d0 108c 	ldr.w	r1, [r0, #140]	@ 0x8c
 8009790:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
 8009794:	621a      	str	r2, [r3, #32]
 8009796:	6a1a      	ldr	r2, [r3, #32]
 8009798:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 800979c:	621a      	str	r2, [r3, #32]
 800979e:	f8c0 1088 	str.w	r1, [r0, #136]	@ 0x88
  pHandle->_Super.pFctTurnOnLowSides = &R3_1_RLTurnOnLowSides;
 80097a2:	4b0f      	ldr	r3, [pc, #60]	@ (80097e0 <R3_1_RLDetectionModeEnable+0xc8>)
  pHandle->_Super.pFctSwitchOnPwm = &R3_1_RLSwitchOnPWM;
 80097a4:	490f      	ldr	r1, [pc, #60]	@ (80097e4 <R3_1_RLDetectionModeEnable+0xcc>)
  pHandle->_Super.pFctSwitchOffPwm = &R3_1_SwitchOffPWM;
 80097a6:	4a10      	ldr	r2, [pc, #64]	@ (80097e8 <R3_1_RLDetectionModeEnable+0xd0>)
  pHandle->_Super.pFctGetPhaseCurrents = &R3_1_RLGetPhaseCurrents;
 80097a8:	4c10      	ldr	r4, [pc, #64]	@ (80097ec <R3_1_RLDetectionModeEnable+0xd4>)
  pHandle->_Super.pFctTurnOnLowSides = &R3_1_RLTurnOnLowSides;
 80097aa:	6103      	str	r3, [r0, #16]
  pHandle->_Super.RLDetectionMode = true;
 80097ac:	2301      	movs	r3, #1
  pHandle->_Super.pFctGetPhaseCurrents = &R3_1_RLGetPhaseCurrents;
 80097ae:	6004      	str	r4, [r0, #0]
  pHandle->_Super.pFctSwitchOffPwm = &R3_1_SwitchOffPWM;
 80097b0:	e9c0 2101 	strd	r2, r1, [r0, #4]
}
 80097b4:	f85d 4b04 	ldr.w	r4, [sp], #4
  pHandle->_Super.RLDetectionMode = true;
 80097b8:	f880 307e 	strb.w	r3, [r0, #126]	@ 0x7e
}
 80097bc:	4770      	bx	lr
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 80097be:	699a      	ldr	r2, [r3, #24]
 80097c0:	f022 7280 	bic.w	r2, r2, #16777216	@ 0x1000000
 80097c4:	f422 42e6 	bic.w	r2, r2, #29440	@ 0x7300
 80097c8:	f442 5280 	orr.w	r2, r2, #4096	@ 0x1000
 80097cc:	619a      	str	r2, [r3, #24]
  CLEAR_BIT(TIMx->CCER, Channels);
 80097ce:	6a1a      	ldr	r2, [r3, #32]
 80097d0:	f022 0210 	bic.w	r2, r2, #16
 80097d4:	621a      	str	r2, [r3, #32]
  SET_BIT(TIMx->CCER, Channels);
 80097d6:	6a1a      	ldr	r2, [r3, #32]
 80097d8:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 80097dc:	621a      	str	r2, [r3, #32]
}
 80097de:	e7cc      	b.n	800977a <R3_1_RLDetectionModeEnable+0x62>
 80097e0:	08009155 	.word	0x08009155
 80097e4:	08008fd1 	.word	0x08008fd1
 80097e8:	08008f09 	.word	0x08008f09
 80097ec:	08008f85 	.word	0x08008f85

080097f0 <R3_1_RLDetectionModeDisable>:
  if (true ==  pHandle->_Super.RLDetectionMode)
 80097f0:	f890 307e 	ldrb.w	r3, [r0, #126]	@ 0x7e
 80097f4:	2b00      	cmp	r3, #0
 80097f6:	d03d      	beq.n	8009874 <R3_1_RLDetectionModeDisable+0x84>
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 80097f8:	f8d0 309c 	ldr.w	r3, [r0, #156]	@ 0x9c
    LL_TIM_OC_SetCompareCH1(TIMx, ((uint32_t)pHandle->Half_PWMPeriod) >> 1);
 80097fc:	f8b0 1094 	ldrh.w	r1, [r0, #148]	@ 0x94
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009800:	685b      	ldr	r3, [r3, #4]
{
 8009802:	b410      	push	{r4}
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 8009804:	699a      	ldr	r2, [r3, #24]
 8009806:	4c40      	ldr	r4, [pc, #256]	@ (8009908 <R3_1_RLDetectionModeDisable+0x118>)
 8009808:	4022      	ands	r2, r4
 800980a:	f042 0260 	orr.w	r2, r2, #96	@ 0x60
 800980e:	619a      	str	r2, [r3, #24]
  SET_BIT(TIMx->CCER, Channels);
 8009810:	6a1a      	ldr	r2, [r3, #32]
 8009812:	f042 0201 	orr.w	r2, r2, #1
 8009816:	621a      	str	r2, [r3, #32]
    if (LS_PWM_TIMER == pHandle->_Super.LowSideOutputs)
 8009818:	f890 207b 	ldrb.w	r2, [r0, #123]	@ 0x7b
 800981c:	2a01      	cmp	r2, #1
    LL_TIM_OC_SetCompareCH1(TIMx, ((uint32_t)pHandle->Half_PWMPeriod) >> 1);
 800981e:	ea4f 0151 	mov.w	r1, r1, lsr #1
    if (LS_PWM_TIMER == pHandle->_Super.LowSideOutputs)
 8009822:	d028      	beq.n	8009876 <R3_1_RLDetectionModeDisable+0x86>
    else if (ES_GPIO == pHandle->_Super.LowSideOutputs)
 8009824:	2a02      	cmp	r2, #2
 8009826:	d04a      	beq.n	80098be <R3_1_RLDetectionModeDisable+0xce>
  WRITE_REG(TIMx->CCR1, CompareValue);
 8009828:	6359      	str	r1, [r3, #52]	@ 0x34
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 800982a:	699a      	ldr	r2, [r3, #24]
 800982c:	f022 7280 	bic.w	r2, r2, #16777216	@ 0x1000000
 8009830:	f422 42e6 	bic.w	r2, r2, #29440	@ 0x7300
 8009834:	f442 42c0 	orr.w	r2, r2, #24576	@ 0x6000
 8009838:	619a      	str	r2, [r3, #24]
  SET_BIT(TIMx->CCER, Channels);
 800983a:	6a1a      	ldr	r2, [r3, #32]
 800983c:	f042 0210 	orr.w	r2, r2, #16
 8009840:	621a      	str	r2, [r3, #32]
  WRITE_REG(TIMx->CCR2, CompareValue);
 8009842:	6399      	str	r1, [r3, #56]	@ 0x38
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 8009844:	69da      	ldr	r2, [r3, #28]
 8009846:	4022      	ands	r2, r4
 8009848:	f042 0260 	orr.w	r2, r2, #96	@ 0x60
 800984c:	61da      	str	r2, [r3, #28]
  SET_BIT(TIMx->CCER, Channels);
 800984e:	6a1a      	ldr	r2, [r3, #32]
 8009850:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 8009854:	621a      	str	r2, [r3, #32]
    pHandle->_Super.pFctGetPhaseCurrents = &R3_1_GetPhaseCurrents;
 8009856:	4a2d      	ldr	r2, [pc, #180]	@ (800990c <R3_1_RLDetectionModeDisable+0x11c>)
  WRITE_REG(TIMx->CCR3, CompareValue);
 8009858:	63d9      	str	r1, [r3, #60]	@ 0x3c
    pHandle->_Super.pFctSwitchOnPwm = &R3_1_SwitchOnPWM;
 800985a:	492d      	ldr	r1, [pc, #180]	@ (8009910 <R3_1_RLDetectionModeDisable+0x120>)
    pHandle->_Super.pFctGetPhaseCurrents = &R3_1_GetPhaseCurrents;
 800985c:	6002      	str	r2, [r0, #0]
    pHandle->_Super.pFctSwitchOffPwm = &R3_1_SwitchOffPWM;
 800985e:	4a2d      	ldr	r2, [pc, #180]	@ (8009914 <R3_1_RLDetectionModeDisable+0x124>)
    pHandle->_Super.pFctTurnOnLowSides = &R3_1_TurnOnLowSides;
 8009860:	4c2d      	ldr	r4, [pc, #180]	@ (8009918 <R3_1_RLDetectionModeDisable+0x128>)
 8009862:	6104      	str	r4, [r0, #16]
    pHandle->_Super.RLDetectionMode = false;
 8009864:	2300      	movs	r3, #0
    pHandle->_Super.pFctSwitchOffPwm = &R3_1_SwitchOffPWM;
 8009866:	e9c0 2101 	strd	r2, r1, [r0, #4]
}
 800986a:	f85d 4b04 	ldr.w	r4, [sp], #4
    pHandle->_Super.RLDetectionMode = false;
 800986e:	f880 307e 	strb.w	r3, [r0, #126]	@ 0x7e
}
 8009872:	4770      	bx	lr
 8009874:	4770      	bx	lr
  SET_BIT(TIMx->CCER, Channels);
 8009876:	6a1a      	ldr	r2, [r3, #32]
 8009878:	f042 0204 	orr.w	r2, r2, #4
 800987c:	621a      	str	r2, [r3, #32]
  WRITE_REG(TIMx->CCR1, CompareValue);
 800987e:	6359      	str	r1, [r3, #52]	@ 0x34
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 8009880:	699a      	ldr	r2, [r3, #24]
 8009882:	f022 7280 	bic.w	r2, r2, #16777216	@ 0x1000000
 8009886:	f422 42e6 	bic.w	r2, r2, #29440	@ 0x7300
 800988a:	f442 42c0 	orr.w	r2, r2, #24576	@ 0x6000
 800988e:	619a      	str	r2, [r3, #24]
  SET_BIT(TIMx->CCER, Channels);
 8009890:	6a1a      	ldr	r2, [r3, #32]
 8009892:	f042 0210 	orr.w	r2, r2, #16
 8009896:	621a      	str	r2, [r3, #32]
 8009898:	6a1a      	ldr	r2, [r3, #32]
 800989a:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 800989e:	621a      	str	r2, [r3, #32]
  WRITE_REG(TIMx->CCR2, CompareValue);
 80098a0:	6399      	str	r1, [r3, #56]	@ 0x38
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 80098a2:	69da      	ldr	r2, [r3, #28]
 80098a4:	4022      	ands	r2, r4
 80098a6:	f042 0260 	orr.w	r2, r2, #96	@ 0x60
 80098aa:	61da      	str	r2, [r3, #28]
  SET_BIT(TIMx->CCER, Channels);
 80098ac:	6a1a      	ldr	r2, [r3, #32]
 80098ae:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 80098b2:	621a      	str	r2, [r3, #32]
 80098b4:	6a1a      	ldr	r2, [r3, #32]
 80098b6:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 80098ba:	621a      	str	r2, [r3, #32]
}
 80098bc:	e7cb      	b.n	8009856 <R3_1_RLDetectionModeDisable+0x66>
  CLEAR_BIT(TIMx->CCER, Channels);
 80098be:	6a1a      	ldr	r2, [r3, #32]
 80098c0:	f022 0204 	bic.w	r2, r2, #4
 80098c4:	621a      	str	r2, [r3, #32]
  WRITE_REG(TIMx->CCR1, CompareValue);
 80098c6:	6359      	str	r1, [r3, #52]	@ 0x34
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 80098c8:	699a      	ldr	r2, [r3, #24]
 80098ca:	f022 7280 	bic.w	r2, r2, #16777216	@ 0x1000000
 80098ce:	f422 42e6 	bic.w	r2, r2, #29440	@ 0x7300
 80098d2:	f442 42c0 	orr.w	r2, r2, #24576	@ 0x6000
 80098d6:	619a      	str	r2, [r3, #24]
  SET_BIT(TIMx->CCER, Channels);
 80098d8:	6a1a      	ldr	r2, [r3, #32]
 80098da:	f042 0210 	orr.w	r2, r2, #16
 80098de:	621a      	str	r2, [r3, #32]
  CLEAR_BIT(TIMx->CCER, Channels);
 80098e0:	6a1a      	ldr	r2, [r3, #32]
 80098e2:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 80098e6:	621a      	str	r2, [r3, #32]
  WRITE_REG(TIMx->CCR2, CompareValue);
 80098e8:	6399      	str	r1, [r3, #56]	@ 0x38
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 80098ea:	69da      	ldr	r2, [r3, #28]
 80098ec:	4022      	ands	r2, r4
 80098ee:	f042 0260 	orr.w	r2, r2, #96	@ 0x60
 80098f2:	61da      	str	r2, [r3, #28]
  SET_BIT(TIMx->CCER, Channels);
 80098f4:	6a1a      	ldr	r2, [r3, #32]
 80098f6:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 80098fa:	621a      	str	r2, [r3, #32]
  CLEAR_BIT(TIMx->CCER, Channels);
 80098fc:	6a1a      	ldr	r2, [r3, #32]
 80098fe:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 8009902:	621a      	str	r2, [r3, #32]
}
 8009904:	e7a7      	b.n	8009856 <R3_1_RLDetectionModeDisable+0x66>
 8009906:	bf00      	nop
 8009908:	fffeff8c 	.word	0xfffeff8c
 800990c:	08008c21 	.word	0x08008c21
 8009910:	08008e75 	.word	0x08008e75
 8009914:	08008f09 	.word	0x08008f09
 8009918:	08009069 	.word	0x08009069

0800991c <R3_1_RLDetectionModeSetDuty>:
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 800991c:	f8d0 209c 	ldr.w	r2, [r0, #156]	@ 0x9c
    val = (((uint32_t)pHandle->Half_PWMPeriod) * ((uint32_t)hDuty)) >> 16;
 8009920:	f8b0 c094 	ldrh.w	ip, [r0, #148]	@ 0x94
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009924:	6852      	ldr	r2, [r2, #4]
{
 8009926:	4603      	mov	r3, r0
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 8009928:	69d0      	ldr	r0, [r2, #28]
 800992a:	f020 7080 	bic.w	r0, r0, #16777216	@ 0x1000000
    val = (((uint32_t)pHandle->Half_PWMPeriod) * ((uint32_t)hDuty)) >> 16;
 800992e:	fb0c f101 	mul.w	r1, ip, r1
 8009932:	f420 40e6 	bic.w	r0, r0, #29440	@ 0x7300
{
 8009936:	b410      	push	{r4}
    val = (((uint32_t)pHandle->Half_PWMPeriod) * ((uint32_t)hDuty)) >> 16;
 8009938:	0c09      	lsrs	r1, r1, #16
    pHandle->ADCRegularLocked = true;
 800993a:	2401      	movs	r4, #1
 800993c:	f440 40e0 	orr.w	r0, r0, #28672	@ 0x7000
 8009940:	f883 40a0 	strb.w	r4, [r3, #160]	@ 0xa0
    pHandle->_Super.CntPhA = (uint16_t)val;
 8009944:	f8a3 1050 	strh.w	r1, [r3, #80]	@ 0x50
 8009948:	61d0      	str	r0, [r2, #28]
    LL_TIM_OC_SetCompareCH4(TIMx, (((uint32_t)pHandle->Half_PWMPeriod) - ((uint32_t)pHandle->_Super.Ton)));
 800994a:	f8b3 0074 	ldrh.w	r0, [r3, #116]	@ 0x74
    LL_TIM_OC_SetCompareCH3(TIMx, (uint32_t)pHandle->_Super.Toff);
 800994e:	f8b3 4076 	ldrh.w	r4, [r3, #118]	@ 0x76
    LL_TIM_OC_SetCompareCH4(TIMx, (((uint32_t)pHandle->Half_PWMPeriod) - ((uint32_t)pHandle->_Super.Ton)));
 8009952:	ebac 0000 	sub.w	r0, ip, r0
  WRITE_REG(TIMx->CCR4, CompareValue);
 8009956:	6410      	str	r0, [r2, #64]	@ 0x40
  WRITE_REG(TIMx->CCR3, CompareValue);
 8009958:	63d4      	str	r4, [r2, #60]	@ 0x3c
  WRITE_REG(TIMx->CCR1, CompareValue);
 800995a:	6351      	str	r1, [r2, #52]	@ 0x34
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 800995c:	6851      	ldr	r1, [r2, #4]
    if (1U ==  pHandle->_Super.SWerror)
 800995e:	f8b3 0056 	ldrh.w	r0, [r3, #86]	@ 0x56
 8009962:	f021 7100 	bic.w	r1, r1, #33554432	@ 0x2000000
 8009966:	f021 0170 	bic.w	r1, r1, #112	@ 0x70
    pHdl->Sector = SECTOR_4;
 800996a:	f04f 0c03 	mov.w	ip, #3
 800996e:	f041 0170 	orr.w	r1, r1, #112	@ 0x70
 8009972:	6051      	str	r1, [r2, #4]
    if (1U ==  pHandle->_Super.SWerror)
 8009974:	2801      	cmp	r0, #1
    pHdl->Sector = SECTOR_4;
 8009976:	f883 c07a 	strb.w	ip, [r3, #122]	@ 0x7a
    if (((TIMx->CR2) & TIM_CR2_MMS_Msk) != LL_TIM_TRGO_RESET)
 800997a:	6852      	ldr	r2, [r2, #4]
    if (1U ==  pHandle->_Super.SWerror)
 800997c:	d007      	beq.n	800998e <R3_1_RLDetectionModeSetDuty+0x72>
    if (((TIMx->CR2) & TIM_CR2_MMS_Msk) != LL_TIM_TRGO_RESET)
 800997e:	4b07      	ldr	r3, [pc, #28]	@ (800999c <R3_1_RLDetectionModeSetDuty+0x80>)
}
 8009980:	f85d 4b04 	ldr.w	r4, [sp], #4
    if (((TIMx->CR2) & TIM_CR2_MMS_Msk) != LL_TIM_TRGO_RESET)
 8009984:	421a      	tst	r2, r3
 8009986:	bf14      	ite	ne
 8009988:	2001      	movne	r0, #1
 800998a:	2000      	moveq	r0, #0
}
 800998c:	4770      	bx	lr
      pHandle->_Super.SWerror = 0U;
 800998e:	2200      	movs	r2, #0
}
 8009990:	f85d 4b04 	ldr.w	r4, [sp], #4
      pHandle->_Super.SWerror = 0U;
 8009994:	f8a3 2056 	strh.w	r2, [r3, #86]	@ 0x56
}
 8009998:	4770      	bx	lr
 800999a:	bf00      	nop
 800999c:	02000070 	.word	0x02000070

080099a0 <R3_1_RLTurnOnLowSidesAndStart>:
  }
  else
  {
#endif
    PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 80099a0:	f8d0 309c 	ldr.w	r3, [r0, #156]	@ 0x9c
 80099a4:	685b      	ldr	r3, [r3, #4]

    pHandle->ADCRegularLocked=true;
 80099a6:	2101      	movs	r1, #1
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 80099a8:	f06f 0201 	mvn.w	r2, #1
{
 80099ac:	b430      	push	{r4, r5}
    pHandle->ADCRegularLocked=true;
 80099ae:	f880 10a0 	strb.w	r1, [r0, #160]	@ 0xa0
 80099b2:	611a      	str	r2, [r3, #16]
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 80099b4:	691a      	ldr	r2, [r3, #16]
 80099b6:	07d1      	lsls	r1, r2, #31
 80099b8:	d5fc      	bpl.n	80099b4 <R3_1_RLTurnOnLowSidesAndStart+0x14>
    LL_TIM_ClearFlag_UPDATE(TIMx);

    LL_TIM_OC_SetCompareCH1(TIMx, 0x0U);
    LL_TIM_OC_SetCompareCH2(TIMx, 0x0U);
    LL_TIM_OC_SetCompareCH3(TIMx, 0x0U);
    LL_TIM_OC_SetCompareCH4(TIMx, ((uint32_t )pHandle->Half_PWMPeriod) - 5U);
 80099ba:	f8b0 2094 	ldrh.w	r2, [r0, #148]	@ 0x94
  WRITE_REG(TIMx->CCR1, CompareValue);
 80099be:	2100      	movs	r1, #0
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 80099c0:	f06f 0401 	mvn.w	r4, #1
 80099c4:	3a05      	subs	r2, #5
 80099c6:	611c      	str	r4, [r3, #16]
  WRITE_REG(TIMx->CCR1, CompareValue);
 80099c8:	6359      	str	r1, [r3, #52]	@ 0x34
  WRITE_REG(TIMx->CCR2, CompareValue);
 80099ca:	6399      	str	r1, [r3, #56]	@ 0x38
  WRITE_REG(TIMx->CCR3, CompareValue);
 80099cc:	63d9      	str	r1, [r3, #60]	@ 0x3c
  WRITE_REG(TIMx->CCR4, CompareValue);
 80099ce:	641a      	str	r2, [r3, #64]	@ 0x40
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 80099d0:	691a      	ldr	r2, [r3, #16]
 80099d2:	07d2      	lsls	r2, r2, #31
 80099d4:	d5fc      	bpl.n	80099d0 <R3_1_RLTurnOnLowSidesAndStart+0x30>
    {
      /* Nothing to do */
    }

    /* Main PWM Output Enable */
    TIMx->BDTR |= LL_TIM_OSSI_ENABLE ;
 80099d6:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 80099d8:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 80099dc:	645a      	str	r2, [r3, #68]	@ 0x44
  SET_BIT(TIMx->BDTR, TIM_BDTR_MOE);
 80099de:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 80099e0:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 80099e4:	645a      	str	r2, [r3, #68]	@ 0x44
    LL_TIM_EnableAllOutputs (TIMx);

    if (ES_GPIO == pHandle->_Super.LowSideOutputs )
 80099e6:	f890 207b 	ldrb.w	r2, [r0, #123]	@ 0x7b
 80099ea:	2a02      	cmp	r2, #2
 80099ec:	d10b      	bne.n	8009a06 <R3_1_RLTurnOnLowSidesAndStart+0x66>
    {
      /* It is executed during calibration phase the EN signal shall stay off */
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_u_port, pHandle->_Super.pwm_en_u_pin);
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 80099ee:	e9d0 410f 	ldrd	r4, r1, [r0, #60]	@ 0x3c
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_u_port, pHandle->_Super.pwm_en_u_pin);
 80099f2:	f8b0 5048 	ldrh.w	r5, [r0, #72]	@ 0x48
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 80099f6:	6c42      	ldr	r2, [r0, #68]	@ 0x44
  WRITE_REG(GPIOx->BSRR, PinMask);
 80099f8:	61a5      	str	r5, [r4, #24]
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 80099fa:	f8b0 404a 	ldrh.w	r4, [r0, #74]	@ 0x4a
 80099fe:	618c      	str	r4, [r1, #24]
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 8009a00:	f8b0 104c 	ldrh.w	r1, [r0, #76]	@ 0x4c
 8009a04:	6191      	str	r1, [r2, #24]
    else
    {
      /* Nothing to do */
    }

    pHdl->Sector = SECTOR_4;
 8009a06:	2203      	movs	r2, #3
 8009a08:	f880 207a 	strb.w	r2, [r0, #122]	@ 0x7a
  SET_BIT(TIMx->CCER, Channels);
 8009a0c:	6a1a      	ldr	r2, [r3, #32]
 8009a0e:	f442 5280 	orr.w	r2, r2, #4096	@ 0x1000
 8009a12:	621a      	str	r2, [r3, #32]
  SET_BIT(TIMx->DIER, TIM_DIER_UIE);
 8009a14:	68da      	ldr	r2, [r3, #12]
 8009a16:	f042 0201 	orr.w	r2, r2, #1

    LL_TIM_EnableIT_UPDATE(TIMx);
#ifdef NULL_PTR_CHECK_R3_1_PWM_CURR_FDB
  }
#endif
}
 8009a1a:	bc30      	pop	{r4, r5}
 8009a1c:	60da      	str	r2, [r3, #12]
 8009a1e:	4770      	bx	lr

08009a20 <RVBS_Clear>:
  {
#endif
    uint16_t aux;
    uint16_t index;

    aux = (pHandle->OverVoltageThreshold + pHandle->UnderVoltageThreshold) / 2U;
 8009a20:	f8b0 c00c 	ldrh.w	ip, [r0, #12]
 8009a24:	8a42      	ldrh	r2, [r0, #18]
    for (index = 0U; index < pHandle->LowPassFilterBW; index++)
 8009a26:	8943      	ldrh	r3, [r0, #10]
    aux = (pHandle->OverVoltageThreshold + pHandle->UnderVoltageThreshold) / 2U;
 8009a28:	4494      	add	ip, r2
 8009a2a:	ea4f 0c5c 	mov.w	ip, ip, lsr #1
{
 8009a2e:	b430      	push	{r4, r5}
 8009a30:	2500      	movs	r5, #0
 8009a32:	f36c 050f 	bfi	r5, ip, #0, #16
 8009a36:	f36c 451f 	bfi	r5, ip, #16, #16
    for (index = 0U; index < pHandle->LowPassFilterBW; index++)
 8009a3a:	b14b      	cbz	r3, 8009a50 <RVBS_Clear+0x30>
    {
      pHandle->aBuffer[index] = aux;
 8009a3c:	6944      	ldr	r4, [r0, #20]
 8009a3e:	2300      	movs	r3, #0
 8009a40:	b29a      	uxth	r2, r3
    for (index = 0U; index < pHandle->LowPassFilterBW; index++)
 8009a42:	3301      	adds	r3, #1
      pHandle->aBuffer[index] = aux;
 8009a44:	f824 c012 	strh.w	ip, [r4, r2, lsl #1]
    for (index = 0U; index < pHandle->LowPassFilterBW; index++)
 8009a48:	8941      	ldrh	r1, [r0, #10]
 8009a4a:	b29a      	uxth	r2, r3
 8009a4c:	4291      	cmp	r1, r2
 8009a4e:	d8f7      	bhi.n	8009a40 <RVBS_Clear+0x20>
    }
    pHandle->_Super.LatestConv = aux;
    pHandle->_Super.AvBusVoltage_d = aux;
    pHandle->index = 0U;
 8009a50:	2300      	movs	r3, #0
    pHandle->_Super.LatestConv = aux;
 8009a52:	6045      	str	r5, [r0, #4]
    pHandle->index = 0U;
 8009a54:	7643      	strb	r3, [r0, #25]
#ifdef NULL_PTR_CHECK_RDIV_BUS_VLT_SNS
  }
#endif
}
 8009a56:	bc30      	pop	{r4, r5}
 8009a58:	4770      	bx	lr
 8009a5a:	bf00      	nop

08009a5c <RVBS_Init>:
{
 8009a5c:	b508      	push	{r3, lr}
    RVBS_Clear(pHandle);
 8009a5e:	f7ff ffdf 	bl	8009a20 <RVBS_Clear>
}
 8009a62:	bd08      	pop	{r3, pc}

08009a64 <RVBS_CheckFaultState>:
  }
  else
  {
#endif
	/* If both thresholds are equal, single threshold feature is used */
	if (pHandle->OverVoltageThreshold == pHandle->OverVoltageThresholdLow)
 8009a64:	8982      	ldrh	r2, [r0, #12]
 8009a66:	89c1      	ldrh	r1, [r0, #14]
	{
      if (pHandle->_Super.AvBusVoltage_d > pHandle->OverVoltageThreshold)
 8009a68:	88c3      	ldrh	r3, [r0, #6]
	if (pHandle->OverVoltageThreshold == pHandle->OverVoltageThresholdLow)
 8009a6a:	428a      	cmp	r2, r1
 8009a6c:	d010      	beq.n	8009a90 <RVBS_CheckFaultState+0x2c>
      }
	}
    else
    {
      /* If both thresholds are different, hysteresis feature is used (Brake mode) */
      if (pHandle->_Super.AvBusVoltage_d < pHandle->UnderVoltageThreshold)
 8009a6e:	f8b0 c012 	ldrh.w	ip, [r0, #18]
 8009a72:	459c      	cmp	ip, r3
 8009a74:	d80a      	bhi.n	8009a8c <RVBS_CheckFaultState+0x28>
{
 8009a76:	b410      	push	{r4}
      {
        fault = MC_UNDER_VOLT;
      }
      else if ( false == pHandle->OverVoltageHysteresisUpDir )
 8009a78:	7c04      	ldrb	r4, [r0, #16]
 8009a7a:	b994      	cbnz	r4, 8009aa2 <RVBS_CheckFaultState+0x3e>
      {
        if (pHandle->_Super.AvBusVoltage_d < pHandle->OverVoltageThresholdLow)
 8009a7c:	4299      	cmp	r1, r3
 8009a7e:	d914      	bls.n	8009aaa <RVBS_CheckFaultState+0x46>
        {
          pHandle->OverVoltageHysteresisUpDir = true;
 8009a80:	2301      	movs	r3, #1
 8009a82:	7403      	strb	r3, [r0, #16]
        {
          pHandle->OverVoltageHysteresisUpDir = false;
          fault = MC_OVER_VOLT;
        }
        else{
          fault = MC_NO_ERROR;
 8009a84:	2000      	movs	r0, #0
    }
#ifdef NULL_PTR_CHECK_RDIV_BUS_VLT_SNS
  }
#endif
  return (fault);
}
 8009a86:	f85d 4b04 	ldr.w	r4, [sp], #4
 8009a8a:	4770      	bx	lr
        fault = MC_UNDER_VOLT;
 8009a8c:	2004      	movs	r0, #4
 8009a8e:	4770      	bx	lr
      if (pHandle->_Super.AvBusVoltage_d > pHandle->OverVoltageThreshold)
 8009a90:	429a      	cmp	r2, r3
 8009a92:	d30c      	bcc.n	8009aae <RVBS_CheckFaultState+0x4a>
      else if (pHandle->_Super.AvBusVoltage_d < pHandle->UnderVoltageThreshold)
 8009a94:	8a40      	ldrh	r0, [r0, #18]
 8009a96:	4298      	cmp	r0, r3
 8009a98:	bf94      	ite	ls
 8009a9a:	2000      	movls	r0, #0
 8009a9c:	2001      	movhi	r0, #1
 8009a9e:	0080      	lsls	r0, r0, #2
 8009aa0:	4770      	bx	lr
        if (pHandle->_Super.AvBusVoltage_d > pHandle->OverVoltageThreshold)
 8009aa2:	429a      	cmp	r2, r3
 8009aa4:	d2ee      	bcs.n	8009a84 <RVBS_CheckFaultState+0x20>
          pHandle->OverVoltageHysteresisUpDir = false;
 8009aa6:	2300      	movs	r3, #0
 8009aa8:	7403      	strb	r3, [r0, #16]
          fault = MC_OVER_VOLT;
 8009aaa:	2002      	movs	r0, #2
 8009aac:	e7eb      	b.n	8009a86 <RVBS_CheckFaultState+0x22>
 8009aae:	2002      	movs	r0, #2
}
 8009ab0:	4770      	bx	lr
 8009ab2:	bf00      	nop

08009ab4 <RVBS_CalcAvVbus>:
{
 8009ab4:	b538      	push	{r3, r4, r5, lr}
    if (0xFFFFU == hAux)
 8009ab6:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 8009aba:	4299      	cmp	r1, r3
{
 8009abc:	4604      	mov	r4, r0
    if (0xFFFFU == hAux)
 8009abe:	d021      	beq.n	8009b04 <RVBS_CalcAvVbus+0x50>
      pHandle->aBuffer[pHandle->index] = hAux;
 8009ac0:	6943      	ldr	r3, [r0, #20]
 8009ac2:	7e45      	ldrb	r5, [r0, #25]
 8009ac4:	f823 1015 	strh.w	r1, [r3, r5, lsl #1]
      for (i = 0U; i < (uint8_t)pHandle->LowPassFilterBW; i++)
 8009ac8:	f8b0 e00a 	ldrh.w	lr, [r0, #10]
 8009acc:	f01e 02ff 	ands.w	r2, lr, #255	@ 0xff
 8009ad0:	d00d      	beq.n	8009aee <RVBS_CalcAvVbus+0x3a>
 8009ad2:	3a01      	subs	r2, #1
 8009ad4:	b2d2      	uxtb	r2, r2
 8009ad6:	eb03 0042 	add.w	r0, r3, r2, lsl #1
 8009ada:	3b02      	subs	r3, #2
      wtemp = 0u;
 8009adc:	2200      	movs	r2, #0
        wtemp += pHandle->aBuffer[i];
 8009ade:	f833 cf02 	ldrh.w	ip, [r3, #2]!
      for (i = 0U; i < (uint8_t)pHandle->LowPassFilterBW; i++)
 8009ae2:	4298      	cmp	r0, r3
        wtemp += pHandle->aBuffer[i];
 8009ae4:	4462      	add	r2, ip
      for (i = 0U; i < (uint8_t)pHandle->LowPassFilterBW; i++)
 8009ae6:	d1fa      	bne.n	8009ade <RVBS_CalcAvVbus+0x2a>
      wtemp /= pHandle->LowPassFilterBW;
 8009ae8:	fbb2 f2fe 	udiv	r2, r2, lr
      pHandle->_Super.AvBusVoltage_d = (uint16_t)wtemp;
 8009aec:	b292      	uxth	r2, r2
      if ((uint16_t)pHandle->index < (pHandle->LowPassFilterBW - 1U))
 8009aee:	f10e 3eff 	add.w	lr, lr, #4294967295
 8009af2:	4575      	cmp	r5, lr
        pHandle->index++;
 8009af4:	bf34      	ite	cc
 8009af6:	3501      	addcc	r5, #1
        pHandle->index = 0U;
 8009af8:	2300      	movcs	r3, #0
      pHandle->_Super.AvBusVoltage_d = (uint16_t)wtemp;
 8009afa:	80e2      	strh	r2, [r4, #6]
      pHandle->_Super.LatestConv = hAux;
 8009afc:	80a1      	strh	r1, [r4, #4]
        pHandle->index++;
 8009afe:	bf34      	ite	cc
 8009b00:	7665      	strbcc	r5, [r4, #25]
        pHandle->index = 0U;
 8009b02:	7663      	strbcs	r3, [r4, #25]
    pHandle->_Super.FaultState = RVBS_CheckFaultState(pHandle);
 8009b04:	4620      	mov	r0, r4
 8009b06:	f7ff ffad 	bl	8009a64 <RVBS_CheckFaultState>
 8009b0a:	8120      	strh	r0, [r4, #8]
}
 8009b0c:	bd38      	pop	{r3, r4, r5, pc}
 8009b0e:	bf00      	nop

08009b10 <REMNG_Init>:
  }
  else
  {
#endif
    pHandle->Ext = 0;
    pHandle->TargetFinal = 0;
 8009b10:	2300      	movs	r3, #0
    pHandle->RampRemainingStep = 0U;
    pHandle->IncDecAmount = 0;
    pHandle->ScalingFactor = 1U;
 8009b12:	2201      	movs	r2, #1
    pHandle->TargetFinal = 0;
 8009b14:	e9c0 3301 	strd	r3, r3, [r0, #4]
    pHandle->IncDecAmount = 0;
 8009b18:	e9c0 3303 	strd	r3, r3, [r0, #12]
    pHandle->ScalingFactor = 1U;
 8009b1c:	6142      	str	r2, [r0, #20]
#ifdef NULL_PTR_CHECK_RMP_EXT_MNG
  }
#endif
}
 8009b1e:	4770      	bx	lr

08009b20 <SPD_GetMecAngle>:
#ifdef NULL_PTR_CHECK_SPD_POS_FBK
  return ((MC_NULL == pHandle) ? 0 : pHandle->wMecAngle);
#else
  return (pHandle->wMecAngle);
#endif
}
 8009b20:	6880      	ldr	r0, [r0, #8]
 8009b22:	4770      	bx	lr

08009b24 <SPD_GetAvrgMecSpeedUnit>:
#ifdef NULL_PTR_CHECK_SPD_POS_FBK
  return ((MC_NULL == pHandle) ? 0 : pHandle->hAvrMecSpeedUnit);
#else
  return (pHandle->hAvrMecSpeedUnit);
#endif
}
 8009b24:	f9b0 000c 	ldrsh.w	r0, [r0, #12]
 8009b28:	4770      	bx	lr
 8009b2a:	bf00      	nop

08009b2c <SPD_IsMecSpeedReliable>:
    bool SpeedError = false;

    bSpeedErrorNumber = pHandle->bSpeedErrorNumber;

    /* Compute absoulte value of mechanical speed */
    if (*pMecSpeedUnit < 0)
 8009b2c:	f9b1 c000 	ldrsh.w	ip, [r1]
{
 8009b30:	4603      	mov	r3, r0
 8009b32:	b510      	push	{r4, lr}
    {
      hAux = -(*pMecSpeedUnit);
 8009b34:	fa1f f18c 	uxth.w	r1, ip
    if (*pMecSpeedUnit < 0)
 8009b38:	f1bc 0f00 	cmp.w	ip, #0
      hAux = -(*pMecSpeedUnit);
 8009b3c:	bfb8      	it	lt
 8009b3e:	4249      	neglt	r1, r1
    else
    {
      /* Nothing to do */
    }

    if (hAbsMecSpeedUnit < pHandle->hMinReliableMecSpeedUnit)
 8009b40:	f8b3 e016 	ldrh.w	lr, [r3, #22]
    uint8_t bMaximumSpeedErrorsNumber = pHandle->bMaximumSpeedErrorsNumber;
 8009b44:	78c0      	ldrb	r0, [r0, #3]
    bSpeedErrorNumber = pHandle->bSpeedErrorNumber;
 8009b46:	781a      	ldrb	r2, [r3, #0]
    if (hAbsMecSpeedUnit > pHandle->hMaxReliableMecSpeedUnit)
 8009b48:	8a9c      	ldrh	r4, [r3, #20]
    {
      /* Nothing to do */
    }

    /* Compute absoulte value of mechanical acceleration */
    if (pHandle->hMecAccelUnitP < 0)
 8009b4a:	f9b3 c012 	ldrsh.w	ip, [r3, #18]
      hAux = -(*pMecSpeedUnit);
 8009b4e:	bfb8      	it	lt
 8009b50:	b289      	uxthlt	r1, r1
    if (hAbsMecSpeedUnit < pHandle->hMinReliableMecSpeedUnit)
 8009b52:	458e      	cmp	lr, r1
 8009b54:	d816      	bhi.n	8009b84 <SPD_IsMecSpeedReliable+0x58>
    {
      hAux = -(pHandle->hMecAccelUnitP);
 8009b56:	fa1f fe8c 	uxth.w	lr, ip
    if (pHandle->hMecAccelUnitP < 0)
 8009b5a:	f1bc 0f00 	cmp.w	ip, #0
      hAux = -(pHandle->hMecAccelUnitP);
 8009b5e:	bfb8      	it	lt
 8009b60:	f1ce 0e00 	rsblt	lr, lr, #0
    else
    {
      hAbsMecAccelUnitP = (uint16_t)pHandle->hMecAccelUnitP;
    }

    if (hAbsMecAccelUnitP > pHandle->hMaxReliableMecAccelUnitP)
 8009b64:	f8b3 c018 	ldrh.w	ip, [r3, #24]
      hAux = -(pHandle->hMecAccelUnitP);
 8009b68:	bfb8      	it	lt
 8009b6a:	fa1f fe8e 	uxthlt.w	lr, lr
    if (hAbsMecAccelUnitP > pHandle->hMaxReliableMecAccelUnitP)
 8009b6e:	45f4      	cmp	ip, lr
 8009b70:	d308      	bcc.n	8009b84 <SPD_IsMecSpeedReliable+0x58>
    else
    {
      /* Nothing to do */
    }

    if (true == SpeedError)
 8009b72:	428c      	cmp	r4, r1
 8009b74:	d306      	bcc.n	8009b84 <SPD_IsMecSpeedReliable+0x58>
        /* Nothing to do */
      }
    }
    else
    {
      if (bSpeedErrorNumber < bMaximumSpeedErrorsNumber)
 8009b76:	4290      	cmp	r0, r2
 8009b78:	d809      	bhi.n	8009b8e <SPD_IsMecSpeedReliable+0x62>
      {
        /* Nothing to do */
      }
    }

    if (bSpeedErrorNumber == bMaximumSpeedErrorsNumber)
 8009b7a:	1a10      	subs	r0, r2, r0
    else
    {
      /* Nothing to do */
    }

    pHandle->bSpeedErrorNumber = bSpeedErrorNumber;
 8009b7c:	701a      	strb	r2, [r3, #0]
    if (bSpeedErrorNumber == bMaximumSpeedErrorsNumber)
 8009b7e:	bf18      	it	ne
 8009b80:	2001      	movne	r0, #1
#ifdef NULL_PTR_CHECK_SPD_POS_FBK
  }
#endif
  return (SpeedSensorReliability);
}
 8009b82:	bd10      	pop	{r4, pc}
      if (bSpeedErrorNumber < bMaximumSpeedErrorsNumber)
 8009b84:	4290      	cmp	r0, r2
 8009b86:	d9f8      	bls.n	8009b7a <SPD_IsMecSpeedReliable+0x4e>
        bSpeedErrorNumber++;
 8009b88:	3201      	adds	r2, #1
 8009b8a:	b2d2      	uxtb	r2, r2
 8009b8c:	e7f5      	b.n	8009b7a <SPD_IsMecSpeedReliable+0x4e>
        bSpeedErrorNumber = 0u;
 8009b8e:	2200      	movs	r2, #0
    pHandle->bSpeedErrorNumber = bSpeedErrorNumber;
 8009b90:	701a      	strb	r2, [r3, #0]
  bool SpeedSensorReliability = true;
 8009b92:	2001      	movs	r0, #1
}
 8009b94:	bd10      	pop	{r4, pc}
 8009b96:	bf00      	nop

08009b98 <SPD_GetS16Speed>:
  }
  else
  {
#endif
    int32_t wAux = (int32_t)pHandle->hAvrMecSpeedUnit;
    wAux *= INT16_MAX;
 8009b98:	f9b0 300c 	ldrsh.w	r3, [r0, #12]
    wAux /= (int16_t)pHandle->hMaxReliableMecSpeedUnit;
 8009b9c:	f9b0 2014 	ldrsh.w	r2, [r0, #20]
    wAux *= INT16_MAX;
 8009ba0:	ebc3 33c3 	rsb	r3, r3, r3, lsl #15
    wAux /= (int16_t)pHandle->hMaxReliableMecSpeedUnit;
 8009ba4:	fb93 f0f2 	sdiv	r0, r3, r2
    tempValue = (int16_t)wAux;
#ifdef NULL_PTR_CHECK_SPD_POS_FBK
  }
#endif
  return (tempValue);
}
 8009ba8:	b200      	sxth	r0, r0
 8009baa:	4770      	bx	lr

08009bac <STC_Init>:
  {
#endif
    pHandle->PISpeed = pPI;
    pHandle->SPD = SPD_Handle;
    pHandle->Mode = pHandle->ModeDefault;
    pHandle->SpeedRefUnitExt = ((int32_t)pHandle->MecSpeedRefUnitDefault) * 65536;
 8009bac:	f9b0 c02c 	ldrsh.w	ip, [r0, #44]	@ 0x2c
    pHandle->PISpeed = pPI;
 8009bb0:	6101      	str	r1, [r0, #16]
    pHandle->TorqueRef = ((int32_t)pHandle->TorqueRefDefault) * 65536;
 8009bb2:	f9b0 102e 	ldrsh.w	r1, [r0, #46]	@ 0x2e
    pHandle->SPD = SPD_Handle;
 8009bb6:	6142      	str	r2, [r0, #20]
{
 8009bb8:	b410      	push	{r4}
    pHandle->Mode = pHandle->ModeDefault;
 8009bba:	f890 402a 	ldrb.w	r4, [r0, #42]	@ 0x2a
 8009bbe:	7004      	strb	r4, [r0, #0]
    pHandle->TargetFinal = 0;
 8009bc0:	2300      	movs	r3, #0
    pHandle->SpeedRefUnitExt = ((int32_t)pHandle->MecSpeedRefUnitDefault) * 65536;
 8009bc2:	ea4f 440c 	mov.w	r4, ip, lsl #16
    pHandle->TorqueRef = ((int32_t)pHandle->TorqueRefDefault) * 65536;
 8009bc6:	0409      	lsls	r1, r1, #16
 8009bc8:	e9c0 4101 	strd	r4, r1, [r0, #4]
    pHandle->TargetFinal = 0;
 8009bcc:	8043      	strh	r3, [r0, #2]
    pHandle->RampRemainingStep = 0U;
    pHandle->IncDecAmount = 0;
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
}
 8009bce:	f85d 4b04 	ldr.w	r4, [sp], #4
    pHandle->RampRemainingStep = 0U;
 8009bd2:	60c3      	str	r3, [r0, #12]
    pHandle->IncDecAmount = 0;
 8009bd4:	6183      	str	r3, [r0, #24]
}
 8009bd6:	4770      	bx	lr

08009bd8 <STC_SetSpeedSensor>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->SPD = SPD_Handle;
 8009bd8:	6141      	str	r1, [r0, #20]
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
}
 8009bda:	4770      	bx	lr

08009bdc <STC_Clear>:
    /* Nothing to do */
  }
  else
  {
#endif
    if (MCM_SPEED_MODE == pHandle->Mode)
 8009bdc:	7803      	ldrb	r3, [r0, #0]
 8009bde:	2b03      	cmp	r3, #3
 8009be0:	d000      	beq.n	8009be4 <STC_Clear+0x8>
      /* Nothing to do */
    }
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
}
 8009be2:	4770      	bx	lr
      PID_SetIntegralTerm(pHandle->PISpeed, 0);
 8009be4:	6900      	ldr	r0, [r0, #16]
 8009be6:	2100      	movs	r1, #0
 8009be8:	f7fe bf54 	b.w	8008a94 <PID_SetIntegralTerm>

08009bec <STC_GetMecSpeedRefUnit>:
  return ((MC_NULL == pHandle) ? 0 : (int16_t)(pHandle->SpeedRefUnitExt / 65536));
#else
  return ((int16_t)(pHandle->SpeedRefUnitExt / 65536));
#endif
#endif
}
 8009bec:	f9b0 0006 	ldrsh.w	r0, [r0, #6]
 8009bf0:	4770      	bx	lr
 8009bf2:	bf00      	nop

08009bf4 <STC_SetControlMode>:
  }
  else
  {
#endif
    pHandle->Mode = bMode;
    pHandle->RampRemainingStep = 0u; /* Interrupts previous ramp */
 8009bf4:	2300      	movs	r3, #0
    pHandle->Mode = bMode;
 8009bf6:	7001      	strb	r1, [r0, #0]
    pHandle->RampRemainingStep = 0u; /* Interrupts previous ramp */
 8009bf8:	60c3      	str	r3, [r0, #12]
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
}
 8009bfa:	4770      	bx	lr

08009bfc <STC_ExecRamp>:
  * @ref EncAlignCtrl "Encoder Alignment Control",
  * @ref PositionControl "Position Control" loop or
  * speed regulation with @ref SpeedRegulatorPotentiometer Speed potentiometer.
  */
__weak bool STC_ExecRamp(SpeednTorqCtrl_Handle_t *pHandle, int16_t hTargetFinal, uint32_t hDurationms)
{
 8009bfc:	b410      	push	{r4}
    uint32_t wAux;
    int32_t wAux1;
    int16_t hCurrentReference;

    /* Check if the hTargetFinal is out of the bound of application */
    if (MCM_TORQUE_MODE == pHandle->Mode)
 8009bfe:	7803      	ldrb	r3, [r0, #0]
 8009c00:	2b04      	cmp	r3, #4
 8009c02:	d019      	beq.n	8009c38 <STC_ExecRamp+0x3c>
#else
      hCurrentReference = (int16_t)(pHandle->SpeedRefUnitExt / 65536);
#endif

#ifdef CHECK_BOUNDARY
      if ((int32_t)hTargetFinal > (int32_t)pHandle->MaxAppPositiveMecSpeedUnit)
 8009c04:	f8b0 c01e 	ldrh.w	ip, [r0, #30]
 8009c08:	458c      	cmp	ip, r1
 8009c0a:	da03      	bge.n	8009c14 <STC_ExecRamp+0x18>
 8009c0c:	2000      	movs	r0, #0
    }
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
  return (allowedRange);
}
 8009c0e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8009c12:	4770      	bx	lr
      else if (hTargetFinal < pHandle->MinAppNegativeMecSpeedUnit)
 8009c14:	f9b0 4024 	ldrsh.w	r4, [r0, #36]	@ 0x24
 8009c18:	428c      	cmp	r4, r1
 8009c1a:	dcf7      	bgt.n	8009c0c <STC_ExecRamp+0x10>
      else if ((int32_t)hTargetFinal < (int32_t)pHandle->MinAppPositiveMecSpeedUnit)
 8009c1c:	8c04      	ldrh	r4, [r0, #32]
 8009c1e:	428c      	cmp	r4, r1
 8009c20:	dd03      	ble.n	8009c2a <STC_ExecRamp+0x2e>
        if (hTargetFinal > pHandle->MaxAppNegativeMecSpeedUnit)
 8009c22:	f9b0 4022 	ldrsh.w	r4, [r0, #34]	@ 0x22
 8009c26:	428c      	cmp	r4, r1
 8009c28:	dbf0      	blt.n	8009c0c <STC_ExecRamp+0x10>
      hCurrentReference = (int16_t)(pHandle->SpeedRefUnitExt >> 16);
 8009c2a:	6844      	ldr	r4, [r0, #4]
      if (0U == hDurationms)
 8009c2c:	b9b2      	cbnz	r2, 8009c5c <STC_ExecRamp+0x60>
        if (MCM_SPEED_MODE == pHandle->Mode)
 8009c2e:	2b03      	cmp	r3, #3
 8009c30:	d10a      	bne.n	8009c48 <STC_ExecRamp+0x4c>
          pHandle->SpeedRefUnitExt = ((int32_t)hTargetFinal) * 65536;
 8009c32:	0409      	lsls	r1, r1, #16
 8009c34:	6041      	str	r1, [r0, #4]
 8009c36:	e009      	b.n	8009c4c <STC_ExecRamp+0x50>
      if ((int32_t)hTargetFinal > (int32_t)pHandle->MaxPositiveTorque)
 8009c38:	8cc3      	ldrh	r3, [r0, #38]	@ 0x26
 8009c3a:	428b      	cmp	r3, r1
 8009c3c:	dbe6      	blt.n	8009c0c <STC_ExecRamp+0x10>
      if ((int32_t)hTargetFinal < (int32_t)pHandle->MinNegativeTorque)
 8009c3e:	f9b0 3028 	ldrsh.w	r3, [r0, #40]	@ 0x28
 8009c42:	428b      	cmp	r3, r1
 8009c44:	dce2      	bgt.n	8009c0c <STC_ExecRamp+0x10>
      if (0U == hDurationms)
 8009c46:	b9da      	cbnz	r2, 8009c80 <STC_ExecRamp+0x84>
          pHandle->TorqueRef = ((int32_t)hTargetFinal) * 65536;
 8009c48:	0409      	lsls	r1, r1, #16
 8009c4a:	6081      	str	r1, [r0, #8]
        pHandle->IncDecAmount = 0;
 8009c4c:	2300      	movs	r3, #0
 8009c4e:	461a      	mov	r2, r3
        pHandle->RampRemainingStep = 0U;
 8009c50:	60c3      	str	r3, [r0, #12]
        pHandle->IncDecAmount = 0;
 8009c52:	6182      	str	r2, [r0, #24]
}
 8009c54:	f85d 4b04 	ldr.w	r4, [sp], #4
        pHandle->IncDecAmount = 0;
 8009c58:	2001      	movs	r0, #1
}
 8009c5a:	4770      	bx	lr
      hCurrentReference = (int16_t)(pHandle->SpeedRefUnitExt >> 16);
 8009c5c:	ea4f 4c24 	mov.w	ip, r4, asr #16
        wAux = ((uint32_t)hDurationms) * ((uint32_t)pHandle->STCFrequencyHz);
 8009c60:	8b83      	ldrh	r3, [r0, #28]
        wAux /= 1000U;
 8009c62:	4c09      	ldr	r4, [pc, #36]	@ (8009c88 <STC_ExecRamp+0x8c>)
        pHandle->TargetFinal = hTargetFinal;
 8009c64:	8041      	strh	r1, [r0, #2]
        wAux = ((uint32_t)hDurationms) * ((uint32_t)pHandle->STCFrequencyHz);
 8009c66:	fb02 f303 	mul.w	r3, r2, r3
        wAux /= 1000U;
 8009c6a:	fba4 4303 	umull	r4, r3, r4, r3
        wAux1 = (((int32_t)hTargetFinal) - ((int32_t)hCurrentReference)) * 65536;
 8009c6e:	eba1 0c0c 	sub.w	ip, r1, ip
        wAux /= 1000U;
 8009c72:	099b      	lsrs	r3, r3, #6
        wAux1 = (((int32_t)hTargetFinal) - ((int32_t)hCurrentReference)) * 65536;
 8009c74:	ea4f 420c 	mov.w	r2, ip, lsl #16
        pHandle->RampRemainingStep++;
 8009c78:	3301      	adds	r3, #1
        wAux1 /= ((int32_t)pHandle->RampRemainingStep);
 8009c7a:	fb92 f2f3 	sdiv	r2, r2, r3
        pHandle->IncDecAmount = wAux1;
 8009c7e:	e7e7      	b.n	8009c50 <STC_ExecRamp+0x54>
  return ((int16_t)(pHandle->TorqueRef >> 16));
 8009c80:	f9b0 c00a 	ldrsh.w	ip, [r0, #10]
 8009c84:	e7ec      	b.n	8009c60 <STC_ExecRamp+0x64>
 8009c86:	bf00      	nop
 8009c88:	10624dd3 	.word	0x10624dd3

08009c8c <STC_CalcTorqueReference>:
  * - Must be called at fixed time equal to hSTCFrequencyHz. It is called
  * passing as parameter the speed sensor used to perform the speed regulation.
  * - Called during START and ALIGNEMENT states of the MC state machine into MediumFrequencyTask.
  */
__weak int16_t STC_CalcTorqueReference(SpeednTorqCtrl_Handle_t *pHandle)
{
 8009c8c:	b538      	push	{r3, r4, r5, lr}
    int32_t wCurrentReference;
    int16_t hMeasuredSpeed;
    int16_t hTargetSpeed;
    int16_t hError;

    if (MCM_TORQUE_MODE == pHandle->Mode)
 8009c8e:	7802      	ldrb	r2, [r0, #0]
      wCurrentReference = pHandle->SpeedRefUnitExt;
    }

    /* Update the speed reference or the torque reference according to the mode
       and terminates the ramp if needed */
    if (pHandle->RampRemainingStep > 1U)
 8009c90:	68c3      	ldr	r3, [r0, #12]
    if (MCM_TORQUE_MODE == pHandle->Mode)
 8009c92:	2a04      	cmp	r2, #4
{
 8009c94:	4604      	mov	r4, r0
    if (MCM_TORQUE_MODE == pHandle->Mode)
 8009c96:	d012      	beq.n	8009cbe <STC_CalcTorqueReference+0x32>
    if (pHandle->RampRemainingStep > 1U)
 8009c98:	2b01      	cmp	r3, #1
      wCurrentReference = pHandle->SpeedRefUnitExt;
 8009c9a:	6845      	ldr	r5, [r0, #4]
    if (pHandle->RampRemainingStep > 1U)
 8009c9c:	d908      	bls.n	8009cb0 <STC_CalcTorqueReference+0x24>
    {
      /* Increment/decrement the reference value */
      wCurrentReference += pHandle->IncDecAmount;
 8009c9e:	6981      	ldr	r1, [r0, #24]

      /* Decrement the number of remaining steps */
      pHandle->RampRemainingStep--;
 8009ca0:	3b01      	subs	r3, #1
      wCurrentReference += pHandle->IncDecAmount;
 8009ca2:	440d      	add	r5, r1
      pHandle->RampRemainingStep--;
 8009ca4:	60c3      	str	r3, [r0, #12]
    else
    {
      /* Do nothing */
    }

    if (MCM_SPEED_MODE == pHandle->Mode)
 8009ca6:	2a03      	cmp	r2, #3
 8009ca8:	d011      	beq.n	8009cce <STC_CalcTorqueReference+0x42>
    else
    {
      pHandle->TorqueRef = wCurrentReference;
#ifndef FULL_MISRA_C_COMPLIANCY_SPD_TORQ_CTRL
      //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
      hTorqueReference = (int16_t)(wCurrentReference >> 16);
 8009caa:	1428      	asrs	r0, r5, #16
      pHandle->TorqueRef = ((int32_t)hTorqueReference) * 65536;
 8009cac:	60a5      	str	r5, [r4, #8]
    }
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
  return (hTorqueReference);
}
 8009cae:	bd38      	pop	{r3, r4, r5, pc}
    else if (1U == pHandle->RampRemainingStep)
 8009cb0:	d1f9      	bne.n	8009ca6 <STC_CalcTorqueReference+0x1a>
      wCurrentReference = ((int32_t)pHandle->TargetFinal) * 65536;
 8009cb2:	f9b0 5002 	ldrsh.w	r5, [r0, #2]
      pHandle->RampRemainingStep = 0U;
 8009cb6:	2300      	movs	r3, #0
      wCurrentReference = ((int32_t)pHandle->TargetFinal) * 65536;
 8009cb8:	042d      	lsls	r5, r5, #16
      pHandle->RampRemainingStep = 0U;
 8009cba:	60c3      	str	r3, [r0, #12]
 8009cbc:	e7f3      	b.n	8009ca6 <STC_CalcTorqueReference+0x1a>
    if (pHandle->RampRemainingStep > 1U)
 8009cbe:	2b01      	cmp	r3, #1
      wCurrentReference = pHandle->TorqueRef;
 8009cc0:	6885      	ldr	r5, [r0, #8]
    if (pHandle->RampRemainingStep > 1U)
 8009cc2:	d911      	bls.n	8009ce8 <STC_CalcTorqueReference+0x5c>
      wCurrentReference += pHandle->IncDecAmount;
 8009cc4:	6982      	ldr	r2, [r0, #24]
      pHandle->RampRemainingStep--;
 8009cc6:	3b01      	subs	r3, #1
      wCurrentReference += pHandle->IncDecAmount;
 8009cc8:	4415      	add	r5, r2
      pHandle->RampRemainingStep--;
 8009cca:	60c3      	str	r3, [r0, #12]
    if (MCM_SPEED_MODE == pHandle->Mode)
 8009ccc:	e7ed      	b.n	8009caa <STC_CalcTorqueReference+0x1e>
      hMeasuredSpeed = SPD_GetAvrgMecSpeedUnit(pHandle->SPD);
 8009cce:	6960      	ldr	r0, [r4, #20]
 8009cd0:	f7ff ff28 	bl	8009b24 <SPD_GetAvrgMecSpeedUnit>
      hError = hTargetSpeed - hMeasuredSpeed;
 8009cd4:	ebc0 4125 	rsb	r1, r0, r5, asr #16
      hTorqueReference = PI_Controller(pHandle->PISpeed, (int32_t)hError);
 8009cd8:	b209      	sxth	r1, r1
 8009cda:	6920      	ldr	r0, [r4, #16]
 8009cdc:	f7fe ff0c 	bl	8008af8 <PI_Controller>
      pHandle->SpeedRefUnitExt = wCurrentReference;
 8009ce0:	6065      	str	r5, [r4, #4]
      pHandle->TorqueRef = ((int32_t)hTorqueReference) * 65536;
 8009ce2:	0405      	lsls	r5, r0, #16
 8009ce4:	60a5      	str	r5, [r4, #8]
}
 8009ce6:	bd38      	pop	{r3, r4, r5, pc}
    else if (1U == pHandle->RampRemainingStep)
 8009ce8:	d1df      	bne.n	8009caa <STC_CalcTorqueReference+0x1e>
      wCurrentReference = ((int32_t)pHandle->TargetFinal) * 65536;
 8009cea:	f9b0 5002 	ldrsh.w	r5, [r0, #2]
      pHandle->RampRemainingStep = 0U;
 8009cee:	2300      	movs	r3, #0
      wCurrentReference = ((int32_t)pHandle->TargetFinal) * 65536;
 8009cf0:	042d      	lsls	r5, r5, #16
      pHandle->RampRemainingStep = 0U;
 8009cf2:	60c3      	str	r3, [r0, #12]
    if (MCM_SPEED_MODE == pHandle->Mode)
 8009cf4:	e7d9      	b.n	8009caa <STC_CalcTorqueReference+0x1e>
 8009cf6:	bf00      	nop

08009cf8 <STC_GetMecSpeedRefUnitDefault>:
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  return ((MC_NULL == pHandle) ? 0 : pHandle->MecSpeedRefUnitDefault);
#else
  return (pHandle->MecSpeedRefUnitDefault);
#endif
}
 8009cf8:	f9b0 002c 	ldrsh.w	r0, [r0, #44]	@ 0x2c
 8009cfc:	4770      	bx	lr
 8009cfe:	bf00      	nop

08009d00 <STC_GetDefaultIqdref>:
    IqdRefDefault.d = 0;
  }
  else
  {
#endif
    IqdRefDefault.q = pHandle->TorqueRefDefault;
 8009d00:	f8d0 302e 	ldr.w	r3, [r0, #46]	@ 0x2e
    IqdRefDefault.d = pHandle->IdrefDefault;
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
  return (IqdRefDefault);
 8009d04:	2200      	movs	r2, #0
 8009d06:	b299      	uxth	r1, r3
 8009d08:	f361 020f 	bfi	r2, r1, #0, #16
 8009d0c:	0c1b      	lsrs	r3, r3, #16
 8009d0e:	f363 421f 	bfi	r2, r3, #16, #16
{
 8009d12:	b082      	sub	sp, #8
}
 8009d14:	4610      	mov	r0, r2
 8009d16:	b002      	add	sp, #8
 8009d18:	4770      	bx	lr
 8009d1a:	bf00      	nop

08009d1c <STC_ForceSpeedReferenceToCurrentSpeed>:
  *
  * - Called during the CHARGE_BOOT_CAP, SWITCH_OVER and WAIT_STOP_MOTOR states of the MC state machine
  * into MediumFrequencyTask to initialize the speed reference.
  */
__weak void STC_ForceSpeedReferenceToCurrentSpeed(SpeednTorqCtrl_Handle_t *pHandle)
{
 8009d1c:	b510      	push	{r4, lr}
 8009d1e:	4604      	mov	r4, r0
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->SpeedRefUnitExt = ((int32_t)SPD_GetAvrgMecSpeedUnit(pHandle->SPD)) * (int32_t)65536;
 8009d20:	6940      	ldr	r0, [r0, #20]
 8009d22:	f7ff feff 	bl	8009b24 <SPD_GetAvrgMecSpeedUnit>
 8009d26:	0400      	lsls	r0, r0, #16
 8009d28:	6060      	str	r0, [r4, #4]
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
}
 8009d2a:	bd10      	pop	{r4, pc}

08009d2c <TC_Init>:
 
  */
void TC_Init(PosCtrl_Handle_t *pHandle, PID_Handle_t *pPIDPosReg, SpeednTorqCtrl_Handle_t *pSTC, ENCODER_Handle_t *pENC)
{

  pHandle->MovementDuration = 0.0f;
 8009d2c:	f04f 0c00 	mov.w	ip, #0
  pHandle->ElapseTime = 0.0f;

  pHandle->PositionControlRegulation = DISABLE;
  pHandle->PositionCtrlStatus = TC_READY_FOR_COMMAND;

  pHandle->pENC = pENC;
 8009d30:	6643      	str	r3, [r0, #100]	@ 0x64
  pHandle->TcTick = 0;
 8009d32:	2300      	movs	r3, #0
  pHandle->pSTC = pSTC;
 8009d34:	e9c0 211a 	strd	r2, r1, [r0, #104]	@ 0x68
  pHandle->MovementDuration = 0.0f;
 8009d38:	f8c0 c000 	str.w	ip, [r0]
  pHandle->AngleStep = 0.0f;
 8009d3c:	f8c0 c00c 	str.w	ip, [r0, #12]
  pHandle->SubStep[0] = 0.0f;
 8009d40:	f8c0 c010 	str.w	ip, [r0, #16]
  pHandle->SubStep[1] = 0.0f;
 8009d44:	f8c0 c014 	str.w	ip, [r0, #20]
  pHandle->SubStep[2] = 0.0f;
 8009d48:	f8c0 c018 	str.w	ip, [r0, #24]
  pHandle->SubStep[3] = 0.0f;
 8009d4c:	f8c0 c01c 	str.w	ip, [r0, #28]
  pHandle->SubStep[4] = 0.0f;
 8009d50:	f8c0 c020 	str.w	ip, [r0, #32]
  pHandle->SubStep[5] = 0.0f;
 8009d54:	f8c0 c024 	str.w	ip, [r0, #36]	@ 0x24
  pHandle->SubStepDuration = 0;
 8009d58:	f8c0 c028 	str.w	ip, [r0, #40]	@ 0x28
  pHandle->ElapseTime = 0.0f;
 8009d5c:	f8c0 c02c 	str.w	ip, [r0, #44]	@ 0x2c
  pHandle->Jerk = 0.0f;
 8009d60:	f8c0 c034 	str.w	ip, [r0, #52]	@ 0x34
  pHandle->CruiseSpeed = 0.0f;
 8009d64:	f8c0 c038 	str.w	ip, [r0, #56]	@ 0x38
  pHandle->Acceleration = 0.0f;
 8009d68:	f8c0 c03c 	str.w	ip, [r0, #60]	@ 0x3c
  pHandle->Omega = 0.0f;
 8009d6c:	f8c0 c040 	str.w	ip, [r0, #64]	@ 0x40
  pHandle->OmegaPrev = 0.0f;
 8009d70:	f8c0 c044 	str.w	ip, [r0, #68]	@ 0x44
  pHandle->Theta = 0.0f;
 8009d74:	f8c0 c048 	str.w	ip, [r0, #72]	@ 0x48
  pHandle->ThetaPrev = 0.0f;
 8009d78:	f8c0 c04c 	str.w	ip, [r0, #76]	@ 0x4c
  pHandle->TcTick = 0;
 8009d7c:	6583      	str	r3, [r0, #88]	@ 0x58
  pHandle->ReceivedTh = 0.0f;
 8009d7e:	f8a0 3050 	strh.w	r3, [r0, #80]	@ 0x50
  pHandle->PositionCtrlStatus = TC_READY_FOR_COMMAND;
 8009d82:	f880 3060 	strb.w	r3, [r0, #96]	@ 0x60
  pHandle->PIDPosRegulator = pPIDPosReg;

  pHandle->MecAngleOffset = 0;
 8009d86:	f8a0 3054 	strh.w	r3, [r0, #84]	@ 0x54
}
 8009d8a:	4770      	bx	lr

08009d8c <TC_MoveCommand>:
  * This function implements the Trajectory Control mode. When fDuration is different from 0,
  * the trajectory of the movement, and therefore its acceleration and speed, are computed. 
  * 
  */
bool TC_MoveCommand(PosCtrl_Handle_t *pHandle, float startingAngle, float angleStep, float movementDuration)
{
 8009d8c:	4603      	mov	r3, r0

  bool RetConfigStatus = false;
  float fMinimumStepDuration;

  if ((pHandle->PositionCtrlStatus == TC_FOLLOWING_ON_GOING) && (movementDuration > 0))
 8009d8e:	f890 0060 	ldrb.w	r0, [r0, #96]	@ 0x60
 8009d92:	2803      	cmp	r0, #3
 8009d94:	d061      	beq.n	8009e5a <TC_MoveCommand+0xce>
  else
  {
    /* Nothing to do */
  }

  if ((pHandle->PositionCtrlStatus == TC_READY_FOR_COMMAND) && (movementDuration > 0))
 8009d96:	b108      	cbz	r0, 8009d9c <TC_MoveCommand+0x10>
  bool RetConfigStatus = false;
 8009d98:	2000      	movs	r0, #0
  else
  {
    /* Nothing to do */
  }
  return (RetConfigStatus);
}
 8009d9a:	4770      	bx	lr
  if ((pHandle->PositionCtrlStatus == TC_READY_FOR_COMMAND) && (movementDuration > 0))
 8009d9c:	eeb5 1ac0 	vcmpe.f32	s2, #0.0
 8009da0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009da4:	ddf9      	ble.n	8009d9a <TC_MoveCommand+0xe>
    fMinimumStepDuration = (9.0f * pHandle->SamplingTime);
 8009da6:	edd3 6a0c 	vldr	s13, [r3, #48]	@ 0x30
    pHandle->Jerk = pHandle->AngleStep / (12 * pHandle->SubStepDuration * pHandle->SubStepDuration * pHandle->SubStepDuration);
 8009daa:	ed9f 4a2f 	vldr	s8, [pc, #188]	@ 8009e68 <TC_MoveCommand+0xdc>
    pHandle->StartingAngle = startingAngle;
 8009dae:	ed83 0a01 	vstr	s0, [r3, #4]
    fMinimumStepDuration = (9.0f * pHandle->SamplingTime);
 8009db2:	eef2 7a02 	vmov.f32	s15, #34	@ 0x41100000  9.0
 8009db6:	ee66 6aa7 	vmul.f32	s13, s13, s15
    pHandle->SubStepDuration = pHandle->MovementDuration / 9.0f;
 8009dba:	eddf 7a2c 	vldr	s15, [pc, #176]	@ 8009e6c <TC_MoveCommand+0xe0>
    pHandle->AngleStep = angleStep;
 8009dbe:	edc3 0a03 	vstr	s1, [r3, #12]
    pHandle->MovementDuration = (float)((int)(movementDuration / fMinimumStepDuration)) * fMinimumStepDuration;
 8009dc2:	ee81 7a26 	vdiv.f32	s14, s2, s13
    pHandle->ElapseTime = 0.0f;
 8009dc6:	2200      	movs	r2, #0
    pHandle->PositionControlRegulation = ENABLE;
 8009dc8:	2001      	movs	r0, #1
 8009dca:	f883 0051 	strb.w	r0, [r3, #81]	@ 0x51
    pHandle->ElapseTime = 0.0f;
 8009dce:	62da      	str	r2, [r3, #44]	@ 0x2c
    pHandle->Omega = 0.0f;
 8009dd0:	641a      	str	r2, [r3, #64]	@ 0x40
    pHandle->Acceleration = 0.0f;
 8009dd2:	63da      	str	r2, [r3, #60]	@ 0x3c
    pHandle->PositionCtrlStatus = TC_MOVEMENT_ON_GOING;   /* new trajectory has been programmed */
 8009dd4:	f883 0060 	strb.w	r0, [r3, #96]	@ 0x60
    pHandle->FinalAngle = startingAngle + angleStep;
 8009dd8:	ee70 3a20 	vadd.f32	s7, s0, s1
    pHandle->MovementDuration = (float)((int)(movementDuration / fMinimumStepDuration)) * fMinimumStepDuration;
 8009ddc:	eebd 7ac7 	vcvt.s32.f32	s14, s14
    pHandle->Jerk = pHandle->AngleStep / (12 * pHandle->SubStepDuration * pHandle->SubStepDuration * pHandle->SubStepDuration);
 8009de0:	ee20 4a84 	vmul.f32	s8, s1, s8
    pHandle->MovementDuration = (float)((int)(movementDuration / fMinimumStepDuration)) * fMinimumStepDuration;
 8009de4:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    pHandle->FinalAngle = startingAngle + angleStep;
 8009de8:	edc3 3a02 	vstr	s7, [r3, #8]
    pHandle->MovementDuration = (float)((int)(movementDuration / fMinimumStepDuration)) * fMinimumStepDuration;
 8009dec:	ee27 7a26 	vmul.f32	s14, s14, s13
    pHandle->SubStep[5] = 8 * pHandle->SubStepDuration;   /* Sub-step 3 of deceleration phase */
 8009df0:	eeb2 6a00 	vmov.f32	s12, #32	@ 0x41000000  8.0
    pHandle->SubStepDuration = pHandle->MovementDuration / 9.0f;
 8009df4:	ee67 7a27 	vmul.f32	s15, s14, s15
    pHandle->MovementDuration = (float)((int)(movementDuration / fMinimumStepDuration)) * fMinimumStepDuration;
 8009df8:	ed83 7a00 	vstr	s14, [r3]
    pHandle->Jerk = pHandle->AngleStep / (12 * pHandle->SubStepDuration * pHandle->SubStepDuration * pHandle->SubStepDuration);
 8009dfc:	ee27 7aa7 	vmul.f32	s14, s15, s15
    pHandle->SubStep[2] = 3 * pHandle->SubStepDuration;   /* Sub-step 3 of acceleration phase */
 8009e00:	eef0 4a08 	vmov.f32	s9, #8	@ 0x40400000  3.0
    pHandle->Jerk = pHandle->AngleStep / (12 * pHandle->SubStepDuration * pHandle->SubStepDuration * pHandle->SubStepDuration);
 8009e04:	ee67 6a27 	vmul.f32	s13, s14, s15
    pHandle->CruiseSpeed = 2 * pHandle->Jerk * pHandle->SubStepDuration * pHandle->SubStepDuration;
 8009e08:	ee37 7a07 	vadd.f32	s14, s14, s14
    pHandle->Jerk = pHandle->AngleStep / (12 * pHandle->SubStepDuration * pHandle->SubStepDuration * pHandle->SubStepDuration);
 8009e0c:	eec4 3a26 	vdiv.f32	s7, s8, s13
    pHandle->SubStep[3] = 6 * pHandle->SubStepDuration;   /* Sub-step 1 of deceleration phase */
 8009e10:	eeb1 5a08 	vmov.f32	s10, #24	@ 0x40c00000  6.0
    pHandle->SubStep[4] = 7 * pHandle->SubStepDuration;   /* Sub-step 2 of deceleration phase */
 8009e14:	eef1 5a0c 	vmov.f32	s11, #28	@ 0x40e00000  7.0
    pHandle->SubStep[1] = 2 * pHandle->SubStepDuration;   /* Sub-step 2 of acceleration phase */
 8009e18:	ee37 3aa7 	vadd.f32	s6, s15, s15
    pHandle->SubStep[2] = 3 * pHandle->SubStepDuration;   /* Sub-step 3 of acceleration phase */
 8009e1c:	ee67 4aa4 	vmul.f32	s9, s15, s9
    pHandle->SubStep[3] = 6 * pHandle->SubStepDuration;   /* Sub-step 1 of deceleration phase */
 8009e20:	ee27 5a85 	vmul.f32	s10, s15, s10
    pHandle->SubStep[4] = 7 * pHandle->SubStepDuration;   /* Sub-step 2 of deceleration phase */
 8009e24:	ee67 5aa5 	vmul.f32	s11, s15, s11
    pHandle->SubStep[5] = 8 * pHandle->SubStepDuration;   /* Sub-step 3 of deceleration phase */
 8009e28:	ee67 6a86 	vmul.f32	s13, s15, s12
    pHandle->CruiseSpeed = 2 * pHandle->Jerk * pHandle->SubStepDuration * pHandle->SubStepDuration;
 8009e2c:	ee27 7a23 	vmul.f32	s14, s14, s7
    pHandle->Theta = startingAngle;
 8009e30:	ed83 0a12 	vstr	s0, [r3, #72]	@ 0x48
    pHandle->SubStepDuration = pHandle->MovementDuration / 9.0f;
 8009e34:	edc3 7a0a 	vstr	s15, [r3, #40]	@ 0x28
    pHandle->SubStep[0] = 1 * pHandle->SubStepDuration;   /* Sub-step 1 of acceleration phase */
 8009e38:	edc3 7a04 	vstr	s15, [r3, #16]
    pHandle->SubStep[1] = 2 * pHandle->SubStepDuration;   /* Sub-step 2 of acceleration phase */
 8009e3c:	ed83 3a05 	vstr	s6, [r3, #20]
    pHandle->SubStep[2] = 3 * pHandle->SubStepDuration;   /* Sub-step 3 of acceleration phase */
 8009e40:	edc3 4a06 	vstr	s9, [r3, #24]
    pHandle->SubStep[3] = 6 * pHandle->SubStepDuration;   /* Sub-step 1 of deceleration phase */
 8009e44:	ed83 5a07 	vstr	s10, [r3, #28]
    pHandle->SubStep[4] = 7 * pHandle->SubStepDuration;   /* Sub-step 2 of deceleration phase */
 8009e48:	edc3 5a08 	vstr	s11, [r3, #32]
    pHandle->SubStep[5] = 8 * pHandle->SubStepDuration;   /* Sub-step 3 of deceleration phase */
 8009e4c:	edc3 6a09 	vstr	s13, [r3, #36]	@ 0x24
    pHandle->Jerk = pHandle->AngleStep / (12 * pHandle->SubStepDuration * pHandle->SubStepDuration * pHandle->SubStepDuration);
 8009e50:	edc3 3a0d 	vstr	s7, [r3, #52]	@ 0x34
    pHandle->CruiseSpeed = 2 * pHandle->Jerk * pHandle->SubStepDuration * pHandle->SubStepDuration;
 8009e54:	ed83 7a0e 	vstr	s14, [r3, #56]	@ 0x38
  return (RetConfigStatus);
 8009e58:	4770      	bx	lr
  if ((pHandle->PositionCtrlStatus == TC_FOLLOWING_ON_GOING) && (movementDuration > 0))
 8009e5a:	eeb5 1ac0 	vcmpe.f32	s2, #0.0
 8009e5e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009e62:	dca0      	bgt.n	8009da6 <TC_MoveCommand+0x1a>
 8009e64:	e798      	b.n	8009d98 <TC_MoveCommand+0xc>
 8009e66:	bf00      	nop
 8009e68:	3daaaaab 	.word	0x3daaaaab
 8009e6c:	3de38e39 	.word	0x3de38e39

08009e70 <TC_FollowCommand>:
void TC_FollowCommand(PosCtrl_Handle_t *pHandle, float Angle)
{
  float omega = 0, acceleration = 0, dt = 0;

  /* Estimate speed */
  if (pHandle->ReceivedTh > 0)
 8009e70:	f890 3050 	ldrb.w	r3, [r0, #80]	@ 0x50
 8009e74:	b373      	cbz	r3, 8009ed4 <TC_FollowCommand+0x64>
  {
    /* Calculate dt */
    dt = pHandle->TcTick * pHandle->SysTickPeriod;
 8009e76:	edd0 7a16 	vldr	s15, [r0, #88]	@ 0x58
 8009e7a:	ed90 7a17 	vldr	s14, [r0, #92]	@ 0x5c
    pHandle->TcTick = 0;
    if (dt > 0)
 8009e7e:	ed9f 6a22 	vldr	s12, [pc, #136]	@ 8009f08 <TC_FollowCommand+0x98>
    dt = pHandle->TcTick * pHandle->SysTickPeriod;
 8009e82:	eef8 7a67 	vcvt.f32.u32	s15, s15
    pHandle->TcTick = 0;
 8009e86:	2200      	movs	r2, #0
    dt = pHandle->TcTick * pHandle->SysTickPeriod;
 8009e88:	ee67 7a87 	vmul.f32	s15, s15, s14
    pHandle->TcTick = 0;
 8009e8c:	6582      	str	r2, [r0, #88]	@ 0x58
    if (dt > 0)
 8009e8e:	eef4 7ac6 	vcmpe.f32	s15, s12
 8009e92:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009e96:	dd29      	ble.n	8009eec <TC_FollowCommand+0x7c>
    {
      omega = (Angle - pHandle->ThetaPrev) / dt;
 8009e98:	edd0 6a13 	vldr	s13, [r0, #76]	@ 0x4c
 8009e9c:	ee70 6a66 	vsub.f32	s13, s0, s13
  {
    /* Nothing to do */
  }

  /* Estimated acceleration */
  if (pHandle->ReceivedTh > 1)
 8009ea0:	2b01      	cmp	r3, #1
      omega = (Angle - pHandle->ThetaPrev) / dt;
 8009ea2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
  if (pHandle->ReceivedTh > 1)
 8009ea6:	d017      	beq.n	8009ed8 <TC_FollowCommand+0x68>
  {
    if (dt > 0)
    {
      acceleration = (omega - pHandle->OmegaPrev) / dt;
 8009ea8:	ed90 6a11 	vldr	s12, [r0, #68]	@ 0x44
  {
    /* Nothing to do */
  }

  /* Update state variable */
  pHandle->ThetaPrev  = Angle;
 8009eac:	ed80 0a13 	vstr	s0, [r0, #76]	@ 0x4c
      acceleration = (omega - pHandle->OmegaPrev) / dt;
 8009eb0:	ee37 6a46 	vsub.f32	s12, s14, s12
  pHandle->OmegaPrev = omega;
 8009eb4:	ed80 7a11 	vstr	s14, [r0, #68]	@ 0x44
      acceleration = (omega - pHandle->OmegaPrev) / dt;
 8009eb8:	eec6 6a27 	vdiv.f32	s13, s12, s15
  pHandle->Acceleration = acceleration;
  pHandle->Omega = omega;
  pHandle->Theta = Angle;

  pHandle->PositionCtrlStatus = TC_FOLLOWING_ON_GOING;   /* follow mode has been programmed */
  pHandle->MovementDuration = 0;
 8009ebc:	2300      	movs	r3, #0
  pHandle->PositionCtrlStatus = TC_FOLLOWING_ON_GOING;   /* follow mode has been programmed */
 8009ebe:	2203      	movs	r2, #3
 8009ec0:	f880 2060 	strb.w	r2, [r0, #96]	@ 0x60
  pHandle->MovementDuration = 0;
 8009ec4:	6003      	str	r3, [r0, #0]
  pHandle->Acceleration = acceleration;
 8009ec6:	edc0 6a0f 	vstr	s13, [r0, #60]	@ 0x3c
  pHandle->Omega = omega;
 8009eca:	ed80 7a10 	vstr	s14, [r0, #64]	@ 0x40
  pHandle->Theta = Angle;
 8009ece:	ed80 0a12 	vstr	s0, [r0, #72]	@ 0x48
}
 8009ed2:	4770      	bx	lr
  float omega = 0, acceleration = 0, dt = 0;
 8009ed4:	ed9f 7a0c 	vldr	s14, [pc, #48]	@ 8009f08 <TC_FollowCommand+0x98>
 8009ed8:	eddf 6a0b 	vldr	s13, [pc, #44]	@ 8009f08 <TC_FollowCommand+0x98>
  pHandle->ThetaPrev  = Angle;
 8009edc:	ed80 0a13 	vstr	s0, [r0, #76]	@ 0x4c
    pHandle->ReceivedTh++;
 8009ee0:	3301      	adds	r3, #1
  pHandle->OmegaPrev = omega;
 8009ee2:	ed80 7a11 	vstr	s14, [r0, #68]	@ 0x44
    pHandle->ReceivedTh++;
 8009ee6:	f880 3050 	strb.w	r3, [r0, #80]	@ 0x50
 8009eea:	e7e7      	b.n	8009ebc <TC_FollowCommand+0x4c>
  if (pHandle->ReceivedTh > 1)
 8009eec:	2b01      	cmp	r3, #1
  float omega = 0, acceleration = 0, dt = 0;
 8009eee:	bf08      	it	eq
 8009ef0:	eeb0 7a46 	vmoveq.f32	s14, s12
  if (pHandle->ReceivedTh > 1)
 8009ef4:	d0f0      	beq.n	8009ed8 <TC_FollowCommand+0x68>
  float omega = 0, acceleration = 0, dt = 0;
 8009ef6:	eef0 6a46 	vmov.f32	s13, s12
  pHandle->ThetaPrev  = Angle;
 8009efa:	ed80 0a13 	vstr	s0, [r0, #76]	@ 0x4c
  float omega = 0, acceleration = 0, dt = 0;
 8009efe:	eeb0 7a46 	vmov.f32	s14, s12
  pHandle->OmegaPrev = omega;
 8009f02:	ed80 6a11 	vstr	s12, [r0, #68]	@ 0x44
  if (pHandle->ReceivedTh < 2)
 8009f06:	e7d9      	b.n	8009ebc <TC_FollowCommand+0x4c>
 8009f08:	00000000 	.word	0x00000000

08009f0c <TC_MoveExecution>:
void TC_MoveExecution(PosCtrl_Handle_t *pHandle)
{

  float jerkApplied = 0;

  if (pHandle->ElapseTime < pHandle->SubStep[0])            /* 1st Sub-Step interval time of acceleration phase */
 8009f0c:	edd0 7a0b 	vldr	s15, [r0, #44]	@ 0x2c
 8009f10:	ed90 6a04 	vldr	s12, [r0, #16]
  }
  else if (pHandle->ElapseTime < pHandle->SubStep[5])       /* 2nd Sub-Step interval time of deceleration phase */
  {

  }
  else if (pHandle->ElapseTime < pHandle->MovementDuration) /* 3rd Sub-Step interval time of deceleration phase */
 8009f14:	edd0 6a00 	vldr	s13, [r0]
  else
  {
    /* Nothing to do */
  }

  pHandle->ElapseTime += pHandle->SamplingTime;
 8009f18:	ed90 7a0c 	vldr	s14, [r0, #48]	@ 0x30
  if (pHandle->ElapseTime < pHandle->SubStep[0])            /* 1st Sub-Step interval time of acceleration phase */
 8009f1c:	eef4 7ac6 	vcmpe.f32	s15, s12
 8009f20:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009f24:	d531      	bpl.n	8009f8a <TC_MoveExecution+0x7e>
    jerkApplied = pHandle->Jerk;
 8009f26:	ed90 5a0d 	vldr	s10, [r0, #52]	@ 0x34
  if (TC_MOVEMENT_ON_GOING == pHandle->PositionCtrlStatus)
 8009f2a:	f890 3060 	ldrb.w	r3, [r0, #96]	@ 0x60
 8009f2e:	2b01      	cmp	r3, #1
 8009f30:	d113      	bne.n	8009f5a <TC_MoveExecution+0x4e>
    pHandle->Acceleration += jerkApplied * pHandle->SamplingTime;
 8009f32:	edd0 5a0f 	vldr	s11, [r0, #60]	@ 0x3c
    pHandle->Omega += pHandle->Acceleration * pHandle->SamplingTime;
 8009f36:	ed90 6a10 	vldr	s12, [r0, #64]	@ 0x40
    pHandle->Acceleration += jerkApplied * pHandle->SamplingTime;
 8009f3a:	eee5 5a07 	vfma.f32	s11, s10, s14
    pHandle->Theta += pHandle->Omega * pHandle->SamplingTime;
 8009f3e:	ed90 5a12 	vldr	s10, [r0, #72]	@ 0x48
    pHandle->Acceleration += jerkApplied * pHandle->SamplingTime;
 8009f42:	edc0 5a0f 	vstr	s11, [r0, #60]	@ 0x3c
    pHandle->Omega += pHandle->Acceleration * pHandle->SamplingTime;
 8009f46:	eea5 6a87 	vfma.f32	s12, s11, s14
    pHandle->Theta += pHandle->Omega * pHandle->SamplingTime;
 8009f4a:	eef0 5a45 	vmov.f32	s11, s10
 8009f4e:	eee6 5a07 	vfma.f32	s11, s12, s14
    pHandle->Omega += pHandle->Acceleration * pHandle->SamplingTime;
 8009f52:	ed80 6a10 	vstr	s12, [r0, #64]	@ 0x40
    pHandle->Theta += pHandle->Omega * pHandle->SamplingTime;
 8009f56:	edc0 5a12 	vstr	s11, [r0, #72]	@ 0x48
  pHandle->ElapseTime += pHandle->SamplingTime;
 8009f5a:	ee77 7a87 	vadd.f32	s15, s15, s14
static inline bool TC_RampCompleted(PosCtrl_Handle_t *pHandle)
{
  bool retVal = false;

  /* Check that entire sequence (Acceleration - Cruise - Deceleration) is completed */
  if (pHandle->ElapseTime > pHandle->MovementDuration + pHandle->SamplingTime)
 8009f5e:	ee76 6a87 	vadd.f32	s13, s13, s14
  pHandle->ElapseTime += pHandle->SamplingTime;
 8009f62:	edc0 7a0b 	vstr	s15, [r0, #44]	@ 0x2c
  if (pHandle->ElapseTime > pHandle->MovementDuration + pHandle->SamplingTime)
 8009f66:	eef4 7ae6 	vcmpe.f32	s15, s13
 8009f6a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009f6e:	dd0b      	ble.n	8009f88 <TC_MoveExecution+0x7c>
    if (TC_ZERO_ALIGNMENT_START == pHandle->AlignmentStatus)
 8009f70:	f890 3062 	ldrb.w	r3, [r0, #98]	@ 0x62
 8009f74:	2b01      	cmp	r3, #1
      pHandle->AlignmentStatus = TC_ALIGNMENT_ERROR;
 8009f76:	bf04      	itt	eq
 8009f78:	2305      	moveq	r3, #5
 8009f7a:	f880 3062 	strbeq.w	r3, [r0, #98]	@ 0x62
    pHandle->ElapseTime = 0;
 8009f7e:	2200      	movs	r2, #0
    pHandle->PositionCtrlStatus = TC_READY_FOR_COMMAND;
 8009f80:	2300      	movs	r3, #0
    pHandle->ElapseTime = 0;
 8009f82:	62c2      	str	r2, [r0, #44]	@ 0x2c
    pHandle->PositionCtrlStatus = TC_READY_FOR_COMMAND;
 8009f84:	f880 3060 	strb.w	r3, [r0, #96]	@ 0x60
}
 8009f88:	4770      	bx	lr
  else if (pHandle->ElapseTime < pHandle->SubStep[1])       /* 2nd Sub-Step interval time of acceleration phase */
 8009f8a:	ed90 6a05 	vldr	s12, [r0, #20]
 8009f8e:	eef4 7ac6 	vcmpe.f32	s15, s12
 8009f92:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009f96:	d502      	bpl.n	8009f9e <TC_MoveExecution+0x92>
  float jerkApplied = 0;
 8009f98:	ed9f 5a19 	vldr	s10, [pc, #100]	@ 800a000 <TC_MoveExecution+0xf4>
 8009f9c:	e7c5      	b.n	8009f2a <TC_MoveExecution+0x1e>
  else if (pHandle->ElapseTime < pHandle->SubStep[2])       /* 3rd Sub-Step interval time of acceleration phase */
 8009f9e:	ed90 6a06 	vldr	s12, [r0, #24]
 8009fa2:	eef4 7ac6 	vcmpe.f32	s15, s12
 8009fa6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009faa:	d412      	bmi.n	8009fd2 <TC_MoveExecution+0xc6>
  else if (pHandle->ElapseTime < pHandle->SubStep[3])       /* Speed Cruise phase (after acceleration and before
 8009fac:	ed90 6a07 	vldr	s12, [r0, #28]
 8009fb0:	eef4 7ac6 	vcmpe.f32	s15, s12
 8009fb4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009fb8:	d504      	bpl.n	8009fc4 <TC_MoveExecution+0xb8>
    pHandle->Omega = pHandle->CruiseSpeed;
 8009fba:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 8009fbc:	6403      	str	r3, [r0, #64]	@ 0x40
    pHandle->Acceleration = 0.0f;
 8009fbe:	2200      	movs	r2, #0
 8009fc0:	63c2      	str	r2, [r0, #60]	@ 0x3c
    pHandle->Omega = pHandle->CruiseSpeed;
 8009fc2:	e7e9      	b.n	8009f98 <TC_MoveExecution+0x8c>
  else if (pHandle->ElapseTime < pHandle->SubStep[4])       /* 1st Sub-Step interval time of deceleration phase */
 8009fc4:	ed90 6a08 	vldr	s12, [r0, #32]
 8009fc8:	eef4 7ac6 	vcmpe.f32	s15, s12
 8009fcc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009fd0:	d504      	bpl.n	8009fdc <TC_MoveExecution+0xd0>
    jerkApplied = -(pHandle->Jerk);
 8009fd2:	ed90 5a0d 	vldr	s10, [r0, #52]	@ 0x34
 8009fd6:	eeb1 5a45 	vneg.f32	s10, s10
 8009fda:	e7a6      	b.n	8009f2a <TC_MoveExecution+0x1e>
  else if (pHandle->ElapseTime < pHandle->SubStep[5])       /* 2nd Sub-Step interval time of deceleration phase */
 8009fdc:	ed90 6a09 	vldr	s12, [r0, #36]	@ 0x24
 8009fe0:	eef4 7ac6 	vcmpe.f32	s15, s12
 8009fe4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009fe8:	d4d6      	bmi.n	8009f98 <TC_MoveExecution+0x8c>
  else if (pHandle->ElapseTime < pHandle->MovementDuration) /* 3rd Sub-Step interval time of deceleration phase */
 8009fea:	eef4 7ae6 	vcmpe.f32	s15, s13
 8009fee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009ff2:	d498      	bmi.n	8009f26 <TC_MoveExecution+0x1a>
    pHandle->Theta = pHandle->FinalAngle;
 8009ff4:	6882      	ldr	r2, [r0, #8]
 8009ff6:	6482      	str	r2, [r0, #72]	@ 0x48
    pHandle->PositionCtrlStatus = TC_TARGET_POSITION_REACHED;
 8009ff8:	2302      	movs	r3, #2
 8009ffa:	f880 3060 	strb.w	r3, [r0, #96]	@ 0x60
  if (TC_MOVEMENT_ON_GOING == pHandle->PositionCtrlStatus)
 8009ffe:	e7ac      	b.n	8009f5a <TC_MoveExecution+0x4e>
 800a000:	00000000 	.word	0x00000000

0800a004 <TC_PositionRegulation>:
{
 800a004:	b538      	push	{r3, r4, r5, lr}
  if (pHandle->PositionCtrlStatus == TC_MOVEMENT_ON_GOING)
 800a006:	f890 3060 	ldrb.w	r3, [r0, #96]	@ 0x60
 800a00a:	2b01      	cmp	r3, #1
{
 800a00c:	4604      	mov	r4, r0
  if (pHandle->PositionCtrlStatus == TC_MOVEMENT_ON_GOING)
 800a00e:	d033      	beq.n	800a078 <TC_PositionRegulation+0x74>
  if (pHandle->PositionCtrlStatus == TC_FOLLOWING_ON_GOING)
 800a010:	2b03      	cmp	r3, #3
 800a012:	d10f      	bne.n	800a034 <TC_PositionRegulation+0x30>
  pHandle->Omega += pHandle->Acceleration * pHandle->SamplingTime;
 800a014:	edd4 6a0c 	vldr	s13, [r4, #48]	@ 0x30
 800a018:	edd4 7a10 	vldr	s15, [r4, #64]	@ 0x40
 800a01c:	ed94 6a0f 	vldr	s12, [r4, #60]	@ 0x3c
  pHandle->Theta += pHandle->Omega        * pHandle->SamplingTime;
 800a020:	ed94 7a12 	vldr	s14, [r4, #72]	@ 0x48
  pHandle->Omega += pHandle->Acceleration * pHandle->SamplingTime;
 800a024:	eee6 7a26 	vfma.f32	s15, s12, s13
  pHandle->Theta += pHandle->Omega        * pHandle->SamplingTime;
 800a028:	eea6 7aa7 	vfma.f32	s14, s13, s15
  pHandle->Omega += pHandle->Acceleration * pHandle->SamplingTime;
 800a02c:	edc4 7a10 	vstr	s15, [r4, #64]	@ 0x40
  pHandle->Theta += pHandle->Omega        * pHandle->SamplingTime;
 800a030:	ed84 7a12 	vstr	s14, [r4, #72]	@ 0x48
  if (pHandle->PositionControlRegulation == ENABLE)
 800a034:	f894 3051 	ldrb.w	r3, [r4, #81]	@ 0x51
 800a038:	b903      	cbnz	r3, 800a03c <TC_PositionRegulation+0x38>
}
 800a03a:	bd38      	pop	{r3, r4, r5, pc}
    wMecAngleRef = (int32_t)(pHandle->Theta * RADTOS16);
 800a03c:	ed9f 7a11 	vldr	s14, [pc, #68]	@ 800a084 <TC_PositionRegulation+0x80>
 800a040:	edd4 7a12 	vldr	s15, [r4, #72]	@ 0x48
 800a044:	6ea3      	ldr	r3, [r4, #104]	@ 0x68
 800a046:	ee67 7a87 	vmul.f32	s15, s15, s14
    wMecAngle = SPD_GetMecAngle(STC_GetSpeedSensor(pHandle->pSTC));
 800a04a:	6958      	ldr	r0, [r3, #20]
    wMecAngleRef = (int32_t)(pHandle->Theta * RADTOS16);
 800a04c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800a050:	ee17 5a90 	vmov	r5, s15
    wMecAngle = SPD_GetMecAngle(STC_GetSpeedSensor(pHandle->pSTC));
 800a054:	f7ff fd64 	bl	8009b20 <SPD_GetMecAngle>
    hTorqueRef_Pos = PID_Controller(pHandle->PIDPosRegulator, wError);
 800a058:	1a29      	subs	r1, r5, r0
 800a05a:	6ee0      	ldr	r0, [r4, #108]	@ 0x6c
 800a05c:	f7fe fd8c 	bl	8008b78 <PID_Controller>
    STC_SetControlMode(pHandle->pSTC, MCM_TORQUE_MODE);
 800a060:	2104      	movs	r1, #4
    hTorqueRef_Pos = PID_Controller(pHandle->PIDPosRegulator, wError);
 800a062:	4605      	mov	r5, r0
    STC_SetControlMode(pHandle->pSTC, MCM_TORQUE_MODE);
 800a064:	6ea0      	ldr	r0, [r4, #104]	@ 0x68
 800a066:	f7ff fdc5 	bl	8009bf4 <STC_SetControlMode>
    STC_ExecRamp(pHandle->pSTC, hTorqueRef_Pos, 0);
 800a06a:	6ea0      	ldr	r0, [r4, #104]	@ 0x68
 800a06c:	4629      	mov	r1, r5
 800a06e:	2200      	movs	r2, #0
}
 800a070:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    STC_ExecRamp(pHandle->pSTC, hTorqueRef_Pos, 0);
 800a074:	f7ff bdc2 	b.w	8009bfc <STC_ExecRamp>
    TC_MoveExecution(pHandle);
 800a078:	f7ff ff48 	bl	8009f0c <TC_MoveExecution>
  if (pHandle->PositionCtrlStatus == TC_FOLLOWING_ON_GOING)
 800a07c:	f890 3060 	ldrb.w	r3, [r0, #96]	@ 0x60
 800a080:	e7c6      	b.n	800a010 <TC_PositionRegulation+0xc>
 800a082:	bf00      	nop
 800a084:	4622f983 	.word	0x4622f983

0800a088 <TC_EncAlignmentCommand>:
{
 800a088:	b510      	push	{r4, lr}
  if (TC_ALIGNMENT_COMPLETED == pHandle->AlignmentStatus)
 800a08a:	f890 3062 	ldrb.w	r3, [r0, #98]	@ 0x62
 800a08e:	2b02      	cmp	r3, #2
{
 800a090:	b082      	sub	sp, #8
 800a092:	4604      	mov	r4, r0
  if (TC_ALIGNMENT_COMPLETED == pHandle->AlignmentStatus)
 800a094:	d010      	beq.n	800a0b8 <TC_EncAlignmentCommand+0x30>
    if (pHandle->AlignmentCfg == TC_ABSOLUTE_ALIGNMENT_SUPPORTED)
 800a096:	f890 3061 	ldrb.w	r3, [r0, #97]	@ 0x61
 800a09a:	2b04      	cmp	r3, #4
 800a09c:	d011      	beq.n	800a0c2 <TC_EncAlignmentCommand+0x3a>
      pHandle->pENC->_Super.wMecAngle = 0;
 800a09e:	6e40      	ldr	r0, [r0, #100]	@ 0x64
 800a0a0:	2300      	movs	r3, #0
      pHandle->AlignmentStatus = TC_ALIGNMENT_COMPLETED;
 800a0a2:	2102      	movs	r1, #2
      pHandle->PositionControlRegulation = ENABLE;
 800a0a4:	2201      	movs	r2, #1
      pHandle->pENC->_Super.wMecAngle = 0;
 800a0a6:	6083      	str	r3, [r0, #8]
      pHandle->AlignmentStatus = TC_ALIGNMENT_COMPLETED;
 800a0a8:	f884 1062 	strb.w	r1, [r4, #98]	@ 0x62
      pHandle->PositionCtrlStatus = TC_READY_FOR_COMMAND;
 800a0ac:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
      pHandle->PositionControlRegulation = ENABLE;
 800a0b0:	f884 2051 	strb.w	r2, [r4, #81]	@ 0x51
}
 800a0b4:	b002      	add	sp, #8
 800a0b6:	bd10      	pop	{r4, pc}
    pHandle->PositionCtrlStatus = TC_READY_FOR_COMMAND;
 800a0b8:	2300      	movs	r3, #0
 800a0ba:	f880 3060 	strb.w	r3, [r0, #96]	@ 0x60
}
 800a0be:	b002      	add	sp, #8
 800a0c0:	bd10      	pop	{r4, pc}
 800a0c2:	6e82      	ldr	r2, [r0, #104]	@ 0x68
      pHandle->EncoderAbsoluteAligned = false;
 800a0c4:	2300      	movs	r3, #0
      wMecAngleRef = SPD_GetMecAngle(STC_GetSpeedSensor(pHandle->pSTC));
 800a0c6:	6950      	ldr	r0, [r2, #20]
      pHandle->EncoderAbsoluteAligned = false;
 800a0c8:	f884 3052 	strb.w	r3, [r4, #82]	@ 0x52
      wMecAngleRef = SPD_GetMecAngle(STC_GetSpeedSensor(pHandle->pSTC));
 800a0cc:	f7ff fd28 	bl	8009b20 <SPD_GetMecAngle>
  if ((pHandle->PositionCtrlStatus == TC_FOLLOWING_ON_GOING) && (movementDuration > 0))
 800a0d0:	f894 3060 	ldrb.w	r3, [r4, #96]	@ 0x60
      wMecAngleRef = SPD_GetMecAngle(STC_GetSpeedSensor(pHandle->pSTC));
 800a0d4:	9001      	str	r0, [sp, #4]
  if ((pHandle->PositionCtrlStatus == TC_FOLLOWING_ON_GOING) && (movementDuration > 0))
 800a0d6:	2b03      	cmp	r3, #3
 800a0d8:	d005      	beq.n	800a0e6 <TC_EncAlignmentCommand+0x5e>
  if ((pHandle->PositionCtrlStatus == TC_READY_FOR_COMMAND) && (movementDuration > 0))
 800a0da:	b123      	cbz	r3, 800a0e6 <TC_EncAlignmentCommand+0x5e>
      pHandle->AlignmentStatus = TC_ZERO_ALIGNMENT_START;
 800a0dc:	2301      	movs	r3, #1
 800a0de:	f884 3062 	strb.w	r3, [r4, #98]	@ 0x62
}
 800a0e2:	b002      	add	sp, #8
 800a0e4:	bd10      	pop	{r4, pc}
    fMinimumStepDuration = (9.0f * pHandle->SamplingTime);
 800a0e6:	edd4 7a0c 	vldr	s15, [r4, #48]	@ 0x30
    pHandle->MovementDuration = (float)((int)(movementDuration / fMinimumStepDuration)) * fMinimumStepDuration;
 800a0ea:	ed9f 6a31 	vldr	s12, [pc, #196]	@ 800a1b0 <TC_EncAlignmentCommand+0x128>
      TC_MoveCommand(pHandle, (float)(wMecAngleRef) / RADTOS16, Z_ALIGNMENT_NB_ROTATION, Z_ALIGNMENT_DURATION);
 800a0ee:	eddf 5a31 	vldr	s11, [pc, #196]	@ 800a1b4 <TC_EncAlignmentCommand+0x12c>
    pHandle->AngleStep = angleStep;
 800a0f2:	eddf 3a31 	vldr	s7, [pc, #196]	@ 800a1b8 <TC_EncAlignmentCommand+0x130>
    pHandle->Jerk = pHandle->AngleStep / (12 * pHandle->SubStepDuration * pHandle->SubStepDuration * pHandle->SubStepDuration);
 800a0f6:	ed9f 2a31 	vldr	s4, [pc, #196]	@ 800a1bc <TC_EncAlignmentCommand+0x134>
    pHandle->AngleStep = angleStep;
 800a0fa:	edc4 3a03 	vstr	s7, [r4, #12]
    pHandle->MovementDuration = (float)((int)(movementDuration / fMinimumStepDuration)) * fMinimumStepDuration;
 800a0fe:	eec6 6a27 	vdiv.f32	s13, s12, s15
    pHandle->ElapseTime = 0.0f;
 800a102:	2300      	movs	r3, #0
    pHandle->PositionControlRegulation = ENABLE;
 800a104:	2201      	movs	r2, #1
 800a106:	f884 2051 	strb.w	r2, [r4, #81]	@ 0x51
    pHandle->ElapseTime = 0.0f;
 800a10a:	62e3      	str	r3, [r4, #44]	@ 0x2c
    pHandle->Omega = 0.0f;
 800a10c:	6423      	str	r3, [r4, #64]	@ 0x40
    pHandle->Acceleration = 0.0f;
 800a10e:	63e3      	str	r3, [r4, #60]	@ 0x3c
    pHandle->PositionCtrlStatus = TC_MOVEMENT_ON_GOING;   /* new trajectory has been programmed */
 800a110:	f884 2060 	strb.w	r2, [r4, #96]	@ 0x60
    fMinimumStepDuration = (9.0f * pHandle->SamplingTime);
 800a114:	eeb2 7a02 	vmov.f32	s14, #34	@ 0x41100000  9.0
    pHandle->MovementDuration = (float)((int)(movementDuration / fMinimumStepDuration)) * fMinimumStepDuration;
 800a118:	eefd 6ae6 	vcvt.s32.f32	s13, s13
    fMinimumStepDuration = (9.0f * pHandle->SamplingTime);
 800a11c:	ee27 6a87 	vmul.f32	s12, s15, s14
    pHandle->MovementDuration = (float)((int)(movementDuration / fMinimumStepDuration)) * fMinimumStepDuration;
 800a120:	eef8 6ae6 	vcvt.f32.s32	s13, s13
    pHandle->SubStepDuration = pHandle->MovementDuration / 9.0f;
 800a124:	eddf 7a26 	vldr	s15, [pc, #152]	@ 800a1c0 <TC_EncAlignmentCommand+0x138>
      TC_MoveCommand(pHandle, (float)(wMecAngleRef) / RADTOS16, Z_ALIGNMENT_NB_ROTATION, Z_ALIGNMENT_DURATION);
 800a128:	ed9d 7a01 	vldr	s14, [sp, #4]
    pHandle->MovementDuration = (float)((int)(movementDuration / fMinimumStepDuration)) * fMinimumStepDuration;
 800a12c:	ee66 6a86 	vmul.f32	s13, s13, s12
      TC_MoveCommand(pHandle, (float)(wMecAngleRef) / RADTOS16, Z_ALIGNMENT_NB_ROTATION, Z_ALIGNMENT_DURATION);
 800a130:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    pHandle->SubStepDuration = pHandle->MovementDuration / 9.0f;
 800a134:	ee66 7aa7 	vmul.f32	s15, s13, s15
    pHandle->MovementDuration = (float)((int)(movementDuration / fMinimumStepDuration)) * fMinimumStepDuration;
 800a138:	edc4 6a00 	vstr	s13, [r4]
    pHandle->Jerk = pHandle->AngleStep / (12 * pHandle->SubStepDuration * pHandle->SubStepDuration * pHandle->SubStepDuration);
 800a13c:	ee67 6aa7 	vmul.f32	s13, s15, s15
      TC_MoveCommand(pHandle, (float)(wMecAngleRef) / RADTOS16, Z_ALIGNMENT_NB_ROTATION, Z_ALIGNMENT_DURATION);
 800a140:	ee27 7a25 	vmul.f32	s14, s14, s11
    pHandle->Jerk = pHandle->AngleStep / (12 * pHandle->SubStepDuration * pHandle->SubStepDuration * pHandle->SubStepDuration);
 800a144:	ee26 6aa7 	vmul.f32	s12, s13, s15
    pHandle->FinalAngle = startingAngle + angleStep;
 800a148:	ee77 2a23 	vadd.f32	s5, s14, s7
    pHandle->Jerk = pHandle->AngleStep / (12 * pHandle->SubStepDuration * pHandle->SubStepDuration * pHandle->SubStepDuration);
 800a14c:	eec2 3a06 	vdiv.f32	s7, s4, s12
    pHandle->CruiseSpeed = 2 * pHandle->Jerk * pHandle->SubStepDuration * pHandle->SubStepDuration;
 800a150:	ee76 6aa6 	vadd.f32	s13, s13, s13
    pHandle->SubStep[2] = 3 * pHandle->SubStepDuration;   /* Sub-step 3 of acceleration phase */
 800a154:	eeb0 4a08 	vmov.f32	s8, #8	@ 0x40400000  3.0
    pHandle->SubStep[3] = 6 * pHandle->SubStepDuration;   /* Sub-step 1 of deceleration phase */
 800a158:	eef1 4a08 	vmov.f32	s9, #24	@ 0x40c00000  6.0
    pHandle->SubStep[4] = 7 * pHandle->SubStepDuration;   /* Sub-step 2 of deceleration phase */
 800a15c:	eeb1 5a0c 	vmov.f32	s10, #28	@ 0x40e00000  7.0
    pHandle->SubStep[5] = 8 * pHandle->SubStepDuration;   /* Sub-step 3 of deceleration phase */
 800a160:	eef2 5a00 	vmov.f32	s11, #32	@ 0x41000000  8.0
    pHandle->SubStep[1] = 2 * pHandle->SubStepDuration;   /* Sub-step 2 of acceleration phase */
 800a164:	ee37 3aa7 	vadd.f32	s6, s15, s15
    pHandle->SubStep[2] = 3 * pHandle->SubStepDuration;   /* Sub-step 3 of acceleration phase */
 800a168:	ee27 4a84 	vmul.f32	s8, s15, s8
    pHandle->SubStep[3] = 6 * pHandle->SubStepDuration;   /* Sub-step 1 of deceleration phase */
 800a16c:	ee67 4aa4 	vmul.f32	s9, s15, s9
    pHandle->SubStep[4] = 7 * pHandle->SubStepDuration;   /* Sub-step 2 of deceleration phase */
 800a170:	ee27 5a85 	vmul.f32	s10, s15, s10
    pHandle->SubStep[5] = 8 * pHandle->SubStepDuration;   /* Sub-step 3 of deceleration phase */
 800a174:	ee27 6aa5 	vmul.f32	s12, s15, s11
    pHandle->CruiseSpeed = 2 * pHandle->Jerk * pHandle->SubStepDuration * pHandle->SubStepDuration;
 800a178:	ee66 6aa3 	vmul.f32	s13, s13, s7
    pHandle->StartingAngle = startingAngle;
 800a17c:	ed84 7a01 	vstr	s14, [r4, #4]
    pHandle->FinalAngle = startingAngle + angleStep;
 800a180:	edc4 2a02 	vstr	s5, [r4, #8]
    pHandle->SubStepDuration = pHandle->MovementDuration / 9.0f;
 800a184:	edc4 7a0a 	vstr	s15, [r4, #40]	@ 0x28
    pHandle->SubStep[0] = 1 * pHandle->SubStepDuration;   /* Sub-step 1 of acceleration phase */
 800a188:	edc4 7a04 	vstr	s15, [r4, #16]
    pHandle->SubStep[1] = 2 * pHandle->SubStepDuration;   /* Sub-step 2 of acceleration phase */
 800a18c:	ed84 3a05 	vstr	s6, [r4, #20]
    pHandle->SubStep[2] = 3 * pHandle->SubStepDuration;   /* Sub-step 3 of acceleration phase */
 800a190:	ed84 4a06 	vstr	s8, [r4, #24]
    pHandle->SubStep[3] = 6 * pHandle->SubStepDuration;   /* Sub-step 1 of deceleration phase */
 800a194:	edc4 4a07 	vstr	s9, [r4, #28]
    pHandle->SubStep[4] = 7 * pHandle->SubStepDuration;   /* Sub-step 2 of deceleration phase */
 800a198:	ed84 5a08 	vstr	s10, [r4, #32]
    pHandle->SubStep[5] = 8 * pHandle->SubStepDuration;   /* Sub-step 3 of deceleration phase */
 800a19c:	ed84 6a09 	vstr	s12, [r4, #36]	@ 0x24
    pHandle->Jerk = pHandle->AngleStep / (12 * pHandle->SubStepDuration * pHandle->SubStepDuration * pHandle->SubStepDuration);
 800a1a0:	edc4 3a0d 	vstr	s7, [r4, #52]	@ 0x34
    pHandle->CruiseSpeed = 2 * pHandle->Jerk * pHandle->SubStepDuration * pHandle->SubStepDuration;
 800a1a4:	edc4 6a0e 	vstr	s13, [r4, #56]	@ 0x38
    pHandle->Theta = startingAngle;
 800a1a8:	ed84 7a12 	vstr	s14, [r4, #72]	@ 0x48
  return (RetConfigStatus);
 800a1ac:	e796      	b.n	800a0dc <TC_EncAlignmentCommand+0x54>
 800a1ae:	bf00      	nop
 800a1b0:	3e638e39 	.word	0x3e638e39
 800a1b4:	38c90fdb 	.word	0x38c90fdb
 800a1b8:	40c90fdb 	.word	0x40c90fdb
 800a1bc:	3f060a92 	.word	0x3f060a92
 800a1c0:	3de38e39 	.word	0x3de38e39

0800a1c4 <TC_GetCurrentPosition>:
  * @brief  Returns the current rotor mechanical angle, expressed in radiant.
  * @param  pHandle: handler of the current instance of the Position Control component.
  * @retval current mechanical position
  */
float TC_GetCurrentPosition(PosCtrl_Handle_t *pHandle)
{
 800a1c4:	b508      	push	{r3, lr}
 800a1c6:	6e83      	ldr	r3, [r0, #104]	@ 0x68

  return ((float)((SPD_GetMecAngle(STC_GetSpeedSensor(pHandle->pSTC))) / RADTOS16));
 800a1c8:	6958      	ldr	r0, [r3, #20]
 800a1ca:	f7ff fca9 	bl	8009b20 <SPD_GetMecAngle>
 800a1ce:	ee07 0a90 	vmov	s15, r0
 800a1d2:	ed9f 0a03 	vldr	s0, [pc, #12]	@ 800a1e0 <TC_GetCurrentPosition+0x1c>
 800a1d6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
}
 800a1da:	ee27 0a80 	vmul.f32	s0, s15, s0
 800a1de:	bd08      	pop	{r3, pc}
 800a1e0:	38c90fdb 	.word	0x38c90fdb

0800a1e4 <TC_GetTargetPosition>:
  * @retval Target mechanical position
  */
float TC_GetTargetPosition(PosCtrl_Handle_t *pHandle)
{
  return (pHandle->FinalAngle);
}
 800a1e4:	ed90 0a02 	vldr	s0, [r0, #8]
 800a1e8:	4770      	bx	lr
 800a1ea:	bf00      	nop

0800a1ec <TC_GetMoveDuration>:
  * @retval Duration of programmed movement
  */
float TC_GetMoveDuration(PosCtrl_Handle_t *pHandle)
{
  return (pHandle->MovementDuration);
}
 800a1ec:	ed90 0a00 	vldr	s0, [r0]
 800a1f0:	4770      	bx	lr
 800a1f2:	bf00      	nop

0800a1f4 <TC_GetControlPositionStatus>:
  * @retval Position Control Status
  */
PosCtrlStatus_t TC_GetControlPositionStatus(PosCtrl_Handle_t *pHandle)
{
  return (pHandle->PositionCtrlStatus);
}
 800a1f4:	f890 0060 	ldrb.w	r0, [r0, #96]	@ 0x60
 800a1f8:	4770      	bx	lr
 800a1fa:	bf00      	nop

0800a1fc <TC_GetAlignmentStatus>:
  * @param  pHandle handler of the current instance of the Position Control component.
  */
AlignStatus_t TC_GetAlignmentStatus(PosCtrl_Handle_t *pHandle)
{
  return (pHandle->AlignmentStatus);
}
 800a1fc:	f890 0062 	ldrb.w	r0, [r0, #98]	@ 0x62
 800a200:	4770      	bx	lr
 800a202:	bf00      	nop

0800a204 <VSS_Clear>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->_Super.bSpeedErrorNumber = 0U;
 800a204:	2300      	movs	r3, #0
    pHandle->hRemainingStep = 0U;
    pHandle->hElAngleAccu = 0;

    pHandle->bTransitionStarted = false;
    pHandle->bTransitionEnded = false;
    pHandle->hTransitionRemainingSteps = pHandle->hTransitionSteps;
 800a206:	8ec2      	ldrh	r2, [r0, #54]	@ 0x36
    pHandle->_Super.bSpeedErrorNumber = 0U;
 800a208:	7003      	strb	r3, [r0, #0]
    pHandle->wElSpeedDpp32 = 0;
 800a20a:	e9c0 3308 	strd	r3, r3, [r0, #32]
    pHandle->_Super.hElAngle = 0;
 800a20e:	6043      	str	r3, [r0, #4]
    pHandle->_Super.hAvrMecSpeedUnit = 0;
 800a210:	60c3      	str	r3, [r0, #12]
    pHandle->_Super.hMecAccelUnitP = 0;
 800a212:	8243      	strh	r3, [r0, #18]
    pHandle->hRemainingStep = 0U;
 800a214:	8503      	strh	r3, [r0, #40]	@ 0x28
    pHandle->bTransitionStarted = false;
 800a216:	8583      	strh	r3, [r0, #44]	@ 0x2c
    pHandle->hTransitionRemainingSteps = pHandle->hTransitionSteps;
 800a218:	85c2      	strh	r2, [r0, #46]	@ 0x2e
    pHandle->hElAngleAccu = 0;
 800a21a:	6303      	str	r3, [r0, #48]	@ 0x30

    pHandle->bCopyObserver = false;
#ifdef NULL_PTR_CHECK_VIR_SPD_SEN
  }
#endif
}
 800a21c:	4770      	bx	lr
 800a21e:	bf00      	nop

0800a220 <VSS_Init>:
{
 800a220:	b508      	push	{r3, lr}
  VSS_Clear(pHandle);
 800a222:	f7ff ffef 	bl	800a204 <VSS_Clear>
}
 800a226:	bd08      	pop	{r3, pc}

0800a228 <VSS_SetMecAcceleration>:
    int32_t wMecAccDppP32;
    uint16_t hNbrStep;
    int16_t hCurrentMecSpeedDpp;
    int16_t hFinalMecSpeedDpp;

    if (false == pHandle->bTransitionStarted)
 800a228:	f890 302c 	ldrb.w	r3, [r0, #44]	@ 0x2c
 800a22c:	b9a3      	cbnz	r3, 800a258 <VSS_SetMecAcceleration+0x30>
        pHandle->_Super.hAvrMecSpeedUnit = hFinalMecSpeedUnit;

        pHandle->_Super.hElSpeedDpp = (int16_t)((((int32_t)hFinalMecSpeedUnit)
                                               * ((int32_t)pHandle->_Super.DPPConvFactor))
                                              / (((int32_t)SPEED_UNIT)
                                               * ((int32_t)pHandle->_Super.hMeasurementFrequency)));
 800a22e:	8b43      	ldrh	r3, [r0, #26]
{
 800a230:	b510      	push	{r4, lr}
                                               * ((int32_t)pHandle->_Super.DPPConvFactor))
 800a232:	69c4      	ldr	r4, [r0, #28]

        pHandle->_Super.hElSpeedDpp *= ((int16_t)pHandle->_Super.bElToMecRatio);
 800a234:	f890 e001 	ldrb.w	lr, [r0, #1]
                                               * ((int32_t)pHandle->_Super.hMeasurementFrequency)));
 800a238:	eb03 0383 	add.w	r3, r3, r3, lsl #2
                                               * ((int32_t)pHandle->_Super.DPPConvFactor))
 800a23c:	fb04 fc01 	mul.w	ip, r4, r1
                                               * ((int32_t)pHandle->_Super.hMeasurementFrequency)));
 800a240:	005b      	lsls	r3, r3, #1
                                              / (((int32_t)SPEED_UNIT)
 800a242:	fb9c fcf3 	sdiv	ip, ip, r3
      if (0U == hDurationms)
 800a246:	b942      	cbnz	r2, 800a25a <VSS_SetMecAcceleration+0x32>
        pHandle->_Super.hElSpeedDpp *= ((int16_t)pHandle->_Super.bElToMecRatio);
 800a248:	fb1c fc0e 	smulbb	ip, ip, lr
        pHandle->_Super.hAvrMecSpeedUnit = hFinalMecSpeedUnit;
 800a24c:	8181      	strh	r1, [r0, #12]
        pHandle->_Super.hElSpeedDpp *= ((int16_t)pHandle->_Super.bElToMecRatio);
 800a24e:	f8a0 c00e 	strh.w	ip, [r0, #14]

        pHandle->hRemainingStep = 0U;
 800a252:	8502      	strh	r2, [r0, #40]	@ 0x28

        pHandle->hFinalMecSpeedUnit = hFinalMecSpeedUnit;
 800a254:	8541      	strh	r1, [r0, #42]	@ 0x2a
      /* Nothing to do */
    }
#ifdef NULL_PTR_CHECK_VIR_SPD_SEN
  }
#endif
}
 800a256:	bd10      	pop	{r4, pc}
 800a258:	4770      	bx	lr
        hNbrStep = (uint16_t)((((uint32_t)hDurationms) * ((uint32_t)pHandle->hSpeedSamplingFreqHz)) / 1000U);
 800a25a:	8e83      	ldrh	r3, [r0, #52]	@ 0x34
 800a25c:	fb02 f303 	mul.w	r3, r2, r3
 800a260:	4a0e      	ldr	r2, [pc, #56]	@ (800a29c <VSS_SetMecAcceleration+0x74>)
 800a262:	fba2 2303 	umull	r2, r3, r2, r3
 800a266:	f3c3 138f 	ubfx	r3, r3, #6, #16
        hNbrStep++;
 800a26a:	3301      	adds	r3, #1
 800a26c:	b29b      	uxth	r3, r3
        hCurrentMecSpeedDpp = pHandle->_Super.hElSpeedDpp / ((int16_t)pHandle->_Super.bElToMecRatio);
 800a26e:	f9b0 200e 	ldrsh.w	r2, [r0, #14]
        pHandle->hRemainingStep = hNbrStep;
 800a272:	8503      	strh	r3, [r0, #40]	@ 0x28
        if (0U == hNbrStep)
 800a274:	b91b      	cbnz	r3, 800a27e <VSS_SetMecAcceleration+0x56>
        pHandle->wElSpeedDpp32 = ((int32_t)pHandle->_Super.hElSpeedDpp) * ((int32_t)65536);
 800a276:	0412      	lsls	r2, r2, #16
        pHandle->hFinalMecSpeedUnit = hFinalMecSpeedUnit;
 800a278:	8541      	strh	r1, [r0, #42]	@ 0x2a
        pHandle->wElSpeedDpp32 = ((int32_t)pHandle->_Super.hElSpeedDpp) * ((int32_t)65536);
 800a27a:	6242      	str	r2, [r0, #36]	@ 0x24
}
 800a27c:	bd10      	pop	{r4, pc}
        hCurrentMecSpeedDpp = pHandle->_Super.hElSpeedDpp / ((int16_t)pHandle->_Super.bElToMecRatio);
 800a27e:	fb92 f4fe 	sdiv	r4, r2, lr
          wMecAccDppP32 = ((((int32_t)hFinalMecSpeedDpp) - ((int32_t)hCurrentMecSpeedDpp))
 800a282:	ebac 0c04 	sub.w	ip, ip, r4
                         * ((int32_t)65536)) / ((int32_t )hNbrStep);
 800a286:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
        pHandle->wElSpeedDpp32 = ((int32_t)pHandle->_Super.hElSpeedDpp) * ((int32_t)65536);
 800a28a:	0412      	lsls	r2, r2, #16
          wMecAccDppP32 = ((((int32_t)hFinalMecSpeedDpp) - ((int32_t)hCurrentMecSpeedDpp))
 800a28c:	fb9c f3f3 	sdiv	r3, ip, r3
          pHandle->wElAccDppP32 = wMecAccDppP32 * ((int16_t)pHandle->_Super.bElToMecRatio);
 800a290:	fb0e f303 	mul.w	r3, lr, r3
 800a294:	6203      	str	r3, [r0, #32]
        pHandle->hFinalMecSpeedUnit = hFinalMecSpeedUnit;
 800a296:	8541      	strh	r1, [r0, #42]	@ 0x2a
        pHandle->wElSpeedDpp32 = ((int32_t)pHandle->_Super.hElSpeedDpp) * ((int32_t)65536);
 800a298:	6242      	str	r2, [r0, #36]	@ 0x24
    }
 800a29a:	e7ef      	b.n	800a27c <VSS_SetMecAcceleration+0x54>
 800a29c:	10624dd3 	.word	0x10624dd3

0800a2a0 <memset>:
 800a2a0:	4402      	add	r2, r0
 800a2a2:	4603      	mov	r3, r0
 800a2a4:	4293      	cmp	r3, r2
 800a2a6:	d100      	bne.n	800a2aa <memset+0xa>
 800a2a8:	4770      	bx	lr
 800a2aa:	f803 1b01 	strb.w	r1, [r3], #1
 800a2ae:	e7f9      	b.n	800a2a4 <memset+0x4>

0800a2b0 <__libc_init_array>:
 800a2b0:	b570      	push	{r4, r5, r6, lr}
 800a2b2:	4d0d      	ldr	r5, [pc, #52]	@ (800a2e8 <__libc_init_array+0x38>)
 800a2b4:	4c0d      	ldr	r4, [pc, #52]	@ (800a2ec <__libc_init_array+0x3c>)
 800a2b6:	1b64      	subs	r4, r4, r5
 800a2b8:	10a4      	asrs	r4, r4, #2
 800a2ba:	2600      	movs	r6, #0
 800a2bc:	42a6      	cmp	r6, r4
 800a2be:	d109      	bne.n	800a2d4 <__libc_init_array+0x24>
 800a2c0:	4d0b      	ldr	r5, [pc, #44]	@ (800a2f0 <__libc_init_array+0x40>)
 800a2c2:	4c0c      	ldr	r4, [pc, #48]	@ (800a2f4 <__libc_init_array+0x44>)
 800a2c4:	f000 f826 	bl	800a314 <_init>
 800a2c8:	1b64      	subs	r4, r4, r5
 800a2ca:	10a4      	asrs	r4, r4, #2
 800a2cc:	2600      	movs	r6, #0
 800a2ce:	42a6      	cmp	r6, r4
 800a2d0:	d105      	bne.n	800a2de <__libc_init_array+0x2e>
 800a2d2:	bd70      	pop	{r4, r5, r6, pc}
 800a2d4:	f855 3b04 	ldr.w	r3, [r5], #4
 800a2d8:	4798      	blx	r3
 800a2da:	3601      	adds	r6, #1
 800a2dc:	e7ee      	b.n	800a2bc <__libc_init_array+0xc>
 800a2de:	f855 3b04 	ldr.w	r3, [r5], #4
 800a2e2:	4798      	blx	r3
 800a2e4:	3601      	adds	r6, #1
 800a2e6:	e7f2      	b.n	800a2ce <__libc_init_array+0x1e>
 800a2e8:	0800a6ec 	.word	0x0800a6ec
 800a2ec:	0800a6ec 	.word	0x0800a6ec
 800a2f0:	0800a6ec 	.word	0x0800a6ec
 800a2f4:	0800a6f0 	.word	0x0800a6f0

0800a2f8 <memcpy>:
 800a2f8:	440a      	add	r2, r1
 800a2fa:	4291      	cmp	r1, r2
 800a2fc:	f100 33ff 	add.w	r3, r0, #4294967295
 800a300:	d100      	bne.n	800a304 <memcpy+0xc>
 800a302:	4770      	bx	lr
 800a304:	b510      	push	{r4, lr}
 800a306:	f811 4b01 	ldrb.w	r4, [r1], #1
 800a30a:	f803 4f01 	strb.w	r4, [r3, #1]!
 800a30e:	4291      	cmp	r1, r2
 800a310:	d1f9      	bne.n	800a306 <memcpy+0xe>
 800a312:	bd10      	pop	{r4, pc}

0800a314 <_init>:
 800a314:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a316:	bf00      	nop
 800a318:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800a31a:	bc08      	pop	{r3}
 800a31c:	469e      	mov	lr, r3
 800a31e:	4770      	bx	lr

0800a320 <_fini>:
 800a320:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a322:	bf00      	nop
 800a324:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800a326:	bc08      	pop	{r3}
 800a328:	469e      	mov	lr, r3
 800a32a:	4770      	bx	lr
